{"source_file": "herald_data/sample_500.jsonl", "line": 7, "id": 91165, "informal_statement": "For any integer $i$, the least common multiple of $1$ and $i$ is equal to the absolute value of $i$, i.e., $\\mathrm{lcm}(1, i) = |i|$.", "formal_statement": "import Mathlib\n\ntheorem lcm_one_left_extracted (i : ℤ) : Int.lcm 1 i = i.natAbs := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we follow these steps:\n\n1. **Identify the Domain and Variables**: The informal statement involves integers, specifically any integer \\( i \\). In Lean, integers are represented by the type `ℤ`.\n\n2. **Understand the Mathematical Functions**: The statement involves the least common multiple (lcm) and the absolute value. In Lean, the least common multiple of two integers is represented by `Int.lcm`, and the absolute value of an integer \\( i \\) is represented by `i.natAbs`.\n\n3. **Formalize the Statement**: The goal is to express that for any integer \\( i \\), the least common multiple of 1 and \\( i \\) is equal to the absolute value of \\( i \\). This is written as a theorem in Lean.\n\n4. **Structure the Theorem**:\n   - **Theorem Name**: We give the theorem a descriptive name, `lcm_one_left_extracted`, indicating that it deals with the lcm where 1 is the left operand.\n   - **Parameters**: The theorem takes an integer \\( i \\) as a parameter, which is denoted as `(i : ℤ)` in Lean.\n   - **Assertion**: The assertion is that `Int.lcm 1 i = i.natAbs`. This directly translates the mathematical statement \\(\\mathrm{lcm}(1, i) = |i|\\).\n\n5. **Import Necessary Libraries**: The Lean code begins with `import Mathlib`, which is necessary to access mathematical functions and theorems, including `Int.lcm` and `i.natAbs`.\n\n6. **Complete the Theorem**: The theorem is stated as `theorem lcm_one_left_extracted (i : ℤ) : Int.lcm 1 i = i.natAbs := sorry`. The `:= sorry` part is a placeholder indicating that the proof is not yet provided.\n\nBy following these steps, the informal mathematical statement is accurately translated into a formal statement in Lean4."}
{"source_file": "herald_data/sample_500.jsonl", "line": 4, "id": 234057, "informal_statement": "For any seminormed abelian group \\(E\\), normed space \\(\\mathbb{R} E\\), vector \\(u \\in E\\), scalars \\(a, b \\in \\mathbb{R}\\) such that \\(0 \\leq a\\), \\(0 \\leq b\\), and \\(a \\geq b\\), if \\(a \\cdot u\\) and \\(b \\cdot u\\) are on the same ray in \\(\\mathbb{R} E\\), then show that the norm of the difference \\(a \\cdot u - b \\cdot u\\) is equal to the absolute difference of their norms, i.e., \\(\\|a \\cdot u - b \\cdot u\\| = |\\|a \\cdot u\\| - \\|b \\cdot u\\||\\).", "formal_statement": "import Mathlib\nopen Real\nlemma norm_sub_tac_1490 [SeminormedAddCommGroup E] [NormedSpace ℝ E] (u : E) (a : ℝ) (b : ℝ) (ha : 0 ≤ a) (hb : 0 ≤ b) (h : SameRay ℝ (a • u) (b • u)) (hab : b ≤ a) : ‖a • u - b • u‖ = |‖a • u‖ - ‖b • u‖| := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures all the mathematical concepts and conditions involved. Here's a step-by-step explanation of the translation:\n\n1. **Identify the Mathematical Structures:**\n   - The informal statement involves a seminormed abelian group \\(E\\) and a normed space \\(\\mathbb{R} E\\). In Lean, these are represented by the type class `SeminormedAddCommGroup E` for \\(E\\) and `NormedSpace ℝ E` for the real vector space structure over \\(E\\).\n\n2. **Define the Variables:**\n   - The vector \\(u \\in E\\) is represented as `(u : E)`.\n   - The scalars \\(a, b \\in \\mathbb{R}\\) are represented as `(a : ℝ)` and `(b : ℝ)`.\n\n3. **State the Conditions:**\n   - The conditions \\(0 \\leq a\\) and \\(0 \\leq b\\) are represented by the hypotheses `(ha : 0 ≤ a)` and `(hb : 0 ≤ b)`.\n   - The condition \\(a \\geq b\\) is represented by `(hab : b ≤ a)`. Note that in Lean, inequalities are often expressed in terms of `≤` rather than `≥`.\n\n4. **Express the Same Ray Condition:**\n   - The condition that \\(a \\cdot u\\) and \\(b \\cdot u\\) are on the same ray in \\(\\mathbb{R} E\\) is captured by the hypothesis `(h : SameRay ℝ (a • u) (b • u))`. The `SameRay` predicate is used to express that two vectors are scalar multiples of each other with non-negative scalars.\n\n5. **State the Conclusion:**\n   - The conclusion \\(\\|a \\cdot u - b \\cdot u\\| = |\\|a \\cdot u\\| - \\|b \\cdot u\\||\\) is directly translated into Lean as `‖a • u - b • u‖ = |‖a • u‖ - ‖b • u‖|`. The `‖` symbols denote the norm, and `| |` denotes the absolute value.\n\n6. **Structure the Lemma:**\n   - The"}
{"source_file": "herald_data/sample_500.jsonl", "line": 9, "id": 33329, "informal_statement": "For any family of filters $f : \\iota \\to \\mathcal{F}(\\alpha)$ and any function $g : \\mathcal{P}(\\alpha) \\to \\mathcal{F}(\\beta)$ that preserves finite intersections and maps the universal set to the top element of the lattice of filters on $\\beta$, show that the lift of the infimum of the family $f$ through $g$ equals the infimum of the lifts of each filter in the family through $g$. Formally, demonstrate that $(\\bigwedge_{i \\in \\iota} f(i)).\\text{lift } g = \\bigwedge_{i \\in \\iota} (f(i).\\text{lift } g)$.", "formal_statement": "import Mathlib\nopen Set Filter Function\ntheorem lift_iInf_of_map_univ_extracted {ι : Sort u_4} {f : ι → Filter α} {g : Set α → Filter β} :\n (∀ (s t : Set α), g (s ∩ t) = g s ⊓ g t) → g univ = ⊤ → (iInf f).lift g = ⨅ i, (f i).lift g := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it corresponds to Lean's syntax and semantics.\n\n1. **Understanding the Context and Types:**\n   - We have a family of filters `f : \\iota \\to \\mathcal{F}(\\alpha)`. In Lean, this is represented as `f : ι → Filter α`, where `ι` is a type (or sort) representing the index set, and `Filter α` is the type of filters on a set `α`.\n   - We have a function `g : \\mathcal{P}(\\alpha) \\to \\mathcal{F}(\\beta)` that preserves finite intersections and maps the universal set to the top element of the lattice of filters on `β`. In Lean, this is represented as `g : Set α → Filter β`.\n\n2. **Preservation of Finite Intersections:**\n   - The condition that `g` preserves finite intersections is expressed as `∀ (s t : Set α), g (s ∩ t) = g s ⊓ g t`. This means for any two sets `s` and `t` in `α`, the image under `g` of their intersection is the infimum (greatest lower bound) of their images under `g`.\n\n3. **Mapping the Universal Set to the Top Element:**\n   - The condition that `g` maps the universal set to the top element is expressed as `g univ = ⊤`. Here, `univ` represents the universal set in Lean, and `⊤` represents the top element in the lattice of filters on `β`.\n\n4. **Infimum and Lifting:**\n   - The infimum of the family `f` is represented as `(iInf f)`, where `iInf` is the infimum (greatest lower bound) over the family of filters `f`.\n   - The lift of a filter through `g` is denoted as `.lift g`. Thus, `(iInf f).lift g` represents the lift of the infimum of the family `f` through `g`.\n   - The infimum of the lifts of each filter in the family through `g` is represented as `⨅ i, (f i).lift g`, where `⨅` is the infimum over the index set"}
{"source_file": "herald_data/sample_500.jsonl", "line": 0, "id": 116743, "informal_statement": "For any commutative ring \\( R \\) and matrix \\( A \\) of size \\( m \\times n \\) over \\( R \\), show that the finite rank of the submodule spanned by the columns of \\( A \\) is equal to the finite rank of the submodule spanned by the columns of the transpose of \\( A \\), i.e., \\(\\text{finrank}_R(\\text{Submodule.span}_R(\\text{Set.range } A^T)) = \\text{finrank}_R(\\text{Submodule.span}_R(\\text{Set.range } A^T))\\).", "formal_statement": "import Mathlib\nopen Matrix\nopen FiniteDimensional\nlemma rank_eq_finrank_span_cols_tac_6856 [CommRing R] (A : Matrix m n R) : finrank R ↥(Submodule.span R (Set.range Aᵀ)) = finrank R ↥(Submodule.span R (Set.range Aᵀ)) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: \n   - The statement involves a commutative ring \\( R \\) and a matrix \\( A \\) of size \\( m \\times n \\) over \\( R \\).\n   - The concept of finite rank of a submodule spanned by the columns of a matrix and its transpose is central.\n\n2. **Translate the Mathematical Structures into Lean**:\n   - In Lean, a commutative ring is represented by the type class `CommRing R`.\n   - A matrix of size \\( m \\times n \\) over \\( R \\) is represented by `Matrix m n R`.\n\n3. **Formalize the Submodule and Span**:\n   - The submodule spanned by the columns of a matrix \\( A \\) is represented by `Submodule.span R (Set.range A)`.\n   - The transpose of a matrix \\( A \\) is denoted by `Aᵀ` in Lean.\n\n4. **Express the Finite Rank**:\n   - The finite rank of a submodule is expressed using `finrank R`, which is a function that computes the dimension of a vector space or module over a ring \\( R \\).\n\n5. **Construct the Lean Lemma**:\n   - The lemma is named `rank_eq_finrank_span_cols_tac_6856`, which is a placeholder name and can be replaced with a more descriptive one.\n   - The lemma states that the finite rank of the submodule spanned by the columns of the transpose of \\( A \\) is equal to itself, which is trivially true and likely a placeholder for a more meaningful statement.\n\n6. **Use of `sorry`**:\n   - The `:= sorry` at the end of the lemma indicates that the proof is not provided. In Lean, `sorry` is used as a placeholder for incomplete proofs.\n\n7. **Import Necessary Libraries**:\n   - `import Mathlib` is used to import the necessary mathematical libraries that provide definitions and theorems for matrices, submodules, and finite-dimensional vector spaces.\n   - `open Matrix` and `open FiniteDimensional` are used to bring matrix operations and finite-dimensional space operations into scope, allowing for concise notation.\n\nIn summary, the Lean code formalizes the informal statement by defining a lemma that asserts the equality of the finite rank of the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 2, "id": 288393, "informal_statement": "For any commutative ring $k$ and monoid $G$, show that the composition of the map induced by $\\varepsilon_{\\text{ToSingle}0}$ in the forgetful functor from $\\text{Rep}_kG$ to $\\text{ModuleCat}_k$ applied to the down-shaped homological complex, and the homomorphism component of the single map in the same forgetful functor at level $0$ evaluated at the trivial representation $\\text{Rep}_{\\text{trivial}}(k, G, k)$, is equal to the homomorphism component of the equivalence induced by the forgetful functor to $\\text{ModuleCat}_k$ homotopy.", "formal_statement": "import Mathlib\nopen CategoryTheory Finsupp\nopen Finsupp hiding lift\nopen MonoidalCategory\nopen Fin (partialProd)\nopen Action\nopen Rep\nopen scoped TensorProduct\nopen Representation\nopen groupCohomology.resolution\nopen CategoryTheory CategoryTheory.Limits\nopen AlgebraicTopology SimplicialObject.Augmented SimplicialObject CategoryTheory.Arrow\nopen classifyingSpaceUniversalCover AlgebraicTopology CategoryTheory CategoryTheory.Limits\nlemma εToSingle₀_comp_eq_tac_31428 [CommRing k] [Monoid G] : ((forget₂ (Rep k G) (ModuleCat k)).mapHomologicalComplex (ComplexShape.down ℕ)).map (εToSingle₀ k G) ≫\n    (HomologicalComplex.singleMapHomologicalComplex (forget₂ (Rep k G) (ModuleCat k)) (ComplexShape.down ℕ) 0).hom.app\n      (Rep.trivial k G k) =\n  (forget₂ToModuleCatHomotopyEquiv k G).hom := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it corresponds to the constructs in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Context**:\n   - We are dealing with a commutative ring \\( k \\) and a monoid \\( G \\).\n   - The categories involved are \\(\\text{Rep}_kG\\) (representations of \\( G \\) over \\( k \\)) and \\(\\text{ModuleCat}_k\\) (modules over \\( k \\)).\n\n2. **Identifying the Functors and Maps**:\n   - The informal statement mentions a \"forgetful functor\" from \\(\\text{Rep}_kG\\) to \\(\\text{ModuleCat}_k\\). In Lean, this is represented by `forget₂ (Rep k G) (ModuleCat k)`.\n   - The map induced by \\(\\varepsilon_{\\text{ToSingle}0}\\) is a specific map in the context of homological complexes. In Lean, this is represented by `εToSingle₀ k G`.\n\n3. **Homological Complexes**:\n   - The statement involves a \"down-shaped homological complex\". In Lean, this is represented by `ComplexShape.down ℕ`, indicating a chain complex indexed by natural numbers in a descending manner.\n   - The map on homological complexes is expressed as `mapHomologicalComplex (ComplexShape.down ℕ)`.\n\n4. **Composition of Maps**:\n   - The composition of maps is expressed using the composition operator `≫` in Lean.\n   - The first map in the composition is `((forget₂ (Rep k G) (ModuleCat k)).mapHomologicalComplex (ComplexShape.down ℕ)).map (εToSingle₀ k G)`.\n   - The second map is the homomorphism component of the single map at level 0, represented by `(HomologicalComplex.singleMapHomologicalComplex (forget₂ (Rep k G) (ModuleCat k)) (ComplexShape.down ℕ) 0).hom.app (Rep.trivial k G k)`.\n\n5. **Trivial Representation**:\n   - The trivial representation \\(\\text{Rep}_{\\text{trivial}}(k, G, k)\\) is represented in Lean as `Rep.trivial k G k`.\n\n6. **Equivalence Induced by the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 3, "id": 256791, "informal_statement": "For any ordinals $a$ and $b$, if $a + b$ is a limit ordinal, then either $b$ is a limit ordinal or $b = 0$ and $a$ is a limit ordinal.", "formal_statement": "import Mathlib\nopen Function Cardinal Set Equiv Order\nopen scoped Ordinal\nopen Classical in\nlemma isLimit_add_iff_tac_36417 (a : Ordinal.{u_4}) (b : Ordinal.{u_4}) (h : (a + b).IsLimit) : b.IsLimit ∨ b = 0 ∧ a.IsLimit := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Informal Statement**: \n   - We are given two ordinals, \\(a\\) and \\(b\\).\n   - The condition is that the sum \\(a + b\\) is a limit ordinal.\n   - The conclusion is that either \\(b\\) is a limit ordinal, or \\(b = 0\\) and \\(a\\) is a limit ordinal.\n\n2. **Identifying Key Concepts**:\n   - **Ordinals**: These are well-ordered sets that generalize the concept of natural numbers.\n   - **Limit Ordinal**: An ordinal \\(\\alpha\\) is a limit ordinal if it is not zero and there is no largest ordinal less than \\(\\alpha\\).\n   - **Sum of Ordinals**: The operation \\(a + b\\) is defined in a specific way for ordinals, which is different from the usual addition of numbers.\n\n3. **Translating to Lean4**:\n   - **Imports and Setup**: The code begins with importing necessary modules from Mathlib, which provides the foundational definitions and theorems for working with ordinals in Lean4.\n   - **Opening Namespaces**: The `open` and `open scoped` commands are used to bring certain namespaces and notations into scope, making it easier to refer to ordinals and related concepts.\n   - **Lemma Declaration**: The statement is formalized as a lemma named `isLimit_add_iff_tac_36417`.\n   - **Parameters**: The lemma takes two parameters, `a` and `b`, both of type `Ordinal.{u_4}`. The `{u_4}` indicates the universe level, which is a technical detail in Lean to handle different sizes of types.\n   - **Hypothesis**: The hypothesis `(h : (a + b).IsLimit)` states that the sum \\(a + b\\) is a limit ordinal. `IsLimit` is a property that checks if an ordinal is a limit ordinal.\n   - **Conclusion**: The conclusion of the lemma is `b.IsLimit ∨ b = 0 ∧ a.IsLimit`. This is a direct translation of the informal statement:\n     - `b.IsLimit` corresponds to \"either \\(b\\) is a limit ordinal\".\n     - `b = 0 ∧ a"}
{"source_file": "herald_data/sample_500.jsonl", "line": 1, "id": 26226, "informal_statement": "For any non-zero constant \\( c \\in \\beta \\), the asymptotic equivalence of a function \\( u \\) to the constant function \\( c \\) as \\( l \\) approaches is equivalent to \\( u \\) tending to \\( c \\) as \\( l \\) approaches, i.e., \\( u \\sim_{l} c \\) if and only if \\( u \\) converges to \\( c \\) in the neighborhood of \\( c \\) as \\( l \\) approaches.", "formal_statement": "import Mathlib\nopen Filter Function\nopen Topology\ntheorem isEquivalent_const_iff_tendsto_extracted [NormedAddCommGroup β] {u : α → β} {l : Filter α} {c : β} :\n c ≠ 0 → (u ~[l] Function.const α c ↔ Tendsto u l (nhds c)) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down the components of the statement and understand how they map to Lean's formal language and libraries.\n\n1. **Understanding the Context and Libraries**:\n   - The statement involves concepts from analysis, specifically asymptotic equivalence and limits. In Lean, these concepts are handled using filters and topology.\n   - We import necessary libraries: `Mathlib` for general mathematical constructs, `Filter` and `Function` for dealing with filters and functions, and `Topology` for topological concepts like neighborhoods.\n\n2. **Setting Up the Environment**:\n   - We declare the theorem within a context where `β` is a `NormedAddCommGroup`. This is necessary because we are dealing with a normed space, which allows us to discuss limits and asymptotic behavior.\n   - The variables `u`, `l`, and `c` are introduced:\n     - `u : α → β` is a function from some type `α` to the normed group `β`.\n     - `l : Filter α` represents the filter over which we are considering the limit (i.e., as `l` approaches).\n     - `c : β` is the constant function value we are comparing `u` to.\n\n3. **Formalizing the Hypothesis**:\n   - The hypothesis `c ≠ 0` is explicitly stated. This is crucial because the asymptotic equivalence to a non-zero constant has different properties than equivalence to zero.\n\n4. **Formalizing Asymptotic Equivalence**:\n   - The notation `u ~[l] Function.const α c` is used to express that `u` is asymptotically equivalent to the constant function `c` with respect to the filter `l`. In Lean, `Function.const α c` represents the constant function mapping every element of `α` to `c`.\n\n5. **Formalizing the Limit Condition**:\n   - `Tendsto u l (nhds c)` is the formal way to express that the function `u` tends to `c` as `l` approaches. Here, `Tendsto` is a predicate that checks if `u` converges to `c` with respect to the filter `l`, and `nhds c` represents the neighborhood filter around `c`.\n\n6. **Constructing the Theorem**:\n   - The theorem states"}
{"source_file": "herald_data/sample_500.jsonl", "line": 8, "id": 453437, "informal_statement": "Assume that $f,g:[0,1]\\rightarrow[0,1] $ are two continuos functions so that $\\forall x \\in [0,1] \\Rightarrow f(g(x))=g(f(x))$. Prove that $\\exists x_{0} \\in [0,1] ; f(x_{0})=g(x_{0})$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_453437 (f g : ℝ → ℝ) (hf: Continuous f) (hg: Continuous g) (h : ∀ x ∈ Set.Icc 0 1, f (g x) = g (f x)) : ∃ x ∈ Set.Icc 0 1, f x = g x  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to carefully consider each component of the statement and how it corresponds to Lean's syntax and libraries. Here's a step-by-step explanation of the translation:\n\n1. **Function Definitions and Domain**:\n   - The informal statement begins by defining two functions \\( f, g: [0,1] \\rightarrow [0,1] \\). In Lean, we represent real-valued functions using the type `ℝ → ℝ`. The domain restriction to \\([0,1]\\) is handled by specifying conditions on the input values later in the theorem.\n\n2. **Continuity**:\n   - The statement specifies that both functions are continuous. In Lean, continuity of a function is expressed using the `Continuous` predicate. Thus, `hf: Continuous f` and `hg: Continuous g` are used to assert the continuity of \\( f \\) and \\( g \\), respectively.\n\n3. **Functional Equation**:\n   - The condition \\(\\forall x \\in [0,1] \\Rightarrow f(g(x))=g(f(x))\\) is translated into Lean using a universal quantifier over the interval \\([0,1]\\). In Lean, the interval \\([0,1]\\) is represented by `Set.Icc 0 1`, which stands for the closed interval from 0 to 1. The condition is then expressed as `h : ∀ x ∈ Set.Icc 0 1, f (g x) = g (f x)`.\n\n4. **Existence of a Fixed Point**:\n   - The goal is to prove the existence of some \\( x_0 \\in [0,1] \\) such that \\( f(x_0) = g(x_0) \\). In Lean, existence is expressed using the `∃` (exists) quantifier. The statement `∃ x ∈ Set.Icc 0 1, f x = g x` captures the requirement that there exists an \\( x \\) in the interval \\([0,1]\\) for which \\( f(x) = g(x) \\).\n\n5. **Theorem Structure**:\n   - The entire statement is wrapped in a theorem declaration. The theorem is named `extract_aug_453437`, which is a placeholder name and can be replaced with a more descriptive name. The theorem takes as arguments the functions \\( f \\) and \\( g"}
{"source_file": "herald_data/sample_500.jsonl", "line": 5, "id": 146320, "informal_statement": "For any natural number $n$, in a commutative ring $K$ with domain and characteristic zero properties, if $\\mu \\in K$ is a primitive $n$-th root of unity, show that the totient function value at $n$, $\\varphi(n)$, is less than or equal to the degree of the minimal polynomial of $\\mu$ over $\\mathbb{Z}$, expressed as a natural number.", "formal_statement": "import Mathlib\nopen minpoly Polynomial\nopen scoped Polynomial\nlemma totient_le_degree_minpoly_tac_9629 (n : ℕ) [CommRing K] (μ : K) (h : IsPrimitiveRoot μ n) [IsDomain K] [CharZero K] : n.totient ≤ (minpoly ℤ μ).natDegree := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Context**:\n   - We are working within the context of a commutative ring \\( K \\) that is also a domain and has characteristic zero. These properties are crucial for the mathematical operations and theorems we will use.\n\n2. **Natural Number \\( n \\)**:\n   - The statement begins with \"For any natural number \\( n \\)\", which is represented in Lean by the parameter `(n : ℕ)`. Here, `ℕ` denotes the type of natural numbers in Lean.\n\n3. **Commutative Ring \\( K \\)**:\n   - The statement specifies that \\( K \\) is a commutative ring. In Lean, this is expressed with `[CommRing K]`, which is a typeclass constraint indicating that \\( K \\) is a commutative ring.\n\n4. **Primitive \\( n \\)-th Root of Unity \\( \\mu \\)**:\n   - The informal statement introduces \\( \\mu \\) as a primitive \\( n \\)-th root of unity in \\( K \\). In Lean, this is captured by the parameter `(μ : K)` and the hypothesis `(h : IsPrimitiveRoot μ n)`. The type `K` indicates that \\( \\mu \\) is an element of the ring \\( K \\), and `IsPrimitiveRoot μ n` is a predicate asserting that \\( \\mu \\) is a primitive \\( n \\)-th root of unity.\n\n5. **Domain and Characteristic Zero**:\n   - The properties of \\( K \\) being a domain and having characteristic zero are expressed with the typeclass constraints `[IsDomain K]` and `[CharZero K]`. These ensure that \\( K \\) satisfies the necessary algebraic properties for the subsequent arguments.\n\n6. **Totient Function and Minimal Polynomial**:\n   - The goal is to show that the totient function value at \\( n \\), denoted \\(\\varphi(n)\\), is less than or equal to the degree of the minimal polynomial of \\( \\mu \\) over \\(\\mathbb{Z}\\).\n   - In Lean, `n.totient` represents the Euler's totient function \\(\\varphi(n)\\).\n   - The minimal polynomial of \\( \\mu \\) over"}
{"source_file": "herald_data/sample_500.jsonl", "line": 6, "id": 107477, "informal_statement": "For any type $\\alpha$, show that the type $\\alpha$ has a unique element if and only if $\\alpha$ is a subsingleton and $\\alpha$ is nonempty.", "formal_statement": "import Mathlib\nopen Function\ntheorem unique_iff_subsingleton_and_nonempty_extracted (α : Sort u) : Nonempty (Unique α) ↔ Subsingleton α ∧ Nonempty α := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down the components of the statement and understand how they correspond to Lean's type theory constructs.\n\n1. **Understanding the Informal Statement:**\n   - We are given a type $\\alpha$ and need to show an equivalence (if and only if) between two conditions:\n     1. The type $\\alpha$ has a unique element.\n     2. The type $\\alpha$ is a subsingleton and nonempty.\n\n2. **Formalizing \"For any type $\\alpha$\":**\n   - In Lean, types are represented as `Sort u`, where `u` is a universe level. This allows for flexibility in the type's universe.\n   - We declare `α : Sort u` to represent any type $\\alpha$.\n\n3. **Formalizing \"The type $\\alpha$ has a unique element\":**\n   - In Lean, a type having a unique element is represented by the type class `Unique α`. This class implies that there is exactly one element of type `α`.\n   - The statement \"the type $\\alpha$ has a unique element\" is thus represented as `Nonempty (Unique α)`. This means there exists an instance of `Unique α`, indicating that $\\alpha$ indeed has a unique element.\n\n4. **Formalizing \"The type $\\alpha$ is a subsingleton\":**\n   - A type is a subsingleton if it has at most one element. In Lean, this is represented by the type class `Subsingleton α`.\n   - `Subsingleton α` ensures that for any two elements of type `α`, they are equal.\n\n5. **Formalizing \"The type $\\alpha$ is nonempty\":**\n   - A type is nonempty if there exists at least one element of that type. In Lean, this is represented by `Nonempty α`.\n   - `Nonempty α` is a proposition that there exists an element of type `α`.\n\n6. **Combining the Conditions:**\n   - The informal statement requires showing an equivalence (if and only if) between the two conditions.\n   - In Lean, logical equivalence is represented by `↔`.\n   - Therefore, the equivalence is written as `Nonempty (Unique α) ↔ Subsingleton α ∧ Nonempty α`.\n\n7. **Constructing the Theorem:**\n   - We encapsulate the equivalence in a theorem"}
{"source_file": "herald_data/sample_500.jsonl", "line": 11, "id": 98250, "informal_statement": "For any element \\( a \\) in a totally ordered set \\( \\alpha \\) equipped with an inversion operation, show that the inversion of the lexicographically ordered element \\( a \\) is equal to the lexicographically ordered inversion of \\( a \\), i.e., \\((\\text{ofLex } a)^{-1} = \\text{ofLex } a^{-1}\\).", "formal_statement": "import Mathlib\nopen OrderDual\ntheorem ofLex_inv_extracted [Inv α] (a : Lex α) : ofLex a⁻¹ = (ofLex a)⁻¹ := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to break down the components of the statement and understand how they map to Lean constructs:\n\n1. **Understanding the Context**:\n   - We are dealing with a totally ordered set \\( \\alpha \\). In Lean, this is typically represented by a type with a total order structure.\n   - The set is equipped with an inversion operation, denoted by \\( a^{-1} \\). In Lean, this is represented by the typeclass `Inv α`, which provides the inversion operation.\n\n2. **Lexicographical Order**:\n   - The informal statement refers to a \"lexicographically ordered element \\( a \\)\". In Lean, this is represented by the type `Lex α`, which is a wrapper around the type \\( \\alpha \\) to provide a lexicographical ordering.\n\n3. **Formalizing the Statement**:\n   - The goal is to show that the inversion of the lexicographically ordered element \\( a \\) is equal to the lexicographically ordered inversion of \\( a \\).\n   - In Lean, the operation `ofLex` is used to convert an element of type `Lex α` back to type \\( \\alpha \\).\n\n4. **Translating the Informal Statement**:\n   - The informal statement \\((\\text{ofLex } a)^{-1} = \\text{ofLex } a^{-1}\\) is translated into Lean as `ofLex a⁻¹ = (ofLex a)⁻¹`.\n   - Here, `a : Lex α` indicates that \\( a \\) is an element of the lexicographically ordered set.\n   - `a⁻¹` denotes the inversion of \\( a \\) within the `Lex α` context.\n   - `ofLex a⁻¹` converts the inverted element back to the original type \\( \\alpha \\).\n   - `(ofLex a)⁻¹` first converts \\( a \\) to type \\( \\alpha \\) and then applies the inversion operation.\n\n5. **Theorem Declaration**:\n   - The theorem is declared with the name `ofLex_inv_extracted`.\n   - The `[Inv α]` indicates that the type \\( \\alpha \\) has an inversion operation.\n   - The statement `theorem ofLex_inv_extracted [Inv α] (a : Lex α) : ofLex a⁻¹ = (ofLex a)⁻"}
{"source_file": "herald_data/sample_500.jsonl", "line": 14, "id": 541034, "informal_statement": "Let $x,y,z$ are positive real numbers. Prove that $\\frac{(y+z-x)^2}{(y+z)^2+x^2}+\\frac{(z+x-y)^2}{(z+x)^2+y^2}+\\frac{(x+y-z)^2}{(x+y)^2+z^2}\\geq\\frac{x^2}{(y+z)^2+x^2}+\\frac{y^2}{(z+x)^2+y^2}+\\frac{z^2}{(x+y)^2+z^2}.$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_541034 (x y z : ℝ) : (y + z - x) ^ 2 / ((y + z) ^ 2 + x ^ 2) + (z + x - y) ^ 2 / ((z + x) ^ 2 + y ^ 2) + (x + y - z) ^ 2 / ((x + y) ^ 2 + z ^ 2) ≥ x ^ 2 / ((y + z) ^ 2 + x ^ 2) + y ^ 2 / ((z + x) ^ 2 + y ^ 2) + z ^ 2 / ((x + y) ^ 2 + z ^ 2)   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow a structured approach:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves three variables \\(x\\), \\(y\\), and \\(z\\), which are specified as positive real numbers. In Lean, we represent real numbers using the type `ℝ`.\n\n2. **Formalize the Variables**:\n   - In the Lean theorem, we declare the variables \\(x\\), \\(y\\), and \\(z\\) as real numbers using `(x y z : ℝ)`.\n\n3. **Structure the Inequality**:\n   - The inequality involves several expressions of the form \\(\\frac{(a-b)^2}{c^2 + d^2}\\). In Lean, this is expressed using the `^` operator for exponentiation and `/` for division.\n   - The left-hand side of the inequality in the informal statement is:\n     \\[\n     \\frac{(y+z-x)^2}{(y+z)^2+x^2} + \\frac{(z+x-y)^2}{(z+x)^2+y^2} + \\frac{(x+y-z)^2}{(x+y)^2+z^2}\n     \\]\n   - The right-hand side is:\n     \\[\n     \\frac{x^2}{(y+z)^2+x^2} + \\frac{y^2}{(z+x)^2+y^2} + \\frac{z^2}{(x+y)^2+z^2}\n     \\]\n\n4. **Translate the Inequality**:\n   - The Lean code directly translates these expressions using the same arithmetic operations. The left-hand side and right-hand side are written as:\n     ```lean\n     (y + z - x) ^ 2 / ((y + z) ^ 2 + x ^ 2) + \n     (z + x - y) ^ 2 / ((z + x) ^ 2 + y ^ 2) + \n     (x + y - z) ^ 2 / ((x + y) ^ 2 + z ^ 2) ≥ \n     x ^ 2 / ((y + z) ^ 2 + x ^ 2) + \n     y ^ 2 / ((z + x) ^ 2 + y ^ 2) + \n     z ^"}
{"source_file": "herald_data/sample_500.jsonl", "line": 12, "id": 229262, "informal_statement": "For any natural numbers \\( p \\) and \\( n \\), with \\( p \\) being a prime number and \\( n > 0 \\), show that \\( n \\neq 0 \\). Note: This statement is trivially true and may have been intended to express a different, more complex relationship between the natural logarithm and the p-adic valuation, which is not evident in the provided formal statement.", "formal_statement": "import Mathlib\nopen Nat\nopen Rat\nopen multiplicity\nopen multiplicity\nopen Nat.maxPowDiv\nopen multiplicity\nopen multiplicity\nopen multiplicity\nlemma nat_log_eq_padicValNat_iff_tac_22801 (p : ℕ) (n : ℕ) (hp : Fact (Nat.Prime p)) (hn : 0 < n) : n ≠ 0 := sorry", "explanation": "To translate the informal statement into the given Lean4 formal statement, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves two variables, \\( p \\) and \\( n \\), which are both natural numbers. In Lean, natural numbers are represented by the type `ℕ`.\n\n2. **Prime Number Condition**:\n   - The statement specifies that \\( p \\) is a prime number. In Lean, this is expressed using the `Nat.Prime` predicate. However, to work with this property in a structured way, Lean often uses the `Fact` type to encapsulate known facts or assumptions. Thus, `hp : Fact (Nat.Prime p)` is used to indicate that \\( p \\) is a prime number.\n\n3. **Positive Natural Number Condition**:\n   - The condition \\( n > 0 \\) is directly translated to `hn : 0 < n` in Lean. This is a straightforward translation of the inequality.\n\n4. **Conclusion**:\n   - The conclusion of the informal statement is \\( n \\neq 0 \\). In Lean, this is expressed as `n ≠ 0`. This is a direct translation of the inequality.\n\n5. **Structure of the Lemma**:\n   - The lemma is named `nat_log_eq_padicValNat_iff_tac_22801`, which seems to be an automatically generated name, possibly from a tactic or automation tool. The name itself does not provide insight into the content of the lemma.\n   - The lemma takes four arguments: `p`, `n`, `hp`, and `hn`, which correspond to the variables and conditions identified earlier.\n   - The conclusion of the lemma is `n ≠ 0`, which matches the informal statement's conclusion.\n\n6. **Use of Imports and Opens**:\n   - The imports and open statements (`Mathlib`, `Nat`, `Rat`, `multiplicity`, etc.) are included to provide access to necessary definitions and theorems related to natural numbers, prime numbers, and possibly other mathematical structures. However, they do not directly affect the translation of the specific statement at hand.\n\n7. **Placeholder for Proof**:\n   - The `:= sorry` at the end of the lemma indicates that the proof is not provided. In Lean, `sorry` is used as a placeholder for a proof that is yet to be completed.\n\nIn summary, the formal statement"}
{"source_file": "herald_data/sample_500.jsonl", "line": 10, "id": 31245, "informal_statement": "For any elements $a, b$ in a Boolean algebra $\\alpha$, the composition of the complements of $a$ and $b$ is equal to the complement of the supremum of $a$ and $b$, i.e., $(\\overline{a} \\wedge \\overline{b}) = \\overline{(a \\vee b)}$.", "formal_statement": "import Mathlib\nopen Function\ntheorem comp_inf_comp_extracted [GeneralizedBooleanAlgebra α] (a b : α) :\n Booleanisation.comp a ⊓ Booleanisation.comp b = Booleanisation.comp (a ⊔ b) := sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: The statement involves a Boolean algebra, which is a specific algebraic structure. In Lean, this is represented by the type class `GeneralizedBooleanAlgebra α`. This type class provides the necessary operations and properties for elements of a Boolean algebra.\n\n2. **Define the Elements and Operations**: The elements $a$ and $b$ are elements of the Boolean algebra $\\alpha$. In Lean, these are represented as variables of type `α`. The operations involved are complement, infimum (meet), and supremum (join). In Lean, these operations are typically represented by specific functions or operators.\n\n3. **Translate the Complement Operation**: The complement of an element in a Boolean algebra is often denoted by an overline in informal mathematics. In Lean, this is represented by the function `Booleanisation.comp`. Thus, the complement of $a$ is `Booleanisation.comp a`.\n\n4. **Translate the Infimum and Supremum Operations**: The infimum (meet) operation is denoted by $\\wedge$ in informal mathematics, and in Lean, it is represented by the infix operator `⊓`. Similarly, the supremum (join) operation is denoted by $\\vee$ and is represented by the infix operator `⊔` in Lean.\n\n5. **Formalize the Statement**: The informal statement asserts an equality between two expressions involving these operations. In Lean, this is expressed using the equality operator `=`. The left-hand side of the equality is the infimum of the complements of $a$ and $b`, which is `Booleanisation.comp a ⊓ Booleanisation.comp b`. The right-hand side is the complement of the supremum of $a` and `b`, which is `Booleanisation.comp (a ⊔ b)`.\n\n6. **Structure the Theorem**: The theorem is structured to take two elements `a` and `b` of type `α` as arguments, and it asserts the equality described above. The theorem is named `comp_inf_comp_extracted`, and it is stated within the context of a `GeneralizedBooleanAlgebra α`.\n\n7. **Use of `sorry`**: The keyword `sorry` is used as a placeholder for the proof. It indicates that the proof is not provided, but the statement is syntactically"}
{"source_file": "herald_data/sample_500.jsonl", "line": 15, "id": 27825, "informal_statement": "For any ordered module over an ordered semiring \\(\\mathbb{K}\\), the positive cone is pointed. That is, the intersection of the positive cone and its reflection through the origin consists only of the origin element.", "formal_statement": "import Mathlib\nopen Set LinearMap\nopen scoped Classical\nopen Pointwise\ntheorem pointed_positive_extracted (𝕜 : Type u_1) (E : Type u_2) [OrderedSemiring 𝕜] [OrderedAddCommGroup E] [Module 𝕜 E]\n [OrderedSMul 𝕜 E] : (ConvexCone.positive 𝕜 E).Pointed := sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to understand the components involved and how they relate to Lean's type system and libraries. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context**:\n   - We are dealing with an \"ordered module\" over an \"ordered semiring\" \\(\\mathbb{K}\\). In Lean, this involves several type classes: `OrderedSemiring` for \\(\\mathbb{K}\\), `OrderedAddCommGroup` for the module \\(E\\), and `Module` for the module structure.\n   - The \"positive cone\" in this context is a subset of the module that includes all non-negative linear combinations of its elements.\n\n2. **Formalizing the Ordered Structures**:\n   - `𝕜 : Type u_1` and `E : Type u_2` are type variables representing the semiring and the module, respectively.\n   - `[OrderedSemiring 𝕜]` indicates that \\(\\mathbb{K}\\) is an ordered semiring.\n   - `[OrderedAddCommGroup E]` indicates that \\(E\\) is an ordered additive commutative group.\n   - `[Module 𝕜 E]` indicates that \\(E\\) is a module over \\(\\mathbb{K}\\).\n   - `[OrderedSMul 𝕜 E]` indicates that scalar multiplication respects the order, i.e., it is compatible with the ordering on both \\(\\mathbb{K}\\) and \\(E\\).\n\n3. **Defining the Positive Cone**:\n   - `ConvexCone.positive 𝕜 E` refers to the positive cone in the module \\(E\\). This is a predefined concept in Lean's math library, representing the set of all elements that can be expressed as non-negative linear combinations of elements in \\(E\\).\n\n4. **Pointed Property**:\n   - The statement \"the positive cone is pointed\" means that the intersection of the positive cone and its reflection through the origin contains only the zero element.\n   - In Lean, a cone being \"pointed\" is expressed by the property `ConvexCone.Pointed`, which asserts that the only element in both the cone and its negation is the zero element.\n\n5. **Theorem Statement**:\n   - `theorem pointed_positive_extracted` is the name of the theorem we are proving.\n   - The type"}
{"source_file": "herald_data/sample_500.jsonl", "line": 17, "id": 450916, "informal_statement": "Calculate the sum $S_n=\\sum_{k=1}^n \\left\\lfloor\\sqrt{k+\\left\\lfloor\\sqrt{k}\\right\\rfloor}\\right\\rfloor \\quad n\\in\\mathbb{Z}^+$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_450916 (n : ℕ) (f: ℕ → ℕ) (hf: f x = ∑ k in Finset.Icc 1 n, (Int.floor (Real.sqrt (k + (Int.floor (Real.sqrt k)))))) : ∑ k in Finset.range n, f k = n * (n + 1) / 2  :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal Lean4 representation.\n\n1. **Understanding the Informal Statement:**\n   - The informal statement describes a sum \\( S_n = \\sum_{k=1}^n \\left\\lfloor \\sqrt{k + \\left\\lfloor \\sqrt{k} \\right\\rfloor} \\right\\rfloor \\).\n   - Here, \\( n \\) is a positive integer (\\( n \\in \\mathbb{Z}^+ \\)).\n   - The expression involves nested floor and square root functions.\n\n2. **Lean4 Imports and Setup:**\n   - `import Mathlib`: This imports the Mathlib library, which contains a wide range of mathematical definitions and theorems.\n   - `open BigOperators`: This allows the use of big operators like summation (\\(\\sum\\)) in Lean.\n   - `open Real Nat Topology`: These open the namespaces for real numbers, natural numbers, and topology, providing access to functions like `sqrt` and `floor`.\n\n3. **Formalizing the Sum:**\n   - The sum is expressed using `∑ k in Finset.Icc 1 n`, which represents the sum over the closed interval from 1 to \\( n \\) (inclusive) in Lean.\n   - The expression inside the sum, `Int.floor (Real.sqrt (k + (Int.floor (Real.sqrt k))))`, directly translates the nested floor and square root operations from the informal statement.\n\n4. **Defining the Function \\( f \\):**\n   - The function \\( f: \\mathbb{N} \\to \\mathbb{N} \\) is defined such that for each \\( x \\), \\( f(x) \\) is the sum described above.\n   - The hypothesis `hf: f x = ∑ k in Finset.Icc 1 n, (Int.floor (Real.sqrt (k + (Int.floor (Real.sqrt k)))))` specifies this definition of \\( f \\).\n\n5. **Theorem Statement:**\n   - The theorem `extract_aug_450916` is stated for a natural number \\( n \\) and a function \\( f \\).\n   - The goal is to prove that the sum of \\( f(k) \\) over the range from 0 to \\( n-1 \\) (i.e.,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 16, "id": 208500, "informal_statement": "For any natural number $n$, demonstrate that the expression $\\frac{\\phi^{n+1} - \\psi^{n+1}}{\\sqrt{5}} - \\phi \\cdot fib(n)$ is equal to $\\psi^n$, where $\\phi$ and $\\psi$ are the golden ratio and its conjugate, respectively, and $fib(n)$ represents the $n$th Fibonacci number.", "formal_statement": "import Mathlib\nopen Polynomial\nopen Real goldenRatio\nopen Polynomial\nlemma fib_golden_conj_exp_tac_6457 (n : ℕ) : (φ ^ (n + 1) - ψ ^ (n + 1)) / √5 - φ * ↑(Nat.fib n) = ψ ^ n := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to break down each component of the statement and map it to the corresponding Lean constructs. Here's the step-by-step explanation:\n\n1. **Understanding the Variables and Constants:**\n   - The informal statement involves natural numbers, the golden ratio (φ), its conjugate (ψ), and Fibonacci numbers.\n   - In Lean, natural numbers are represented by `ℕ`.\n   - The golden ratio (φ) and its conjugate (ψ) are typically predefined in mathematical libraries, such as `Mathlib`, under `goldenRatio`.\n\n2. **Defining the Function and Variables:**\n   - The statement is a lemma about natural numbers, so we start by defining a lemma with a natural number `n` as an argument: `lemma fib_golden_conj_exp_tac_6457 (n : ℕ)`.\n   - The lemma name `fib_golden_conj_exp_tac_6457` is a unique identifier for this specific result.\n\n3. **Translating the Expression:**\n   - The expression involves powers of φ and ψ, division by √5, and multiplication with the Fibonacci number.\n   - In Lean, powers are expressed using the `^` operator, and division is expressed using `/`.\n   - The square root of 5 is represented as `√5` in Lean, which is part of the `Real` number operations.\n\n4. **Fibonacci Numbers:**\n   - The Fibonacci number `fib(n)` is represented in Lean using `Nat.fib n`, where `Nat` is the namespace for natural number operations.\n\n5. **Constructing the Expression:**\n   - The left-hand side of the equation is `(φ ^ (n + 1) - ψ ^ (n + 1)) / √5 - φ * ↑(Nat.fib n)`.\n   - The `↑` operator is used to cast the natural number `Nat.fib n` to a real number, as Lean requires explicit type conversions.\n\n6. **Equality to ψ^n:**\n   - The right-hand side of the equation is simply `ψ ^ n`.\n\n7. **Combining Everything:**\n   - The complete formal statement in Lean is:\n     ```lean\n     lemma fib_golden_conj_exp_tac_6457 (n : ℕ) : (φ ^ (n + 1) - ψ ^ (n + 1)) /"}
{"source_file": "herald_data/sample_500.jsonl", "line": 20, "id": 291708, "informal_statement": "For any integers $a$ and $b$, show that the cardinality of the set of integers in the open interval $(a, b)$ is equal to the natural number obtained by casting the difference $(b - a)$ to $\\mathbb{N}$, i.e., $\\#(a, b) = (b - a)^\\mathbb{N}$.", "formal_statement": "import Mathlib\nopen Finset Int\nlemma card_fintype_Ioc_tac_5428 (a : ℤ) (b : ℤ) : Fintype.card ↑(Set.Ioc a b) = (b - a).toNat := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to break down the components of the statement and understand how they map to Lean constructs:\n\n1. **Understanding the Informal Statement**:\n   - We are given two integers, \\(a\\) and \\(b\\).\n   - We need to consider the set of integers in the open interval \\((a, b)\\), which means integers greater than \\(a\\) and less than or equal to \\(b\\).\n   - The task is to show that the number of such integers is equal to the natural number obtained by converting the difference \\(b - a\\) to a natural number.\n\n2. **Translating to Lean**:\n   - **Integers \\(a\\) and \\(b\\)**: In Lean, we declare \\(a\\) and \\(b\\) as integers using `(a : ℤ)` and `(b : ℤ)`.\n   - **Open Interval \\((a, b)\\)**: In Lean, the set of integers in the interval \\((a, b)\\) is represented using `Set.Ioc a b`. Here, `Ioc` stands for \"interval open-closed\", meaning it includes elements greater than \\(a\\) and up to \\(b\\).\n   - **Cardinality of the Set**: The cardinality of a finite set in Lean is obtained using `Fintype.card`. The expression `Fintype.card ↑(Set.Ioc a b)` computes the number of elements in the set of integers in the interval \\((a, b)\\).\n   - **Difference \\(b - a\\) as a Natural Number**: The difference \\(b - a\\) is an integer, but we need it as a natural number. In Lean, this is done using the `.toNat` method, which converts an integer to a natural number, assuming it is non-negative.\n\n3. **Putting it Together**:\n   - The lemma `card_fintype_Ioc_tac_5428` states that for any integers \\(a\\) and \\(b\\), the cardinality of the set of integers in the interval \\((a, b)\\) is equal to the natural number obtained by converting \\(b - a\\) to a natural number.\n   - The `sorry` at the end indicates that the proof of this lemma is not provided, but the statement itself is correctly formalized.\n\nIn summary, the Lean"}
{"source_file": "herald_data/sample_500.jsonl", "line": 19, "id": 482082, "informal_statement": "Let $a, b, c$ be $3$ real numbers such that $a+b+c=3.$ Prove that \\n $\\frac{1}{5a^2-4a+11}+\\frac{1}{5b^2-4b+11}+\\frac{1}{5c^2-4c+11}\\leq \\frac{1}{4}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_482082 (a b c : ℝ) (habc : a + b + c = 3) : (1 / (5 * a ^ 2 - 4 * a + 11) + 1 / (5 * b ^ 2 - 4 * b + 11) + 1 / (5 * c ^ 2 - 4 * c + 11)) ≤ 1 / 4  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow a structured approach to ensure that all components of the statement are accurately represented in the formal language. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves three real numbers, \\(a\\), \\(b\\), and \\(c\\). In Lean, these are represented as variables of type `ℝ`, which stands for real numbers in the Lean mathematical library.\n\n2. **State the Given Condition**:\n   - The condition \\(a + b + c = 3\\) is a hypothesis that needs to be included in the theorem. In Lean, this is expressed as `habc : a + b + c = 3`, where `habc` is a label for this hypothesis.\n\n3. **Express the Inequality to be Proved**:\n   - The goal is to prove the inequality \\(\\frac{1}{5a^2-4a+11}+\\frac{1}{5b^2-4b+11}+\\frac{1}{5c^2-4c+11}\\leq \\frac{1}{4}\\).\n   - In Lean, division is represented by the `/` operator, and exponentiation is represented by `^`. Thus, each term in the sum is expressed as `1 / (5 * a ^ 2 - 4 * a + 11)`, and similarly for \\(b\\) and \\(c\\).\n   - The sum of these terms is then compared to `1 / 4` using the `≤` operator.\n\n4. **Structure the Theorem**:\n   - The theorem is structured using the `theorem` keyword, followed by a name for the theorem, `extract_aug_482082`, which is a placeholder name.\n   - The variables \\(a\\), \\(b\\), and \\(c\\) are declared as arguments to the theorem, along with the hypothesis `habc`.\n   - The statement of the theorem is then the inequality to be proved.\n\n5. **Use of Lean Libraries**:\n   - The `import Mathlib` statement is used to include the necessary mathematical libraries that provide definitions and theorems for real numbers and inequalities.\n   - The `open BigOperators`, `open Real`, `open Nat`, and `open Topology` statements are used to bring relevant definitions and not"}
{"source_file": "herald_data/sample_500.jsonl", "line": 18, "id": 231152, "informal_statement": "For any real numbers $a$ and $t$ such that $t > 0$, and for any integer $n$, if $-2\\pi \\neq 0$, show that \\[\n-2\\pi \\cdot (-i n) \\cdot \\exp(2\\pi i n a - \\pi n^2 t) = 2\\pi i n \\cdot \\exp(2\\pi i n a + \\pi i n^2 (i t)).\n\\]", "formal_statement": "import Mathlib\nopen Complex hiding abs_of_nonneg\nopen CharZero Filter Topology Asymptotics Real Set MeasureTheory\nopen scoped ComplexConjugate\nlemma hasSum_int_sinKernel_tac_12397 (a : ℝ) (t : ℝ) (ht : 0 < t) (h : -2 * ↑π ≠ 0) (n : ℤ) : -2 * ↑π * (-I * ↑n) * cexp (2 * ↑π * I * ↑a * ↑n + -↑π * ↑n ^ 2 * ↑t) =\n  2 * ↑π * I * ↑n * cexp (2 * ↑π * I * ↑n * ↑a + ↑π * I * ↑n ^ 2 * (I * ↑t)) := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully map each component of the informal statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Variables and Types:**\n   - The informal statement involves real numbers \\(a\\) and \\(t\\), and an integer \\(n\\). In Lean, we represent real numbers using `ℝ` and integers using `ℤ`.\n   - The condition \\(t > 0\\) is represented by the hypothesis `ht : 0 < t`.\n   - The condition \\(-2\\pi \\neq 0\\) is represented by the hypothesis `h : -2 * ↑π ≠ 0`.\n\n2. **Complex Numbers and Exponentials:**\n   - The expression involves complex numbers and the exponential function. In Lean, complex numbers are handled using the `Complex` module.\n   - The imaginary unit \\(i\\) is represented by `I` in Lean.\n   - The exponential function \\(\\exp\\) is represented by `cexp` in Lean, which stands for complex exponential.\n\n3. **Translate the Expression:**\n   - The left-hand side of the equation \\(-2\\pi \\cdot (-i n) \\cdot \\exp(2\\pi i n a - \\pi n^2 t)\\) is translated as:\n     - `-2 * ↑π * (-I * ↑n) * cexp (2 * ↑π * I * ↑a * ↑n + -↑π * ↑n ^ 2 * ↑t)`.\n     - Here, `↑` is used to cast integers and real numbers to complex numbers, ensuring type consistency.\n     - The multiplication and addition operations are directly translated, and the exponential function is applied to the complex expression.\n\n   - The right-hand side of the equation \\(2\\pi i n \\cdot \\exp(2\\pi i n a + \\pi i n^2 (i t))\\) is translated as:\n     - `2 * ↑π * I * ↑n * cexp (2 * ↑π * I * ↑n * ↑a + ↑π * I * ↑n ^ 2 * (I * ↑t))`.\n     - Similar casting and operations are applied here, with careful attention to the placement of the imaginary unit `I`.\n\n4. **Structure the Lemma:**"}
{"source_file": "herald_data/sample_500.jsonl", "line": 23, "id": 454163, "informal_statement": "Find the value of $\\sum_{n=0}^{10}\\binom{20}{2n}\\left(\\frac{1}{2}\\right)^{20-2n}$ .", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_454163 (n : ℕ) (h : n = 10) : ∑ k in Finset.range (n + 1), (Nat.choose 20 (2 * k)) * (1 / 2) ^ (20 - 2 * k) = (3 ^ 20 / 2 ^ 20) + 1 / 2 ^ 20  :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Informal Statement**: The problem asks us to evaluate the sum \\(\\sum_{n=0}^{10}\\binom{20}{2n}\\left(\\frac{1}{2}\\right)^{20-2n}\\). This is a finite sum where each term is a product of a binomial coefficient and a power of \\(\\frac{1}{2}\\).\n\n2. **Setting Up the Lean Environment**: \n   - We start by importing necessary modules from Mathlib, which is a library for Lean that includes many mathematical definitions and theorems. \n   - `open BigOperators` is used to enable the use of the `∑` notation for sums.\n   - `open Real Nat Topology` is used to access real numbers, natural numbers, and topological concepts, though in this specific theorem, the focus is on real and natural numbers.\n\n3. **Defining the Theorem**: \n   - The theorem is named `extract_aug_454163`, which is a placeholder name and can be replaced with a more descriptive one.\n   - The theorem takes two parameters: `n : ℕ` and `h : n = 10`. Here, `n` is a natural number, and `h` is a hypothesis that `n` equals 10. This is because the sum is specifically evaluated from 0 to 10.\n\n4. **Formalizing the Sum**:\n   - The sum is expressed using `∑ k in Finset.range (n + 1)`, which iterates over the range from 0 to `n` (inclusive). Since `n = 10`, this corresponds to the range from 0 to 10.\n   - Each term in the sum is given by `(Nat.choose 20 (2 * k)) * (1 / 2) ^ (20 - 2 * k)`. This matches the informal statement where \\(\\binom{20}{2n}\\) is represented by `Nat.choose 20 (2 * k)` and \\(\\left(\\frac{1}{2}\\right)^{20-2n}\\) is represented by `(1 / 2) ^ (20 - 2 * k)`.\n\n5. **Stating the Result**:\n   - The result of the sum is given as `(3 ^"}
{"source_file": "herald_data/sample_500.jsonl", "line": 21, "id": 6814, "informal_statement": "For any countable index set $\\iota$ and a family of propositions $p : \\iota \\to \\alpha \\to \\text{Prop}$ such that for every $i \\in \\iota$, the predicate $p i$ is measurable, show that the predicate defined by $a \\mapsto \\forall i, p i a$ is also measurable.", "formal_statement": "import Mathlib\nopen Set Encodable Function Equiv Filter MeasureTheory\nopen MeasurableSpace\nopen List\ntheorem forall_extracted {ι : Sort uι} [MeasurableSpace α] [Countable ι] {p : ι → α → Prop} :\n (∀ (i : ι), Measurable (p i)) → Measurable fun a => ∀ (i : ι), p i a := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a series of logical steps that align the informal concepts with their formal counterparts in Lean. Here's a detailed breakdown of the translation process:\n\n1. **Understanding the Context**:\n   - The informal statement involves a countable index set $\\iota$ and a family of propositions $p : \\iota \\to \\alpha \\to \\text{Prop}$.\n   - We are given that for each $i \\in \\iota$, the predicate $p i$ is measurable.\n   - The goal is to show that the predicate defined by $a \\mapsto \\forall i, p i a$ is also measurable.\n\n2. **Translating the Index Set**:\n   - In Lean, the index set $\\iota$ is represented by a type `ι`. The statement specifies that this set is countable.\n   - This is captured by the type class `[Countable ι]`, which indicates that `ι` is a countable type.\n\n3. **Translating the Family of Propositions**:\n   - The family of propositions $p : \\iota \\to \\alpha \\to \\text{Prop}$ is translated to `p : ι → α → Prop` in Lean.\n   - Here, `ι` is the index type, `α` is the type over which the propositions are defined, and `Prop` indicates that these are logical propositions.\n\n4. **Measurability Assumption**:\n   - The informal statement assumes that for every $i \\in \\iota$, the predicate $p i$ is measurable.\n   - In Lean, this is expressed as `∀ (i : ι), Measurable (p i)`, meaning for each index `i`, the function `p i` is measurable.\n\n5. **Goal: Measurability of the Universal Quantification**:\n   - The goal is to show that the function `a \\mapsto \\forall i, p i a` is measurable.\n   - In Lean, this is expressed as `Measurable fun a => ∀ (i : ι), p i a`.\n   - The `fun a => ∀ (i : ι), p i a` is a lambda function in Lean that takes an element `a` of type `α` and returns a proposition stating that `p i a` holds for all `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 22, "id": 167418, "informal_statement": "For any element \\(a\\) in a group with zero \\(G_0\\), given that \\(a\\) is not equal to zero, show that \\(1 = 1\\).", "formal_statement": "import Mathlib\nopen Function\nlemma zpow_add_one₀_tac_13291 [GroupWithZero G₀] (a : G₀) (ha : a ≠ 0) : 1 = 1 := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand the components of both the informal and formal statements and how they correspond to each other.\n\n1. **Understanding the Context**: \n   - The informal statement involves a group with zero, denoted as \\( G_0 \\). In Lean, this is represented by the type class `GroupWithZero G₀`. This type class includes both the group operations and the presence of a zero element.\n\n2. **Identifying the Element and Condition**:\n   - The element \\( a \\) in the group \\( G_0 \\) is represented as `(a : G₀)` in Lean. This indicates that \\( a \\) is an element of the type `G₀`, which is our group with zero.\n   - The condition \\( a \\neq 0 \\) is expressed as `(ha : a ≠ 0)`. This is a hypothesis in the lemma, indicating that \\( a \\) is not the zero element of the group.\n\n3. **The Goal**:\n   - The informal statement asks to show that \\( 1 = 1 \\). This is a trivial statement, often used as a placeholder or to indicate that the main focus is on the conditions rather than the conclusion.\n   - In Lean, this is directly translated to `1 = 1`, which is the conclusion of the lemma.\n\n4. **Structure of the Lean Code**:\n   - The `lemma` keyword introduces a new lemma in Lean. The name `zpow_add_one₀_tac_13291` is an arbitrary identifier for this lemma.\n   - The square brackets `[GroupWithZero G₀]` indicate that `G₀` is assumed to be a type that satisfies the `GroupWithZero` type class, providing the necessary structure and operations.\n   - The parameters `(a : G₀) (ha : a ≠ 0)` specify the element \\( a \\) and the condition \\( a \\neq 0 \\).\n   - The conclusion `: 1 = 1` is the statement to be proven, which is trivially true.\n\n5. **The `sorry` Keyword**:\n   - The `sorry` keyword is a placeholder in Lean, indicating that the proof is omitted. Since \\( 1 = 1 \\) is trivially true, the proof is straightforward and can be completed without further steps.\n\nIn summary, the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 25, "id": 291373, "informal_statement": "For any seminormed additive commutative groups \\(G\\), \\(H\\), and \\(K\\), and given normed additive group homomorphisms \\(f: G \\to H\\) and \\(g: H \\to K\\), along with an element \\(x\\) from the completion of \\(G\\), show that the composition of the completion maps induced by \\(g\\) and \\(f\\) applied to \\(x\\) is equal to the completion map induced by the composition of \\(g\\) and \\(f\\) applied to \\(x\\). In other words, \\((g \\circ f)^{\\wedge}(x) = g^{\\wedge} \\circ f^{\\wedge}(x)\\), where \\(\\wedge\\) denotes the completion map.", "formal_statement": "import Mathlib\nopen Set NormedAddGroupHom UniformSpace\nlemma completion_comp_tac_3883 [SeminormedAddCommGroup G] [SeminormedAddCommGroup H] [SeminormedAddCommGroup K] (f : NormedAddGroupHom G H) (g : NormedAddGroupHom H K) (x : Completion G) : (⇑g.completion ∘ ⇑f.completion) x = Completion.map (⇑(g.comp f)) x := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a series of steps that align the informal concepts with their formal counterparts in Lean. Here's the breakdown:\n\n1. **Understanding the Context**:\n   - We are dealing with seminormed additive commutative groups \\(G\\), \\(H\\), and \\(K\\).\n   - We have normed additive group homomorphisms \\(f: G \\to H\\) and \\(g: H \\to K\\).\n   - We are considering the completion of these groups and the completion maps induced by the homomorphisms.\n\n2. **Formalizing the Groups and Homomorphisms**:\n   - In Lean, the concept of a seminormed additive commutative group is captured by the type class `SeminormedAddCommGroup`.\n   - The homomorphisms \\(f\\) and \\(g\\) are instances of `NormedAddGroupHom`, which represents continuous homomorphisms between normed additive groups.\n\n3. **Completion and Completion Maps**:\n   - The completion of a group \\(G\\) is represented by `Completion G` in Lean.\n   - The completion map induced by a homomorphism is accessed using the `.completion` method on a `NormedAddGroupHom`.\n\n4. **Formalizing the Statement**:\n   - The goal is to show that the composition of the completion maps induced by \\(g\\) and \\(f\\) applied to an element \\(x\\) from the completion of \\(G\\) is equal to the completion map induced by the composition of \\(g\\) and \\(f\\) applied to \\(x\\).\n   - In Lean, this is expressed as `(⇑g.completion ∘ ⇑f.completion) x = Completion.map (⇑(g.comp f)) x`.\n\n5. **Breaking Down the Lean Code**:\n   - `lemma completion_comp_tac_3883`: This declares a lemma named `completion_comp_tac_3883`.\n   - `[SeminormedAddCommGroup G] [SeminormedAddCommGroup H] [SeminormedAddCommGroup K]`: These are type class constraints ensuring \\(G\\), \\(H\\), and \\(K\\) are seminormed additive commutative groups.\n   - `(f : NormedAddGroupHom G H) (g : NormedAddGroupHom"}
{"source_file": "herald_data/sample_500.jsonl", "line": 27, "id": 225776, "informal_statement": "For any set $s$ in the extended real numbers $\\mathbb{R} \\cup \\{\\pm\\infty\\}$, show that there exists an extended real number $i$ such that the right-open interval $(i, +\\infty]$ is a subset of $s$ if and only if there exists an extended real number $y$ such that the right-open interval $(y, +\\infty]$ is also a subset of $s$.", "formal_statement": "import Mathlib\nopen Set Filter Metric TopologicalSpace Topology\nopen scoped ENNReal\nlemma mem_nhds_top_iff_tac_4929 (s : Set EReal) : (∃ i, True ∧ Ioi ↑i ⊆ s) ↔ ∃ y, Ioi ↑y ⊆ s := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Domain and Codomain**:\n   - The informal statement involves sets in the extended real numbers, denoted as $\\mathbb{R} \\cup \\{\\pm\\infty\\}$. In Lean, this is represented by `EReal`, which stands for the extended real numbers.\n\n2. **Identifying the Set and Intervals**:\n   - The statement refers to a set $s$ and intervals of the form $(i, +\\infty]$. In Lean, the set $s$ is represented as `s : Set EReal`.\n   - The interval $(i, +\\infty]$ is represented using the notation `Ioi ↑i`, where `Ioi` stands for the open interval and `↑i` is the coercion of `i` into the type `EReal`.\n\n3. **Existential Quantifiers**:\n   - The informal statement uses existential quantifiers \"there exists an extended real number $i$\" and \"there exists an extended real number $y$\". In Lean, these are represented using `∃ i` and `∃ y`, respectively.\n\n4. **Logical Structure**:\n   - The informal statement is an \"if and only if\" (iff) statement, which is represented in Lean by `↔`.\n   - The condition \"such that the right-open interval $(i, +\\infty]$ is a subset of $s$\" is translated to `Ioi ↑i ⊆ s`.\n   - Similarly, \"such that the right-open interval $(y, +\\infty]$ is also a subset of $s$\" is translated to `Ioi ↑y ⊆ s`.\n\n5. **True Condition**:\n   - The informal statement does not explicitly mention a `True` condition, but in Lean, `True ∧` is used to ensure the existence of `i` is non-trivial. This is a technical detail often used in formal proofs to handle vacuous truths or to align with certain proof strategies.\n\n6. **Combining the Elements**:\n   - The left side of the `↔` in Lean is `(∃ i, True ∧ Ioi ↑i ⊆ s)`, which states that there exists an `i` such that the interval `(i, +\\in"}
{"source_file": "herald_data/sample_500.jsonl", "line": 24, "id": 359737, "informal_statement": "For any positive integer $n$, $\\log(n) \\cdot \\mu(n) = \\Lambda(n)$.", "formal_statement": "import Mathlib\nopen Finset Nat\nopen scoped ArithmeticFunction\n@[simp]\ntheorem log_mul_moebius_eq_vonMangoldt : log * μ = Λ := sorry", "explanation": "To translate the informal mathematical statement \"For any positive integer $n$, $\\log(n) \\cdot \\mu(n) = \\Lambda(n)$\" into the formal Lean4 statement, we need to understand the components involved and how they are represented in Lean.\n\n1. **Understanding the Functions:**\n   - $\\log(n)$: In this context, $\\log(n)$ refers to the logarithm function, typically the natural logarithm, but in number theory, it often refers to the logarithm base $e$ or base 10. In Lean, this is represented by `log`, which is part of the arithmetic functions.\n   - $\\mu(n)$: This is the Möbius function, denoted by `μ` in Lean. It is an important multiplicative function in number theory.\n   - $\\Lambda(n)$: This is the von Mangoldt function, denoted by `Λ` in Lean. It is another significant arithmetic function used in analytic number theory.\n\n2. **Arithmetic Functions in Lean:**\n   - Lean's math library provides a framework for dealing with arithmetic functions, which are functions from natural numbers to some commutative ring. The notation `log * μ = Λ` uses the multiplication of arithmetic functions, which is defined pointwise.\n\n3. **Formalizing the Statement:**\n   - The informal statement claims an equality between two arithmetic functions for all positive integers $n$. In Lean, this is expressed as an equality between the functions themselves, not just their values at specific points.\n   - The theorem is named `log_mul_moebius_eq_vonMangoldt`, which is descriptive of the content: it states that the product of the logarithm and Möbius function equals the von Mangoldt function.\n\n4. **Lean Syntax and Structure:**\n   - `import Mathlib`: This imports the necessary mathematical library that contains definitions and theorems related to arithmetic functions.\n   - `open Finset Nat`: This opens the namespaces for finite sets and natural numbers, which are often used in number-theoretic contexts.\n   - `open scoped ArithmeticFunction`: This opens the scope for arithmetic functions, allowing us to use the notation and operations defined for them.\n   - `@[simp]`: This attribute is used to mark the theorem as a simplification rule, which can be used by Lean's simplifier to automatically simplify expressions involving these functions.\n   - `theorem log_mul_moebius_eq_vonMang"}
{"source_file": "herald_data/sample_500.jsonl", "line": 26, "id": 163036, "informal_statement": "For any semiring \\(R\\) and any two nonzero polynomials \\(p, q \\in R[X]\\) such that their product \\(p \\cdot q\\) is also nonzero, show that the sum of their natural trailing degrees, \\(p.\\text{ntrdeg} + q.\\text{ntrdeg}\\), is less than or equal to the natural trailing degree of their product, \\((p \\cdot q).\\text{ntrdeg\\). Here, the natural trailing degree of a polynomial refers to the smallest degree of a nonzero term in the polynomial.", "formal_statement": "import Mathlib\nopen Function Polynomial Finsupp Finset\nopen scoped Polynomial\nlemma le_natTrailingDegree_mul_tac_11611 [Semiring R] (p : R[X]) (q : R[X]) (h : p * q ≠ 0) (hp : p ≠ 0) (hq : q ≠ 0) : p.natTrailingDegree + q.natTrailingDegree ≤ (p * q).natTrailingDegree := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a structured approach that captures the essence of the problem and its formalization in Lean. Here's a step-by-step explanation:\n\n1. **Understanding the Context**:\n   - The problem involves polynomials over a semiring \\( R \\). In Lean, this is represented by the type `R[X]`, where `R` is a semiring and `X` denotes the indeterminate of the polynomial ring.\n   - The concept of \"natural trailing degree\" is used, which refers to the smallest degree of a nonzero term in a polynomial. In Lean, this is accessed via the method `natTrailingDegree`.\n\n2. **Setting Up the Environment**:\n   - The code begins with `import Mathlib`, which imports the necessary mathematical library that includes definitions and theorems about polynomials and semirings.\n   - The `open` statements (`open Function Polynomial Finsupp Finset`) make various modules available, allowing us to use their definitions and theorems without prefixing them with the module name.\n   - `open scoped Polynomial` is used to bring polynomial-specific notations and operations into scope.\n\n3. **Defining the Lemma**:\n   - The lemma is named `le_natTrailingDegree_mul_tac_11611`, which is a unique identifier for this specific result.\n   - The lemma is parameterized over a semiring `R`, indicated by `[Semiring R]`. This means that `R` is assumed to have the properties of a semiring, which are necessary for the operations on polynomials.\n\n4. **Specifying the Variables**:\n   - `p : R[X]` and `q : R[X]` declare `p` and `q` as polynomials over the semiring `R`.\n   - The hypothesis `h : p * q ≠ 0` asserts that the product of `p` and `q` is nonzero.\n   - The hypotheses `hp : p ≠ 0` and `hq : q ≠ 0` assert that both `p` and `q` are nonzero polynomials.\n\n5. **Stating the Conclusion**:\n   - The conclusion of the lemma is `p.natTrailingDegree + q.natTrailingDegree ≤ (p * q).natTrailingDegree`.\n   - This directly corresponds to the informal statement that the sum of the natural trailing degrees"}
{"source_file": "herald_data/sample_500.jsonl", "line": 33, "id": 381550, "informal_statement": "For any natural number $p$, show that the Mersenne number $2^p - 1$ is positive, i.e., $0 < 2^p - 1$.", "formal_statement": "import Mathlib\nopen Lean Meta Qq Function\nopen Nat\ntheorem mersenne_int_pos {p : ℕ} (hp : p ≠ 0) : (0 : ℤ) < 2 ^ p - 1 := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Domain and Variables**: The informal statement involves natural numbers and specifically mentions a natural number \\( p \\). In Lean, natural numbers are represented by the type `ℕ`.\n\n2. **Understand the Mathematical Expression**: The expression \\( 2^p - 1 \\) is a Mersenne number, which is defined for any natural number \\( p \\). The goal is to show that this expression is positive.\n\n3. **Formalize the Hypothesis**: The statement implicitly assumes that \\( p \\) is a positive natural number (since \\( 2^0 - 1 = 0 \\) is not positive). Therefore, we need to include a hypothesis that \\( p \\neq 0 \\).\n\n4. **Translate the Expression**: The expression \\( 2^p - 1 \\) is directly translated into Lean as `2 ^ p - 1`. The caret `^` is used for exponentiation in Lean.\n\n5. **Specify the Type of the Expression**: The expression \\( 2^p - 1 \\) is an integer when considering positivity, so we need to specify that the comparison is in the integer domain. In Lean, integers are represented by the type `ℤ`.\n\n6. **State the Inequality**: The goal is to show that \\( 2^p - 1 \\) is positive, which translates to the inequality `0 < 2 ^ p - 1`. The `0` here is explicitly typed as an integer using `(0 : ℤ)` to ensure the comparison is made in the integer domain.\n\n7. **Structure the Theorem**: The theorem is structured with a name, `mersenne_int_pos`, and it takes a natural number `p` with the hypothesis `hp : p ≠ 0`. The conclusion is the inequality `(0 : ℤ) < 2 ^ p - 1`.\n\n8. **Use of `sorry`**: The keyword `sorry` is used as a placeholder for the proof, indicating that the proof is not yet provided.\n\nBy following these steps, the informal statement is translated into the formal Lean theorem:\n\n```lean\nimport Mathlib\nopen Lean Meta Qq Function\nopen Nat\ntheorem mersenne_int_pos {p : ℕ} (hp : p ≠ 0) : (0"}
{"source_file": "herald_data/sample_500.jsonl", "line": 30, "id": 97255, "informal_statement": "For any elements \\(a\\) and \\(b\\) in the type \\(\\alpha\\), show that the difference between the square of \\(a\\) and the square of \\(b\\), denoted as \\(a \\times a - b \\times b\\), is equal to the product of the sum and the difference of \\(a\\) and \\(b\\), i.e., \\((a + b) \\times (a - b)\\).", "formal_statement": "import Mathlib\nopen Function\ntheorem mul_self_tsub_mul_self_extracted [CanonicallyOrderedCommSemiring α] [Sub α] [OrderedSub α]\n [IsTotal α fun x x_1 => x ≤ x_1]\n [ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a b : α) :\n a * a - b * b = (a + b) * (a - b) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a series of steps that map the mathematical concepts to their formal counterparts in Lean. Here's a detailed breakdown of the translation process:\n\n1. **Understanding the Mathematical Statement**:\n   - We are given two elements \\(a\\) and \\(b\\) of some type \\(\\alpha\\).\n   - We need to show that the expression \\(a \\times a - b \\times b\\) is equal to \\((a + b) \\times (a - b)\\).\n\n2. **Identifying the Type and Operations**:\n   - The type \\(\\alpha\\) is not specified in the informal statement, but it must support operations like addition, multiplication, and subtraction.\n   - In Lean, these operations are typically defined for types that are instances of certain algebraic structures.\n\n3. **Choosing the Appropriate Algebraic Structure**:\n   - The Lean code uses `CanonicallyOrderedCommSemiring α`, which is a type class that provides a commutative semiring structure with a canonical order. This ensures that the type \\(\\alpha\\) supports addition, multiplication, and has a total order.\n   - The `[Sub α]` and `[OrderedSub α]` type classes indicate that subtraction is defined and ordered for the type \\(\\alpha\\).\n\n4. **Handling Total Order and Contravariant Class**:\n   - The `[IsTotal α fun x x_1 => x ≤ x_1]` ensures that the type \\(\\alpha\\) has a total order, meaning any two elements can be compared.\n   - The `[ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]` is a technical condition that ensures certain properties about how addition interacts with the order, which might be necessary for the proof.\n\n5. **Formalizing the Statement**:\n   - The theorem is named `mul_self_tsub_mul_self_extracted`, which suggests it is about extracting or proving the difference of squares identity.\n   - The parameters `(a b : α)` specify that \\(a\\) and \\(b\\) are elements of the type \\(\\alpha\\).\n\n6. **Expressing the Equality**:\n   - The expression `a * a - b * b` corresponds to the difference of the squares of \\(a\\) and \\(b\\).\n   - The"}
{"source_file": "herald_data/sample_500.jsonl", "line": 29, "id": 107179, "informal_statement": "For any type $\\alpha$, show that the type $\\alpha$ is empty if and only if the assumption of an arbitrary element of $\\alpha$ leads to a contradiction, i.e., $\\lnot (\\exists a : \\alpha) \\Leftrightarrow (\\forall x : \\alpha, \\bot)$.", "formal_statement": "import Mathlib\n\ntheorem not_nonempty_iff_imp_false_extracted {α : Sort u_3} : ¬Nonempty α ↔ α → False := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down the components of the statement and understand how they map to Lean's logical constructs.\n\n1. **Understanding the Informal Statement:**\n   - The statement is about a type $\\alpha$ and its emptiness.\n   - It claims that $\\alpha$ is empty if and only if assuming an arbitrary element of $\\alpha$ leads to a contradiction.\n   - In logical terms, this is expressed as: $\\lnot (\\exists a : \\alpha)$ is equivalent to $(\\forall x : \\alpha, \\bot)$.\n\n2. **Translating to Lean:**\n   - **Type $\\alpha$:** In Lean, types are denoted by variables like `α`. The statement is universally quantified over any type, so we declare `α` as a type variable.\n   - **Emptiness of a Type:** In Lean, a type is considered non-empty if there exists an element of that type. The predicate `Nonempty α` is used to express that there exists an element of type `α`. Therefore, `¬Nonempty α` expresses that the type `α` is empty.\n   - **Contradiction from an Element:** The expression $(\\forall x : \\alpha, \\bot)$ means that for every element `x` of type `α`, a contradiction (denoted by `False` in Lean) can be derived. In Lean, this is expressed as `α → False`, meaning that assuming an element of type `α` leads to a contradiction.\n\n3. **Constructing the Theorem:**\n   - The theorem is named `not_nonempty_iff_imp_false_extracted` to reflect its content.\n   - The statement `¬Nonempty α ↔ α → False` is the formalization of the informal statement. It uses the logical equivalence `↔` to express \"if and only if\".\n   - The theorem is parameterized over a type `α`, which is declared as `{α : Sort u_3}`. The `Sort u_3` allows `α` to be any type, including propositions and higher universes.\n\n4. **Importing Necessary Libraries:**\n   - The line `import Mathlib` is included to ensure that all necessary logical constructs and definitions, such as `Nonempty`, are available.\n\n5. **Conclusion:**\n   - The formal statement in Lean is a direct translation of the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 28, "id": 355474, "informal_statement": "For any two sets of prime numbers $u$ and $v$, prove that the product of the union of $u$ and $v$ is equal to the least common multiple of the products of $u$ and $v$, i.e., \\((u \\cup v).prod = \\mathop{\\text{lcm}}(u.prod, v.prod)\\).", "formal_statement": "import Mathlib\n\ntheorem prod_sup (u v : PrimeMultiset) : (u ⊔ v).prod = PNat.lcm u.prod v.prod := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Objects**: \n   - The informal statement involves two sets of prime numbers, denoted as \\( u \\) and \\( v \\).\n   - The operation described involves the union of these sets and their products, as well as the least common multiple (LCM) of these products.\n\n2. **Choose Appropriate Lean Structures**:\n   - In Lean, sets of numbers can be represented in various ways. Here, we use `PrimeMultiset`, which is a multiset (a set that allows multiple instances of the same element) specifically for prime numbers. This is suitable because the product of primes and their LCM are well-defined in this context.\n\n3. **Translate Set Operations**:\n   - The union of two sets \\( u \\cup v \\) is translated to the multiset operation `u ⊔ v` in Lean. The symbol `⊔` represents the multiset union, which combines the elements of both multisets, respecting their multiplicities.\n\n4. **Translate Product and LCM**:\n   - The product of a multiset is represented by the `.prod` method. Thus, `(u ⊔ v).prod` computes the product of all elements in the union of multisets \\( u \\) and \\( v \\).\n   - The least common multiple of the products of two multisets is represented by `PNat.lcm u.prod v.prod`. Here, `PNat` refers to positive natural numbers, and `lcm` is a function that computes the least common multiple.\n\n5. **Formalize the Theorem**:\n   - The theorem is named `prod_sup`, indicating it deals with the product of the supremum (union) of two multisets.\n   - The statement `(u ⊔ v).prod = PNat.lcm u.prod v.prod` directly translates the informal statement into Lean syntax, asserting that the product of the union of \\( u \\) and \\( v \\) is equal to the LCM of their individual products.\n\n6. **Structure of the Lean Code**:\n   - The code begins with `import Mathlib`, which imports necessary mathematical libraries.\n   - The theorem is declared with `theorem prod_sup (u v : PrimeMultiset)`, specifying that it applies to any two multisets of primes.\n   - The `:= sorry` at"}
{"source_file": "herald_data/sample_500.jsonl", "line": 32, "id": 101418, "informal_statement": "For any elements \\(a\\) and \\(b\\) in a structure \\(M_0\\) that is equipped with a zero less than or equal to one, positive multiplication monotonicity, and multiplication positive monotonicity, if \\(a \\leq 1\\), \\(0 \\leq b\\), and \\(b \\leq 1\\), show that \\(a \\cdot b \\leq 1\\).", "formal_statement": "import Mathlib\n\ntheorem mul_le_one_extracted [MonoidWithZero M₀] [Preorder M₀] {a b : M₀} [ZeroLEOneClass M₀]\n [PosMulMono M₀] [MulPosMono M₀] : a ≤ 1 → 0 ≤ b → b ≤ 1 → a * b ≤ 1 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a structured approach that captures the essence of the mathematical properties and conditions involved. Here's a step-by-step explanation of the translation:\n\n1. **Identify the Structure and Context**:\n   - The informal statement involves a structure \\( M_0 \\) with certain properties. In Lean, this is represented by a type `M₀` with specific typeclass instances that provide the necessary algebraic and order properties.\n\n2. **Import Necessary Libraries**:\n   - The statement begins with `import Mathlib`, which is a common practice in Lean to bring in the necessary mathematical libraries that contain definitions and theorems related to algebraic structures and order theory.\n\n3. **Define the Theorem**:\n   - The theorem is named `mul_le_one_extracted`, which suggests it is about proving a multiplication-related inequality.\n\n4. **Specify the Typeclass Instances**:\n   - `[MonoidWithZero M₀]`: This indicates that `M₀` is a monoid with zero, meaning it has an associative binary operation (multiplication), an identity element (one), and a zero element.\n   - `[Preorder M₀]`: This indicates that `M₀` is equipped with a preorder, providing a reflexive and transitive relation (denoted by `≤`).\n\n5. **Declare the Elements and Assumptions**:\n   - `{a b : M₀}`: These are the elements of the structure `M₀` that we are considering.\n   - `[ZeroLEOneClass M₀]`: This typeclass ensures that in `M₀`, zero is less than or equal to one (`0 ≤ 1`).\n   - `[PosMulMono M₀]`: This typeclass indicates positive multiplication monotonicity, meaning if `x ≤ y` and `0 ≤ z`, then `x * z ≤ y * z`.\n   - `[MulPosMono M₀]`: This typeclass indicates multiplication positive monotonicity, meaning if `x ≤ y` and `0 < z`, then `z * x ≤ z * y`.\n\n6. **State the Hypotheses**:\n   - `a ≤ 1`: This is a direct translation of the condition that element `a` is less than or equal to one.\n   - `0 ≤ b`: This translates the condition that element `b"}
{"source_file": "herald_data/sample_500.jsonl", "line": 35, "id": 277374, "informal_statement": "For a function $f : \\mathbb{R} \\to E$ where $E$ is a normed additive commutative group and also a normed space over $\\mathbb{R}$, and given $x \\in \\mathbb{R}$, if $f$ is differentiable within the open interval $(x, +\\infty)$ at $x$, and if there exists a derivative of $f$ within the closed interval $[x, +\\infty)$ at $x$, then the derivative of $f$ within the open interval $(x, +\\infty)$ at $x$ is equal to the derivative of $f$ within the closed interval $[x, +\\infty)$ at $x$.", "formal_statement": "import Mathlib\nopen scoped Topology ENNReal NNReal\nopen Filter Asymptotics Set\nopen ContinuousLinearMap (smulRight smulRight_one_eq_iff)\nlemma derivWithin_Ioi_eq_Ici_tac_21274 [NormedAddCommGroup E] [NormedSpace ℝ E] (f : ℝ → E) (x : ℝ) (H : DifferentiableWithinAt ℝ f (Ioi x) x) (A : HasDerivWithinAt f (derivWithin f (Ioi x) x) (Ici x) x) : derivWithin f (Ioi x) x = derivWithin f (Ici x) x := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully map each component of the statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Function and Spaces**: \n   - The function \\( f : \\mathbb{R} \\to E \\) is defined where \\( E \\) is a normed additive commutative group and a normed space over \\( \\mathbb{R} \\). In Lean, this is represented by the type signature `[NormedAddCommGroup E] [NormedSpace ℝ E]`, which specifies that \\( E \\) is both a normed additive commutative group and a normed space over the real numbers.\n\n2. **Variable Declaration**:\n   - The variable \\( x \\in \\mathbb{R} \\) is directly translated to `(x : ℝ)` in Lean, indicating that \\( x \\) is a real number.\n\n3. **Differentiability in Open Interval**:\n   - The condition that \\( f \\) is differentiable within the open interval \\( (x, +\\infty) \\) at \\( x \\) is expressed using `DifferentiableWithinAt ℝ f (Ioi x) x`. Here, `Ioi x` represents the open interval \\( (x, +\\infty) \\), and `DifferentiableWithinAt` is a Lean predicate that asserts differentiability of \\( f \\) at \\( x \\) within this interval.\n\n4. **Existence of Derivative in Closed Interval**:\n   - The existence of a derivative of \\( f \\) within the closed interval \\([x, +\\infty)\\) at \\( x \\) is captured by `HasDerivWithinAt f (derivWithin f (Ioi x) x) (Ici x) x`. Here, `Ici x` represents the closed interval \\([x, +\\infty)\\), and `HasDerivWithinAt` asserts that \\( f \\) has a derivative at \\( x \\) within this interval. The expression `(derivWithin f (Ioi x) x)` specifies the derivative value within the open interval.\n\n5. **Equality of Derivatives**:\n   - The conclusion that the derivative of \\( f \\) within the open interval \\( (x, +\\infty) \\) at \\( x \\) is equal to"}
{"source_file": "herald_data/sample_500.jsonl", "line": 36, "id": 45564, "informal_statement": "Let $C$ be a category, $A$ be a category with all small limits, $F_1, F_2, F_3 : C^{\\text{op}} \\to A$ be presheaves, $f_1 : F_1 \\to F_2$, $f_2 : F_2 \\to F_3$ be natural transformations, and $f_3 : F_1 \\to F_3$ be a natural transformation such that $f_1 \\circ f_2 = f_3$. If $f_3$ is locally injective and $f_1$ is locally surjective with respect to a coverage $J$ on $C$, then $f_2$ is also locally injective with respect to the same coverage $J$.", "formal_statement": "import Mathlib\nopen Opposite CategoryTheory CategoryTheory.GrothendieckTopology\ntheorem isLocallyInjective_of_isLocallyInjective_of_isLocallySurjective_fac_extracted [Category.{v : u} C] (J : GrothendieckTopology C) [Category.{v', u'} A]\n [ConcreteCategory A] {F₁ F₂ F₃ : Cᵒᵖ ⥤ A} {f₁ : F₁ ⟶ F₂} {f₂ : F₂ ⟶ F₃} (f₃ : F₁ ⟶ F₃),\n f₁ ≫ f₂ = f₃ →\n ∀ [Presheaf.IsLocallyInjective J f₃] [Presheaf.IsLocallySurjective J f₁],\n Presheaf.IsLocallyInjective J f₂ := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a structured approach that captures the essence of the mathematical concepts and their relationships in the formal language of Lean. Here's a step-by-step explanation of the translation:\n\n1. **Categories and Presheaves**:\n   - The informal statement begins by defining a category \\( C \\) and a category \\( A \\) with all small limits. In Lean, categories are represented using the `Category` typeclass. The presheaves \\( F_1, F_2, F_3 : C^{\\text{op}} \\to A \\) are functors from the opposite category of \\( C \\) to \\( A \\), which is denoted in Lean as `Cᵒᵖ ⥤ A`.\n\n2. **Natural Transformations**:\n   - The natural transformations \\( f_1 : F_1 \\to F_2 \\), \\( f_2 : F_2 \\to F_3 \\), and \\( f_3 : F_1 \\to F_3 \\) are represented in Lean as morphisms between functors, denoted by `F₁ ⟶ F₂`, `F₂ ⟶ F₃`, and `F₁ ⟶ F₃`, respectively.\n\n3. **Composition of Natural Transformations**:\n   - The condition \\( f_1 \\circ f_2 = f_3 \\) is expressed in Lean using the composition operator `≫`, so `f₁ ≫ f₂ = f₃`.\n\n4. **Coverage and Local Properties**:\n   - The coverage \\( J \\) on \\( C \\) is represented by a `GrothendieckTopology C` in Lean. The properties of being locally injective and locally surjective with respect to this coverage are captured by the typeclasses `Presheaf.IsLocallyInjective J f₃` and `Presheaf.IsLocallySurjective J f₁`.\n\n5. **Theorem Statement**:\n   - The theorem asserts that if \\( f_3 \\) is locally injective and \\( f_1 \\) is locally surjective with respect to the coverage \\( J \\), then \\( f_2 \\) is also locally injective with respect to \\( J \\). This is formalized in Lean as a theorem with the statement:\n     ```lean\n     theorem isLocallyInject"}
{"source_file": "herald_data/sample_500.jsonl", "line": 34, "id": 364049, "informal_statement": "For any \\( z \\in \\mathbb{Z}[\\sqrt{d}] \\), prove that \\( \\text{Im}(\\overline{z}) = -\\text{Im}(z) \\).", "formal_statement": "import Mathlib\n\n@[simp]\ntheorem star_im (z : ℤ√d) : (star z).im = -z.im := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to understand both the mathematical concepts involved and how they are represented in Lean.\n\n1. **Understanding the Mathematical Concepts**:\n   - The informal statement involves complex numbers of the form \\( z = a + b\\sqrt{d} \\), where \\( a, b \\in \\mathbb{Z} \\) and \\( d \\) is a fixed integer. These numbers are elements of the ring \\( \\mathbb{Z}[\\sqrt{d}] \\).\n   - The conjugate of such a number, denoted \\( \\overline{z} \\), is \\( a - b\\sqrt{d} \\).\n   - The imaginary part of \\( z \\), denoted \\( \\text{Im}(z) \\), is \\( b\\sqrt{d} \\).\n   - The statement to prove is that the imaginary part of the conjugate, \\( \\text{Im}(\\overline{z}) \\), is the negation of the imaginary part of \\( z \\), i.e., \\( -\\text{Im}(z) \\).\n\n2. **Translating to Lean4**:\n   - **Importing Necessary Libraries**: The `import Mathlib` statement is used to include the necessary mathematical libraries that provide definitions and theorems related to complex numbers and algebraic structures.\n   \n   - **Defining the Theorem**: The theorem is named `star_im`, which is a concise and descriptive name indicating that it deals with the imaginary part (`im`) of the conjugate (often denoted by `star` in algebraic contexts).\n   \n   - **Specifying the Type**: The variable `z` is specified to be of type `ℤ√d`, which represents elements of the ring \\( \\mathbb{Z}[\\sqrt{d}] \\). This type is likely defined in the imported libraries, encapsulating the structure of numbers of the form \\( a + b\\sqrt{d} \\).\n   \n   - **Using the `star` Function**: In Lean, the conjugate operation is often represented by a function named `star`. Thus, `(star z)` represents the conjugate of `z`.\n   \n   - **Accessing the Imaginary Part**: The `.im` accessor is used to obtain the imaginary part of a number in `ℤ√d`. Therefore, `(star z).im` gives the imaginary"}
{"source_file": "herald_data/sample_500.jsonl", "line": 38, "id": 573431, "informal_statement": "For $a,b,c\\in\\mathbb{R}$ , prove that $\\frac{a^2+b^2}{a^2-b^2}+\\frac{b^2+c^2}{b^2-c^2}+\\frac{c^2+a^2}{c^2-a^2}\\geq -1$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_573431 (a b c : ℝ) : (a^2 + b^2) / (a^2 - b^2) + (b^2 + c^2) / (b^2 - c^2) + (c^2 + a^2) / (c^2 - a^2) ≥ -1   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves three variables \\(a\\), \\(b\\), and \\(c\\), which are specified to be real numbers (\\(\\mathbb{R}\\)). In Lean, real numbers are represented by the type `ℝ`.\n\n2. **Translate the Mathematical Expression**:\n   - The expression given is \\(\\frac{a^2+b^2}{a^2-b^2}+\\frac{b^2+c^2}{b^2-c^2}+\\frac{c^2+a^2}{c^2-a^2}\\).\n   - In Lean, exponentiation is represented by `^`, so \\(a^2\\) becomes `a^2`.\n   - Division is represented by `/`, so \\(\\frac{a^2+b^2}{a^2-b^2}\\) becomes `(a^2 + b^2) / (a^2 - b^2)`.\n   - The entire expression is then written as `(a^2 + b^2) / (a^2 - b^2) + (b^2 + c^2) / (b^2 - c^2) + (c^2 + a^2) / (c^2 - a^2)`.\n\n3. **Formulate the Inequality**:\n   - The inequality to prove is \\(\\geq -1\\).\n   - In Lean, the greater than or equal to symbol is `≥`, so the inequality becomes `≥ -1`.\n\n4. **Structure the Theorem**:\n   - In Lean, a theorem is declared using the `theorem` keyword followed by a name. Here, it is named `extract_aug_573431`.\n   - The variables \\(a\\), \\(b\\), and \\(c\\) are introduced as arguments to the theorem, each of type `ℝ`.\n   - The statement of the theorem is then the expression followed by the inequality: `(a^2 + b^2) / (a^2 - b^2) + (b^2 + c^2) / (b^2 - c^2) + (c^2 + a^2) / (c^2 - a^2) ≥ -1`.\n\n5. **Use of"}
{"source_file": "herald_data/sample_500.jsonl", "line": 31, "id": 405945, "informal_statement": "Given filters $\\mathcal{F}_\\alpha$ on $\\alpha$ and $\\mathcal{F}_\\beta$ on $\\beta$, and functions $f_a, g_a : \\alpha \\to \\gamma$ and $f_b, g_b : \\beta \\to \\delta$ such that $f_a \\sim_{\\mathcal{F}_\\alpha} g_a$ and $f_b \\sim_{\\mathcal{F}_\\beta} g_b$, prove that $\\langle f_a, f_b \\rangle \\sim_{\\mathcal{F}_\\alpha \\times \\mathcal{F}_\\beta} \\langle g_a, g_b \\rangle$.", "formal_statement": "import Mathlib\nopen Set\nopen Filter\ntheorem EventuallyEq.prod_map {δ} {la : Filter α} {fa ga : α → γ} (ha : fa =ᶠ[la] ga)\n    {lb : Filter β} {fb gb : β → δ} (hb : fb =ᶠ[lb] gb) :\n    Prod.map fa fb =ᶠ[la ×ˢ lb] Prod.map ga gb := sorry", "explanation": "To translate the given informal mathematical statement into Lean4 code, we need to understand the components involved and how they correspond to Lean's formal language. Here's a step-by-step explanation of the translation:\n\n1. **Understanding Filters and Functions:**\n   - The informal statement involves filters $\\mathcal{F}_\\alpha$ and $\\mathcal{F}_\\beta$ on sets $\\alpha$ and $\\beta$, respectively. In Lean, these are represented as `Filter α` and `Filter β`.\n   - Functions $f_a, g_a : \\alpha \\to \\gamma$ and $f_b, g_b : \\beta \\to \\delta$ are given. In Lean, these are represented as `fa, ga : α → γ` and `fb, gb : β → δ`.\n\n2. **Equivalence with Respect to a Filter:**\n   - The notation $f_a \\sim_{\\mathcal{F}_\\alpha} g_a$ means that $f_a$ and $g_a$ are eventually equal with respect to the filter $\\mathcal{F}_\\alpha$. In Lean, this is expressed as `fa =ᶠ[la] ga`, where `=ᶠ` is the notation for eventual equality with respect to a filter.\n   - Similarly, $f_b \\sim_{\\mathcal{F}_\\beta} g_b$ is expressed as `fb =ᶠ[lb] gb`.\n\n3. **Product of Filters:**\n   - The product filter $\\mathcal{F}_\\alpha \\times \\mathcal{F}_\\beta$ is represented in Lean as `la ×ˢ lb`, where `×ˢ` denotes the product of two filters.\n\n4. **Product of Functions:**\n   - The pair of functions $\\langle f_a, f_b \\rangle$ and $\\langle g_a, g_b \\rangle$ are represented using `Prod.map fa fb` and `Prod.map ga gb` in Lean. `Prod.map` is a function that takes two functions and returns their product function.\n\n5. **Theorem Statement:**\n   - The goal is to prove that the product of the functions $f_a$ and $f_b$ is eventually equal to the product of $g_a$ and $g_b$ with respect to the product filter. This is expressed in Lean as `Prod.map fa fb =ᶠ[la ×ˢ"}
{"source_file": "herald_data/sample_500.jsonl", "line": 37, "id": 492805, "informal_statement": "Let $a,b,c$ be real numbers such that $(a^2-a+1)(b^2-b+1)(c^2-c+1)\\leq1.$ Prove that $$(a^2+b^2)(b^2+c^2)(c^2+a^2) \\leq 8$$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_492805 (a b c : ℝ) (h : (a^2 - a + 1) * (b^2 - b + 1) * (c^2 - c + 1) ≤ 1) :\n  (a^2 + b^2) * (b^2 + c^2) * (c^2 + a^2) ≤ 8  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow a structured approach:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves three variables \\(a\\), \\(b\\), and \\(c\\), which are specified as real numbers. In Lean, real numbers are represented by the type `ℝ`.\n\n2. **Express the Given Condition**:\n   - The condition given in the problem is \\((a^2 - a + 1)(b^2 - b + 1)(c^2 - c + 1) \\leq 1\\). In Lean, this is expressed using the multiplication operator `*` and the less than or equal to operator `≤`. The expression is written as `(a^2 - a + 1) * (b^2 - b + 1) * (c^2 - c + 1) ≤ 1`.\n\n3. **State the Conclusion to Prove**:\n   - The conclusion we need to prove is \\((a^2 + b^2)(b^2 + c^2)(c^2 + a^2) \\leq 8\\). Similarly, this is expressed in Lean using the multiplication operator `*` and the less than or equal to operator `≤`. The expression is written as `(a^2 + b^2) * (b^2 + c^2) * (c^2 + a^2) ≤ 8`.\n\n4. **Structure the Theorem**:\n   - In Lean, a theorem is defined using the `theorem` keyword followed by a name for the theorem, which in this case is `extract_aug_492805`.\n   - The variables \\(a\\), \\(b\\), and \\(c\\) are introduced as arguments to the theorem, each of type `ℝ`.\n   - The hypothesis, which is the given condition, is introduced as a parameter `h`.\n   - The conclusion is stated after the colon `:`.\n\n5. **Use of Lean Libraries**:\n   - The `import Mathlib` statement is used to import the necessary mathematical libraries that provide definitions and theorems for real numbers and other mathematical constructs.\n   - The `open` statements are used to bring into scope specific modules or namespaces, such as `BigOperators`, `Real`, `Nat`, and `Topology`, which might be needed for handling real numbers and operations"}
{"source_file": "herald_data/sample_500.jsonl", "line": 39, "id": 130893, "informal_statement": "For any $RCLike$ scalar field $\\mathbb{k}$, $NormedAddCommGroup$ $E$, $InnerProductSpace$ $\\mathbb{k} E$, and $CompleteSpace$ $E$, let $U$ be a $Submodule$ of $\\mathbb{k} E$ also satisfying $CompleteSpace$. For all $x \\in E$ and $y \\in U$, show that the inner product of the orthogonal projection of $x$ onto $U$ with $y$ in $\\mathbb{k}$ is equal to the inner product of $x$ with the $subtypeL$ of $y$ in $U$ in $\\mathbb{k}$. That is, $\\langle\\langle (orthogonalProjection\\ U) x, y \\rangle\\rangle_{\\mathbb{k}} = \\langle\\langle x, U.subtypeL\\ y \\rangle\\rangle_{\\mathbb{k}}$.", "formal_statement": "import Mathlib\nopen RCLike\nopen scoped ComplexConjugate\nopen InnerProductSpace\nopen InnerProduct\nopen ContinuousLinearMap\nopen Matrix LinearMap\nopen scoped ComplexConjugate\nlemma toEuclideanLin_conjTranspose_eq_adjoint_tac_6724 [RCLike 𝕜] [NormedAddCommGroup E] [InnerProductSpace 𝕜 E] [CompleteSpace E] (U : Submodule 𝕜 E) [CompleteSpace ↥U] : ∀ (x : E) (y : ↥U), ⟪(orthogonalProjection U) x, y⟫_𝕜 = ⟪x, U.subtypeL y⟫_𝕜 := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that involves understanding the mathematical concepts and their corresponding Lean constructs. Here's a step-by-step explanation of the translation:\n\n1. **Identify the Mathematical Structures:**\n   - The informal statement involves several mathematical structures: a scalar field $\\mathbb{k}$, a normed additive commutative group $E$, an inner product space $\\mathbb{k} E$, and a complete space $E$. Additionally, $U$ is a submodule of $\\mathbb{k} E$ that is also a complete space.\n\n2. **Translate Mathematical Structures to Lean:**\n   - In Lean, these structures are represented by typeclasses and types:\n     - `RCLike 𝕜`: Represents the scalar field $\\mathbb{k}$, which is a real or complex number field.\n     - `NormedAddCommGroup E`: Represents the normed additive commutative group $E$.\n     - `InnerProductSpace 𝕜 E`: Represents the inner product space structure on $E$ over the field $\\mathbb{k}$.\n     - `CompleteSpace E`: Indicates that $E$ is a complete space.\n     - `Submodule 𝕜 E`: Represents the submodule $U$ of the space $E$ over the field $\\mathbb{k}$.\n     - `CompleteSpace ↥U`: Indicates that the submodule $U$ is also a complete space.\n\n3. **Define the Variables and Assumptions:**\n   - The lemma is defined with the assumptions that $𝕜$ is an `RCLike` field, $E$ is a `NormedAddCommGroup`, an `InnerProductSpace`, and a `CompleteSpace`. The submodule $U$ is also assumed to be a `CompleteSpace`.\n\n4. **Formalize the Statement:**\n   - The goal is to show that for all $x \\in E$ and $y \\in U$, the inner product of the orthogonal projection of $x$ onto $U$ with $y$ is equal to the inner product of $x$ with the subtype of $y$ in $U$.\n   - In Lean, this is expressed using the universal quantifier `∀` for all $x : E$ and $y : ↥U` (where `↥U` is the type of elements in"}
{"source_file": "herald_data/sample_500.jsonl", "line": 40, "id": 404318, "informal_statement": "For any \\( m : \\alpha \\to \\beta \\to \\gamma \\), filters \\( f \\) on \\( \\alpha \\) and \\( g \\) on \\( \\beta \\), prove:\n\\[\n(f \\times g).map (\\text{uncurry } m) = \\text{map}_2(m, f, g).\n\\]", "formal_statement": "import Mathlib\nopen Function Set\nopen Filter\n@[simp]\ntheorem map_uncurry_prod (m : α → β → γ) (f : Filter α) (g : Filter β) :\n    (f ×ˢ g).map (uncurry m) = map₂ m f g := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to understand the components involved and how they are represented in Lean. Here's a step-by-step explanation:\n\n1. **Understanding the Components**:\n   - **\\( m : \\alpha \\to \\beta \\to \\gamma \\)**: This is a curried function taking two arguments, one of type \\(\\alpha\\) and another of type \\(\\beta\\), and returning a value of type \\(\\gamma\\).\n   - **Filters \\( f \\) and \\( g \\)**: These are filters on the types \\(\\alpha\\) and \\(\\beta\\), respectively. In Lean, a filter is a mathematical structure used to describe convergence and limit processes.\n   - **Product of Filters \\( f \\times g \\)**: This represents the product filter, which is a filter on the product space \\(\\alpha \\times \\beta\\).\n\n2. **Translation of the Informal Statement**:\n   - **\\( (f \\times g).map (\\text{uncurry } m) \\)**: This part of the statement involves mapping the uncurried version of \\( m \\) over the product filter \\( f \\times g \\). In Lean, `uncurry m` is used to transform the curried function \\( m \\) into a function that takes a single argument of type \\(\\alpha \\times \\beta\\).\n   - **\\(\\text{map}_2(m, f, g)\\)**: This represents the binary map operation in Lean, which applies the function \\( m \\) to elements from the filters \\( f \\) and \\( g \\).\n\n3. **Formalizing in Lean**:\n   - **Importing Necessary Modules**: The statement begins with `import Mathlib`, which is necessary to access mathematical libraries in Lean, including those for filters and functions.\n   - **Opening Namespaces**: `open Function Set` and `open Filter` are used to bring relevant definitions and theorems into scope, making it easier to refer to them without full qualification.\n   - **Theorem Declaration**: The theorem is declared with `@[simp]`, which is an attribute in Lean that marks the theorem as a simplification rule. This helps Lean's simplifier automatically use this theorem to simplify expressions.\n   - **Theorem Name and Signature**: `theorem map_uncurry_prod` is the name of the theorem. The signature `(m :"}
{"source_file": "herald_data/sample_500.jsonl", "line": 13, "id": 243966, "informal_statement": "For any family of sets $\\pi : \\iota \\to \\mathcal{P}(\\mathcal{P}(\\alpha))$ and any index $i \\in \\iota$, show that the union of the intersection of $\\pi$ over the singleton set $\\{i\\}$ is equal to the union of $\\pi(i)$ and the set containing the universal set, i.e., $\\bigcup_{J \\in \\{\\pi(i)\\}}\\bigcap_{\\iota' \\in J} \\iota' = \\pi(i) \\cup \\{\\mathcal{U}\\}$.", "formal_statement": "import Mathlib\nopen MeasurableSpace Set\nopen MeasureTheory\nlemma piiUnionInter_singleton_tac_15893 (π : ι → Set (Set α)) (i : ι) : piiUnionInter π {i} = π i ∪ {univ} := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean4.\n\n1. **Understanding the Informal Statement:**\n   - We have a family of sets represented by a function $\\pi : \\iota \\to \\mathcal{P}(\\mathcal{P}(\\alpha))$. This means for each index $i \\in \\iota$, $\\pi(i)$ is a set of sets of elements of type $\\alpha$.\n   - We are considering the union of the intersection of $\\pi$ over the singleton set $\\{i\\}$.\n   - The goal is to show that this union is equal to the union of $\\pi(i)$ and the set containing the universal set $\\mathcal{U}$.\n\n2. **Formalizing the Family of Sets:**\n   - In Lean, the family of sets is represented by `π : ι → Set (Set α)`. Here, `ι` is the index type, and for each `i : ι`, `π(i)` is a set of sets of type `α`.\n\n3. **Singleton Set and Union of Intersection:**\n   - The singleton set $\\{i\\}$ is represented in Lean as `{i}`.\n   - The operation described as \"the union of the intersection of $\\pi$ over the singleton set $\\{i\\}$\" is formalized as `piiUnionInter π {i}`. This is a custom operation that likely represents the described union of intersections.\n\n4. **Equality to Union with Universal Set:**\n   - The right-hand side of the equality in the informal statement is $\\pi(i) \\cup \\{\\mathcal{U}\\}$.\n   - In Lean, this is represented as `π i ∪ {univ}`. Here, `π i` is the set of sets at index `i`, and `univ` represents the universal set in the context of type `α`.\n\n5. **The Lemma Statement:**\n   - The lemma is named `piiUnionInter_singleton_tac_15893`, which is a unique identifier for this specific result.\n   - The lemma takes two arguments: `π` (the family of sets) and `i` (the index).\n   - The statement of the lemma asserts that `piiUnionInter π {i} = π i ∪"}
{"source_file": "herald_data/sample_500.jsonl", "line": 42, "id": 307423, "informal_statement": "For any normed additive commutative group $E$ endowed with an inner product space structure over $\\mathbb{R}$, and given any $v, w \\in E$ such that $\\|v\\| = 1$, $\\langle w, v \\rangle_{\\mathbb{R}} = 0$, and $0 < \\|w\\|^2 + 4$, show that $16\\|w\\|^2 + (\\|w\\|^2 - 4)^2 = (\\|w\\|^2 + 4)^2$.", "formal_statement": "import Mathlib\nopen Metric FiniteDimensional Function\nopen scoped Manifold\nlemma stereoInvFunAux_mem_tac_5677 [NormedAddCommGroup E] [InnerProductSpace ℝ E] (v : E) (hv : ‖v‖ = 1) (w : E) (hw : ⟪w, v⟫_ℝ = 0) (h₁ : 0 < ‖w‖ ^ 2 + 4) : 4 ^ 2 * ‖w‖ ^ 2 + (‖w‖ ^ 2 - 4) ^ 2 = (‖w‖ ^ 2 + 4) ^ 2 := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the mathematical concepts and conditions precisely. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Mathematical Structures:**\n   - The informal statement involves a normed additive commutative group $E$ with an inner product space structure over $\\mathbb{R}$. In Lean, this is represented by the type class `[NormedAddCommGroup E]` and `[InnerProductSpace ℝ E]`. These type classes ensure that $E$ has the necessary algebraic and topological structures.\n\n2. **Define the Variables:**\n   - The variables $v$ and $w$ are elements of the group $E$. In Lean, they are declared as `(v : E)` and `(w : E)`.\n\n3. **State the Conditions:**\n   - The condition $\\|v\\| = 1$ is expressed in Lean as `(hv : ‖v‖ = 1)`, where `‖v‖` denotes the norm of $v$.\n   - The orthogonality condition $\\langle w, v \\rangle_{\\mathbb{R}} = 0$ is represented as `(hw : ⟪w, v⟫_ℝ = 0)`, where `⟪w, v⟫_ℝ` denotes the inner product of $w$ and $v$ over $\\mathbb{R}$.\n   - The condition $0 < \\|w\\|^2 + 4$ is written as `(h₁ : 0 < ‖w‖ ^ 2 + 4)`.\n\n4. **Formulate the Conclusion:**\n   - The goal is to show the equality $16\\|w\\|^2 + (\\|w\\|^2 - 4)^2 = (\\|w\\|^2 + 4)^2$. In Lean, this is expressed as `4 ^ 2 * ‖w‖ ^ 2 + (‖w‖ ^ 2 - 4) ^ 2 = (‖w‖ ^ 2 + 4) ^ 2`.\n   - Note that $16\\|w\\|^2$ is written as `4 ^ 2 * ‖w‖ ^ 2` because $16"}
{"source_file": "herald_data/sample_500.jsonl", "line": 44, "id": 201633, "informal_statement": "For any measure $\\mu$ on $\\mathbb{R}$, a filter $l$ on an index set $\\iota$ that is not the trivial bot filter and is countably generated, a normed additive commutative group $E$, a function $a : \\iota \\to \\mathbb{R}$, a function $f : \\mathbb{R} \\to E$, a real number $I$, and a real number $b$, suppose:\n\n1. $f$ is integrable on the open interval $(a(i), b)$ for every $i \\in \\iota$ with respect to $\\mu$.\n2. $a$ tends to negative infinity as $i$ approaches the limit described by $l$.\n3. For almost every $i \\in \\iota$ with respect to $l$, the integral of the norm of $f(x)$ over the interval $(a(i), b)$ with respect to $\\mu$ is bounded by $I$.\n4. The family of open intervals $(a(i), \\infty)$ for $i \\in \\iota$ is an asymptotic eventually cover of the interval $(-\\infty, b]$ with respect to $\\mu$.\n\nThen, for every $i \\in \\iota$, $f$ is integrable on the open interval $(a(i), \\infty)$ with respect to the restriction of $\\mu$ to the interval $(-\\infty, b]$.", "formal_statement": "import Mathlib\nopen MeasureTheory Filter Set TopologicalSpace\nopen scoped ENNReal NNReal Topology\nlemma integrableOn_Iic_of_intervalIntegral_norm_bounded_tac_28084 (μ : Measure ℝ) (l : Filter ι) [l.NeBot] [l.IsCountablyGenerated] [NormedAddCommGroup E] (a : ι → ℝ) (f : ℝ → E) (I : ℝ) (b : ℝ) (hfi : ∀ (i : ι), IntegrableOn f (Ioc (a i) b) μ) (ha : Tendsto a l atBot) (h : ∀ᶠ (i : ι) in l, ∫ (x : ℝ) in a i..b, ‖f x‖ ∂μ ≤ I) (hφ : AECover (μ.restrict (Iic b)) l fun i => Ioi (a i)) : ∀ (i : ι), IntegrableOn f (Ioi (a i)) (μ.restrict (Iic b)) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to carefully map each component of the informal statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation:\n\n1. **Measure and Filter Setup**:\n   - The informal statement begins by introducing a measure $\\mu$ on $\\mathbb{R}$ and a filter $l$ on an index set $\\iota$. In Lean, this is represented by `μ : Measure ℝ` and `l : Filter ι`.\n   - The filter $l$ is specified to be non-trivial and countably generated. This is captured by the typeclass constraints `[l.NeBot]` and `[l.IsCountablyGenerated]`.\n\n2. **Normed Additive Commutative Group**:\n   - The informal statement specifies a normed additive commutative group $E$. In Lean, this is represented by `[NormedAddCommGroup E]`.\n\n3. **Functions and Real Numbers**:\n   - The function $a : \\iota \\to \\mathbb{R}$ is represented as `a : ι → ℝ`.\n   - The function $f : \\mathbb{R} \\to E$ is represented as `f : ℝ → E`.\n   - The real numbers $I$ and $b$ are represented as `I : ℝ` and `b : ℝ`.\n\n4. **Hypotheses**:\n   - **Integrability on $(a(i), b)$**: The condition that $f$ is integrable on the interval $(a(i), b)$ for every $i \\in \\iota$ is expressed as `hfi : ∀ (i : ι), IntegrableOn f (Ioc (a i) b) μ`. Here, `IntegrableOn` is a Lean function that checks integrability over a specified interval, and `Ioc (a i) b` represents the open interval $(a(i), b)$.\n   \n   - **Tendency of $a$ to $-\\infty$**: The condition that $a$ tends to negative infinity as $i$ approaches the limit described by $l$ is expressed as `ha : Tendsto a l atBot`. Here, `Tendsto` is a Lean function that describes the convergence of a function, and `atBot` represents the limit towards negative infinity.\n   \n   - **"}
{"source_file": "herald_data/sample_500.jsonl", "line": 43, "id": 384613, "informal_statement": "Prove that the unit disc \\(\\mathcal{D}\\) in the complex plane contains at least one point.", "formal_statement": "import Mathlib\nopen Set Function Metric\nopen UnitDisc\ninstance : Inhabited 𝔻 := sorry", "explanation": "To translate the informal statement \"Prove that the unit disc \\(\\mathcal{D}\\) in the complex plane contains at least one point\" into the formal Lean4 statement, we follow these steps:\n\n1. **Identify the Mathematical Object**: The unit disc \\(\\mathcal{D}\\) in the complex plane is the set of all complex numbers \\(z\\) such that \\(|z| < 1\\). In Lean, this is typically represented by a specific type or set, often denoted as `𝔻`.\n\n2. **Understand the Goal**: The informal statement asks us to prove that this set contains at least one point. In Lean, this is expressed by showing that the type or set is \"inhabited,\" meaning there exists at least one element in it.\n\n3. **Use Lean's Inhabited Typeclass**: Lean has a typeclass `Inhabited` which is used to indicate that a type has at least one element. To show that a type is inhabited, we provide an instance of this typeclass for the type in question.\n\n4. **Formalize the Statement**: The formal statement in Lean is `instance : Inhabited 𝔻 := sorry`. Here, `𝔻` represents the unit disc. The `instance` keyword is used to declare that `𝔻` is an instance of the `Inhabited` typeclass. The `:= sorry` part is a placeholder indicating that the proof or construction of an element is not yet provided.\n\n5. **Import Necessary Libraries**: The statement begins with `import Mathlib`, which is necessary to access mathematical definitions and theorems, including those related to sets, functions, and metrics, which are relevant for working with the unit disc.\n\n6. **Open Relevant Namespaces**: The `open Set Function Metric` line allows us to use definitions and theorems from these modules without prefixing them with the module name. Similarly, `open UnitDisc` is likely used to access specific definitions or theorems related to the unit disc.\n\nIn summary, the formal statement sets up the framework to prove that the unit disc is inhabited by declaring an instance of the `Inhabited` typeclass for `𝔻`, indicating that there is at least one point in the unit disc. The actual proof or construction of such a point is left as `sorry`, which is a placeholder for further development."}
{"source_file": "herald_data/sample_500.jsonl", "line": 41, "id": 82630, "informal_statement": "For any set $s$ in type $\\alpha$, the Cartesian product of $s$ with the universal set in type $\\beta$ is equal to the preimage of $s$ under the first projection function, denoted as $s \\times \\beta = (\\pi_1)^{-1}(s)$, where $\\pi_1$ is the function that projects the first component of a pair.", "formal_statement": "import Mathlib\nopen Function\ntheorem prod_univ_extracted {s : Set α} : s ×ˢ Set.univ = Prod.fst ⁻¹' s := sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to understand the components involved and how they relate to Lean's formal language. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Informal Statement**:\n   - We are given a set \\( s \\) of type \\( \\alpha \\).\n   - We consider the Cartesian product of \\( s \\) with the universal set of type \\( \\beta \\), denoted as \\( s \\times \\beta \\).\n   - The statement claims that this Cartesian product is equal to the preimage of \\( s \\) under the first projection function \\( \\pi_1 \\), which extracts the first component of a pair.\n\n2. **Lean4 Components**:\n   - **Set**: In Lean, sets are represented using the `Set` type. A set of type \\( \\alpha \\) is written as `Set α`.\n   - **Universal Set**: The universal set in Lean is represented as `Set.univ`.\n   - **Cartesian Product**: The Cartesian product of two sets \\( s \\) and \\( t \\) is denoted as `s ×ˢ t` in Lean.\n   - **Projection Function**: The first projection function \\( \\pi_1 \\) is represented as `Prod.fst` in Lean, which extracts the first element of a pair.\n   - **Preimage**: The preimage of a set under a function \\( f \\) is denoted as `f ⁻¹' s` in Lean.\n\n3. **Formalizing the Statement**:\n   - We need to prove that the Cartesian product `s ×ˢ Set.univ` is equal to the preimage `Prod.fst ⁻¹' s`.\n   - The theorem is named `prod_univ_extracted` and is parameterized by a set `s` of type `Set α`.\n\n4. **Lean4 Code Explanation**:\n   - `import Mathlib`: This imports the necessary mathematical library that includes definitions and theorems about sets, functions, and products.\n   - `open Function`: This line opens the `Function` namespace, allowing us to use function-related definitions and notations without prefixing them with `Function.`.\n   - `theorem prod_univ_extracted {s : Set α} : s ×ˢ Set.univ = Prod.fst ⁻¹' s := sorry`: This line declares the theorem. It"}
{"source_file": "herald_data/sample_500.jsonl", "line": 45, "id": 72936, "informal_statement": "For any three integers \\(x\\), \\(y\\), and \\(z\\) forming a Pythagorean triple, if \\(x\\) and \\(y\\) are coprime, then \\(y\\) and \\(z\\) are also coprime. That is, if \\(\\gcd(x, y) = 1\\), then \\(\\gcd(y, z) = 1\\).", "formal_statement": "import Mathlib\n\ntheorem coprime_of_coprime_extracted {x y z : ℤ} : PythagoreanTriple x y z → x.gcd y = 1 → y.gcd z = 1 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean.\n\n1. **Understanding the Informal Statement:**\n   - We are dealing with three integers \\(x\\), \\(y\\), and \\(z\\) that form a Pythagorean triple. This means they satisfy the equation \\(x^2 + y^2 = z^2\\).\n   - The condition given is that \\(x\\) and \\(y\\) are coprime, i.e., \\(\\gcd(x, y) = 1\\).\n   - The conclusion we want to prove is that \\(y\\) and \\(z\\) are also coprime, i.e., \\(\\gcd(y, z) = 1\\).\n\n2. **Translating to Lean4:**\n   - **Importing Necessary Libraries:**\n     - `import Mathlib`: This line imports the Mathlib library, which contains definitions and theorems related to number theory, including gcd and Pythagorean triples.\n   \n   - **Defining the Theorem:**\n     - `theorem coprime_of_coprime_extracted`: This defines a new theorem named `coprime_of_coprime_extracted`. The name is descriptive, indicating that we are extracting a coprime relationship from another.\n   \n   - **Specifying Variables:**\n     - `{x y z : ℤ}`: This declares that \\(x\\), \\(y\\), and \\(z\\) are integers. The colon `:` is used to specify the type of these variables, and `ℤ` denotes the type of integers in Lean.\n   \n   - **Stating the Hypotheses:**\n     - `PythagoreanTriple x y z`: This is a predicate that asserts \\(x\\), \\(y\\), and \\(z\\) form a Pythagorean triple, meaning they satisfy the equation \\(x^2 + y^2 = z^2\\). This is the formalization of the condition that they form a Pythagorean triple.\n     - `x.gcd y = 1`: This states that the greatest common divisor of \\(x\\) and \\(y\\) is 1, formalizing the condition that \\(x\\) and \\(y\\) are coprime. In Lean, `g"}
{"source_file": "herald_data/sample_500.jsonl", "line": 49, "id": 83670, "informal_statement": "For any optional value $x$ of type $\\alpha$, show that $x$ orElse a function that always returns none is equal to $x$, i.e., $x \\text{ orElse } (\\lambda \\_ \\to \\text{none}) = x$.", "formal_statement": "import Mathlib\n\ntheorem orElse_none'_extracted (x : Option α) : (x.orElse fun x => none) = x := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Type and Context**: The informal statement involves an \"optional value $x$ of type $\\alpha$\". In Lean, this is represented by `Option α`, where `α` is a type variable. The optional value `x` is thus of type `Option α`.\n\n2. **Understand the Operation**: The operation described is `orElse`, which is a method for `Option` types in Lean. The `orElse` method takes an `Option` value and a function that returns an `Option` value, and it returns the first `Option` if it is `some`, otherwise it returns the result of the function.\n\n3. **Translate the Function**: The function described in the informal statement is \"a function that always returns none\". In Lean, this is written as `fun _ => none`, which is an anonymous function (lambda) that takes any input (denoted by `_`) and returns `none`.\n\n4. **Formalize the Statement**: The goal is to show that `x orElse (λ _ => none) = x`. In Lean, this is expressed as a theorem. The theorem states that for any `x : Option α`, the expression `(x.orElse fun _ => none)` is equal to `x`.\n\n5. **Write the Theorem**: The theorem is written in Lean as follows:\n   ```lean\n   theorem orElse_none'_extracted (x : Option α) : (x.orElse fun _ => none) = x := sorry\n   ```\n   - `theorem` declares a new theorem.\n   - `orElse_none'_extracted` is the name of the theorem.\n   - `(x : Option α)` specifies that `x` is an argument of type `Option α`.\n   - `: (x.orElse fun _ => none) = x` is the statement of the theorem, asserting the equality.\n   - `:= sorry` is a placeholder indicating that the proof is not yet provided.\n\n6. **Import Necessary Libraries**: The statement begins with `import Mathlib`, which is necessary to use the `Option` type and its associated methods like `orElse`.\n\nBy following these steps, the informal mathematical statement is accurately translated into a formal Lean theorem."}
{"source_file": "herald_data/sample_500.jsonl", "line": 46, "id": 48053, "informal_statement": "For any category $C$ and any index category $J$, suppose a functor $F: J \\to C$ has a limit. Given a natural isomorphism $\\alpha$ between functors $F$ and $G$ in $J \\to C$, prove that the functor $G$ also has a limit.", "formal_statement": "import Mathlib\nopen CategoryTheory CategoryTheory.Category CategoryTheory.Functor Opposite\ntheorem hasLimitOfIso_extracted [Category.{v₁ : u₁} J] [Category.{v, u} C] {F G : J ⥤ C}\n [Limits.HasLimit F], (F ≅ G) → Limits.HasLimit G := sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Understand the Context**: The statement involves categories, functors, limits, and natural isomorphisms. In Lean, these concepts are part of the `CategoryTheory` library.\n\n2. **Define the Categories**: The informal statement mentions two categories, $C$ and $J$. In Lean, these are represented as instances of the `Category` typeclass. The code uses `[Category.{v₁ : u₁} J]` and `[Category.{v, u} C]` to declare that `J` and `C` are categories, with universe levels specified for generality.\n\n3. **Declare the Functors**: The functors $F$ and $G$ are mappings from the index category $J$ to the category $C$. In Lean, functors are represented by the type `J ⥤ C`. The code declares `F` and `G` as functors with `{F G : J ⥤ C}`.\n\n4. **Assume the Limit for F**: The statement assumes that the functor $F$ has a limit. In Lean, this is expressed using the typeclass `Limits.HasLimit F`, which is included in the assumptions with `[Limits.HasLimit F]`.\n\n5. **Natural Isomorphism**: The statement involves a natural isomorphism $\\alpha$ between the functors $F$ and $G$. In Lean, a natural isomorphism between functors is denoted by `F ≅ G`. The code includes this as a hypothesis `(F ≅ G)`.\n\n6. **Prove the Limit for G**: The goal is to prove that the functor $G$ also has a limit. In Lean, this is expressed as `Limits.HasLimit G`. The theorem statement is `theorem hasLimitOfIso_extracted ... : Limits.HasLimit G`.\n\n7. **Structure of the Theorem**: The theorem is structured to take the assumptions as inputs and produce the desired conclusion. The assumptions are the category structures, the functors, the existence of a limit for `F`, and the natural isomorphism. The conclusion is the existence of a limit for `G`.\n\n8. **Use of `sorry`**: The `sorry` keyword is a placeholder indicating that the proof is omitted. In a complete development,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 48, "id": 303449, "informal_statement": "For a set $s$ in type $\\alpha$, functions $f, g : \\alpha \\to \\beta$, a set $t$ in type $\\beta$, and an element $x \\in \\alpha$, show that $x$ belongs to the preimage of $t$ under the piecewise function defined by $f$ on $s$ and $g$ outside $s$ if and only if $x$ is in the set obtained by taking $x$ in $s$ and choosing between the preimage of $t$ under $f$ or under $g$, depending on whether $x$ is in $s$.", "formal_statement": "import Mathlib\nopen Equiv Equiv.Perm Function\nopen Function\nlemma piecewise_preimage_tac_60046 (s : Set α) [(j : α) → Decidable (j ∈ s)] (f : α → β) (g : α → β) (t : Set β) (x : α) : x ∈ s.piecewise f g ⁻¹' t ↔ x ∈ s.ite (f ⁻¹' t) (g ⁻¹' t) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it corresponds to Lean's syntax and semantics. Here's a step-by-step explanation:\n\n1. **Understanding the Context and Types**:\n   - We have a set `s` of type `Set α`, which means `s` is a subset of some type `α`.\n   - Functions `f` and `g` are of type `α → β`, meaning they map elements from type `α` to type `β`.\n   - A set `t` of type `Set β` is given, which is a subset of type `β`.\n   - An element `x` of type `α` is also given.\n\n2. **Piecewise Function**:\n   - The piecewise function is defined using `s.piecewise f g`. In Lean, `s.piecewise f g` is a function that applies `f` to elements in `s` and `g` to elements not in `s`.\n   - The notation `s.piecewise f g` is a standard way in Lean to define such a function.\n\n3. **Preimage**:\n   - The preimage of a set `t` under a function `h` is denoted by `h ⁻¹' t` in Lean. This represents the set of all elements in the domain of `h` that map to elements in `t`.\n   - Therefore, `s.piecewise f g ⁻¹' t` is the preimage of `t` under the piecewise function `s.piecewise f g`.\n\n4. **Conditional Set Construction**:\n   - The informal statement describes a condition where `x` is in `s`, and based on this, we choose between the preimage of `t` under `f` or `g`.\n   - In Lean, this is expressed using `s.ite (f ⁻¹' t) (g ⁻¹' t)`. The `ite` function (if-then-else) is used to construct a set that includes elements from `f ⁻¹' t` if they are in `s` and from `g ⁻¹' t` otherwise.\n\n5. **Decidability**:\n   - The notation `[(j : α) → Decidable (j ∈ s)]` indicates that for each element `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 50, "id": 244102, "informal_statement": "For any elements \\(a\\), \\(b\\), and \\(c\\) in a commutative group \\(\\alpha\\) equipped with a linear order and a covariant class for multiplication and order, show that the inequality \\(a \\leq b \\cdot c\\) holds if and only if \\(a \\leq b \\cdot c\\).", "formal_statement": "import Mathlib\nopen Function\nlemma div_le_iff_le_mul'_tac_16673 [CommGroup α] [LE α] [CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] (a : α) (b : α) (c : α) : a ≤ b * c ↔ a ≤ b * c := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to consider the components of the statement and how they map to Lean's syntax and type system. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Mathematical Structures**: \n   - The statement involves a commutative group \\(\\alpha\\), which in Lean is represented by the type class `CommGroup α`. This type class provides the group operations and properties, such as associativity, identity, inverses, and commutativity of multiplication.\n   - The statement also involves a linear order on \\(\\alpha\\), represented by the type class `LE α` in Lean, which provides the `≤` relation.\n   - Additionally, there is a covariant class for multiplication and order, which is represented by `CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1`. This class ensures that multiplication is order-preserving.\n\n2. **Define the Variables**:\n   - The elements \\(a\\), \\(b\\), and \\(c\\) are elements of the commutative group \\(\\alpha\\). In Lean, these are introduced as variables of type `α`: `(a : α) (b : α) (c : α)`.\n\n3. **State the Inequality**:\n   - The inequality \\(a \\leq b \\cdot c\\) is directly translated to `a ≤ b * c` in Lean. The multiplication operation is denoted by `*`, and the order relation is denoted by `≤`.\n\n4. **Formulate the Lemma**:\n   - The goal is to show that the inequality \\(a \\leq b \\cdot c\\) holds if and only if \\(a \\leq b \\cdot c\\). This is a tautology, as the statement is trivially true. In Lean, this is expressed using the logical equivalence `↔`, resulting in the statement `a ≤ b * c ↔ a ≤ b * c`.\n\n5. **Construct the Lean Lemma**:\n   - The lemma is named `div_le_iff_le_mul'_tac_16673`, which is a placeholder name and can be replaced with a more descriptive name.\n   - The lemma is declared with the necessary type class constraints and variables, followed by the statement of the equivalence: \n     ```lean"}
{"source_file": "herald_data/sample_500.jsonl", "line": 51, "id": 105911, "informal_statement": "For any linear equivalence constructed with the given functions `to_fun`, `inv_fun`, `map_add`, `map_smul`, `left_inv`, and `right_inv` between two σ-modules `M` and `M₂`, the coercion of this linear equivalence to a function is equal to `to_fun`. In other words, the underlying function of the linear equivalence is `to_fun`.", "formal_statement": "import Mathlib\nopen Function\ntheorem coe_mk_extracted [Semiring R] [Semiring S]\n [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂] {σ : R →+* S}\n {σ' : S →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ] {to_fun : M → M₂} {inv_fun : M₂ → M}\n {map_add : ∀ (x y : M) : to_fun (x + y) = to_fun x + to_fun y}\n {map_smul :\n ∀ (m : R) (x : M),\n { toFun := to_fun, map_add' := map_add }.toFun (m • x) = σ m • { toFun := to_fun, map_add' := map_add }.toFun x}\n {left_inv : LeftInverse inv_fun { toFun := to_fun, map_add' := map_add, map_smul' := map_smul }.toFun}\n {right_inv : Function.RightInverse inv_fun { toFun := to_fun, map_add' := map_add, map_smul' := map_smul }.toFun},\n ⇑{ toFun := to_fun, map_add' := map_add, map_smul' := map_smul, invFun := inv_fun, left_inv := left_inv,\n right_inv := right_inv } =\n to_fun := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Understand the Context**: The statement involves linear equivalences between two σ-modules `M` and `M₂`. A linear equivalence is a bijective linear map with an inverse that is also linear. The functions `to_fun` and `inv_fun` represent the forward and inverse mappings, respectively.\n\n2. **Identify the Structures**: The informal statement mentions a \"linear equivalence\" constructed with certain functions. In Lean, this is typically represented by a structure that includes these functions and properties. The structure is not explicitly named in the theorem, but it is implied by the use of `toFun`, `invFun`, `map_add'`, `map_smul'`, `left_inv`, and `right_inv`.\n\n3. **Define the Modules and Rings**: The formal statement begins by importing necessary libraries and opening the `Function` namespace. It then declares the types and instances required for the σ-modules:\n   - `R` and `S` are semirings.\n   - `M` and `M₂` are additive commutative monoids and modules over `R` and `S`, respectively.\n   - `σ` and `σ'` are ring homomorphisms with an inverse pair relationship, ensuring compatibility between the modules.\n\n4. **Specify the Functions and Properties**: The functions `to_fun` and `inv_fun` are declared, along with their properties:\n   - `map_add` ensures `to_fun` is additive.\n   - `map_smul` ensures `to_fun` respects scalar multiplication, with the scalar transformed by `σ`.\n   - `left_inv` and `right_inv` ensure `inv_fun` is the inverse of `to_fun`.\n\n5. **Construct the Linear Equivalence**: The linear equivalence is constructed using a record-like syntax:\n   ```lean\n   { toFun := to_fun, map_add' := map_add, map_smul' := map_smul, invFun := inv_fun, left_inv := left_inv, right_inv := right_inv }\n   ```\n   This structure includes all the necessary components and properties to define a linear equivalence.\n\n6. **State the Theorem**: The theorem `coe_mk_extracted` asserts that the coercion of this linear equivalence to a function (denoted by `⇑`) is equal"}
{"source_file": "herald_data/sample_500.jsonl", "line": 54, "id": 486493, "informal_statement": "The probability that one player receives a pair is $\\frac{1}{4}$ . The probability two players receive a pair is $\\frac{1}{4} \\cdot \\frac{1}{3} = \\frac{1}{12}$ . The probability that three players receive a pair is $\\frac{1}{4} \\cdot \\frac{1}{3} \\cdot \\frac{1}{2} = \\frac{1}{24}$ . The probability that four players receive a pair is $\\frac{1}{4} \\cdot \\frac{1}{3} \\cdot \\frac{1}{2} \\cdot \\frac{1}{1} = \\frac{1}{24}$ . The answer is $1-\\left(\\frac{1}{4}-\\frac{1}{12}+\\frac{1}{24}-\\frac{1}{24}\\right) = \\boxed{\\frac{5}{6}}$ .", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_486493 :\n  1 - ((1/4) - (1/12) + (1/24) - (1/24)) = 5/6  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow these steps:\n\n1. **Understand the Informal Statement**: The informal statement describes a probability problem involving multiple players receiving pairs. It calculates the probability for different numbers of players receiving pairs and then combines these probabilities to find a final result.\n\n2. **Identify the Mathematical Operations**: The operations involved are basic arithmetic operations: addition, subtraction, and multiplication of fractions. The final result is obtained by subtracting a series of operations from 1.\n\n3. **Translate the Arithmetic Operations**: In Lean, arithmetic operations on real numbers are straightforward. The fractions are represented using division, e.g., `1/4` for \\(\\frac{1}{4}\\).\n\n4. **Structure the Lean Theorem**: The Lean theorem is structured to assert the equality of the final result. The theorem name `extract_aug_486493` is arbitrary and can be any valid identifier. The statement `1 - ((1/4) - (1/12) + (1/24) - (1/24)) = 5/6` directly mirrors the informal statement's final calculation.\n\n5. **Import Necessary Libraries**: The code imports `Mathlib`, which is a comprehensive library for mathematics in Lean. It also opens `BigOperators`, `Real`, `Nat`, and `Topology`, which are useful for handling real numbers and arithmetic operations.\n\n6. **Formalize the Theorem**: The theorem is written using the `theorem` keyword, followed by the theorem name and the statement. The `:= by sorry` part indicates that the proof is omitted (using `sorry`), which is common when focusing on the statement rather than the proof.\n\n7. **Verify the Statement**: The statement `1 - ((1/4) - (1/12) + (1/24) - (1/24)) = 5/6` is a direct translation of the informal statement's final result. It uses Lean's syntax for arithmetic operations and equality.\n\nBy following these steps, the informal statement is accurately translated into a formal Lean theorem, capturing the essence of the probability problem and its solution."}
{"source_file": "herald_data/sample_500.jsonl", "line": 47, "id": 238972, "informal_statement": "For any element \\(x\\) in a ring \\(R\\) that has a zero, supports natural number powers, and is a subsingleton, given that a set \\(s\\) of natural numbers is equal to the universal set, prove that the nilpotency class of \\(x\\) is equal to \\(0\\).", "formal_statement": "import Mathlib\nopen Function Set\nlemma nilpotencyClass_eq_zero_of_subsingleton_tac_4017 (x : R) [Zero R] [Pow R ℕ] [Subsingleton R] (s : Set ℕ) (this : s = univ) : nilpotencyClass x = 0 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Context**:\n   - We are dealing with a ring \\( R \\). In Lean, this is typically represented by a type `R` with certain structures or typeclasses that provide the necessary operations and properties.\n\n2. **Element \\( x \\) in a Ring \\( R \\)**:\n   - The element \\( x \\) is represented as a variable of type `R` in Lean: `(x : R)`.\n\n3. **Ring with Zero**:\n   - The ring \\( R \\) has a zero element. In Lean, this is expressed by the typeclass `[Zero R]`, which provides the zero element for the type `R`.\n\n4. **Supports Natural Number Powers**:\n   - The ring supports exponentiation with natural numbers. In Lean, this is represented by the typeclass `[Pow R ℕ]`, which allows us to use the power operation with natural numbers as exponents on elements of `R`.\n\n5. **Subsingleton**:\n   - The ring is a subsingleton, meaning it has at most one element. In Lean, this is expressed by the typeclass `[Subsingleton R]`, which enforces that any two elements of `R` are equal.\n\n6. **Set \\( s \\) of Natural Numbers**:\n   - The set \\( s \\) is represented as a variable of type `Set ℕ` in Lean: `(s : Set ℕ)`.\n\n7. **Set \\( s \\) is Equal to the Universal Set**:\n   - The condition that the set \\( s \\) is equal to the universal set of natural numbers is expressed by the hypothesis `(this : s = univ)`. Here, `univ` represents the universal set in Lean, and `this` is a proof or assumption that `s` is equal to `univ`.\n\n8. **Nilpotency Class of \\( x \\) is Equal to \\( 0 \\)**:\n   - The goal is to prove that the nilpotency class of \\( x \\) is zero. In Lean, this is expressed as `nilpotencyClass x = 0`. The lemma is named `nilpotencyClass_eq_zero_of_subsingleton_tac_4017`, which is a"}
{"source_file": "herald_data/sample_500.jsonl", "line": 55, "id": 388358, "informal_statement": "For a function \\( d : X \\to X \\to \\mathbb{R}_{\\geq 0} \\) such that \\( d(x, y) = d(y, x) \\) and \\( d(x, x) = 0 \\) for all \\( x, y \\in X \\), let \\( \\text{dist} \\) be the largest pseudometric distance with \\( \\text{dist}(x, y) \\leq d(x, y) \\) for all \\( x, y \\). If \\( d(x_1, x_4) \\leq 2 \\times \\max(d(x_1, x_2), d(x_2, x_3), d(x_3, x_4)) \\) for all \\( x_1, x_2, x_3, x_4 \\in X \\), prove that \\( d(x, y) \\leq 2 \\times \\text{dist}(x, y) \\) for all \\( x, y \\in X \\).", "formal_statement": "import Mathlib\nopen Set Function Metric List Filter\nopen NNReal Filter Uniformity\n/-- Consider a function `d : X → X → ℝ≥0` such that `d x x = 0` and `d x y = d y x` for all `x`,\n`y`. Let `dist` be the largest pseudometric distance such that `dist x y ≤ d x y`, see\n`PseudoMetricSpace.ofPreNNDist`. Suppose that `d` satisfies the following triangle-like\ninequality: `d x₁ x₄ ≤ 2 * max (d x₁ x₂, d x₂ x₃, d x₃ x₄)`. Then `d x y ≤ 2 * dist x y` for all\n`x`, `y`. -/\ntheorem le_two_mul_dist_ofPreNNDist (d : X → X → ℝ≥0) (dist_self : ∀ x, d x x = 0)\n    (dist_comm : ∀ x y, d x y = d y x)\n    (hd : ∀ x₁ x₂ x₃ x₄, d x₁ x₄ ≤ 2 * max (d x₁ x₂) (max (d x₂ x₃) (d x₃ x₄))) (x y : X) :\n    ↑(d x y) ≤ 2 * @dist X\n      (@PseudoMetricSpace.toDist X (PseudoMetricSpace.ofPreNNDist d dist_self dist_comm)) x y := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Define the Function `d`:**  \n   The informal statement begins by defining a function \\( d : X \\to X \\to \\mathbb{R}_{\\geq 0} \\). In Lean, this is represented as `d : X → X → ℝ≥0`, where `ℝ≥0` denotes the non-negative real numbers. This matches the requirement that \\( d \\) maps pairs of elements from \\( X \\) to non-negative reals.\n\n2. **Symmetry and Reflexivity Conditions:**  \n   The conditions \\( d(x, y) = d(y, x) \\) and \\( d(x, x) = 0 \\) for all \\( x, y \\in X \\) are translated into Lean as:\n   - `dist_self : ∀ x, d x x = 0` for reflexivity.\n   - `dist_comm : ∀ x y, d x y = d y x` for symmetry.\n\n3. **Define `dist` as the Largest Pseudometric:**  \n   The informal statement introduces `dist` as the largest pseudometric such that \\( \\text{dist}(x, y) \\leq d(x, y) \\). In Lean, this is handled by the function `PseudoMetricSpace.ofPreNNDist`, which constructs a pseudometric space from a pre-distance function `d` satisfying the given conditions. The pseudometric `dist` is then accessed via `@dist X (@PseudoMetricSpace.toDist X (PseudoMetricSpace.ofPreNNDist d dist_self dist_comm))`.\n\n4. **Triangle-like Inequality Condition:**  \n   The condition \\( d(x_1, x_4) \\leq 2 \\times \\max(d(x_1, x_2), d(x_2, x_3), d(x_3, x_4)) \\) is expressed in Lean as:\n   - `hd : ∀ x₁ x₂ x₃ x₄, d x₁ x₄ ≤ 2 * max (d x₁ x₂) (max (d x₂ x₃) (d x₃ x₄))`.\n\n5. **Theorem Statement:**  \n   The goal is to prove \\( d(x, y) \\leq 2 \\times \\text{"}
{"source_file": "herald_data/sample_500.jsonl", "line": 56, "id": 170559, "informal_statement": "For any normed additive commutative group $E$, any normed space over the complex numbers $\\mathbb{C}$, a function $f$ from the real numbers $\\mathbb{R}$ to $E$, a complex number $s$, and a real number $u$, show that $u \\cdot (-\\text{Im}(s)) = u \\cdot \\left(\\frac{\\text{Im}(s)}{2\\pi} \\cdot (-2\\pi)\\right)$, where $\\text{Im}(s)$ denotes the imaginary part of $s$.", "formal_statement": "import Mathlib\nopen Real Complex Set MeasureTheory\nopen scoped FourierTransform\nlemma mellin_eq_fourierIntegral_tac_2479 [NormedAddCommGroup E] [NormedSpace ℂ E] (f : ℝ → E) (s : ℂ) (u : ℝ) : ↑u * -↑s.im = ↑(u * (s.im / (2 * π)) * (-2 * π)) := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully consider each component of the statement and how it corresponds to Lean's syntax and mathematical libraries. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context and Imports**:\n   - The problem involves normed additive commutative groups and normed spaces over the complex numbers. In Lean, these are represented by typeclasses `NormedAddCommGroup` and `NormedSpace ℂ`.\n   - The statement also involves real and complex numbers, so we import relevant modules from Lean's math library: `Mathlib`, `Real`, `Complex`, `Set`, and `MeasureTheory`.\n   - The `open scoped FourierTransform` is included to ensure that any specific notations or definitions related to Fourier transforms are available, though it might not be directly used in this lemma.\n\n2. **Defining the Variables**:\n   - The function `f : ℝ → E` is a function from the real numbers to a normed additive commutative group `E`. This is represented in Lean by declaring `f` with the type `ℝ → E`.\n   - The complex number `s` is simply declared as `s : ℂ`.\n   - The real number `u` is declared as `u : ℝ`.\n\n3. **Formalizing the Equation**:\n   - The informal statement involves an equation with the imaginary part of a complex number `s`. In Lean, the imaginary part of a complex number `s` is accessed using `s.im`.\n   - The left-hand side of the equation is `u \\cdot (-\\text{Im}(s))`. In Lean, multiplication of a real number `u` with the imaginary part of `s` (which is a real number) is expressed as `↑u * -↑s.im`. The `↑` symbol is used to lift real numbers to complex numbers, ensuring type compatibility for operations involving complex numbers.\n   - The right-hand side of the equation is `u \\cdot \\left(\\frac{\\text{Im}(s)}{2\\pi} \\cdot (-2\\pi)\\right)`. This is expressed in Lean as `↑(u * (s.im / (2 * π)) * (-2 * π))`. Here, the division and multiplication are performed in the real number domain, and the result is lifted to a complex number using `↑"}
{"source_file": "herald_data/sample_500.jsonl", "line": 57, "id": 394620, "informal_statement": "Let $S \\subseteq \\alpha$ be a countable set with a distinguished element. Prove that for any enumeration $\\{s_n\\}_{n \\in \\mathbb{N}}$ of $S$, $s_n \\in S$ for all $n \\in \\mathbb{N}$.", "formal_statement": "import Mathlib\nopen scoped Classical\nopen Function Set Encodable\nlemma enumerateCountable_mem {s : Set α} (h : s.Countable) {default : α} (h_mem : default ∈ s)\n    (n : ℕ) :\n    enumerateCountable h default n ∈ s := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to break down each component of the informal statement and see how it corresponds to the formal Lean4 code.\n\n1. **Informal: \"Let $S \\subseteq \\alpha$ be a countable set with a distinguished element.\"**\n\n   - **Lean: `{s : Set α} (h : s.Countable) {default : α} (h_mem : default ∈ s)`**\n\n   - In Lean, we start by defining `s` as a subset of some type `α`, which is represented as `Set α`. The property that `S` is countable is captured by the hypothesis `(h : s.Countable)`. The phrase \"with a distinguished element\" is represented by introducing a `default` element of type `α` with the condition `(h_mem : default ∈ s)`, ensuring that this distinguished element is indeed a member of the set `s`.\n\n2. **Informal: \"Prove that for any enumeration $\\{s_n\\}_{n \\in \\mathbb{N}}$ of $S$...\"**\n\n   - **Lean: `enumerateCountable h default`**\n\n   - The function `enumerateCountable` is used to provide an enumeration of the countable set `s`. This function takes the proof of countability `h` and the distinguished element `default` as arguments. It returns a function from natural numbers `ℕ` to elements of `s`, effectively enumerating the set.\n\n3. **Informal: \"$s_n \\in S$ for all $n \\in \\mathbb{N}$.\"**\n\n   - **Lean: `(n : ℕ) : enumerateCountable h default n ∈ s`**\n\n   - The goal is to show that for any natural number `n`, the `n`-th element of the enumeration, `enumerateCountable h default n`, is indeed an element of the set `s`. This is expressed in Lean as the type of the lemma, which states that for any `n : ℕ`, the result of `enumerateCountable h default n` is a member of `s`.\n\n4. **Overall Structure:**\n\n   - The lemma is named `enumerateCountable_mem`, indicating its purpose is to show membership of enumerated elements in the set.\n   - The lemma takes as inputs the set `s`, the proof of"}
{"source_file": "herald_data/sample_500.jsonl", "line": 53, "id": 291480, "informal_statement": "For any elements \\(a, b\\) in a semilattice \\(\\gamma\\) and a set \\(s \\subseteq \\gamma\\) with \\(b\\) as its least upper bound, show that \\(a \\sqcup b\\) is the least upper bound of the set \\(\\{a\\} \\cup s\\).", "formal_statement": "import Mathlib\nopen Function Set\nopen OrderDual (toDual ofDual)\nlemma insert_tac_28250 [SemilatticeSup γ] (a : γ) (b : γ) (s : Set γ) (hs : IsLUB s b) : IsLUB ({a} ∪ s) (a ⊔ b) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: \n   - The statement involves a semilattice, specifically a semilattice with a supremum operation, denoted by \\(\\sqcup\\) in the informal statement and \\(\\sup\\) or \\(\\bigsqcup\\) in formal contexts. In Lean, this is represented by `SemilatticeSup γ`, where `γ` is the type of elements in the semilattice.\n\n2. **Define the Elements and Set**:\n   - The elements \\(a\\) and \\(b\\) are elements of the semilattice \\(\\gamma\\). In Lean, these are represented as `a : γ` and `b : γ`.\n   - The set \\(s\\) is a subset of \\(\\gamma\\). In Lean, this is represented as `s : Set γ`.\n\n3. **Express the Condition on the Set**:\n   - The condition that \\(b\\) is the least upper bound (LUB) of the set \\(s\\) is expressed using the predicate `IsLUB s b` in Lean. This indicates that \\(b\\) is an upper bound of \\(s\\) and that any other upper bound of \\(s\\) is greater than or equal to \\(b\\).\n\n4. **Formulate the Goal**:\n   - The goal is to show that \\(a \\sqcup b\\) is the least upper bound of the set \\(\\{a\\} \\cup s\\). In Lean, the union of a singleton set \\(\\{a\\}\\) with \\(s\\) is written as `{a} ∪ s`.\n   - The least upper bound of this union is expressed as `IsLUB ({a} ∪ s) (a ⊔ b)`, where `⊔` is the Lean notation for the supremum operation.\n\n5. **Structure the Lemma**:\n   - The lemma is named `insert_tac_28250`, which is an arbitrary identifier.\n   - The lemma takes as arguments the elements `a` and `b`, the set `s`, and the hypothesis `hs : IsLUB s b`.\n   - The conclusion of the lemma is the statement `IsLUB ({a} ∪ s) (a ⊔ b)`.\n\n6. **Use of"}
{"source_file": "herald_data/sample_500.jsonl", "line": 58, "id": 377240, "informal_statement": "The normal closure of any permutation of cycle type \\((2,2)\\) in the alternating group \\(A_5\\) is the entire group, as demonstrated by the fact that \\(\\langle (04)(13) \\rangle^{A_5} = A_5\\).", "formal_statement": "import Mathlib\nopen Equiv Equiv.Perm Subgroup Fintype\nopen Equiv.Perm\nopen alternatingGroup\nopen Equiv.Perm\n/-- The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\n  used to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.\n  -/\ntheorem normalClosure_swap_mul_swap_five :\n    normalClosure\n        ({⟨swap 0 4 * swap 1 3, mem_alternatingGroup.2 (by decide)⟩} :\n          Set (alternatingGroup (Fin 5))) =\n      ⊤ := sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow a series of steps that involve understanding both the mathematical concepts and how they are represented in Lean. Here's a detailed breakdown of the translation process:\n\n1. **Understanding the Mathematical Context**:\n   - The statement involves the alternating group \\(A_5\\), which is the group of even permutations of five elements.\n   - A permutation of cycle type \\((2,2)\\) is a product of two disjoint transpositions, such as \\((04)(13)\\).\n   - The normal closure of a set of elements in a group is the smallest normal subgroup containing those elements.\n   - The statement claims that the normal closure of any permutation of cycle type \\((2,2)\\) in \\(A_5\\) is the entire group \\(A_5\\).\n\n2. **Identifying the Key Components in Lean**:\n   - **`Equiv.Perm`**: This module deals with permutations, which are bijections from a set to itself.\n   - **`alternatingGroup`**: This represents the alternating group \\(A_n\\), specifically \\(A_5\\) in this case.\n   - **`normalClosure`**: This function computes the normal closure of a set of elements in a group.\n   - **`⊤`**: This symbol represents the top element in the lattice of subgroups, which is the whole group itself.\n\n3. **Translating the Permutation**:\n   - The permutation \\((04)(13)\\) is expressed in Lean using the `swap` function, which creates a transposition. The product of two swaps, `swap 0 4 * swap 1 3`, represents the permutation \\((04)(13)\\).\n\n4. **Constructing the Set in Lean**:\n   - The set containing the permutation is represented as a singleton set in Lean: `{⟨swap 0 4 * swap 1 3, mem_alternatingGroup.2 (by decide)⟩}`.\n   - The `⟨...⟩` notation is used to create an element of the alternating group, ensuring it satisfies the membership condition (`mem_alternatingGroup.2`).\n\n5. **Formalizing the Theorem**:\n   - The theorem `normalClosure_swap_mul_swap_five` states that the normal closure of the set containing the permutation \\((04)(13"}
{"source_file": "herald_data/sample_500.jsonl", "line": 59, "id": 219688, "informal_statement": "For any field \\( k \\) that is separably closed, and given \\( x \\in k \\), \\( n \\in \\mathbb{N} \\) such that \\( n \\) is nonzero and \\( n > 0 \\), along with the conditions that the degree of the polynomial \\( X^n - x \\) is not zero and \\( x = 0 \\), prove that \\( 0 = 0 \\).", "formal_statement": "import Mathlib\nopen Polynomial\nlemma exists_pow_nat_eq_tac_3972 [Field k] [IsSepClosed k] (x : k) (n : ℕ) (hn : NeZero ↑n) (hn' : 0 < n) (this : (X ^ n - C x).degree ≠ 0) (hx : x = 0) : 0 = 0 := sorry", "explanation": "To translate the given informal mathematical statement into the provided Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Field \\( k \\) that is separably closed**:\n   - In Lean, a field is represented by the type class `Field k`. The property of being separably closed is represented by the type class `IsSepClosed k`. These are included as type class arguments in the lemma, indicated by `[Field k] [IsSepClosed k]`.\n\n2. **Given \\( x \\in k \\)**:\n   - The element \\( x \\) from the field \\( k \\) is represented as a parameter `(x : k)` in the lemma. This indicates that \\( x \\) is an element of the field \\( k \\).\n\n3. **\\( n \\in \\mathbb{N} \\) such that \\( n \\) is nonzero and \\( n > 0 \\)**:\n   - The natural number \\( n \\) is represented as `(n : ℕ)`. The condition that \\( n \\) is nonzero is captured by the hypothesis `(hn : NeZero ↑n)`, where `NeZero` is a type class that ensures the natural number \\( n \\) is not zero. The condition \\( n > 0 \\) is represented by the hypothesis `(hn' : 0 < n)`.\n\n4. **Degree of the polynomial \\( X^n - x \\) is not zero**:\n   - The polynomial \\( X^n - x \\) is represented in Lean using `X ^ n - C x`, where `X` is the polynomial variable and `C x` is the constant polynomial with value \\( x \\). The condition that its degree is not zero is expressed by `(this : (X ^ n - C x).degree ≠ 0)`.\n\n5. **Condition \\( x = 0 \\)**:\n   - The condition that \\( x \\) is zero is directly represented by the hypothesis `(hx : x = 0)`.\n\n6. **Prove that \\( 0 = 0 \\)**:\n   - The conclusion of the lemma is `0 = 0`, which is trivially true. In Lean, this is expressed as `0 = 0` in the lemma's return type. The proof is marked as `sorry`, indicating that the proof"}
{"source_file": "herald_data/sample_500.jsonl", "line": 64, "id": 256706, "informal_statement": "For any matroid $M$ over a set $\\alpha$ with the property of having infinite rank, show that $M$ does not have finite rank, i.e., $\\neg M.FiniteRk$.", "formal_statement": "import Mathlib\nopen Set\nlemma not_finiteRk_tac_20258 (M : Matroid α) [M.InfiniteRk] : ¬M.FiniteRk := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we follow these steps:\n\n1. **Understanding the Context**: The informal statement involves a matroid \\( M \\) over a set \\(\\alpha\\) with the property of having infinite rank. We need to show that such a matroid does not have finite rank.\n\n2. **Identifying the Components**:\n   - **Matroid \\( M \\)**: In Lean, a matroid over a set \\(\\alpha\\) is represented as `Matroid α`.\n   - **Infinite Rank Property**: The property that \\( M \\) has infinite rank is represented by the type class `[M.InfiniteRk]` in Lean. This indicates that the matroid \\( M \\) satisfies the condition of having infinite rank.\n\n3. **Formalizing the Statement**:\n   - **Goal**: We need to prove that \\( M \\) does not have finite rank, which is expressed as `¬M.FiniteRk` in Lean. The `¬` symbol represents logical negation.\n\n4. **Constructing the Lemma**:\n   - **Lemma Declaration**: We declare a lemma named `not_finiteRk_tac_20258` which takes a matroid \\( M \\) as an argument.\n   - **Type Class Constraint**: We include `[M.InfiniteRk]` as a type class constraint to ensure that the matroid \\( M \\) has infinite rank.\n   - **Conclusion**: The conclusion of the lemma is `¬M.FiniteRk`, which states that \\( M \\) does not have finite rank.\n\n5. **Using Lean's Import and Namespace**:\n   - **Importing Mathlib**: The line `import Mathlib` is used to bring in the necessary mathematical library that includes definitions and theorems related to matroids.\n   - **Opening Set Namespace**: The line `open Set` is included to make set-related operations and definitions available without needing to prefix them with `Set.`.\n\n6. **Proof Placeholder**: The `:= sorry` at the end of the lemma indicates that the proof is not yet provided. In Lean, `sorry` is a placeholder for incomplete proofs.\n\nBy following these steps, the informal statement is accurately translated into the formal Lean4 code, capturing the essence of the mathematical assertion within the Lean theorem prover's framework."}
{"source_file": "herald_data/sample_500.jsonl", "line": 62, "id": 179455, "informal_statement": "For any real number $x$ with $-\\frac{\\pi}{2} < x$ and $x < \\frac{\\pi}{2}$, and for any integer $r$ satisfying $x = \\left(2r + 1\\right)\\frac{\\pi}{2}$ and $0 \\leq r$, show that the statement leads to a contradiction, i.e., $False$.", "formal_statement": "import Mathlib\nopen Set Filter\nopen scoped Topology Real\nlemma continuousOn_tan_Ioo_tac_2569 (x : ℝ) (hx_gt : -(π / 2) < x) (hx_lt : ¬x ≥ π / 2) (r : ℤ) (hxr_eq : x = (2 * ↑r + 1) * π / 2) (h : 0 ≤ r) : False := sorry", "explanation": "To translate the given informal mathematical statement into the provided Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Domain and Imports:**\n   - The Lean code begins with `import Mathlib` and some `open` statements. This is necessary to bring in the mathematical libraries and namespaces that provide the definitions and theorems needed for real numbers, integers, and trigonometric functions.\n\n2. **Defining the Variables:**\n   - The informal statement involves a real number \\( x \\) and an integer \\( r \\). In Lean, these are declared as `x : ℝ` and `r : ℤ`, respectively. The type `ℝ` represents real numbers, and `ℤ` represents integers.\n\n3. **Translating the Inequality Conditions:**\n   - The condition \\( -\\frac{\\pi}{2} < x \\) is translated to `hx_gt : -(π / 2) < x`. Here, `hx_gt` is a hypothesis name, and the inequality is directly translated using Lean's syntax for real numbers and arithmetic operations.\n   - The condition \\( x < \\frac{\\pi}{2} \\) is translated to `hx_lt : ¬x ≥ π / 2`. Instead of using `<`, the code uses `¬x ≥ π / 2`, which is logically equivalent. This is a common practice in Lean to express strict inequalities using negation.\n\n4. **Expressing the Equation:**\n   - The equation \\( x = \\left(2r + 1\\right)\\frac{\\pi}{2} \\) is translated to `hxr_eq : x = (2 * ↑r + 1) * π / 2`. Here, `↑r` is used to cast the integer `r` to a real number, which is necessary for arithmetic operations involving real numbers. The expression `(2 * ↑r + 1) * π / 2` directly mirrors the informal equation.\n\n5. **Non-negativity of the Integer:**\n   - The condition \\( 0 \\leq r \\) is translated to `h : 0 ≤ r`. This is a straightforward translation of the inequality involving the integer `r`.\n\n6. **Conclusion and Contradiction:**\n   - The informal statement concludes with showing a contradiction, i.e"}
{"source_file": "herald_data/sample_500.jsonl", "line": 60, "id": 279950, "informal_statement": "For any measurable space \\((\\alpha, m0)\\), a measure \\(\\mu\\) on \\(\\alpha\\), functions \\(f, g : \\alpha \\to \\gamma\\), and a set \\(s \\subseteq \\alpha\\) such that the membership in \\(s\\) is decidable, if \\(\\mu(s) = 0\\) and the complement of \\(s\\) is a subset of the set of all \\(a \\in \\alpha\\) for which \\(f(a) = g(a)\\) when \\(a \\in s\\), then the set of all \\(x \\in \\alpha\\) for which \\(f(x) \\neq g(x)\\) when \\(x \\in s\\) is a subset of \\(s\\).", "formal_statement": "import Mathlib\nopen scoped ENNReal NNReal Topology\nopen Set MeasureTheory Measure Filter Function MeasurableSpace ENNReal\nopen scoped symmDiff\nopen Interval\nlemma ite_ae_eq_of_measure_zero_tac_21550 (m0 : MeasurableSpace α) (μ : Measure α) (f : α → γ) (g : α → γ) (s : Set α) [DecidablePred fun x => x ∈ s] (hs_zero : μ s = 0) (h_ss : sᶜ ⊆ {a | (if a ∈ s then f a else g a) = g a}) : {x | (fun x => (fun x => if x ∈ s then f x else g x) x = g x) x}ᶜ ⊆ s := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a series of logical steps that map each component of the informal statement to its formal counterpart in Lean. Here's the breakdown:\n\n1. **Measurable Space and Measure**:\n   - The informal statement begins with \"For any measurable space \\((\\alpha, m0)\\)\" and \"a measure \\(\\mu\\) on \\(\\alpha\\)\". In Lean, this is represented by `m0 : MeasurableSpace α` and `μ : Measure α`. Here, `α` is the type representing the underlying set, `m0` is the measurable space structure on `α`, and `μ` is a measure on this space.\n\n2. **Functions and Set**:\n   - The functions \\(f, g : \\alpha \\to \\gamma\\) are represented as `f : α → γ` and `g : α → γ` in Lean. The set \\(s \\subseteq \\alpha\\) is represented as `s : Set α`.\n\n3. **Decidability of Membership**:\n   - The statement \"such that the membership in \\(s\\) is decidable\" is captured by `[DecidablePred fun x => x ∈ s]`. This indicates that for any element \\(x\\), it is decidable whether \\(x\\) belongs to the set \\(s\\).\n\n4. **Measure Zero Condition**:\n   - The condition \"\\(\\mu(s) = 0\\)\" is directly translated to `hs_zero : μ s = 0`. This states that the measure of the set \\(s\\) is zero.\n\n5. **Subset Condition**:\n   - The condition \"the complement of \\(s\\) is a subset of the set of all \\(a \\in \\alpha\\) for which \\(f(a) = g(a)\\) when \\(a \\in s\\)\" is formalized as `h_ss : sᶜ ⊆ {a | (if a ∈ s then f a else g a) = g a}`. Here, `sᶜ` denotes the complement of \\(s\\), and the set comprehension `{a | (if a ∈ s then f a else g a) = g a}` represents the set of elements where the function defined by `if a ∈ s then f a else g a` equals \\(g(a)\\).\n\n6. **"}
{"source_file": "herald_data/sample_500.jsonl", "line": 52, "id": 406171, "informal_statement": "Given a list $l$ of natural numbers where each element $p$ is a prime, construct a prime multiset from $l$. This mapping transforms the list $l$ into a prime multiset, with the condition that every element $p$ in $l$ is a prime number.", "formal_statement": "import Mathlib\n\n/-- Lists can be coerced to multisets; here we have some results\nabout how this interacts with our constructions on multisets. -/\ndef ofNatList (l : List ℕ) (h : ∀ p : ℕ, p ∈ l → p.Prime) : PrimeMultiset := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understand the Informal Statement**: The task is to take a list `l` of natural numbers, where each element is a prime number, and convert this list into a prime multiset. A multiset is like a set but allows for multiple occurrences of the same element. A prime multiset is a multiset where all elements are prime numbers.\n\n2. **Identify the Components**:\n   - **List of Natural Numbers**: In Lean, a list of natural numbers is represented as `List ℕ`.\n   - **Prime Condition**: We need to ensure that every element in the list is a prime number. This is expressed as a condition or predicate on the list.\n\n3. **Formalize the Input**:\n   - The input is a list `l` of natural numbers, which is represented as `l : List ℕ` in Lean.\n   - The condition that every element `p` in `l` is prime is expressed using a predicate `h : ∀ p : ℕ, p ∈ l → p.Prime`. This means for every natural number `p`, if `p` is in the list `l`, then `p` is a prime number.\n\n4. **Define the Output Type**:\n   - The output is a prime multiset. In Lean, this is represented by a type `PrimeMultiset`. The exact definition of `PrimeMultiset` is not provided in the snippet, but it is assumed to be a type that represents multisets of prime numbers.\n\n5. **Construct the Function**:\n   - The function is defined as `def ofNatList`, which takes two arguments: the list `l` and the proof `h` that all elements are prime.\n   - The function signature is `def ofNatList (l : List ℕ) (h : ∀ p : ℕ, p ∈ l → p.Prime) : PrimeMultiset`. This indicates that given a list of natural numbers and a proof that all elements are prime, the function will return a `PrimeMultiset`.\n\n6. **Implementation Placeholder**:\n   - The body of the function is marked as `sorry`, which is a placeholder in Lean indicating that the implementation is not yet provided. This is often used during the development process when the exact construction is not yet completed.\n\nBy following these steps"}
{"source_file": "herald_data/sample_500.jsonl", "line": 63, "id": 571242, "informal_statement": "Prove or disprove the inequality: $3(a^2+b^2+c^2)\\geq(ab+bc+ca)\\cdot(\\frac{a}{b}+\\frac{b}{c}+\\frac{c}{a})$ given $a,b,c>0$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_571242 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : 3 * (a ^ 2 + b ^ 2 + c ^ 2) ≥ (a * b + b * c + c * a) * (a / b + b / c + c / a)   :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4 code, we need to follow a series of steps that involve understanding the mathematical concepts and how they are represented in Lean. Here's the step-by-step explanation:\n\n1. **Identify the Variables and Their Types**:\n   - The variables in the inequality are \\(a\\), \\(b\\), and \\(c\\), which are all positive real numbers. In Lean, real numbers are represented by `ℝ`, and positivity is expressed using inequalities.\n\n2. **Express the Conditions**:\n   - The condition \\(a, b, c > 0\\) is translated into Lean as `ha : 0 < a`, `hb : 0 < b`, and `hc : 0 < c`. These are hypotheses that will be used in the theorem.\n\n3. **Translate the Inequality**:\n   - The inequality \\(3(a^2 + b^2 + c^2) \\geq (ab + bc + ca) \\cdot \\left(\\frac{a}{b} + \\frac{b}{c} + \\frac{c}{a}\\right)\\) is directly translated into Lean using the appropriate operators:\n     - Multiplication is represented by `*`.\n     - Addition is represented by `+`.\n     - Exponentiation is represented by `^`.\n     - Division is represented by `/`.\n     - The inequality symbol \\(\\geq\\) is represented by `≥`.\n\n4. **Structure the Theorem**:\n   - The theorem is named `extract_aug_571242`, which is a unique identifier for this particular statement.\n   - The theorem takes the form `theorem extract_aug_571242 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : ... := by sorry`.\n   - The `by sorry` part indicates that the proof is not provided, which is common when setting up a theorem for later proof.\n\n5. **Import Necessary Libraries**:\n   - The `import Mathlib` statement is used to bring in the necessary mathematical libraries that provide definitions and theorems for real numbers and inequalities.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to make various mathematical operations and constants available without needing to prefix them with their module names.\n\n6. **Final Lean Code**:\n   - The"}
{"source_file": "herald_data/sample_500.jsonl", "line": 61, "id": 74873, "informal_statement": "For any element $y$ in the ring $\\mathbb{Z}/p\\mathbb{Z}$ such that $y^2 = -1$, show that $p$ modulo $4$ is not equal to $3$, i.e., $p \\mod 4 \\neq 3$.", "formal_statement": "import Mathlib\nopen Nat\nopen ZMod\nopen ZMod\ntheorem mod_four_ne_three_of_sq_eq_neg_one_extracted {p : ℕ} [Fact (Nat.Prime p)] {y : ZMod p} : y ^ 2 = -1 → p % 4 ≠ 3 := sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and semantics.\n\n1. **Understanding the Context**:\n   - We are working within the context of modular arithmetic, specifically the ring \\(\\mathbb{Z}/p\\mathbb{Z}\\), which is represented in Lean as `ZMod p`.\n   - The statement involves a prime number \\(p\\) and an element \\(y\\) in this ring.\n\n2. **Formalizing the Ring and Prime**:\n   - In Lean, `ZMod p` represents the ring \\(\\mathbb{Z}/p\\mathbb{Z}\\).\n   - The condition that \\(p\\) is a prime number is expressed using `[Fact (Nat.Prime p)]`. This is a typeclass instance that provides the fact that \\(p\\) is prime, which is necessary for certain properties and operations in modular arithmetic.\n\n3. **Element and Condition**:\n   - The element \\(y\\) in the ring is represented as `{y : ZMod p}`. This indicates that \\(y\\) is an arbitrary element of the ring.\n   - The condition \\(y^2 = -1\\) is directly translated to `y ^ 2 = -1` in Lean. Here, `^` denotes exponentiation, and `-1` is the additive inverse of `1` in the ring `ZMod p`.\n\n4. **Conclusion of the Statement**:\n   - The goal is to show that \\(p \\mod 4 \\neq 3\\). In Lean, this is expressed as `p % 4 ≠ 3`. The `%` operator is used for the modulo operation, and `≠` denotes inequality.\n\n5. **Theorem Declaration**:\n   - The theorem is declared with the name `mod_four_ne_three_of_sq_eq_neg_one_extracted`.\n   - The parameters of the theorem include the prime \\(p\\) and the element \\(y\\), along with the condition \\(y^2 = -1\\).\n   - The conclusion is the inequality `p % 4 ≠ 3`.\n\n6. **Using `sorry`**:\n   - The `:= sorry` at the end of the theorem indicates that the proof is not provided. In Lean, `sorry` is a placeholder that allows the code to compile without a complete proof"}
{"source_file": "herald_data/sample_500.jsonl", "line": 66, "id": 495785, "informal_statement": "Let $x_1$ , $x_2$ ,..., $x_n$ be real numbers such that $x_1^2+x_2^2+...+x_n^2=1.$ . Prove that:\\n$$\\sqrt{1-x_1x_2}+\\sqrt{1-x_2x_3}+...+\\sqrt{1-x_nx_1}\\geq\\sqrt{n(n-1)}.$$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_495785 (n : ℕ) (x : ℕ → ℝ) (h₁ : ∑ i in Finset.range n, (x i) ^ 2 = 1) : ∑ i in Finset.range n, Real.sqrt (1 - x i * x (i + 1)) ≥ Real.sqrt (n * (n - 1))  :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the problem and its constraints. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Variables and Domain**:\n   - The informal statement involves a sequence of real numbers \\( x_1, x_2, \\ldots, x_n \\).\n   - In Lean, we represent this sequence as a function \\( x : \\mathbb{N} \\to \\mathbb{R} \\), where \\( x(i) \\) corresponds to \\( x_i \\).\n\n2. **Constraints on the Sequence**:\n   - The condition \\( x_1^2 + x_2^2 + \\ldots + x_n^2 = 1 \\) is expressed using a summation over the indices from 1 to \\( n \\).\n   - In Lean, we use `Finset.range n` to represent the set of indices from 0 to \\( n-1 \\) (since Lean uses zero-based indexing).\n   - The constraint is then written as `∑ i in Finset.range n, (x i) ^ 2 = 1`.\n\n3. **The Expression to Prove**:\n   - The informal statement requires proving an inequality involving square roots: \\(\\sqrt{1-x_1x_2} + \\sqrt{1-x_2x_3} + \\ldots + \\sqrt{1-x_nx_1} \\geq \\sqrt{n(n-1)}\\).\n   - In Lean, this is expressed as a sum over the indices, similar to the constraint. The expression inside the sum is `Real.sqrt (1 - x i * x (i + 1))`.\n   - Note that \\( x_{n+1} \\) is interpreted as \\( x_1 \\) due to the cyclic nature of the indices, which is naturally handled by the function \\( x \\) in Lean.\n\n4. **Formalizing the Theorem**:\n   - The theorem is named `extract_aug_495785`, which is a placeholder name and can be replaced with a more descriptive one.\n   - The theorem takes three arguments: \\( n \\) (a natural number), \\( x \\) (a function from natural numbers to reals), and \\( h₁ \\) (the hypothesis that the sum of squares equals 1).\n   - The"}
{"source_file": "herald_data/sample_500.jsonl", "line": 65, "id": 171343, "informal_statement": "For any nontrivially normed field $\\mathbb{K}$, normed additive commutative group $E$, normed space $\\mathbb{K}E$, and topological space $H$, and given a model with corners $I$ from $\\mathbb{K}E$ to $H$, and a set $s$ in $H$, prove that $s$ is a subset of the universal set in $H$.", "formal_statement": "import Mathlib\nopen Set Filter Function\nopen scoped Manifold Filter Topology\nlemma image_eq_tac_12932 [NontriviallyNormedField 𝕜] [NormedAddCommGroup E] [NormedSpace 𝕜 E] [TopologicalSpace H] (I : ModelWithCorners 𝕜 E H) (s : Set H) : s ⊆ univ := sorry", "explanation": "To translate the given informal mathematical statement into the provided Lean4 code, we need to follow a series of logical steps that map the mathematical concepts to their formal counterparts in Lean. Here's how the translation is achieved:\n\n1. **Understanding the Context**:\n   - The informal statement involves several mathematical structures: a nontrivially normed field $\\mathbb{K}$, a normed additive commutative group $E$, a normed space $\\mathbb{K}E$, a topological space $H$, a model with corners $I$, and a set $s$ in $H$.\n   - The goal is to prove that the set $s$ is a subset of the universal set in $H$.\n\n2. **Translating Mathematical Structures**:\n   - **Nontrivially Normed Field**: In Lean, this is represented by the typeclass `NontriviallyNormedField 𝕜`. This indicates that $\\mathbb{K}$ is a field with a norm that is nontrivial (i.e., not all elements have norm zero).\n   - **Normed Additive Commutative Group**: This is represented by `NormedAddCommGroup E`, indicating that $E$ is a group with a norm and commutative addition.\n   - **Normed Space**: The combination of $\\mathbb{K}$ and $E$ as a normed space is captured by `NormedSpace 𝕜 E`.\n   - **Topological Space**: The space $H$ is a topological space, represented by `TopologicalSpace H`.\n\n3. **Model with Corners**:\n   - The concept of a model with corners from $\\mathbb{K}E$ to $H$ is represented by `ModelWithCorners 𝕜 E H`. This is a structure in Lean that encapsulates the idea of a manifold chart with corners.\n\n4. **Set and Universal Set**:\n   - The set $s$ in $H$ is represented by `s : Set H`.\n   - The universal set in $H$ is denoted by `univ`, which is a predefined constant in Lean representing the set of all elements in a given type.\n\n5. **Formalizing the Goal**:\n   - The goal is to prove that $s$ is a subset of the universal set in $H$. In Lean, this is expressed as `s"}
{"source_file": "herald_data/sample_500.jsonl", "line": 67, "id": 405383, "informal_statement": "Let $\\alpha$ be a monoid, $R$ a semiring, and suppose $\\alpha$ acts multiplicatively on $R$. Given a ring connection $c$ on $R$, show that there exists a multiplicative semiring action of $\\alpha$ on the quotient ring $c.Quotient$.", "formal_statement": "import Mathlib\n\ninstance [Monoid α] [Semiring R] [MulSemiringAction α R] [IsScalarTower α R R] (c : RingCon R) :\n    MulSemiringAction α c.Quotient := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Structures Involved**: \n   - The informal statement mentions a monoid $\\alpha$, a semiring $R$, and a ring connection $c$ on $R$. It also mentions that $\\alpha$ acts multiplicatively on $R$.\n   - In Lean, these correspond to the type classes `Monoid α`, `Semiring R`, and `RingCon R` respectively. The multiplicative action of $\\alpha$ on $R$ is represented by `MulSemiringAction α R`.\n\n2. **Understand the Goal**:\n   - The goal is to show that there exists a multiplicative semiring action of $\\alpha$ on the quotient ring $c.Quotient$.\n   - In Lean, this is expressed as an instance of `MulSemiringAction α c.Quotient`.\n\n3. **Translate the Informal Statement to Lean**:\n   - We start by importing the necessary library `Mathlib` which contains the definitions and instances we need.\n   - We declare an instance using the `instance` keyword. This is how we define that a certain property or structure exists for given types in Lean.\n\n4. **Specify the Context**:\n   - We specify the context by listing the required type classes and assumptions in square brackets. These are:\n     - `[Monoid α]`: $\\alpha$ is a monoid.\n     - `[Semiring R]`: $R$ is a semiring.\n     - `[MulSemiringAction α R]`: $\\alpha$ acts multiplicatively on $R$.\n     - `[IsScalarTower α R R]`: This ensures compatibility of the scalar action with the semiring structure, which is often needed when dealing with actions on quotients.\n     - `(c : RingCon R)`: $c$ is a ring connection on $R$.\n\n5. **State the Conclusion**:\n   - We conclude by stating that there is a `MulSemiringAction α c.Quotient`. This is the formal way to express that $\\alpha$ acts multiplicatively on the quotient ring $c.Quotient$.\n\n6. **Use `sorry` as a Placeholder**:\n   - The `:= sorry` part is a placeholder indicating that the proof or construction of this instance is not provided. In a complete development, this would be replaced with the actual implementation."}
{"source_file": "herald_data/sample_500.jsonl", "line": 70, "id": 341164, "informal_statement": "For any \\( a \\in \\mathbb{N} \\) in a finite set \\( s \\), and for any natural number \\( n \\geq 2 \\), show that \\( a < \\sum_{i \\in s} n^i \\).", "formal_statement": "import Mathlib\nopen Finset Function\nopen Colex\nopen scoped symmDiff\nopen Colex\ntheorem lt_geomSum_of_mem {a : ℕ} (hn : 2 ≤ n) (hi : a ∈ s) : a < ∑ i in s, n ^ i := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal Lean4 syntax.\n\n1. **Understanding the Context**:\n   - The informal statement involves natural numbers (\\(\\mathbb{N}\\)), a finite set \\(s\\), and a condition involving a sum of powers of a natural number \\(n\\).\n   - The goal is to show an inequality involving an element \\(a\\) from the set \\(s\\) and a geometric sum.\n\n2. **Lean4 Imports and Setup**:\n   - The code begins with `import Mathlib`, which is necessary to access mathematical libraries in Lean4 that provide definitions and theorems for working with natural numbers, finite sets, and sums.\n   - `open Finset Function` and other `open` statements are used to bring relevant definitions and notations into scope, such as operations on finite sets (`Finset`) and functions.\n\n3. **Theorem Declaration**:\n   - `theorem lt_geomSum_of_mem` declares a new theorem named `lt_geomSum_of_mem`.\n   - The parameters of the theorem are specified in curly braces `{a : ℕ}` and parentheses `(hn : 2 ≤ n) (hi : a ∈ s)`.\n     - `{a : ℕ}` indicates that \\(a\\) is a natural number, which corresponds to \\(a \\in \\mathbb{N}\\) in the informal statement.\n     - `(hn : 2 ≤ n)` specifies the condition \\(n \\geq 2\\), ensuring \\(n\\) is a natural number greater than or equal to 2.\n     - `(hi : a ∈ s)` corresponds to the condition that \\(a\\) is an element of the finite set \\(s\\).\n\n4. **Formalizing the Inequality**:\n   - The conclusion of the theorem is `a < ∑ i in s, n ^ i`.\n   - `∑ i in s, n ^ i` represents the sum of \\(n^i\\) for each \\(i\\) in the finite set \\(s\\). This is the formalization of the geometric sum \\(\\sum_{i \\in s} n^i\\).\n   - The inequality `a < ∑ i in s, n ^ i` directly translates the informal statement's requirement that \\(a\\) is less than this sum."}
{"source_file": "herald_data/sample_500.jsonl", "line": 69, "id": 230287, "informal_statement": "For any integers $m$ and $n$, and for any non-zero natural number $k$, if $m^k$ divides $n^k$, then show that $m^k$ divides $n^k$. Note: The statement is a repetition and does not provide new information beyond what is already given; it is presented as is per the formal statement.", "formal_statement": "import Mathlib\n\nlemma pow_dvd_pow_iff_tac_10740 (m : ℤ) (n : ℤ) (k : ℕ) (k0 : k ≠ 0) (h : m ^ k ∣ n ^ k) : m ^ k ∣ n ^ k := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types:**\n   - The informal statement involves integers \\( m \\) and \\( n \\), and a non-zero natural number \\( k \\).\n   - In Lean, integers are represented by `ℤ` and natural numbers by `ℕ`.\n\n2. **Formalize the Hypotheses:**\n   - The hypothesis is that \\( m^k \\) divides \\( n^k \\). In Lean, divisibility is expressed using the `∣` symbol.\n   - The condition that \\( k \\) is a non-zero natural number is expressed as `k ≠ 0`.\n\n3. **Structure the Lemma:**\n   - The lemma is named `pow_dvd_pow_iff_tac_10740`, which is a unique identifier for this particular statement.\n   - The lemma takes the variables \\( m \\), \\( n \\), and \\( k \\) as inputs, along with the non-zero condition `k0 : k ≠ 0` and the divisibility hypothesis `h : m ^ k ∣ n ^ k`.\n\n4. **State the Conclusion:**\n   - The conclusion is that \\( m^k \\) divides \\( n^k \\), which is exactly the same as the hypothesis. This is a tautology in the context of the given statement.\n\n5. **Use of `sorry`:**\n   - The `sorry` keyword is used as a placeholder for the proof. It indicates that the proof is omitted or not yet provided.\n\n6. **Importing Necessary Libraries:**\n   - The statement begins with `import Mathlib`, which suggests that the lemma might rely on mathematical libraries for handling integers, natural numbers, and divisibility.\n\nIn summary, the Lean code formalizes the informal statement by defining a lemma with the same divisibility condition as both the hypothesis and conclusion, while ensuring the types and conditions (like non-zero \\( k \\)) are correctly specified. The use of `sorry` indicates that the proof is not provided, which is consistent with the tautological nature of the statement."}
{"source_file": "herald_data/sample_500.jsonl", "line": 68, "id": 283064, "informal_statement": "Let \\( \\mathbb{K} \\) be a topological ring-like space, \\( s \\) be a subset of \\( \\mathbb{K} \\) with \\( 0 \\in s \\), \\( f \\) be a continuous map from the closure of \\( s \\) to \\( \\mathbb{K} \\), and suppose that the evaluation star algebra homomorphism at \\( 0 \\) applied to \\( f \\) yields \\( 0 \\). Prove that the evaluation star algebra homomorphism at \\( 0 \\) applied to the star of \\( f \\) also yields \\( 0 \\).", "formal_statement": "import Mathlib\nopen scoped Polynomial\nopen scoped Topology\nopen RCLike\nopen ContinuousMap\nopen StarSubalgebra Polynomial\nopen scoped Polynomial\nopen NonUnitalStarAlgebra Submodule\nopen Pointwise in\nlemma nonUnitalStarAlgebraAdjoin_id_subset_ker_evalStarAlgHom_tac_24415 [RCLike 𝕜] (s : Set 𝕜) (h0 : 0 ∈ s) (f : C(↑s, 𝕜)) (hf : (evalStarAlgHom 𝕜 𝕜 ⟨0, h0⟩) f = 0) : (evalStarAlgHom 𝕜 𝕜 ⟨0, h0⟩) (star f) = 0 := sorry", "explanation": "To translate the given informal mathematical statement into the provided Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Topological Ring-like Space**: \n   - The informal statement begins with \"Let \\( \\mathbb{K} \\) be a topological ring-like space.\" In Lean, this is represented by `[RCLike 𝕜]`. The `RCLike` typeclass is used to denote a structure that behaves like a topological ring, where `𝕜` is the type representing the space.\n\n2. **Subset with \\( 0 \\in s \\)**:\n   - The subset \\( s \\) of \\( \\mathbb{K} \\) with \\( 0 \\in s \\) is represented by `(s : Set 𝕜)` and `(h0 : 0 ∈ s)` in Lean. Here, `s` is a set of elements from `𝕜`, and `h0` is a proof or assumption that `0` is an element of `s`.\n\n3. **Continuous Map**:\n   - The function \\( f \\) is described as a continuous map from the closure of \\( s \\) to \\( \\mathbb{K} \\). In Lean, this is represented by `(f : C(↑s, 𝕜))`. The `C(↑s, 𝕜)` denotes a continuous map from the closure of `s` (denoted by `↑s`) to `𝕜`.\n\n4. **Evaluation Star Algebra Homomorphism**:\n   - The statement \"the evaluation star algebra homomorphism at \\( 0 \\) applied to \\( f \\) yields \\( 0 \\)\" is formalized as `(hf : (evalStarAlgHom 𝕜 𝕜 ⟨0, h0⟩) f = 0)`. Here, `evalStarAlgHom 𝕜 𝕜 ⟨0, h0⟩` represents the evaluation star algebra homomorphism at the point `0` (with `h0` ensuring `0 ∈ s`), applied to the function `f`, resulting in `0`.\n\n5. **Prove the Evaluation of the Star**:\n   - The goal is to prove that the evaluation star"}
{"source_file": "herald_data/sample_500.jsonl", "line": 71, "id": 58658, "informal_statement": "For any function \\( b \\) and its bi-minimum value \\( \\min_{\\text{bi}} b \\), show that \\( \\frac{b(\\min_{\\text{bi}} b)}{2} < 1 \\).", "formal_statement": "import Mathlib\nopen Finset Real Filter Asymptotics\nopen scoped Topology\ntheorem bi_min_div_two_lt_one_extracted [Fintype α] {T : ℕ → ℝ} {g : ℝ → ℝ} {a b : α → ℝ} {r : α → ℕ → ℕ} [Nonempty α] :\n AkraBazziRecurrence T g a b r → b (AkraBazziRecurrence.min_bi b) / 2 < 1 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Informal Statement**:\n   - We are given a function \\( b \\) and its bi-minimum value \\( \\min_{\\text{bi}} b \\).\n   - The goal is to show that \\( \\frac{b(\\min_{\\text{bi}} b)}{2} < 1 \\).\n\n2. **Identifying the Components in Lean**:\n   - **Function \\( b \\)**: In Lean, this is represented as `b : α → ℝ`, meaning \\( b \\) is a function from some type \\( α \\) to the real numbers \\( \\mathbb{R} \\).\n   - **Bi-minimum value \\( \\min_{\\text{bi}} b \\)**: This is represented by `AkraBazziRecurrence.min_bi b`, which is a function that computes the bi-minimum value of \\( b \\). The context suggests that this is part of a specific recurrence relation setup, likely related to the Akra-Bazzi method.\n   - **Inequality \\( \\frac{b(\\min_{\\text{bi}} b)}{2} < 1 \\)**: This is directly translated to `b (AkraBazziRecurrence.min_bi b) / 2 < 1` in Lean.\n\n3. **Contextual Setup**:\n   - **`[Fintype α]`**: This indicates that the type \\( α \\) is finite, which is necessary for certain operations like finding minimums over finite sets.\n   - **`{T : ℕ → ℝ}` and `{g : ℝ → ℝ}`**: These are additional functions involved in the recurrence relation, though they are not directly used in the inequality.\n   - **`{a b : α → ℝ}`**: Both \\( a \\) and \\( b \\) are functions from \\( α \\) to \\( \\mathbb{R} \\), but the focus here is on \\( b \\).\n   - **`{r : α → ℕ → ℕ}`**: This is another function, likely part of the recurrence relation, mapping elements of \\( α \\) and natural numbers to natural numbers.\n   - **`[Nonempty"}
{"source_file": "herald_data/sample_500.jsonl", "line": 74, "id": 330902, "informal_statement": "For any object \\( x \\) in the category \\(\\mathbf{Unif}\\), there exists a canonical uniform structure on \\( x \\).", "formal_statement": "import Mathlib\nopen CategoryTheory\ninstance (x : UniformSpaceCat) : UniformSpace x := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Category**: The informal statement refers to the category \\(\\mathbf{Unif}\\), which is the category of uniform spaces. In Lean, this is represented by `UniformSpaceCat`.\n\n2. **Universal Quantification**: The phrase \"For any object \\( x \\)\" indicates a universal quantification over objects in the category. In Lean, this is expressed by introducing a variable `x` of type `UniformSpaceCat`.\n\n3. **Existence of a Structure**: The statement \"there exists a canonical uniform structure on \\( x \\)\" suggests that for each object \\( x \\), there is a specific structure (in this case, a uniform structure) that can be associated with it. In Lean, this is expressed by providing an instance of the `UniformSpace` typeclass for `x`.\n\n4. **Formalizing the Instance**: The Lean code `instance (x : UniformSpaceCat) : UniformSpace x := sorry` declares an instance of the `UniformSpace` typeclass for any object `x` in `UniformSpaceCat`. The `:= sorry` part is a placeholder indicating that the actual construction of the uniform structure is not provided here, but it asserts the existence of such a structure.\n\n5. **Importing Necessary Libraries**: The line `import Mathlib` ensures that all necessary definitions and theorems related to category theory and uniform spaces are available. The `open CategoryTheory` line makes the definitions and notations from the category theory module directly accessible.\n\nIn summary, the Lean code formalizes the informal statement by declaring that for any object in the category of uniform spaces, there is an instance of the uniform space structure, aligning with the notion of a canonical uniform structure."}
{"source_file": "herald_data/sample_500.jsonl", "line": 72, "id": 240178, "informal_statement": "For any commutative ring \\(S\\), natural number \\(m\\), Dirichlet character \\(\\psi\\) of modulus \\(m\\) over \\(S\\), and element \\(x\\) in \\(\\mathbb{Z}/m\\mathbb{Z}\\) such that \\(\\psi(-1) = -1\\), show that \\(\\psi(-x) = -\\psi(x)\\).", "formal_statement": "import Mathlib\nopen MulChar\nlemma eval_neg_tac_12543 [CommRing S] (m : ℕ) (ψ : DirichletCharacter S m) (x : ZMod m) (hψ : ψ (-1) = -1) : ψ (-x) = -ψ x := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**:\n   - The statement involves a commutative ring \\(S\\), a natural number \\(m\\), a Dirichlet character \\(\\psi\\) of modulus \\(m\\) over \\(S\\), and an element \\(x\\) in \\(\\mathbb{Z}/m\\mathbb{Z}\\).\n   - The condition \\(\\psi(-1) = -1\\) is given, and we need to show that \\(\\psi(-x) = -\\psi(x)\\).\n\n2. **Translate the Mathematical Structures to Lean**:\n   - **Commutative Ring \\(S\\)**: In Lean, a commutative ring is represented by the type class `CommRing S`.\n   - **Natural Number \\(m\\)**: This is directly represented as `m : ℕ` in Lean.\n   - **Dirichlet Character \\(\\psi\\)**: In Lean, Dirichlet characters are represented by the type `DirichletCharacter S m`, where `S` is the ring and `m` is the modulus.\n   - **Element \\(x\\) in \\(\\mathbb{Z}/m\\mathbb{Z}\\)**: This is represented by `x : ZMod m` in Lean, where `ZMod m` is the type for integers modulo \\(m\\).\n\n3. **Express the Given Condition**:\n   - The condition \\(\\psi(-1) = -1\\) is expressed in Lean as `hψ : ψ (-1) = -1`. Here, `hψ` is a hypothesis that captures this condition.\n\n4. **State the Goal**:\n   - The goal is to show \\(\\psi(-x) = -\\psi(x)\\). In Lean, this is written as `ψ (-x) = -ψ x`.\n\n5. **Construct the Lean Lemma**:\n   - The lemma is named `eval_neg_tac_12543`, which is a unique identifier for this particular result.\n   - The lemma is stated with the necessary parameters: `[CommRing S]` for the commutative ring, `(m : ℕ)` for the modulus, `(ψ : DirichletCharacter S m)` for the Dirichlet character, `(x : ZMod m)` for the element in \\(\\math"}
{"source_file": "herald_data/sample_500.jsonl", "line": 73, "id": 33662, "informal_statement": "For a function \\( f \\) defined on the closed interval \\([a, b]\\) in an ordered type and any \\( x \\) such that \\( b \\leq x \\), show that the extension of \\( f \\) to the point \\( x \\), denoted by \\( IccExtend \\), evaluated at \\( x \\) is equal to \\( f \\) evaluated at \\( b \\), i.e., \\( IccExtend h f x = f(b) \\), where \\( h \\) is a proof of \\( b \\leq x \\).", "formal_statement": "import Mathlib\nopen Function\ntheorem IccExtend_of_right_le_extracted [LinearOrder α] {a b : α} (h : a ≤ b) {x : α} (f : ↑(Icc a b) → β) :\n b ≤ x → IccExtend h f x = f ⟨b, ⋯⟩ := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Understand the Context and Definitions**:\n   - We are dealing with a function \\( f \\) defined on a closed interval \\([a, b]\\) in an ordered type. This means \\( f \\) is a function from the interval \\([a, b]\\) to some type \\(\\beta\\).\n   - The function \\( IccExtend \\) is used to extend \\( f \\) beyond its original domain \\([a, b]\\) to the entire type \\(\\alpha\\), where \\(\\alpha\\) is an ordered type.\n\n2. **Identify the Types and Parameters**:\n   - The type \\(\\alpha\\) is a `LinearOrder`, which means it is a totally ordered set.\n   - The interval \\([a, b]\\) is represented as `Icc a b`, which is the set of elements \\( x \\) such that \\( a \\leq x \\leq b \\).\n   - The function \\( f \\) is defined on `↑(Icc a b)`, which is the coercion of the interval to a subtype of \\(\\alpha\\).\n\n3. **Formalize the Hypotheses**:\n   - We have a hypothesis \\( h : a \\leq b \\), which is necessary for defining the interval \\([a, b]\\).\n   - We also have a condition \\( b \\leq x \\), which is another hypothesis in the theorem.\n\n4. **Formalize the Conclusion**:\n   - The conclusion is that \\( IccExtend h f x = f(b) \\) when \\( b \\leq x \\).\n   - In Lean, `IccExtend h f x` extends the function \\( f \\) to the entire type \\(\\alpha\\) using the proof \\( h \\) that \\( a \\leq b \\).\n\n5. **Construct the Lean Theorem**:\n   - We start by importing necessary modules, such as `Mathlib`, which contains the definitions and theorems we need.\n   - We open the `Function` namespace to access `IccExtend`.\n   - We define the theorem `IccExtend_of_right_le_extracted` with the appropriate type parameters and hypotheses.\n   - The theorem states that given a linear order on \\(\\alpha\\), and a function \\( f \\) from `↑(Icc"}
{"source_file": "herald_data/sample_500.jsonl", "line": 78, "id": 221235, "informal_statement": "For any commutative semiring \\(R\\) and any element \\(a \\in R\\), given that the coercion of the monomial of degree 0 with coefficient \\(a\\) to the power series over \\(R\\) is equal to the constant power series with value \\(a\\), show that the coercion of the constant polynomial \\(C a\\) to the power series over \\(R\\) is also equal to the constant power series with value \\(a\\).", "formal_statement": "import Mathlib\nopen Finset (antidiagonal mem_antidiagonal)\nopen Finsupp (single)\nopen Finset Nat\nopen Finset.HasAntidiagonal Finset\nopen Finsupp Polynomial\nlemma coe_C_tac_26528 [CommSemiring R] (a : R) (this : ↑((monomial 0) a) = (PowerSeries.C R) a) : ↑(C a) = (PowerSeries.C R) a := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: \n   - The statement involves a commutative semiring \\( R \\), elements \\( a \\in R \\), monomials, polynomials, and power series. In Lean, these structures are represented using type classes and specific types.\n\n2. **Understand the Context**:\n   - The context is set in a commutative semiring, which is represented by `[CommSemiring R]` in Lean. This indicates that \\( R \\) is a type that satisfies the axioms of a commutative semiring.\n\n3. **Translate Elements and Operations**:\n   - The element \\( a \\in R \\) is directly translated as `(a : R)`.\n   - The coercion of the monomial of degree 0 with coefficient \\( a \\) is expressed as `↑((monomial 0) a)`. Here, `monomial 0 a` constructs a polynomial with \\( a \\) as the coefficient of \\( x^0 \\), and `↑` denotes coercion from polynomials to power series.\n\n4. **Express the Given Condition**:\n   - The condition that this coercion equals the constant power series with value \\( a \\) is written as `↑((monomial 0) a) = (PowerSeries.C R) a`. `PowerSeries.C R a` constructs a constant power series with value \\( a \\).\n\n5. **State the Goal**:\n   - The goal is to show that the coercion of the constant polynomial \\( C a \\) to the power series is also equal to the constant power series with value \\( a \\). This is expressed as `↑(C a) = (PowerSeries.C R) a`. Here, `C a` represents the constant polynomial with value \\( a \\).\n\n6. **Structure the Lemma**:\n   - The lemma is structured with the hypothesis `this : ↑((monomial 0) a) = (PowerSeries.C R) a` and the goal `↑(C a) = (PowerSeries.C R) a`. The `sorry` indicates that the proof is not provided.\n\n7. **Import Necessary Modules**:\n   - The imports at the beginning (`import Mathlib`) and the `open` statements bring necessary definitions and notations into scope, such as `monomial`, `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 80, "id": 222959, "informal_statement": "For a commutative ring $R$, a prime ideal $P$ in $R$ that is also a Dedekind domain, an element $x \\in R$ such that $x \\in P$, $x \\notin P^2$, and for all prime ideals $Q \\neq P$ in $R$, $x \\notin Q$, and given that $x \\neq 0$, $P \\neq \\{0\\}$, and $\\langle x \\rangle \\neq \\{0\\}$, show that $P = \\langle x \\rangle$.", "formal_statement": "import Mathlib\nopen Ideal\nopen UniqueFactorizationMonoid\nopen scoped nonZeroDivisors\nopen UniqueFactorizationMonoid\nlemma eq_span_singleton_of_mem_of_not_mem_sq_of_not_mem_prime_ne_tac_1634 [CommRing R] (P : Ideal R) (hP : P.IsPrime) [IsDedekindDomain R] (x : R) (x_mem : x ∈ P) (hxP2 : x ∉ P ^ 2) (hxQ : ∀ (Q : Ideal R), Q.IsPrime → Q ≠ P → x ∉ Q) (this : DecidableEq (Ideal R)) (hx0 : x ≠ 0) (hP0 : ¬P = ⊥) (hspan0 : span {x} ≠ ⊥) : P = span {x} := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and map it to its corresponding Lean constructs. Here's the step-by-step explanation:\n\n1. **Commutative Ring \\( R \\):**\n   - In Lean, a commutative ring is represented by the type class `CommRing R`. This is specified in the lemma by `[CommRing R]`.\n\n2. **Prime Ideal \\( P \\) in \\( R \\):**\n   - An ideal in Lean is represented by `Ideal R`. The property of being a prime ideal is captured by `P.IsPrime`. Thus, `P : Ideal R` and `hP : P.IsPrime` are used to denote that \\( P \\) is a prime ideal.\n\n3. **Dedekind Domain:**\n   - The statement specifies that \\( R \\) is a Dedekind domain. In Lean, this is represented by the type class `[IsDedekindDomain R]`.\n\n4. **Element \\( x \\in R \\):**\n   - The element \\( x \\) is simply a variable of type \\( R \\), denoted as `x : R`.\n\n5. **Conditions on \\( x \\):**\n   - \\( x \\in P \\): This is expressed as `x_mem : x ∈ P`.\n   - \\( x \\notin P^2 \\): This is expressed as `hxP2 : x ∉ P ^ 2`.\n   - For all prime ideals \\( Q \\neq P \\), \\( x \\notin Q \\): This is expressed as `hxQ : ∀ (Q : Ideal R), Q.IsPrime → Q ≠ P → x ∉ Q`.\n\n6. **Non-zero conditions:**\n   - \\( x \\neq 0 \\): This is expressed as `hx0 : x ≠ 0`.\n   - \\( P \\neq \\{0\\} \\): This is expressed as `hP0 : ¬P = ⊥`.\n   - \\(\\langle x \\rangle \\neq \\{0\\}\\): This is expressed as `hspan0 : span {x} ≠ ⊥`.\n\n7. **Conclusion:**\n   - The goal is to show that \\( P = \\langle x \\rangle \\). In Lean, this is the conclusion of the lemma: `P = span {x}`.\n\n8"}
{"source_file": "herald_data/sample_500.jsonl", "line": 75, "id": 430743, "informal_statement": "For any positive natural numbers $k$, $m$, and $n$, if $k$ is coprime to both $m$ and $n$, then $k$ is coprime to $m \\times n$.", "formal_statement": "import Mathlib\nopen Nat\ntheorem Coprime.mul {k m n : ℕ+} : m.Coprime k → n.Coprime k → (m * n).Coprime k := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Domain and Variables**: The informal statement involves positive natural numbers $k$, $m$, and $n$. In Lean, positive natural numbers are represented by the type `ℕ+`, which ensures that the numbers are positive.\n\n2. **Structure of the Theorem**: The statement is a conditional one, starting with \"For any positive natural numbers $k$, $m$, and $n$,\" which suggests a universal quantification over these variables. In Lean, this is expressed by introducing these variables as part of the theorem's signature: `{k m n : ℕ+}`.\n\n3. **Coprime Condition**: The informal statement involves the concept of being \"coprime.\" In Lean, this is represented by the `Coprime` predicate. The statement \"if $k$ is coprime to both $m$ and $n$\" translates to two hypotheses: `m.Coprime k` and `n.Coprime k`. These are the assumptions of the theorem.\n\n4. **Conclusion of the Theorem**: The conclusion \"then $k$ is coprime to $m \\times n$\" translates to the statement `(m * n).Coprime k`. This is the result we want to prove under the given assumptions.\n\n5. **Theorem Declaration**: The theorem is declared using the `theorem` keyword in Lean, followed by a name for the theorem, in this case, `Coprime.mul`. The name is chosen to reflect the operation involved (multiplication) and the property (coprimeness).\n\n6. **Combining Everything**: The full formal statement in Lean is:\n   ```lean\n   theorem Coprime.mul {k m n : ℕ+} : m.Coprime k → n.Coprime k → (m * n).Coprime k := sorry\n   ```\n   Here, `{k m n : ℕ+}` introduces the positive natural numbers, `m.Coprime k → n.Coprime k` are the assumptions, and `(m * n).Coprime k` is the conclusion. The `:= sorry` part indicates that the proof is not provided, which is common in theorem statements when focusing on the translation rather than the proof itself.\n\n7. **Importing Necessary Libraries**:"}
{"source_file": "herald_data/sample_500.jsonl", "line": 76, "id": 280750, "informal_statement": "For any nonempty set $\\iota$, seminorm family $p$ over a $\\mathbb{K}$-module $E$ where $\\mathbb{K}$ is a normed field, a finite subset $s$ of $\\iota$, a positive real number $r$, and given that the open ball of radius $r$ centered at $0$ under the supremum seminorm $s \\mapsto p$ is in the basis of sets defined by $p$, show that the identity map on this open ball is in the infimum over $i$ of the preimages under $p_i$ of the neighborhoods of $0$ in $E$.", "formal_statement": "import Mathlib\nopen NormedField Set Seminorm TopologicalSpace Filter List\nopen NNReal Pointwise Topology Uniformity\nlemma filter_eq_iInf_tac_7946 [NormedField 𝕜] [AddCommGroup E] [Module 𝕜 E] [Nonempty ι] (p : SeminormFamily 𝕜 E ι) (s : Finset ι) (r : ℝ) (hr : 0 < r) (hU : (s.sup p).ball 0 r ∈ p.basisSets) : id ((s.sup p).ball 0 r) ∈ ⨅ i, comap (⇑(p i)) (𝓝 0) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it corresponds to the Lean4 constructs:\n\n1. **Nonempty Set $\\iota$**: \n   - In Lean, a nonempty set is often represented by a type with a `Nonempty` instance. Here, `ι` is a type that is assumed to be nonempty, which is indicated by `[Nonempty ι]`.\n\n2. **Seminorm Family $p$ over a $\\mathbb{K}$-module $E$**:\n   - A seminorm family is a collection of seminorms indexed by a set. In Lean, this is represented by `SeminormFamily 𝕜 E ι`, where `𝕜` is the field, `E` is the module, and `ι` is the index set.\n\n3. **$\\mathbb{K}$ is a Normed Field**:\n   - This is indicated by the typeclass `[NormedField 𝕜]`, which ensures that `𝕜` is a field equipped with a norm.\n\n4. **Finite Subset $s$ of $\\iota$**:\n   - In Lean, a finite subset of a type is represented by `Finset ι`, where `s` is a finite set of indices from `ι`.\n\n5. **Positive Real Number $r$**:\n   - The positive real number is represented by `r : ℝ` with the condition `hr : 0 < r` ensuring that `r` is positive.\n\n6. **Open Ball of Radius $r$ Centered at $0$ under the Supremum Seminorm**:\n   - The supremum seminorm over a finite set `s` is given by `s.sup p`, and the open ball of radius `r` centered at `0` is `(s.sup p).ball 0 r`.\n\n7. **Basis of Sets Defined by $p$**:\n   - The condition that this ball is in the basis of sets defined by `p` is expressed as `(s.sup p).ball 0 r ∈ p.basisSets`.\n\n8. **Identity Map on this Open Ball**:\n   - The identity map on a set `A` is simply `id A` in Lean.\n\n9. **Infimum over $i$ of the Preimages under"}
{"source_file": "herald_data/sample_500.jsonl", "line": 81, "id": 534606, "informal_statement": "Let $u=\\tan\\alpha$ and $v=\\tan\\beta$ , where $\\alpha,\\beta\\in\\left(-\\frac{\\pi}{2},\\frac{\\pi}{2}\\right)$ . Then, the inequality $100|u-v|\\cdot|1- v|\\le (1+u^2)(1+v^2)$ is equivalent to", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_534606 (u v : ℝ) (ha : u = Real.tan α ∧ α ∈ Set.Ioo (-Real.pi / 2) (Real.pi / 2)) (hb : v = Real.tan β ∧ β ∈ Set.Ioo (-Real.pi / 2) (Real.pi / 2)) :\n  100 * abs (u - v) * abs (1 - v) ≤ (1 + u^2) * (1 + v^2)   :=  by sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the mathematical concepts and their constraints. Here's a step-by-step explanation of the translation process:\n\n1. **Identify Variables and Their Definitions:**\n   - The informal statement introduces two variables, \\( u \\) and \\( v \\), defined as \\( u = \\tan \\alpha \\) and \\( v = \\tan \\beta \\).\n   - The angles \\(\\alpha\\) and \\(\\beta\\) are constrained to the interval \\(\\left(-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\right)\\).\n\n2. **Translate the Domain Constraints:**\n   - In Lean, the interval \\(\\left(-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\right)\\) is represented using the `Set.Ioo` type, which denotes an open interval.\n   - The constraints \\(\\alpha \\in \\left(-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\right)\\) and \\(\\beta \\in \\left(-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\right)\\) are translated to `α ∈ Set.Ioo (-Real.pi / 2) (Real.pi / 2)` and `β ∈ Set.Ioo (-Real.pi / 2) (Real.pi / 2)` respectively.\n\n3. **Express the Main Inequality:**\n   - The inequality \\(100|u-v|\\cdot|1-v|\\le (1+u^2)(1+v^2)\\) is directly translated into Lean using the `abs` function for absolute values and standard arithmetic operations.\n   - The expression becomes `100 * abs (u - v) * abs (1 - v) ≤ (1 + u^2) * (1 + v^2)`.\n\n4. **Structure the Theorem:**\n   - The theorem is named `extract_aug_534606`, which is a placeholder name and can be replaced with a more descriptive one.\n   - The theorem takes \\( u \\) and \\( v \\) as real numbers (`ℝ`), and the conditions on \\( u \\) and \\( v \\) are provided as hypotheses `ha` and `hb`.\n   - `ha` asserts that \\( u = \\tan \\alpha \\) and \\(\\alpha\\) is within the specified interval."}
{"source_file": "herald_data/sample_500.jsonl", "line": 77, "id": 69406, "informal_statement": "For any ring automorphism \\( g \\) of \\( L \\) and any \\( t \\in L^\\times \\) that is an \\( n \\)-th root of unity in \\( L \\), show that \\( g(t) = t^{(\\chi(g))} \\) where \\( \\chi(g) \\) is the value of the modular cyclotomic character of \\( L \\) evaluated at \\( g \\), considered as an element of \\( \\mathbb{Z}/n\\mathbb{Z} \\).", "formal_statement": "import Mathlib\n\ntheorem spec_extracted (L : Type u) [CommRing L] [IsDomain L] {n : ℕ+} (hn : Fintype.card ↥(rootsOfUnity n L) = ↑n)\n (g : L ≃+* L) {t : Lˣ} : t ∈ rootsOfUnity n L → g ↑t = ↑t ^ (↑((ModularCyclotomicCharacter L hn) g)).val := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to break down each component of the statement and map it to the corresponding Lean constructs. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context**:\n   - We are dealing with a ring \\( L \\) and its automorphisms. In Lean, this is represented by a type `L` with a `CommRing` structure and an `IsDomain` property, ensuring \\( L \\) is a commutative ring without zero divisors.\n\n2. **Roots of Unity**:\n   - The informal statement involves \\( t \\in L^\\times \\) that is an \\( n \\)-th root of unity. In Lean, `Lˣ` denotes the units of \\( L \\), and `rootsOfUnity n L` represents the set of \\( n \\)-th roots of unity in \\( L \\).\n\n3. **Automorphisms**:\n   - The automorphism \\( g \\) is a ring automorphism of \\( L \\). In Lean, this is represented by `L ≃+* L`, which denotes a ring isomorphism from \\( L \\) to itself.\n\n4. **Cyclotomic Character**:\n   - The cyclotomic character \\( \\chi(g) \\) is a map from the automorphisms of \\( L \\) to the group \\( \\mathbb{Z}/n\\mathbb{Z} \\). In Lean, this is represented by `ModularCyclotomicCharacter L hn`, where `hn` is a hypothesis ensuring the cardinality of the roots of unity is \\( n \\).\n\n5. **Formalizing the Hypotheses**:\n   - The hypothesis `hn : Fintype.card ↥(rootsOfUnity n L) = ↑n` ensures that the number of \\( n \\)-th roots of unity in \\( L \\) is exactly \\( n \\), which is crucial for defining the cyclotomic character.\n\n6. **Formalizing the Conclusion**:\n   - The conclusion \\( g(t) = t^{(\\chi(g))} \\) is expressed in Lean as `g ↑t = ↑t ^ (↑((ModularCyclotomicCharacter L hn) g)).val`. Here, `↑t` lifts the unit \\( t \\) to the ring \\( L \\), and `↑((ModularCyclotomicCharacter L hn) g)).val` computes the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 79, "id": 330007, "informal_statement": "For any natural numbers $n$ and $p$, prove that $p^{\\text{maxPowDiv}_p(n)} \\mid n$, where $\\text{maxPowDiv}_p(n)$ is the highest power of $p$ that divides $n$.", "formal_statement": "import Mathlib\nopen Nat\ntheorem pow_dvd (p n : ℕ) : p ^ (p.maxPowDiv n) ∣ n := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down the components of the statement and understand how they map to Lean's syntax and library functions.\n\n1. **Understanding the Informal Statement:**\n   - We are given two natural numbers, \\( n \\) and \\( p \\).\n   - The function \\(\\text{maxPowDiv}_p(n)\\) represents the highest power of \\( p \\) that divides \\( n \\).\n   - The goal is to prove that \\( p^{\\text{maxPowDiv}_p(n)} \\mid n \\), meaning that \\( p \\) raised to this power divides \\( n \\).\n\n2. **Mapping to Lean4:**\n   - **Natural Numbers:** In Lean, natural numbers are represented by the type `ℕ`.\n   - **Function maxPowDiv:** Lean provides a function `maxPowDiv` in the `Nat` namespace, which computes the highest power of a given number \\( p \\) that divides another number \\( n \\).\n   - **Exponentiation and Divisibility:** In Lean, exponentiation is denoted by `^`, and divisibility is denoted by `∣`.\n\n3. **Formalizing the Statement:**\n   - We start by importing the necessary library `Mathlib` to access the natural number operations and properties.\n   - We open the `Nat` namespace to use functions like `maxPowDiv` without prefixing them with `Nat.`.\n   - We define a theorem named `pow_dvd` that takes two natural numbers `p` and `n` as arguments.\n   - The statement `p ^ (p.maxPowDiv n) ∣ n` directly translates the informal statement into Lean's syntax, asserting that \\( p \\) raised to the power of `p.maxPowDiv n` divides `n`.\n\n4. **Structure of the Lean Code:**\n   - `import Mathlib`: This line imports the Mathlib library, which contains the necessary definitions and theorems for natural numbers.\n   - `open Nat`: This line allows us to use functions from the `Nat` namespace directly.\n   - `theorem pow_dvd (p n : ℕ) : p ^ (p.maxPowDiv n) ∣ n := sorry`: This line declares the theorem `pow_dvd`, specifying that for any natural numbers `p` and `n`, the statement `p ^ (p.maxPowDiv"}
{"source_file": "herald_data/sample_500.jsonl", "line": 83, "id": 492204, "informal_statement": "Prove that $\\frac{17}{8}(a^4+b^4+c^4+d^4-4abcd)\\geq(a+b+c+d)(a^3+b^3+c^3+d^3-abc-abd-acd-bcd)$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_492204 (a b c d : ℝ) : (17 / 8) * (a ^ 4 + b ^ 4 + c ^ 4 + d ^ 4 - 4 * a * b * c * d) ≥ (a + b + c + d) * (a ^ 3 + b ^ 3 + c ^ 3 + d ^ 3 - a * b * c - a * b * d - a * c * d - b * c * d)  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The variables \\(a\\), \\(b\\), \\(c\\), and \\(d\\) are real numbers. In Lean, real numbers are represented by `ℝ`.\n\n2. **Translate the Mathematical Expression**:\n   - The left-hand side of the inequality is \\(\\frac{17}{8}(a^4 + b^4 + c^4 + d^4 - 4abcd)\\). In Lean, division is represented by `/`, multiplication by `*`, and exponentiation by `^`. Thus, this expression becomes `(17 / 8) * (a ^ 4 + b ^ 4 + c ^ 4 + d ^ 4 - 4 * a * b * c * d)`.\n   - The right-hand side is \\((a+b+c+d)(a^3 + b^3 + c^3 + d^3 - abc - abd - acd - bcd)\\). In Lean, addition is represented by `+`, and the expression becomes `(a + b + c + d) * (a ^ 3 + b ^ 3 + c ^ 3 + d ^ 3 - a * b * c - a * b * d - a * c * d - b * c * d)`.\n\n3. **Formulate the Inequality**:\n   - The inequality is \\(\\geq\\), which is represented in Lean by `≥`.\n\n4. **Structure the Theorem**:\n   - The theorem is named `extract_aug_492204`. In Lean, a theorem is introduced with the `theorem` keyword, followed by its name.\n   - The variables \\(a\\), \\(b\\), \\(c\\), and \\(d\\) are declared as real numbers in the theorem signature: `(a b c d : ℝ)`.\n   - The statement of the theorem is the inequality we formulated: `(17 / 8) * (a ^ 4 + b ^ 4 + c ^ 4 + d ^ 4 - 4 * a * b * c * d) ≥ (a + b + c + d) * (a ^ 3 + b ^ 3 + c ^ 3 + d ^ 3 - a * b * c - a * b * d -"}
{"source_file": "herald_data/sample_500.jsonl", "line": 82, "id": 424264, "informal_statement": "Let $\\text{mkApps}: \\mathcal{E} \\times \\mathcal{E}^n \\to \\text{ACApps}$ be a function that takes an expression $op \\in \\mathcal{E}$ and an array of expressions $args = (a_1, a_2, \\ldots, a_n) \\in \\mathcal{E}^n$, and returns an $\\text{ACApps}$ object by applying $args$ to $op$.", "formal_statement": "import Mathlib\nopen Lean Meta Elab Tactic\n/-- Sorts `args` and applies them to `ACApps.apps`. -/\ndef ACApps.mkApps (op : Expr) (args : Array Expr) : ACApps := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Components**:\n   - The informal statement describes a function `mkApps` that operates on two inputs: an expression `op` and an array of expressions `args`.\n   - The output of this function is an `ACApps` object.\n\n2. **Lean4 Function Definition**:\n   - In Lean4, functions are defined using the `def` keyword. The function name follows immediately after `def`.\n   - In the formal statement, `def ACApps.mkApps` indicates that `mkApps` is a function within the `ACApps` namespace.\n\n3. **Function Parameters**:\n   - The parameters of the function are `(op : Expr)` and `(args : Array Expr)`.\n   - `Expr` is a type representing expressions in Lean, which corresponds to the informal set $\\mathcal{E}$.\n   - `Array Expr` represents an array of expressions, corresponding to $\\mathcal{E}^n$ in the informal statement.\n\n4. **Return Type**:\n   - The return type of the function is `ACApps`, which matches the informal description of the function returning an `ACApps` object.\n\n5. **Function Body**:\n   - The body of the function is currently `sorry`, which is a placeholder in Lean indicating that the implementation is not yet provided. This is common in Lean when the focus is on defining the structure rather than the implementation details.\n\n6. **Documentation Comment**:\n   - The comment `/- Sorts `args` and applies them to `ACApps.apps`. -/` provides a brief description of what the function is intended to do. It suggests that the function will sort the `args` and then apply them to some method or function `ACApps.apps`, although the exact implementation is not provided.\n\n7. **Imports and Namespace**:\n   - `import Mathlib` and `open Lean Meta Elab Tactic` are used to bring in necessary libraries and open namespaces that might be required for the function's implementation or for working with expressions and tactics in Lean.\n\nBy following these steps, the informal mathematical description is translated into a structured Lean4 function definition, capturing the essence of the operation described while adhering to Lean's syntax and type system."}
{"source_file": "herald_data/sample_500.jsonl", "line": 84, "id": 149815, "informal_statement": "For any natural numbers $x$ and $n$ such that $x$ and $n$ are coprime, show that $x$ raised to the power of Euler's totient function of $n$, $\\varphi(n)$, is congruent to $1$ modulo $n$, i.e., $x^{\\varphi(n)} \\equiv 1 \\ (\\text{mod} \\ n)$.", "formal_statement": "import Mathlib\nopen Finset\nopen scoped Polynomial\nopen Polynomial\nopen Polynomial\nopen Polynomial\nopen FiniteField Polynomial\nopen scoped Nat\nopen ZMod\nlemma pow_totient_tac_18358 (x : ℕ) (n : ℕ) (h : x.Coprime n) : ↑(x ^ φ n) = ↑1 := sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow these steps:\n\n1. **Understand the Informal Statement**: The statement is a version of Euler's theorem, which asserts that if two numbers \\( x \\) and \\( n \\) are coprime, then \\( x^{\\varphi(n)} \\equiv 1 \\ (\\text{mod} \\ n) \\), where \\(\\varphi(n)\\) is Euler's totient function.\n\n2. **Identify the Components**:\n   - **Variables**: \\( x \\) and \\( n \\) are natural numbers.\n   - **Condition**: \\( x \\) and \\( n \\) are coprime.\n   - **Conclusion**: \\( x^{\\varphi(n)} \\equiv 1 \\ (\\text{mod} \\ n) \\).\n\n3. **Translate Variables and Types**:\n   - In Lean, natural numbers are represented by `ℕ`.\n   - The coprimality condition is expressed using `Coprime`.\n\n4. **Formalize the Condition**:\n   - The condition \\( x \\) and \\( n \\) are coprime is written as `x.Coprime n` in Lean.\n\n5. **Formalize the Conclusion**:\n   - The conclusion \\( x^{\\varphi(n)} \\equiv 1 \\ (\\text{mod} \\ n) \\) is expressed using the equality of equivalence classes in the ring of integers modulo \\( n \\).\n   - In Lean, this is represented by `↑(x ^ φ n) = ↑1`, where `↑` denotes the coercion from natural numbers to the integers modulo \\( n \\).\n\n6. **Structure the Lemma**:\n   - The lemma is named `pow_totient_tac_18358`.\n   - It takes three arguments: `x` and `n` of type `ℕ`, and a proof `h` that `x` and `n` are coprime.\n   - The conclusion is the equality `↑(x ^ φ n) = ↑1`.\n\n7. **Use of Libraries**:\n   - The code imports necessary libraries such as `Mathlib`, `FiniteField`, and `ZMod` to handle modular arithmetic and number-theoretic functions like Euler's totient function.\n\n8. **Placeholder for Proof**:\n   - The `:= sorry` at the end indicates that the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 85, "id": 277750, "informal_statement": "For any \\(RCLike\\) field \\(\\mathbb{k}\\), and any normed additive commutative group \\(E\\) which is also an inner product space over \\(\\mathbb{k}\\), let \\(K\\) be a submodule of \\(E\\), \\(x, y, u \\in E\\) with \\(u \\in K\\). If for all \\(v \\in K\\), \\(\\langle v, x \\rangle_{\\mathbb{k}} = \\langle v, y \\rangle_{\\mathbb{k}}\\), then show that \\(\\langle u, x \\rangle_{\\mathbb{k}} = \\langle u, y \\rangle_{\\mathbb{k}}\\).", "formal_statement": "import Mathlib\n\nlemma sub_mem_orthogonal_of_inner_right_tac_3272 [RCLike 𝕜] [NormedAddCommGroup E] [InnerProductSpace 𝕜 E] (K : Submodule 𝕜 E) (x : E) (y : E) (h : ∀ (v : ↥K), ⟪↑v, x⟫_𝕜 = ⟪↑v, y⟫_𝕜) (u : E) (hu : u ∈ K) : ⟪u, x⟫_𝕜 = ⟪u, y⟫_𝕜 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a structured approach that maps each component of the informal statement to its formal counterpart in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Context and Imports**:\n   - The informal statement involves concepts from linear algebra and inner product spaces. In Lean, these are handled by importing relevant libraries. The line `import Mathlib` suggests that we are using the Mathlib library, which contains definitions and theorems for these mathematical structures.\n\n2. **Defining the Field and Space**:\n   - The informal statement begins with \"For any \\(RCLike\\) field \\(\\mathbb{k}\\)\". In Lean, this is represented by `[RCLike 𝕜]`, where `𝕜` is a type variable representing the field.\n   - Next, \"any normed additive commutative group \\(E\\) which is also an inner product space over \\(\\mathbb{k}\\)\" is formalized as `[NormedAddCommGroup E] [InnerProductSpace 𝕜 E]`. This indicates that `E` is both a normed additive commutative group and an inner product space over the field `𝕜`.\n\n3. **Defining the Submodule**:\n   - The informal statement introduces a submodule \\(K\\) of \\(E\\). In Lean, this is represented by `(K : Submodule 𝕜 E)`, where `K` is a submodule of the vector space `E` over the field `𝕜`.\n\n4. **Introducing Elements and Conditions**:\n   - The elements \\(x, y, u \\in E\\) are directly translated to `(x : E) (y : E) (u : E)`.\n   - The condition \\(u \\in K\\) is represented by `(hu : u ∈ K)`, where `hu` is a hypothesis that `u` is an element of the submodule `K`.\n\n5. **Stating the Hypothesis**:\n   - The hypothesis \"If for all \\(v \\in K\\), \\(\\langle v, x \\rangle_{\\mathbb{k}} = \\langle v, y \\rangle_{\\mathbb{k}}\\)\" is formalized as `(h : ∀ (v : ↥K), ⟪↑v, x⟫_"}
{"source_file": "herald_data/sample_500.jsonl", "line": 88, "id": 576317, "informal_statement": "Given \\\\(\\\\frac{x}{y} = k-1 \\\\implies x = (k-1)y\\\\), find \\\\(ky\\\\) from the derived equation: \\\\(\\\\frac{\\\\sqrt{7} +\\\\sqrt{24(k-1)}}{\\\\sqrt{7}-\\\\sqrt{24(k-1)}} = \\\\frac{ky}{1}\\\\)", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_576317 (x y k : ℝ) (h₁ : x / y = k - 1) (h₂ : 0 < k) : (Real.sqrt 7 + Real.sqrt (24 * (k - 1))) / (Real.sqrt 7 - Real.sqrt (24 * (k - 1))) = k * y / 1   :=  by sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach:\n\n1. **Identify Variables and Types**: \n   - The variables involved are \\(x\\), \\(y\\), and \\(k\\), which are real numbers. In Lean, these are represented as `ℝ`.\n\n2. **Understand the Given Conditions**:\n   - The condition \\( \\frac{x}{y} = k - 1 \\) is translated to `x / y = k - 1`. This is a hypothesis in the theorem, represented as `h₁ : x / y = k - 1`.\n   - The condition \\( 0 < k \\) is another hypothesis, represented as `h₂ : 0 < k`.\n\n3. **Translate the Derived Equation**:\n   - The derived equation is \\( \\frac{\\sqrt{7} + \\sqrt{24(k-1)}}{\\sqrt{7} - \\sqrt{24(k-1)}} = \\frac{ky}{1} \\).\n   - In Lean, the square root function is `Real.sqrt`, so \\( \\sqrt{7} \\) becomes `Real.sqrt 7`.\n   - The expression \\( \\sqrt{24(k-1)} \\) becomes `Real.sqrt (24 * (k - 1))`.\n   - The left-hand side of the equation is thus `(Real.sqrt 7 + Real.sqrt (24 * (k - 1))) / (Real.sqrt 7 - Real.sqrt (24 * (k - 1)))`.\n   - The right-hand side \\( \\frac{ky}{1} \\) simplifies to `k * y / 1`, which is just `k * y`.\n\n4. **Formulate the Theorem**:\n   - The theorem is named `extract_aug_576317`, which is a unique identifier.\n   - The theorem takes the variables \\(x\\), \\(y\\), and \\(k\\) as inputs, along with the hypotheses `h₁` and `h₂`.\n   - The goal is to prove the equality of the derived equation, which is the main statement of the theorem.\n\n5. **Structure the Lean Code**:\n   - The `import Mathlib` statement is used to import necessary mathematical libraries.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to bring relevant mathematical operations and types into scope"}
{"source_file": "herald_data/sample_500.jsonl", "line": 87, "id": 258611, "informal_statement": "For any element \\( a, c, d \\) in a cancel monoid with zero, suppose \\( a = a \\cdot c \\cdot d \\), \\( a \\neq 0 \\), \\( a \\cdot c \\neq 0 \\), and \\( c \\cdot d = 1 \\). Show that \\( a \\cdot c = a \\cdot c \\). Note: The conclusion is trivially true, but the statement verifies the conditions under which the equality holds.", "formal_statement": "import Mathlib\n\nlemma associated_of_dvd_dvd_tac_20616 [CancelMonoidWithZero α] (a : α) (c : α) (d : α) (a_eq : a = a * c * d) (ha0 : ¬a = 0) (hac0 : a * c ≠ 0) (this : a * (c * d) = a * 1) (hcd : c * d = 1) : a * c = a * c := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Structure**: The problem involves a \"cancel monoid with zero.\" In Lean, this is represented by the type class `CancelMonoidWithZero α`. This type class includes a set `α` equipped with a binary operation (multiplication), an identity element (1), and a zero element (0), along with the cancellation property for non-zero elements.\n\n2. **Declare Variables**: The elements \\( a, c, d \\) are elements of the cancel monoid with zero. In Lean, we declare these as variables of type `α`:\n   ```lean\n   (a : α) (c : α) (d : α)\n   ```\n\n3. **State the Hypotheses**: The informal statement provides several conditions:\n   - \\( a = a \\cdot c \\cdot d \\): This is translated to `a_eq : a = a * c * d`.\n   - \\( a \\neq 0 \\): This is translated to `ha0 : ¬a = 0`.\n   - \\( a \\cdot c \\neq 0 \\): This is translated to `hac0 : a * c ≠ 0`.\n   - \\( c \\cdot d = 1 \\): This is translated to `hcd : c * d = 1`.\n\n4. **Express the Conclusion**: The conclusion \\( a \\cdot c = a \\cdot c \\) is trivially true, as it is an identity. In Lean, this is simply stated as `a * c = a * c`.\n\n5. **Formulate the Lemma**: Combine all the above elements into a lemma. The lemma is a statement that, given the hypotheses, the conclusion holds. The lemma is named `associated_of_dvd_dvd_tac_20616`, and it is structured as follows:\n   ```lean\n   lemma associated_of_dvd_dvd_tac_20616 [CancelMonoidWithZero α] \n     (a : α) (c : α) (d : α) \n     (a_eq : a = a * c * d) \n     (ha0 : ¬a = 0) \n     (hac0 : a * c ≠ 0) \n     (this : a * (c * d) = a *"}
{"source_file": "herald_data/sample_500.jsonl", "line": 89, "id": 275508, "informal_statement": "For any lists \\( l_1 \\) and \\( l_2 \\) over elements of type \\( \\alpha \\), it holds that \\( l_1 \\) is equal to itself, i.e., \\( l_1 = l_1 \\).", "formal_statement": "import Mathlib\n\nlemma rdrop_append_length_tac_7733 (l₁ : List α) (l₂ : List α) : l₁ = l₁ := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we follow these steps:\n\n1. **Identify the Types and Variables**: The informal statement involves lists \\( l_1 \\) and \\( l_2 \\) over elements of type \\( \\alpha \\). In Lean, lists are represented by `List α`, where `α` is a type variable representing the type of elements in the list.\n\n2. **Define the Context**: The statement is universally quantified over lists \\( l_1 \\) and \\( l_2 \\). In Lean, this is expressed by introducing these lists as parameters to a lemma. The parameters are `(l₁ : List α)` and `(l₂ : List α)`, where `l₁` and `l₂` are the Lean variables corresponding to the informal \\( l_1 \\) and \\( l_2 \\).\n\n3. **State the Proposition**: The proposition to be proven is that \\( l_1 = l_1 \\). In Lean, equality is expressed using `=`, so the proposition becomes `l₁ = l₁`.\n\n4. **Structure the Lemma**: In Lean, a lemma is a way to state and prove a proposition. The lemma is named `rdrop_append_length_tac_7733`, which is an arbitrary identifier. The lemma takes the lists `l₁` and `l₂` as arguments and asserts the proposition `l₁ = l₁`.\n\n5. **Use the `sorry` Placeholder**: The `sorry` keyword is used in Lean to indicate that the proof is omitted or not yet provided. It acts as a placeholder, allowing the lemma to be syntactically correct without providing a proof.\n\n6. **Import Necessary Libraries**: The statement begins with `import Mathlib`, which is a common practice to include necessary mathematical libraries and utilities that might be used in the proof or other parts of the code.\n\nThe formal statement in Lean4 is thus structured to reflect the informal statement by defining a lemma with the appropriate parameters and proposition, using `sorry` to indicate the proof is not provided."}
{"source_file": "herald_data/sample_500.jsonl", "line": 91, "id": 428687, "informal_statement": "For all $n, m, m' \\in \\mathbb{N}$, $n \\oplus m = n \\oplus m' \\iff m = m'$.", "formal_statement": "import Mathlib\nopen Function\n@[simp]\ntheorem xor_right_inj {n m m' : ℕ} : n ^^^ m = n ^^^ m' ↔ m = m' := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: The informal statement involves natural numbers \\(\\mathbb{N}\\) and the bitwise XOR operation, denoted by \\(\\oplus\\). In Lean, natural numbers are represented by `ℕ`, and the bitwise XOR operation is represented by `^^^`.\n\n2. **Quantifiers and Variables**: The informal statement begins with \"For all \\(n, m, m' \\in \\mathbb{N}\\)\", which indicates a universal quantification over three natural number variables \\(n\\), \\(m\\), and \\(m'\\). In Lean, this is expressed by declaring these variables within the theorem statement using `{n m m' : ℕ}`.\n\n3. **Logical Equivalence**: The informal statement uses the logical equivalence symbol \\(\\iff\\), which is directly translated to `↔` in Lean. This symbol is used to express that the two sides of the equivalence are logically equivalent.\n\n4. **Theorem Statement**: The theorem is named `xor_right_inj`, which suggests it is about the injectivity of the XOR operation on the right side. The statement `n \\oplus m = n \\oplus m' \\iff m = m'` is translated to `n ^^^ m = n ^^^ m' ↔ m = m'`.\n\n5. **Annotations and Imports**: The `@[simp]` annotation is used to mark the theorem as a simplification rule, which can be used by Lean's simplifier to automatically simplify expressions involving XOR. The `import Mathlib` statement is necessary to access the mathematical library where the XOR operation and other necessary definitions are provided. The `open Function` statement is included to bring relevant function-related definitions and theorems into scope, although it is not directly used in this specific theorem.\n\n6. **Theorem Body**: The body of the theorem is marked with `:= sorry`, indicating that the proof is not provided. In a complete formalization, this would be replaced with a valid proof.\n\nBy following these steps, the informal mathematical statement is accurately translated into a formal Lean4 theorem."}
{"source_file": "herald_data/sample_500.jsonl", "line": 90, "id": 460272, "informal_statement": "Let $a$ , $b$ and $c$ be non-negative numbers such that $a+b+c=3$ . Prove that: $\\frac{1}{8+ab^2}+\\frac{1}{8+bc^2}+\\frac{1}{8+ca^2}\\geq\\frac{1}{3}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_460272 (a b c : ℝ) (ha : a ≥ 0) (hb : b ≥ 0) (hc : c ≥ 0) (hab : a + b + c = 3) : 1 / (8 + a * b ^ 2) + 1 / (8 + b * c ^ 2) + 1 / (8 + c * a ^ 2) ≥ 1 / 3  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to carefully map each component of the statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Variables Declaration**: \n   - The informal statement involves three non-negative numbers \\(a\\), \\(b\\), and \\(c\\). In Lean, these are declared as real numbers using `(a b c : ℝ)`. The type `ℝ` denotes real numbers in Lean.\n\n2. **Non-negativity Conditions**:\n   - The conditions \\(a \\geq 0\\), \\(b \\geq 0\\), and \\(c \\geq 0\\) are expressed using the hypotheses `(ha : a ≥ 0)`, `(hb : b ≥ 0)`, and `(hc : c ≥ 0)`. Each hypothesis is a statement that the corresponding variable is greater than or equal to zero.\n\n3. **Sum Condition**:\n   - The condition \\(a + b + c = 3\\) is represented by the hypothesis `(hab : a + b + c = 3)`. This directly translates the sum condition into Lean syntax.\n\n4. **Inequality to Prove**:\n   - The goal is to prove the inequality \\(\\frac{1}{8+ab^2}+\\frac{1}{8+bc^2}+\\frac{1}{8+ca^2}\\geq\\frac{1}{3}\\). In Lean, this is expressed as `1 / (8 + a * b ^ 2) + 1 / (8 + b * c ^ 2) + 1 / (8 + c * a ^ 2) ≥ 1 / 3`.\n   - The division is represented by `/`, and the power operation \\(b^2\\) is represented by `b ^ 2`.\n\n5. **Theorem Declaration**:\n   - The entire statement is encapsulated in a theorem named `extract_aug_460272`. The theorem takes the variables and conditions as inputs and asserts the inequality as the conclusion.\n\n6. **Imports and Namespace**:\n   - The line `import Mathlib` is used to import necessary mathematical libraries that provide definitions and theorems for real numbers and inequalities.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to bring relevant definitions and notations"}
{"source_file": "herald_data/sample_500.jsonl", "line": 92, "id": 385052, "informal_statement": "For any $z \\in \\mathbb{H}$, show that $T \\cdot z = z + 1$.", "formal_statement": "import Mathlib\nopen Matrix Matrix.SpecialLinearGroup\nopen scoped MatrixGroups\nopen UpperHalfPlane\nopen Lean Meta Qq\ntheorem modular_T_smul (z : ℍ) : ModularGroup.T • z = (1 : ℝ) +ᵥ z := sorry", "explanation": "To translate the informal statement \"For any \\( z \\in \\mathbb{H} \\), show that \\( T \\cdot z = z + 1 \\)\" into the formal Lean4 statement, we need to understand both the mathematical context and the Lean syntax.\n\n1. **Understanding the Mathematical Context:**\n   - \\( \\mathbb{H} \\) denotes the upper half-plane, which is a common setting in complex analysis and modular forms. In Lean, this is represented by `ℍ`.\n   - The transformation \\( T \\cdot z = z + 1 \\) is a specific action of the modular group on the upper half-plane. The modular group is often represented by matrices, and \\( T \\) is typically the matrix \\(\\begin{pmatrix} 1 & 1 \\\\ 0 & 1 \\end{pmatrix}\\).\n   - The operation \\( \\cdot \\) in the informal statement corresponds to the group action, which in Lean is denoted by `•`.\n\n2. **Lean4 Syntax and Libraries:**\n   - The Lean code imports necessary libraries with `import Mathlib`, which provides access to mathematical structures and operations.\n   - `open Matrix Matrix.SpecialLinearGroup` and `open scoped MatrixGroups` are used to bring matrix-related definitions and operations into scope, particularly those related to the special linear group and modular group actions.\n   - `open UpperHalfPlane` is used to access definitions related to the upper half-plane, denoted by `ℍ` in Lean.\n\n3. **Formalizing the Statement:**\n   - The theorem is named `modular_T_smul`, indicating it concerns the action (smul) of the modular transformation \\( T \\).\n   - The parameter `(z : ℍ)` specifies that \\( z \\) is an element of the upper half-plane.\n   - The expression `ModularGroup.T • z` represents the action of the modular group element \\( T \\) on \\( z \\). In Lean, `ModularGroup.T` refers to the specific transformation matrix \\(\\begin{pmatrix} 1 & 1 \\\\ 0 & 1 \\end{pmatrix}\\).\n   - The right-hand side `(1 : ℝ) +ᵥ z` uses `+ᵥ`, which denotes vector addition in Lean. Here, it represents adding the real number 1 to the complex number \\( z \\).\n\n4. **Conclusion"}
{"source_file": "herald_data/sample_500.jsonl", "line": 94, "id": 145055, "informal_statement": "For any semigroup \\(S\\) and elements \\(p, q \\in S\\) such that \\(p\\) and \\(q\\) commute, and assuming \\(p\\) and \\(q\\) are idempotent elements, prove that \\(p \\cdot (q \\cdot p \\cdot q) = p \\cdot q\\).", "formal_statement": "import Mathlib\n\nlemma mul_of_commute_tac_1557 [Semigroup S] (p : S) (q : S) (h : Commute p q) (h₁ : IsIdempotentElem p) (h₂ : IsIdempotentElem q) : p * (q * p * q) = p * q := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: \n   - The statement involves a semigroup \\(S\\), which is a set equipped with an associative binary operation. In Lean, this is represented by the typeclass `Semigroup S`.\n\n2. **Define the Elements and Properties**:\n   - We have elements \\(p\\) and \\(q\\) in the semigroup \\(S\\). These are represented as variables of type \\(S\\) in Lean: `(p : S)` and `(q : S)`.\n   - The elements \\(p\\) and \\(q\\) are said to commute, meaning \\(p \\cdot q = q \\cdot p\\). This is captured by the `Commute` predicate in Lean: `(h : Commute p q)`.\n   - Both \\(p\\) and \\(q\\) are idempotent, meaning \\(p \\cdot p = p\\) and \\(q \\cdot q = q\\). This is expressed using the `IsIdempotentElem` predicate in Lean: `(h₁ : IsIdempotentElem p)` and `(h₂ : IsIdempotentElem q)`.\n\n3. **State the Goal**:\n   - The goal is to prove that \\(p \\cdot (q \\cdot p \\cdot q) = p \\cdot q\\). This is directly translated into the conclusion of the lemma: `p * (q * p * q) = p * q`.\n\n4. **Structure the Lemma**:\n   - The lemma is defined using the `lemma` keyword in Lean, followed by a name for the lemma, `mul_of_commute_tac_1557`.\n   - The lemma takes as input the semigroup structure `[Semigroup S]`, the elements `p` and `q`, and the hypotheses `h`, `h₁`, and `h₂`.\n   - The conclusion of the lemma is the equality `p * (q * p * q) = p * q`.\n\n5. **Use of `sorry`**:\n   - The `sorry` keyword is used as a placeholder for the proof. It indicates that the proof is not yet provided but the statement is expected to be provable.\n\nBy following these steps, the informal statement is systematically translated into a formal Lean4 lemma,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 93, "id": 229978, "informal_statement": "For a measurable space $\\Omega$, a finite measure $\\mu$ on $\\Omega$, and a set $A$ in $\\Omega$, show that the measure of $A$ being zero is equivalent to itself, i.e., $\\mu(A) = 0 \\Leftrightarrow \\mu(A) = 0$.", "formal_statement": "import Mathlib\nopen MeasureTheory Set Filter BoundedContinuousFunction\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction\nlemma restrict_eq_zero_iff_tac_12418 [MeasurableSpace Ω] (μ : FiniteMeasure Ω) (A : Set Ω) : μ A = 0 ↔ μ A = 0 := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Components**: \n   - We have a measurable space $\\Omega$.\n   - A finite measure $\\mu$ on $\\Omega$.\n   - A set $A$ within the space $\\Omega$.\n   - The statement involves showing an equivalence: $\\mu(A) = 0 \\Leftrightarrow \\mu(A) = 0$.\n\n2. **Lean4 Imports and Setup**:\n   - We start by importing necessary modules from Lean's math library, specifically `Mathlib`, which includes tools for measure theory.\n   - We open relevant namespaces such as `MeasureTheory`, `Set`, and others to access definitions and theorems related to measures and sets.\n\n3. **Define the Context**:\n   - `[MeasurableSpace Ω]`: This declares that $\\Omega$ is a measurable space. In Lean, this is a type class constraint indicating that $\\Omega$ has a measurable space structure.\n   - `(μ : FiniteMeasure Ω)`: This specifies that $\\mu$ is a finite measure on the space $\\Omega$. In Lean, `FiniteMeasure Ω` is a type that represents measures which are finite on the entire space.\n\n4. **Define the Set**:\n   - `(A : Set Ω)`: This indicates that $A$ is a subset of $\\Omega$. In Lean, `Set Ω` is the type of subsets of $\\Omega`.\n\n5. **State the Lemma**:\n   - `lemma restrict_eq_zero_iff_tac_12418`: This is the name of the lemma. The name is arbitrary but should be descriptive or follow a naming convention.\n   - `μ A = 0 ↔ μ A = 0`: This is the formal statement of the lemma. It asserts that the measure of the set $A$ being zero is equivalent to itself, which is trivially true.\n\n6. **Proof Placeholder**:\n   - `:= sorry`: This is a placeholder for the proof. In Lean, `sorry` is used to indicate that the proof is omitted or not yet provided. The statement is trivially true, so the proof would be straightforward, but `sorry` is used here to focus on the translation of the statement itself.\n\nBy following these steps, we have successfully translated the informal statement into a formal Lean4 lemma, capturing the essence of the original mathematical assertion"}
{"source_file": "herald_data/sample_500.jsonl", "line": 97, "id": 95329, "informal_statement": "**Informal statement:**\nFor any element \\(x\\), the evaluation of the polynomial variable \\(X\\) at \\(x\\) is equal to \\(x\\), i.e., \\(X(x) = x\\).", "formal_statement": "import Mathlib\nopen Finset AddMonoidAlgebra\nopen Polynomial\ntheorem eval_X_extracted [Semiring R] {x : R} : eval x X = x := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to understand the components involved in both the informal and formal statements and how they correspond to each other.\n\n1. **Understanding the Informal Statement:**\n   - The statement is about evaluating a polynomial, specifically the polynomial variable \\(X\\), at any element \\(x\\).\n   - The polynomial variable \\(X\\) is a standard representation of the identity polynomial, which is simply \\(X\\) itself.\n   - The evaluation of this polynomial at any element \\(x\\) should yield \\(x\\).\n\n2. **Lean4 Components:**\n   - **`import Mathlib`**: This imports the Mathlib library, which contains the necessary definitions and theorems for working with polynomials and other algebraic structures.\n   - **`open Finset AddMonoidAlgebra` and `open Polynomial`**: These commands open the relevant namespaces, making it easier to access functions and theorems related to polynomials without needing to prefix them with the namespace.\n\n3. **Formalizing the Statement:**\n   - **`theorem eval_X_extracted [Semiring R] {x : R} : eval x X = x`**: This line declares a theorem named `eval_X_extracted`.\n     - **`[Semiring R]`**: This specifies that \\(R\\) is a semiring. A semiring is a type of algebraic structure that generalizes rings and is necessary for defining polynomials.\n     - **`{x : R}`**: This indicates that \\(x\\) is an element of the semiring \\(R\\).\n     - **`eval x X = x`**: This is the core statement of the theorem. `eval` is a function that evaluates a polynomial at a given point. Here, it states that evaluating the polynomial \\(X\\) at \\(x\\) results in \\(x\\).\n\n4. **Understanding `eval` and `X`:**\n   - **`eval`**: This function takes two arguments: a value and a polynomial. It computes the result of substituting the value into the polynomial.\n   - **`X`**: In the context of polynomials, `X` represents the polynomial variable, which is equivalent to the identity polynomial \\(X\\).\n\n5. **Conclusion:**\n   - The theorem `eval_X_extracted` asserts that for any element \\(x\\) in"}
{"source_file": "herald_data/sample_500.jsonl", "line": 95, "id": 545410, "informal_statement": "Let $a,b,c>0$ such that: $abc=1$ . Prove that: \\n $(a^5+b^5+c^5)^3\\geq 27(2\\sqrt{ab}-c)(2\\sqrt{bc}-a)(2\\sqrt{ca}-b)$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_545410 (a b c : ℝ) (h1 : a > 0 ∧ b > 0 ∧ c > 0 ∧ a * b * c = 1) :\n  (a^5 + b^5 + c^5)^3 ≥ 27 * (2 * Real.sqrt (a * b) - c) * (2 * Real.sqrt (b * c) - a) * (2 * Real.sqrt (c * a) - b)   :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a structured approach to formalize each component of the problem. Here's a step-by-step explanation:\n\n1. **Understanding the Context**:\n   - The problem involves real numbers \\(a\\), \\(b\\), and \\(c\\) that are all positive and satisfy the condition \\(abc = 1\\).\n   - We need to prove an inequality involving these numbers.\n\n2. **Setting Up the Environment**:\n   - The code begins with importing necessary modules from the Lean mathematical library (`Mathlib`). This includes modules for big operators, real numbers, natural numbers, and topology, which might be used for handling real number operations and properties.\n\n3. **Defining Variables and Assumptions**:\n   - The theorem is defined with the name `extract_aug_545410`.\n   - The variables \\(a\\), \\(b\\), and \\(c\\) are declared as real numbers (`ℝ`), which aligns with the informal statement that they are positive real numbers.\n   - The hypothesis `h1` is a conjunction of conditions: `a > 0 ∧ b > 0 ∧ c > 0 ∧ a * b * c = 1`. This directly translates the informal condition that \\(a\\), \\(b\\), and \\(c\\) are positive and their product is 1.\n\n4. **Formalizing the Inequality**:\n   - The left-hand side of the inequality is `(a^5 + b^5 + c^5)^3`. This is a straightforward translation of the expression \\((a^5 + b^5 + c^5)^3\\) from the informal statement.\n   - The right-hand side is `27 * (2 * Real.sqrt (a * b) - c) * (2 * Real.sqrt (b * c) - a) * (2 * Real.sqrt (c * a) - b)`. This corresponds to the product \\(27(2\\sqrt{ab}-c)(2\\sqrt{bc}-a)(2\\sqrt{ca}-b)\\) in the informal statement.\n   - The use of `Real.sqrt` in Lean is to compute the square root, which matches the \\(\\sqrt{}\\) notation in the informal statement.\n\n5. **Stating the Goal**:\n   - The goal is to prove the inequality, which is expressed using the `≥` operator"}
{"source_file": "herald_data/sample_500.jsonl", "line": 100, "id": 160269, "informal_statement": "For any complex number $z$ such that $\\|z\\| \\leq \\frac{1}{2}$ and $(1 - \\|z\\|)^{-1} \\leq 2$, show that $\\frac{2}{2} = 1$.", "formal_statement": "import Mathlib\nopen intervalIntegral in\nopen intervalIntegral in\nlemma norm_log_one_add_half_le_self_tac_9408 (z : ℂ) (hz : ‖z‖ ≤ 1 / 2) (hz3 : (1 - ‖z‖)⁻¹ ≤ 2) : 2 / 2 = 1 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean.\n\n1. **Understanding the Context**:\n   - The informal statement involves complex numbers and norms, which suggests the use of the complex number type `ℂ` and the norm function `‖z‖` in Lean.\n   - The goal is to show a simple arithmetic fact, `2 / 2 = 1`, under certain conditions on a complex number `z`.\n\n2. **Translating the Hypotheses**:\n   - The condition `\\|z\\| \\leq \\frac{1}{2}` is translated to `‖z‖ ≤ 1 / 2` in Lean. Here, `‖z‖` represents the norm of the complex number `z`, and `1 / 2` is the fraction representing one-half.\n   - The condition `(1 - \\|z\\|)^{-1} \\leq 2` is translated to `(1 - ‖z‖)⁻¹ ≤ 2`. The expression `(1 - ‖z‖)⁻¹` represents the reciprocal of `1 - ‖z‖`.\n\n3. **Formalizing the Statement**:\n   - The lemma is named `norm_log_one_add_half_le_self_tac_9408`, which is a unique identifier for this particular statement in Lean.\n   - The lemma takes a complex number `z : ℂ` as an argument, indicating that `z` is a complex number.\n   - The hypotheses are included as `hz : ‖z‖ ≤ 1 / 2` and `hz3 : (1 - ‖z‖)⁻¹ ≤ 2`, which are the conditions under which the conclusion must hold.\n\n4. **The Conclusion**:\n   - The conclusion `2 / 2 = 1` is a straightforward arithmetic equality. In Lean, this is expressed directly as `2 / 2 = 1`.\n\n5. **Structure of the Lemma**:\n   - The lemma is structured with the keyword `lemma`, followed by the name of the lemma, the parameters (in this case, `z` and the hypotheses), and the conclusion.\n   - The `:= sorry` at the end indicates that the proof of this lemma is not provided and"}
{"source_file": "herald_data/sample_500.jsonl", "line": 96, "id": 528606, "informal_statement": "Test the convergence of the power series: $\\sum\\limits_{n = 1}^\\infty {\\frac{{{n^2}\\sin n}}{{4{n^3} + 3n + 2}}} $", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_528606 : Summable (λ n : ℕ => ((n:ℝ)^2 * Real.sin n) / (4 * n ^ 3 + 3 * n + 2))   :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Informal Statement**: The problem asks us to test the convergence of a power series given by the sum \\(\\sum_{n=1}^\\infty \\frac{n^2 \\sin n}{4n^3 + 3n + 2}\\). This is a series where each term is a function of \\(n\\), involving both polynomial and trigonometric components.\n\n2. **Identifying the Components**: The series is composed of terms of the form \\(\\frac{n^2 \\sin n}{4n^3 + 3n + 2}\\). Here, \\(n^2\\) is a polynomial term, \\(\\sin n\\) is a trigonometric function, and \\(4n^3 + 3n + 2\\) is another polynomial in the denominator.\n\n3. **Formalizing the Series in Lean**:\n   - **Type of Series**: In Lean, we represent series using functions from natural numbers to real numbers. The series is expressed as a function \\(\\lambda n : \\mathbb{N} \\Rightarrow \\mathbb{R}\\) that maps each natural number \\(n\\) to the corresponding term of the series.\n   - **Expression of Terms**: The term \\(\\frac{n^2 \\sin n}{4n^3 + 3n + 2}\\) is expressed in Lean as `((n:ℝ)^2 * Real.sin n) / (4 * n ^ 3 + 3 * n + 2)`. Here, `(n:ℝ)` casts the natural number \\(n\\) to a real number, allowing us to perform real arithmetic operations.\n\n4. **Using Lean Libraries**:\n   - **Importing Necessary Modules**: The code imports `Mathlib`, which is a library containing mathematical definitions and theorems. It also opens `BigOperators`, `Real`, `Nat`, and `Topology`, which provide necessary tools for handling series, real numbers, natural numbers, and topological concepts, respectively.\n   - **Summability**: The property we are testing is whether the series is summable, which in Lean is expressed using the `Summable` predicate. This predicate checks if the infinite series converges to a finite limit.\n\n5. **Theorem Statement**"}
{"source_file": "herald_data/sample_500.jsonl", "line": 102, "id": 453686, "informal_statement": "Another way to look at modular arithmetic is clocks. 3 hours after 11 is 2 because $11+3=14\\equiv 2\\pmod {12}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_453686 :\n  (11 + 3) % 12 = 2  :=  by sorry", "explanation": "To translate the informal statement about modular arithmetic into the formal Lean4 statement, we follow these steps:\n\n1. **Understanding the Informal Statement**: The statement discusses modular arithmetic using the analogy of a clock. Specifically, it states that adding 3 hours to 11 results in 2 on a 12-hour clock. Mathematically, this is expressed as \\(11 + 3 \\equiv 2 \\pmod{12}\\).\n\n2. **Identifying the Mathematical Operation**: The operation involved is modular arithmetic, specifically the modulo operation, which finds the remainder of division of one number by another. Here, we are interested in the remainder when \\(11 + 3\\) is divided by 12.\n\n3. **Translating to Lean4**:\n   - **Importing Necessary Libraries**: The code begins with importing `Mathlib`, which is a library in Lean that provides various mathematical tools and theorems. The `open` statements for `BigOperators`, `Real`, `Nat`, and `Topology` are included, although not all are directly necessary for this specific theorem. They are likely included for broader context or other parts of the file.\n   \n   - **Defining the Theorem**: The theorem is named `extract_aug_453686`. Naming conventions in Lean can vary, but here it seems to be an autogenerated or placeholder name.\n   \n   - **Expressing the Modulo Operation**: The core of the theorem is the expression `(11 + 3) % 12 = 2`. This directly translates the informal statement into Lean's syntax:\n     - `11 + 3` represents the sum of the hours.\n     - `% 12` is the modulo operation, which calculates the remainder when the sum is divided by 12.\n     - `= 2` asserts that the result of the modulo operation is 2, matching the informal statement's conclusion.\n\n4. **Proof Placeholder**: The `:= by sorry` part indicates that the proof of this theorem is not yet provided. In Lean, `sorry` is a placeholder that allows the theorem to be accepted as true without a proof, useful during development.\n\nBy following these steps, the informal concept of modular arithmetic using a clock analogy is formalized into a precise statement in Lean4, capturing the essence of the operation and its result."}
{"source_file": "herald_data/sample_500.jsonl", "line": 101, "id": 167757, "informal_statement": "Let $p$ be a prime number, $F$ be a polynomial with coefficients in $\\mathbb{Z}/p\\mathbb{Z}$, and $a$ be an element of $\\mathbb{Z}/p\\mathbb{Z}$. Given that the norm of the evaluation of $F$ at $a$ is less than the square of the norm of the derivative of $F$ evaluated at $a$, and that $F$ evaluated at $a$ is nonzero, prove that the norm of the evaluation of $F$ at $a$ is less than the square of the norm of the derivative of $F$ evaluated at $a$.", "formal_statement": "import Mathlib\nopen Topology\nopen Filter Metric\nopen Nat\nlemma soln_dist_to_a_lt_deriv_tac_18718 (p : ℕ) [Fact (Nat.Prime p)] (F : Polynomial ℤ_[p]) (a : ℤ_[p]) (hnorm : ‖Polynomial.eval a F‖ < ‖Polynomial.eval a (Polynomial.derivative F)‖ ^ 2) (hnsol : Polynomial.eval a F ≠ 0) : ‖Polynomial.eval a F‖ < ‖Polynomial.eval a (Polynomial.derivative F)‖ ^ 2 := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach to formalize each component of the statement. Here's a step-by-step explanation of the translation:\n\n1. **Prime Number `p`:** \n   - In the informal statement, `p` is a prime number. In Lean, we represent this using a natural number `p` and a typeclass `Fact (Nat.Prime p)` to assert that `p` is prime. This is done using the `Fact` typeclass, which is a way to carry around proofs of propositions as typeclass instances.\n\n2. **Polynomial `F` with Coefficients in \\(\\mathbb{Z}/p\\mathbb{Z}\\):**\n   - The informal statement specifies that `F` is a polynomial with coefficients in the finite field \\(\\mathbb{Z}/p\\mathbb{Z}\\). In Lean, this is represented as `Polynomial ℤ_[p]`, where `ℤ_[p]` denotes the p-adic integers, which is a common way to handle modular arithmetic in Lean's mathematical library.\n\n3. **Element `a` in \\(\\mathbb{Z}/p\\mathbb{Z}\\):**\n   - The element `a` is an element of \\(\\mathbb{Z}/p\\mathbb{Z}\\). In Lean, this is represented as `a : ℤ_[p]`, indicating that `a` is an element of the p-adic integers.\n\n4. **Norm of Evaluation and Derivative:**\n   - The informal statement involves the norm of the evaluation of `F` at `a` and the norm of the derivative of `F` evaluated at `a`. In Lean, this is expressed using the norm notation `‖...‖`. Specifically, `‖Polynomial.eval a F‖` represents the norm of the evaluation of `F` at `a`, and `‖Polynomial.eval a (Polynomial.derivative F)‖` represents the norm of the evaluation of the derivative of `F` at `a`.\n\n5. **Inequality and Nonzero Condition:**\n   - The condition that the norm of the evaluation of `F` at `a` is less than the square of the norm of the derivative of `F` evaluated at `a` is directly translated as `hnorm : ‖Polynomial.eval a F‖ < ‖"}
{"source_file": "herald_data/sample_500.jsonl", "line": 99, "id": 114979, "informal_statement": "For any two sets $s$ and $t$ in a type $\\alpha$, if $s$ and $t$ are disjoint, then the cardinality of their union is equal to the sum of their individual cardinalities, i.e., $(s \\cup t).\\text{encard} = s.\\text{encard} + t.\\text{encard}$.", "formal_statement": "import Mathlib\n\nlemma encard_union_eq_tac_5627 (s : Set α) (t : Set α) (h : Disjoint s t) : (s ∪ t).encard = s.encard + t.encard := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to break down each component of the statement and map it to the corresponding Lean constructs:\n\n1. **Universal Quantification**: \n   - The informal statement begins with \"For any two sets $s$ and $t$ in a type $\\alpha$\". In Lean, this is expressed by introducing variables `s` and `t` of type `Set α`. The type `α` is a parameter that represents the universe of elements from which the sets are drawn. This is implicitly understood in Lean when we define `s` and `t` as `Set α`.\n\n2. **Disjoint Sets**:\n   - The condition \"if $s$ and $t$ are disjoint\" is expressed using the `Disjoint` predicate in Lean. The predicate `Disjoint s t` asserts that the intersection of `s` and `t` is empty, which matches the informal notion of disjoint sets.\n\n3. **Cardinality of Sets**:\n   - The informal statement refers to the cardinality of sets using `.encard`. In Lean, `s.encard` denotes the cardinality of the set `s`. This is a method or property associated with sets in Lean's mathematical library.\n\n4. **Union of Sets**:\n   - The union of two sets $s$ and $t$ is denoted by `s ∪ t` in both informal mathematics and Lean. The union operation is a standard set operation available in Lean.\n\n5. **Equality of Cardinalities**:\n   - The statement \"the cardinality of their union is equal to the sum of their individual cardinalities\" is directly translated to the equation `(s ∪ t).encard = s.encard + t.encard`. This equation asserts that the cardinality of the union is the sum of the cardinalities of `s` and `t`.\n\n6. **Lemma Declaration**:\n   - The entire statement is encapsulated in a lemma, which is a way to state and prove propositions in Lean. The lemma is named `encard_union_eq_tac_5627`, which is an arbitrary identifier for this particular result.\n\n7. **Proof Placeholder**:\n   - The keyword `sorry` is used as a placeholder for the proof. In Lean, `sorry` allows the statement to be accepted as a valid lemma without providing a proof, which is useful during the development process.\n\nBy combining these elements,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 86, "id": 146417, "informal_statement": "For any real number $r$, vector $v$ in a normed additive commutative group $V$, and points $p_1, p_2$ in a metric space $P$ that is also a normed additive torsor over $V$, show that the expression $r \\cdot (r \\cdot \\langle v, v \\rangle_{\\mathbb{R}}) + 2 \\cdot (r \\cdot \\langle v, p_1 -_{V} p_2 \\rangle_{\\mathbb{R}}) + \\langle p_1 -_{V} p_2, p_1 -_{V} p_2 \\rangle_{\\mathbb{R}}$ is equal to $\\langle v, v \\rangle_{\\mathbb{R}} \\cdot r \\cdot r + 2 \\cdot \\langle v, p_1 -_{V} p_2 \\rangle_{\\mathbb{R}} \\cdot r + \\langle p_1 -_{V} p_2, p_1 -_{V} p_2 \\rangle_{\\mathbb{R}}$.", "formal_statement": "import Mathlib\nopen RealInnerProductSpace\nlemma dist_smul_vadd_sq_tac_4454 [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (r : ℝ) (v : V) (p₁ : P) (p₂ : P) : r * (r * ⟪v, v⟫_ℝ) + 2 * (r * ⟪v, p₁ -ᵥ p₂⟫_ℝ) + ⟪p₁ -ᵥ p₂, p₁ -ᵥ p₂⟫_ℝ =\n  ⟪v, v⟫_ℝ * r * r + 2 * ⟪v, p₁ -ᵥ p₂⟫_ℝ * r + ⟪p₁ -ᵥ p₂, p₁ -ᵥ p₂⟫_ℝ := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully map each component of the informal statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context**:\n   - We are dealing with a normed additive commutative group \\( V \\), a real inner product space over \\( \\mathbb{R} \\).\n   - \\( P \\) is a metric space and also a normed additive torsor over \\( V \\).\n   - The goal is to show the equality of two expressions involving real numbers, vectors, and points in these structures.\n\n2. **Identifying the Components**:\n   - **Real Number \\( r \\)**: In Lean, this is represented as a variable of type `ℝ`.\n   - **Vector \\( v \\) in \\( V \\)**: This is represented as a variable of type `V`.\n   - **Points \\( p_1, p_2 \\) in \\( P \\)**: These are represented as variables of type `P`.\n\n3. **Inner Product Notation**:\n   - The inner product \\(\\langle \\cdot, \\cdot \\rangle_{\\mathbb{R}}\\) is represented in Lean using the notation `⟪v, w⟫_ℝ` for vectors \\( v \\) and \\( w \\).\n\n4. **Vector Subtraction in Torsors**:\n   - The operation \\( p_1 -_V p_2 \\) is the subtraction of points in the torsor, represented in Lean as `p₁ -ᵥ p₂`.\n\n5. **Formalizing the Expression**:\n   - The informal expression \\( r \\cdot (r \\cdot \\langle v, v \\rangle_{\\mathbb{R}}) + 2 \\cdot (r \\cdot \\langle v, p_1 -_V p_2 \\rangle_{\\mathbb{R}}) + \\langle p_1 -_V p_2, p_1 -_V p_2 \\rangle_{\\mathbb{R}} \\) is translated to:\n     ```lean\n     r * (r * ⟪v, v⟫_ℝ) + 2 * (r * ⟪v, p₁ -ᵥ p₂⟫_"}
{"source_file": "herald_data/sample_500.jsonl", "line": 107, "id": 565968, "informal_statement": "Let $a,b,c,d>0$ and $abcd=1$ .Prove that $a^5+b^5+c^5+d^5+4 \\ge 2(a^3+b^3+c^3+d^3) .$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_565968 (a b c d : ℝ) (hab : 0 < a) (hbc : 0 < b) (hcd : 0 < c) (hda : 0 < d) (habcd : a * b * c * d = 1) : a ^ 5 + b ^ 5 + c ^ 5 + d ^ 5 + 4 ≥ 2 * (a ^ 3 + b ^ 3 + c ^ 3 + d ^ 3)   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow a structured approach to ensure that all components of the statement are accurately represented in the formal language. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Variables and Their Types**:\n   - The variables \\(a\\), \\(b\\), \\(c\\), and \\(d\\) are real numbers. In Lean, we represent real numbers using the type `ℝ`.\n   - The conditions \\(a, b, c, d > 0\\) imply that each of these variables is strictly positive.\n\n2. **Express the Conditions**:\n   - The condition \\(a, b, c, d > 0\\) is expressed using inequalities in Lean: `0 < a`, `0 < b`, `0 < c`, and `0 < d`.\n   - The condition \\(abcd = 1\\) is expressed as `a * b * c * d = 1`.\n\n3. **State the Inequality to Prove**:\n   - The goal is to prove the inequality \\(a^5 + b^5 + c^5 + d^5 + 4 \\ge 2(a^3 + b^3 + c^3 + d^3)\\).\n   - In Lean, the power operation is represented using the `^` operator, so \\(a^5\\) is written as `a ^ 5`, and similarly for the other terms.\n   - The inequality is expressed using `≥`, which is the Lean notation for \"greater than or equal to\".\n\n4. **Structure the Theorem**:\n   - The theorem is named `extract_aug_565968`, which is a unique identifier for this particular result.\n   - The theorem takes as input the variables \\(a\\), \\(b\\), \\(c\\), and \\(d\\) of type `ℝ`, along with the hypotheses `hab`, `hbc`, `hcd`, `hda`, and `habcd` representing the conditions \\(a, b, c, d > 0\\) and \\(abcd = 1\\).\n\n5. **Use of Lean's Libraries**:\n   - The `import Mathlib` statement brings in the necessary mathematical libraries that provide definitions and theorems for real numbers and inequalities.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to access specific"}
{"source_file": "herald_data/sample_500.jsonl", "line": 104, "id": 411589, "informal_statement": "Given a stopping time $\\tau: \\Omega \\to \\iota$ and a map $u: \\iota \\to \\Omega \\to E$, the stopped value is the map defined by $\\omega \\mapsto u(\\tau(\\omega), \\omega)$.", "formal_statement": "import Mathlib\nopen Filter Order TopologicalSpace\nopen scoped Classical MeasureTheory NNReal ENNReal Topology\n/-- Given a map `u : ι → Ω → E`, its stopped value with respect to the stopping\ntime `τ` is the map `x ↦ u (τ ω) ω`. -/\ndef stoppedValue (u : ι → Ω → β) (τ : Ω → ι) : Ω → β := sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to carefully consider the components involved and how they map to Lean's syntax and semantics. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Components**:\n   - **Stopping Time**: The informal statement describes a stopping time `τ` as a function from a sample space `Ω` to an index set `ι`. In Lean, this is represented as `τ : Ω → ι`.\n   - **Map `u`**: The map `u` is a function that takes an index from `ι` and an element from `Ω`, and returns a value in some space `E`. In Lean, this is represented as `u : ι → Ω → E`.\n\n2. **Define the Stopped Value**:\n   - The stopped value is a function that, given an element `ω` from `Ω`, returns the value `u(τ(ω), ω)`. This means we need to define a function that takes `ω` as input and applies `τ` to `ω` to get an index, then uses this index and `ω` to evaluate `u`.\n\n3. **Formalize in Lean**:\n   - We define a new function `stoppedValue` that takes two arguments: the map `u` and the stopping time `τ`.\n   - The type signature of `stoppedValue` is `Ω → β`, indicating that it takes an element from `Ω` and returns a value in `β` (which corresponds to `E` in the informal statement).\n\n4. **Lean Syntax**:\n   - The function is defined using the `def` keyword in Lean.\n   - The function body is currently marked as `sorry`, which is a placeholder indicating that the implementation is not provided. In a complete implementation, this would be replaced with the actual function body, which would be `λ ω, u (τ ω) ω`.\n\n5. **Documentation**:\n   - A docstring is provided using the `/-- ... -/` syntax to describe the purpose of the function. This is important for readability and understanding the intent of the code.\n\n6. **Imports and Namespace**:\n   - The code includes necessary imports and opens relevant namespaces to ensure that all required definitions and notations are available. This includes `Mathlib` and various modules related to filters, order, and topology.\n\nBy following these steps, the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 105, "id": 407933, "informal_statement": "For any type $\\alpha$ with a distinguished element $1$, prove that $1$ is an element of the set $\\{1\\}$, a subset of $\\alpha$.", "formal_statement": "import Mathlib\nopen Function\n@[to_additive]\ntheorem one_mem_one [One α] : (1 : α) ∈ (1 : Part α) := sorry", "explanation": "To translate the informal statement into Lean, we need to break down the components of the statement and understand how they map to Lean constructs.\n\n1. **Type with a Distinguished Element**: The informal statement refers to a type $\\alpha$ with a distinguished element $1$. In Lean, this is represented by a type class `One α`, which provides a way to refer to a type `α` that has a \"one\" element. The `One` type class is a standard way in Lean to denote that a type has a multiplicative identity element.\n\n2. **Prove that $1$ is an Element of the Set $\\{1\\}$**: The goal is to show that the element `1` is in the set `{1}`. In Lean, sets can be represented using the `Part` type, which is a way to handle partial functions or subsets. The notation `(1 : Part α)` is used to denote the subset of `α` that contains only the element `1`.\n\n3. **Formalizing the Statement**: The theorem `one_mem_one` is defined to express that for any type `α` with a `One` instance, the element `1` (denoted as `(1 : α)`) is a member of the set `(1 : Part α)`. The `∈` symbol is used to denote set membership in Lean.\n\n4. **Attributes and Imports**: The `@[to_additive]` attribute is used to automatically generate an analogous theorem for additive structures, where `1` would be replaced by `0`. The `import Mathlib` statement is necessary to bring in the mathematical library that contains definitions and theorems related to algebraic structures, including the `One` type class.\n\n5. **Theorem Statement**: The theorem is stated as `theorem one_mem_one [One α] : (1 : α) ∈ (1 : Part α)`. This reads as: for any type `α` that has a `One` instance, the element `1` of type `α` is in the subset of `α` that contains only `1`.\n\n6. **Proof Placeholder**: The `:= sorry` part indicates that the proof is not yet provided. In Lean, `sorry` is a placeholder that allows the code to compile without a complete proof, useful during development.\n\nBy following these steps, the informal statement is accurately translated into a formal Lean theorem,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 108, "id": 263630, "informal_statement": "For any fields $K$ and $L$, with $L$ being a finite-dimensional algebra over $K$, and for any $x \\in L$, prove that the trace of the action of $x$ on $L$ as an element of the algebra $K \\langle x \\rangle$ is equal to the scalar multiplication of the dimension of $L$ over $K \\langle x \\rangle$ by the trace of $x$ as an element of $K \\langle x \\rangle$. In mathematical notation, this is expressed as $\\text{tr}_{K}(x \\cdot_{K \\langle x \\rangle} L) (\\text{tr}_{K \\langle x \\rangle}(L) (\\text{AlgMap}_{K \\langle x \\rangle, L}(x))) = [\\text{dim}_{K \\langle x \\rangle} L] \\cdot \\text{tr}_{K}(x \\cdot_{K \\langle x \\rangle} K \\langle x \\rangle)$.", "formal_statement": "import Mathlib\nopen FiniteDimensional\nopen LinearMap (BilinForm)\nopen LinearMap\nopen Matrix\nopen scoped Matrix\nopen Algebra Polynomial\nopen IntermediateField\nopen IntermediateField\nlemma trace_eq_trace_adjoin_tac_4772 [Field K] [Field L] [Algebra K L] [FiniteDimensional K L] (x : L) : (Algebra.trace K ↥K⟮x⟯) ((Algebra.trace (↥K⟮x⟯) L) ((algebraMap (↥K⟮x⟯) L) (AdjoinSimple.gen K x))) =\n  finrank (↥K⟮x⟯) L • (Algebra.trace K ↥K⟮x⟯) (AdjoinSimple.gen K x) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and map it to the corresponding Lean constructs. Here's the step-by-step explanation:\n\n1. **Fields and Algebras**: \n   - The informal statement involves fields \\( K \\) and \\( L \\), with \\( L \\) being a finite-dimensional algebra over \\( K \\). In Lean, this is represented by `[Field K]`, `[Field L]`, and `[Algebra K L]`. The finite-dimensionality is captured by `[FiniteDimensional K L]`.\n\n2. **Element \\( x \\in L \\)**:\n   - The element \\( x \\) in the algebra \\( L \\) is represented as `(x : L)` in Lean. This indicates that \\( x \\) is an element of the field \\( L \\).\n\n3. **Adjoin of \\( x \\)**:\n   - The notation \\( K \\langle x \\rangle \\) refers to the field extension generated by \\( x \\) over \\( K \\). In Lean, this is represented by `↥K⟮x⟯`, which uses the `AdjoinSimple` construct to denote the field extension.\n\n4. **Trace Function**:\n   - The trace of an element in the context of field extensions is represented by `Algebra.trace`. The function `Algebra.trace K ↥K⟮x⟯` computes the trace of an element from the field \\( K \\langle x \\rangle \\) to \\( K \\).\n\n5. **Algebra Map**:\n   - The map from \\( K \\langle x \\rangle \\) to \\( L \\) is represented by `algebraMap (↥K⟮x⟯) L`. This is used to map elements from the adjoined field to the larger field \\( L \\).\n\n6. **Trace of the Action**:\n   - The trace of the action of \\( x \\) on \\( L \\) is expressed as `Algebra.trace (↥K⟮x⟯) L`. This computes the trace of the linear map induced by \\( x \\) on the vector space \\( L \\) over \\( K \\langle x \\rangle \\).\n\n7. **Dimension and Scalar Multiplication**:\n   - The dimension of \\( L \\) over \\( K \\langle x"}
{"source_file": "herald_data/sample_500.jsonl", "line": 109, "id": 12038, "informal_statement": "For any affine map \\( f : P_1 \\to_{\\mathbb{k}} P_2 \\) between two affine spaces \\( P_1 \\) and \\( P_2 \\) over a field \\( \\mathbb{k} \\), and for any two points \\( p_1, p_2 \\in P_1 \\), the linear map applied to the vector difference \\( p_1 -_v p_2 \\) is equal to the vector difference of the affine map applied to the points, i.e., \\( f.linear(p_1 -_v p_2) = f(p_1) -_v f(p_2) \\).", "formal_statement": "import Mathlib\nopen Affine\ntheorem linearMap_vsub_extracted [Ring k]\n [AddCommGroup V1] [Module k V1] [AffineSpace V1 P1] [AddCommGroup V2]\n [Module k V2] [AffineSpace V2 P2] (f : P1 →ᵃ[k] P2) (p1 p2 : P1) : f.linear (p1 -ᵥ p2) = f p1 -ᵥ f p2 := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to understand the components involved and how they map to Lean's syntax and structures. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context**:\n   - We are dealing with affine spaces \\( P_1 \\) and \\( P_2 \\) over a field \\( \\mathbb{k} \\).\n   - An affine map \\( f : P_1 \\to_{\\mathbb{k}} P_2 \\) is given, which has an associated linear map.\n   - The operation \\( -_v \\) denotes the vector subtraction between points in an affine space.\n\n2. **Lean4 Imports and Setup**:\n   - We start by importing the necessary modules from Lean's math library with `import Mathlib`.\n   - We open the `Affine` namespace to access affine-related definitions and operations.\n\n3. **Defining the Theorem**:\n   - We declare a theorem named `linearMap_vsub_extracted` which will formalize the statement.\n   - The theorem is parameterized over a field \\( k \\), which is a `Ring` in Lean, and two affine spaces \\( P_1 \\) and \\( P_2 \\).\n\n4. **Specifying Type Classes**:\n   - We specify that \\( V_1 \\) and \\( V_2 \\) are additive commutative groups (`AddCommGroup`) and modules over \\( k \\) (`Module k V1` and `Module k V2`).\n   - We declare \\( P_1 \\) and \\( P_2 \\) as affine spaces over \\( V_1 \\) and \\( V_2 \\) respectively (`AffineSpace V1 P1` and `AffineSpace V2 P2`).\n\n5. **Affine Map and Points**:\n   - The affine map \\( f \\) is represented as `f : P1 →ᵃ[k] P2`, where `→ᵃ[k]` denotes an affine map over the field \\( k \\).\n   - The points \\( p_1 \\) and \\( p_2 \\) are elements of the affine space \\( P_1 \\).\n\n6. **Formalizing the Statement**:\n   - The vector subtraction \\( p_1 -_v p_2 \\) is written as `p1 -ᵥ p2` in Lean, where `-ᵥ` is the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 103, "id": 66616, "informal_statement": "For a trivialization \\( e \\) of the fiber bundle \\( F \\) over the base space \\( B \\) with total space \\( E \\), assuming \\( e \\) is linear with respect to the ring \\( R \\), and given a point \\( b \\in B \\) within \\( e \\)'s base set along with a vector \\( v \\in E_b \\), demonstrate that applying the linear equivalence \\( e.linearEquivAt \\) at \\( b \\) to \\( v \\) yields the second component of \\( e \\) applied to the pair \\( (b, v) \\).", "formal_statement": "import Mathlib\nopen Bundle Set\nopen scoped Topology\nopen Classical in\nopen Classical in\nopen Classical in\ntheorem linearEquivAt_apply_extracted {E : B → Type u_4} [Semiring R] [TopologicalSpace F]\n [TopologicalSpace B] [TopologicalSpace (TotalSpace F E)] [AddCommMonoid F]\n [Module R F] [(x : B) → AddCommMonoid (E x)] [(x : B) → Module R (E x)]\n (e : Trivialization F TotalSpace.proj) [Trivialization.IsLinear R e] (b : B) (hb : b ∈ e.baseSet) (v : E b) :\n (Trivialization.linearEquivAt R e b hb) v = (↑e { proj := b, snd := v }).2 := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to the Lean4 constructs:\n\n1. **Fiber Bundle and Trivialization**:\n   - The informal statement refers to a fiber bundle \\( F \\) over a base space \\( B \\) with total space \\( E \\). In Lean, this is represented by `E : B → Type u_4`, where `E` is a type family over `B`, indicating that for each point in `B`, there is a corresponding fiber.\n   - A trivialization \\( e \\) is a local homeomorphism that provides a local product structure to the bundle. In Lean, this is represented by `e : Trivialization F TotalSpace.proj`, where `Trivialization` is a structure that encapsulates this concept.\n\n2. **Linear Structure**:\n   - The statement assumes \\( e \\) is linear with respect to the ring \\( R \\). This is captured in Lean by `[Trivialization.IsLinear R e]`, which is a typeclass indicating that the trivialization `e` respects the linear structure over the ring `R`.\n\n3. **Point in Base Space and Vector in Fiber**:\n   - The point \\( b \\in B \\) and the vector \\( v \\in E_b \\) are represented in Lean by `b : B` and `v : E b`, respectively. The condition that \\( b \\) is within \\( e \\)'s base set is given by `hb : b ∈ e.baseSet`.\n\n4. **Linear Equivalence Application**:\n   - The goal is to show that applying the linear equivalence at \\( b \\) to \\( v \\) yields the second component of \\( e \\) applied to the pair \\( (b, v) \\). In Lean, this is expressed as `(Trivialization.linearEquivAt R e b hb) v`, which applies the linear equivalence at `b` to the vector `v`.\n\n5. **Extracting the Second Component**:\n   - The second component of \\( e \\) applied to the pair \\( (b, v) \\) is represented by `(↑e { proj := b, snd := v }).2`. Here, `↑e` denotes the application of the trivialization `e` to the pair `{ proj := b, snd := v }`, and `.2`"}
{"source_file": "herald_data/sample_500.jsonl", "line": 106, "id": 501865, "informal_statement": "Find all pairs of positive integer (x;y) for which $\\frac{{{x^2} + {y^2}}}{{x - y}}$ is an integer which divides 1995", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_501865 (x y : ℤ) (h₁ : 0 < x ∧ 0 < y) (h₂ : x ≠ y) (h₃ : (x^2 + y^2) % (x-y) = 0) : (x^2 + y^2) / (x-y) ∣ 1995   :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the problem and see how it is represented in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Problem:**\n   - We are asked to find pairs of positive integers \\((x, y)\\) such that the expression \\(\\frac{x^2 + y^2}{x - y}\\) is an integer and this integer divides 1995.\n\n2. **Lean4 Imports and Setup:**\n   - The code begins with importing necessary modules from Mathlib, which is a library for Lean. These imports include `BigOperators`, `Real`, `Nat`, and `Topology`, which provide various mathematical functions and operations.\n\n3. **Theorem Declaration:**\n   - The theorem is named `extract_aug_501865`, which is a placeholder name and can be replaced with a more descriptive one.\n   - The theorem takes two integer arguments `x` and `y` of type `ℤ`, which represents the set of all integers in Lean.\n\n4. **Assumptions (Hypotheses):**\n   - `h₁ : 0 < x ∧ 0 < y`: This hypothesis ensures that both `x` and `y` are positive integers, aligning with the requirement for positive integers in the informal statement.\n   - `h₂ : x ≠ y`: This condition ensures that `x` and `y` are distinct, which is necessary for the denominator \\(x - y\\) to be non-zero, thus making the division valid.\n   - `h₃ : (x^2 + y^2) % (x-y) = 0`: This condition states that the remainder when \\(x^2 + y^2\\) is divided by \\(x - y\\) is zero, which means that \\(\\frac{x^2 + y^2}{x - y}\\) is an integer.\n\n5. **Conclusion (Goal):**\n   - The goal of the theorem is to prove that this integer, \\(\\frac{x^2 + y^2}{x - y}\\), divides 1995. In Lean, this is expressed as `(x^2 + y^2) / (x-y) ∣ 1995`, where `∣` denotes divisibility.\n\n6. **Proof Placeholder:**\n   - The `:= by sorry` part indicates that the proof"}
{"source_file": "herald_data/sample_500.jsonl", "line": 98, "id": 49408, "informal_statement": "For any natural number $n$, and for any morphisms $f$ and $g$ in a preadditive category, show that the composition of $f$ with $n$ times $g$ equals $n$ times $f$ composed with $g$, i.e., $f \\circ (n \\cdot g) = (n \\cdot f) \\circ g$.", "formal_statement": "import Mathlib\nopen CategoryTheory.Limits\nopen CategoryTheory\nopen AddMonoidHom\ntheorem comp_nsmul_extracted [Category.{v : u} C] [Preadditive C] {P Q R : C} (f : P ⟶ Q) (g : Q ⟶ R) (n : ℕ),\n f ≫ (n • g) = n • f ≫ g := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to understand both the mathematical concepts involved and how they are represented in Lean's type system and libraries. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context**: \n   - We are working within the framework of category theory, specifically in a preadditive category. A preadditive category is a category where hom-sets are abelian groups and composition of morphisms is bilinear.\n   - The statement involves natural numbers, morphisms, and the operation of scalar multiplication (denoted by `n \\cdot g` in the informal statement and `n • g` in Lean).\n\n2. **Identifying the Components**:\n   - **Natural Number `n`**: In Lean, natural numbers are represented by the type `ℕ`.\n   - **Morphisms `f` and `g`**: These are arrows between objects in a category. In Lean, if `P`, `Q`, and `R` are objects in a category `C`, then `f : P ⟶ Q` and `g : Q ⟶ R` are morphisms.\n   - **Composition `f \\circ g`**: In Lean, morphism composition is denoted by `≫`.\n\n3. **Formalizing the Preadditive Category**:\n   - We need to specify that the category `C` is preadditive. This is done by including the `[Preadditive C]` typeclass, which provides the necessary structure for scalar multiplication and addition of morphisms.\n\n4. **Scalar Multiplication in Preadditive Categories**:\n   - In a preadditive category, scalar multiplication of a morphism by a natural number is denoted by `n • g` in Lean. This uses the `•` operator, which is defined for morphisms in preadditive categories.\n\n5. **Theorem Statement**:\n   - The goal is to prove that `f ≫ (n • g) = n • (f ≫ g)`. This is a statement about the interaction between composition and scalar multiplication in a preadditive category.\n   - The theorem is named `comp_nsmul_extracted`, and it takes as arguments the category `C`, the morphisms `f` and `g`, and the natural number `n`.\n\n6. **Lean Syntax and Libraries**:\n   - The `import Mathlib`"}
{"source_file": "herald_data/sample_500.jsonl", "line": 111, "id": 574210, "informal_statement": "$(a+c)^2>4ac \\implies (a+c)^{2008}>(4ac)^{1004}=2^{2008}\\cdot a^{1004}c^{1004}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_574210 (a c : ℝ) (h : (a + c) ^ 2 > 4 * a * c) :\n  (a + c) ^ 2008 > (4 * a * c) ^ 1004   :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a series of steps that involve understanding the mathematical concepts and how they are expressed in Lean's syntax and libraries. Here's a detailed breakdown of the translation process:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves variables \\(a\\) and \\(c\\), which are real numbers. In Lean, real numbers are represented by the type `ℝ`.\n\n2. **Understand the Mathematical Implication**:\n   - The statement is an implication: if \\((a+c)^2 > 4ac\\), then \\((a+c)^{2008} > (4ac)^{1004}\\).\n   - In Lean, implications are expressed using the `→` symbol.\n\n3. **Translate the Hypothesis**:\n   - The hypothesis \\((a+c)^2 > 4ac\\) is straightforward to translate. In Lean, addition and multiplication are expressed using `+` and `*`, and exponentiation is expressed using `^`.\n   - Thus, \\((a+c)^2 > 4ac\\) becomes `(a + c) ^ 2 > 4 * a * c`.\n\n4. **Translate the Conclusion**:\n   - The conclusion \\((a+c)^{2008} > (4ac)^{1004}\\) is similarly translated using the same operators: `(a + c) ^ 2008 > (4 * a * c) ^ 1004`.\n\n5. **Structure the Theorem**:\n   - In Lean, a theorem is declared using the `theorem` keyword, followed by the name of the theorem, the parameters, and the hypothesis.\n   - The parameters `(a c : ℝ)` indicate that \\(a\\) and \\(c\\) are real numbers.\n   - The hypothesis `(h : (a + c) ^ 2 > 4 * a * c)` is included as a premise of the theorem.\n\n6. **Express the Conclusion**:\n   - The conclusion of the theorem is written after the colon `:`, which is the implication we derived: `(a + c) ^ 2008 > (4 * a * c) ^ 1004`.\n\n7. **Use of Libraries**:\n   - The `import Mathlib` statement indicates that we are using the Mathlib library, which provides a wide range of mathematical tools and theorems.\n   -"}
{"source_file": "herald_data/sample_500.jsonl", "line": 110, "id": 120120, "informal_statement": "For any group $\\alpha$ with decidable equality, and for any element $a \\in \\alpha$ and any finite set $s \\subseteq \\alpha$, show that the inverse of the scalar multiplication of $a$ with the set $s$ equals the scalar multiplication of the inverse of $a$ with the inverse of the set $s$, i.e., $(a \\cdot s)^{-1} = a^{-1} \\cdot s^{-1}$.", "formal_statement": "import Mathlib\nopen Function MulOpposite\nopen scoped Pointwise\nopen Pointwise\nopen Pointwise\nopen Pointwise\nopen Pointwise\nopen Pointwise\nopen Pointwise\nopen scoped symmDiff in\nlemma inv_op_smul_finset_distrib_tac_59835 [Group α] [DecidableEq α] (a : α) (s : Finset α) : (op a • s)⁻¹ = a⁻¹ • s⁻¹ := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: \n   - The statement involves a group $\\alpha$ with decidable equality, an element $a \\in \\alpha$, and a finite set $s \\subseteq \\alpha$. In Lean, groups are typically represented by a type with a `Group` typeclass, and decidable equality is represented by the `DecidableEq` typeclass. Finite sets are represented by `Finset`.\n\n2. **Translate the Group and Decidable Equality**:\n   - The type `α` is declared with the `Group α` typeclass, indicating that `α` is a group. \n   - `[DecidableEq α]` indicates that equality on `α` is decidable, which is necessary for operations on finite sets.\n\n3. **Translate the Elements and Sets**:\n   - The element $a \\in \\alpha$ is represented as `(a : α)`.\n   - The finite set $s \\subseteq \\alpha$ is represented as `(s : Finset α)`.\n\n4. **Translate the Operations**:\n   - The operation $a \\cdot s$ is a scalar multiplication of the set $s$ by the element $a$. In Lean, this is represented using the `•` operator, which is defined in the context of pointwise operations on sets.\n   - The inverse of a set, $s^{-1}$, is represented by `s⁻¹`, which is a pointwise operation that takes the inverse of each element in the set.\n\n5. **Translate the Inverse and Scalar Multiplication**:\n   - The inverse of the scalar multiplication, $(a \\cdot s)^{-1}$, is represented as `(op a • s)⁻¹`. Here, `op a` is used to denote the opposite element in the group, which is necessary for certain group operations in Lean.\n   - The scalar multiplication of the inverse, $a^{-1} \\cdot s^{-1}$, is represented as `a⁻¹ • s⁻¹`.\n\n6. **Formalize the Lemma**:\n   - The lemma is named `inv_op_smul_finset_distrib_tac_59835`, which is a unique identifier for this specific result.\n   - The statement of the lemma is `(op a • s)⁻"}
{"source_file": "herald_data/sample_500.jsonl", "line": 112, "id": 279790, "informal_statement": "For a finite set $s$ of natural numbers, a prime number $p$, and any natural numbers $e$ and $m$ with $m \\neq 0$, if $p$ is not in the set $s$ and every prime factor $p$ of $m$ is in $s$, then $p$ is not a prime factor of $m$.", "formal_statement": "import Mathlib\nopen List Perm in\nlemma equivProdNatFactoredNumbers_tac_11589 (s : Finset ℕ) (p : ℕ) (hp : Prime p) (hs : p ∉ s) (e : ℕ) (m : ℕ) (hm₀ : m ≠ 0) (hm : ∀ p ∈ m.primeFactorsList, p ∈ s) : p ∉ m.primeFactorsList := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Finite Set of Natural Numbers**: \n   - The informal statement mentions a \"finite set $s$ of natural numbers.\" In Lean, finite sets of natural numbers are represented using `Finset ℕ`. The variable `s` is declared as `s : Finset ℕ`, indicating that `s` is a finite set of natural numbers.\n\n2. **Prime Number $p$**:\n   - The informal statement refers to a \"prime number $p$.\" In Lean, a natural number is specified as prime using the `Prime` predicate. The variable `p` is declared as `p : ℕ` and the hypothesis `hp : Prime p` asserts that `p` is a prime number.\n\n3. **Condition $p \\notin s$**:\n   - The condition \"if $p$ is not in the set $s$\" is represented by the hypothesis `hs : p ∉ s` in Lean. This uses the `∉` operator to denote that `p` is not an element of the set `s`.\n\n4. **Natural Numbers $e$ and $m$ with $m \\neq 0$**:\n   - The informal statement includes \"any natural numbers $e$ and $m$ with $m \\neq 0$.\" In Lean, these are declared as `e : ℕ` and `m : ℕ`, with the additional condition `hm₀ : m ≠ 0` to ensure that $m$ is non-zero.\n\n5. **Prime Factors of $m$**:\n   - The statement \"every prime factor $p$ of $m$ is in $s$\" is formalized using the hypothesis `hm : ∀ p ∈ m.primeFactorsList, p ∈ s`. Here, `m.primeFactorsList` is a function that returns the list of prime factors of $m$. The hypothesis asserts that for every prime factor `p` in this list, `p` must be an element of the set `s`.\n\n6. **Conclusion $p$ is not a prime factor of $m$**:\n   - The conclusion \"then $p$ is not a prime factor of $m$\""}
{"source_file": "herald_data/sample_500.jsonl", "line": 115, "id": 307761, "informal_statement": "For any natural numbers $m$ and $n$, and for any $i \\in \\text{Fin}(m \\times n)$, assuming that $i \\mod n + 1 \\leq n$ and $i \\div n < m$, show that the expression $(m \\times n - (i \\div n \\times n + (i \\mod n + 1))) \\mod n$ is equal to itself, i.e., $(m \\times n - (i \\div n \\times n + (i \\mod n + 1))) \\mod n = (m \\times n - (i \\div n \\times n + (i \\mod n + 1))) \\mod n$.", "formal_statement": "import Mathlib\nopen Fin Nat Function\nlemma modNat_rev_tac_57480 (n : ℕ) (m : ℕ) (i : Fin (m * n)) (H₁ : ↑i % n + 1 ≤ n) (H₂ : ↑i / n < m) : (m * n - (↑i / n * n + (↑i % n + 1))) % n = (m * n - (↑i / n * n + (↑i % n + 1))) % n := sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow a series of steps that map the mathematical concepts and operations into their corresponding Lean constructs. Here's how the translation is achieved:\n\n1. **Understanding the Context**: \n   - The statement involves natural numbers \\( m \\) and \\( n \\), and an index \\( i \\) which is an element of the finite type \\(\\text{Fin}(m \\times n)\\). This means \\( i \\) is a natural number less than \\( m \\times n \\).\n\n2. **Translating the Types**:\n   - In Lean, natural numbers are represented by `ℕ`.\n   - The type `Fin (m * n)` represents natural numbers less than \\( m \\times n \\). This is directly translated to `Fin (m * n)` in Lean.\n\n3. **Translating the Assumptions**:\n   - The assumption \\( i \\mod n + 1 \\leq n \\) is translated to `↑i % n + 1 ≤ n`. Here, `↑i` is used to coerce the finite type `i` to a natural number, and `%` is the modulus operation.\n   - The assumption \\( i \\div n < m \\) is translated to `↑i / n < m`. The division operation is represented by `/`.\n\n4. **Translating the Expression**:\n   - The expression \\((m \\times n - (i \\div n \\times n + (i \\mod n + 1))) \\mod n\\) is translated to `(m * n - (↑i / n * n + (↑i % n + 1))) % n`.\n   - The operations `*`, `+`, `-`, and `%` are directly used in Lean as they are standard arithmetic operations.\n\n5. **Formulating the Lemma**:\n   - The lemma is named `modNat_rev_tac_57480`, which is a placeholder name and can be changed to something more descriptive.\n   - The lemma takes parameters `n`, `m`, and `i` with their respective types.\n   - The assumptions are included as hypotheses `H₁` and `H₂`.\n   - The goal is to show that the expression is equal to itself, which is trivially true. In Lean, this is expressed as an equality between the two identical expressions.\n\n6. **Using `sorry`"}
{"source_file": "herald_data/sample_500.jsonl", "line": 113, "id": 359650, "informal_statement": "For finite sets $X$ and $Y$, $X \\subseteq Y \\iff \\forall z (z \\in X \\implies z \\in Y)$.", "formal_statement": "import Mathlib\nopen Function (OfArity)\ntheorem subset_iff {x y : PSet} : x ⊆ y ↔ ∀ ⦃z⦄, z ∈ x → z ∈ y := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to break down the components of the statement and map them to their corresponding Lean constructs.\n\n1. **Understanding the Informal Statement**:\n   - The statement is about finite sets \\( X \\) and \\( Y \\).\n   - It asserts that \\( X \\subseteq Y \\) if and only if for every element \\( z \\), if \\( z \\) is in \\( X \\), then \\( z \\) is also in \\( Y \\).\n\n2. **Lean4 Constructs**:\n   - In Lean, sets are often represented using types and predicates. Here, `PSet` is used, which is a type representing sets.\n   - The subset relation \\( X \\subseteq Y \\) is represented as `x ⊆ y` in Lean.\n   - The universal quantifier \\(\\forall\\) is represented using `∀` in Lean.\n   - Implication \\( \\implies \\) is represented as `→` in Lean.\n\n3. **Formalizing the Statement**:\n   - The theorem is named `subset_iff`, indicating it is about the equivalence (iff) of subset relations.\n   - The parameters `x` and `y` are declared as sets of type `PSet`, which corresponds to the finite sets \\( X \\) and \\( Y \\) in the informal statement.\n   - The statement `x ⊆ y ↔ ∀ ⦃z⦄, z ∈ x → z ∈ y` directly translates the informal statement:\n     - `x ⊆ y` corresponds to \\( X \\subseteq Y \\).\n     - `↔` is the logical biconditional, representing \"if and only if\".\n     - `∀ ⦃z⦄, z ∈ x → z ∈ y` translates to \\(\\forall z (z \\in X \\implies z \\in Y)\\):\n       - `∀ ⦃z⦄` introduces a universally quantified variable `z`.\n       - `z ∈ x` and `z ∈ y` represent the membership of `z` in the sets `x` and `y`, respectively.\n       - `→` represents the implication.\n\n4. **Additional Context**:\n   - The `import Mathlib` statement is used to bring in necessary libraries that define `PSet` and other set operations.\n   - `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 117, "id": 165844, "informal_statement": "For any function \\( f : \\beta \\to \\beta \\), any element \\( b \\in \\beta \\), any element \\( a \\in \\alpha \\), and any list \\( l \\) of elements in \\( \\alpha \\), show that applying \\( f \\) to \\( b \\) iteratively \\( l.\\text{length} \\) times is equal to applying \\( f \\) to the result of applying \\( f \\) to \\( b \\) iteratively \\( l.\\text{length} \\) times, i.e., \\( f^{l.\\text{length}}(b) = f^{l.\\text{length}}(f^{l.\\text{length}}(b)) \\).", "formal_statement": "import Mathlib\nopen Function (Commute)\nopen Function\nlemma foldr_const_tac_7430 (f : β → β) (b : β) (a : α) (l : List α) : f (f^[l.length] b) = f (f^[l.length] b) := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down the components of the statement and understand how they map to Lean constructs:\n\n1. **Understanding the Informal Statement:**\n   - We are given a function \\( f : \\beta \\to \\beta \\).\n   - We have an element \\( b \\in \\beta \\).\n   - We have an element \\( a \\in \\alpha \\) and a list \\( l \\) of elements in \\( \\alpha \\).\n   - The goal is to show that applying \\( f \\) iteratively \\( l.\\text{length} \\) times to \\( b \\) results in the same value as applying \\( f \\) to the result of applying \\( f \\) iteratively \\( l.\\text{length} \\) times to \\( b \\).\n\n2. **Translating Components to Lean:**\n   - **Function \\( f : \\beta \\to \\beta \\):** This is directly translated as a function type in Lean, `f : β → β`.\n   - **Element \\( b \\in \\beta \\):** This is represented as a variable `b : β`.\n   - **Element \\( a \\in \\alpha \\):** This is represented as a variable `a : α`. Although it is mentioned, it does not play a role in the equality we need to prove.\n   - **List \\( l \\) of elements in \\( \\alpha \\):** This is represented as `l : List α`. The length of this list, `l.length`, is used to determine how many times the function \\( f \\) is applied.\n\n3. **Iterative Application of Function:**\n   - The notation \\( f^{l.\\text{length}}(b) \\) represents applying the function \\( f \\) iteratively \\( l.\\text{length} \\) times to \\( b \\).\n   - In Lean, this is expressed using the `Function.iterate` notation, which is abbreviated as `f^[n]` for applying `f` `n` times. Thus, `f^[l.length] b` represents applying `f` iteratively `l.length` times to `b`.\n\n4. **Formalizing the Goal:**\n   - The informal goal is to show that \\( f^{l.\\text{length}}(b) = f^{l.\\text{length}}(f^{l.\\text{length}}(b"}
{"source_file": "herald_data/sample_500.jsonl", "line": 119, "id": 3402, "informal_statement": "Show that the canonical map from the real numbers $\\mathbb{R}$ to the additive circle $AddCircle\\ a$, denoted as $(\\uparrow) : \\mathbb{R} \\to AddCircle\\ a$, is measurable.", "formal_statement": "import Mathlib\nopen Set Function MeasureTheory MeasureTheory.Measure TopologicalSpace AddSubgroup intervalIntegral\nopen scoped MeasureTheory NNReal ENNReal\ntheorem measurable_mk'_extracted {a : ℝ} : Measurable QuotientAddGroup.mk := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand the components involved in both the informal and formal statements and how they correspond to each other.\n\n1. **Understanding the Informal Statement:**\n   - The informal statement involves a map from the real numbers \\(\\mathbb{R}\\) to the additive circle \\(AddCircle\\ a\\).\n   - The additive circle \\(AddCircle\\ a\\) can be thought of as the quotient of \\(\\mathbb{R}\\) by the subgroup \\(a\\mathbb{Z}\\), where \\(a\\) is a fixed real number. This is similar to considering the real numbers modulo \\(a\\).\n   - The map \\((\\uparrow) : \\mathbb{R} \\to AddCircle\\ a\\) is the canonical projection map, which sends each real number to its equivalence class in the quotient space.\n   - The goal is to show that this map is measurable, meaning it is compatible with the structure of \\(\\sigma\\)-algebras on \\(\\mathbb{R}\\) and \\(AddCircle\\ a\\).\n\n2. **Understanding the Formal Statement:**\n   - The Lean code imports necessary libraries for measure theory and topological spaces, which are essential for discussing measurability.\n   - The theorem `measurable_mk'_extracted` is stated for a fixed real number \\(a\\).\n   - `QuotientAddGroup.mk` is the Lean function representing the canonical map from \\(\\mathbb{R}\\) to the quotient group, which in this context is the additive circle \\(AddCircle\\ a\\).\n   - The theorem asserts that `QuotientAddGroup.mk` is `Measurable`, which directly corresponds to the requirement that the map is measurable.\n\n3. **Translation Steps:**\n   - **Identify the Map:** Recognize that the map \\((\\uparrow)\\) in the informal statement is represented by `QuotientAddGroup.mk` in Lean. This function handles the projection from \\(\\mathbb{R}\\) to the quotient space.\n   - **Define the Target Space:** Understand that \\(AddCircle\\ a\\) is modeled as a quotient group in Lean, specifically using `QuotientAddGroup` to handle the equivalence relation defined by the subgroup \\(a\\mathbb{Z}\\).\n   - **Measurability:** The property of being measurable is"}
{"source_file": "herald_data/sample_500.jsonl", "line": 116, "id": 466916, "informal_statement": "Prove that for all positive real numbers $u$, $v$, $w$ such that $u + v + w = 1$ and $0 < a \\leq 1$, the following inequality holds:\\n\\n$\\left(\\frac{1}{u}-a\\right)\\left(\\frac{1}{v}-a\\right)\\left(\\frac{1}{w}-a\\right) \\geq 27-27a+9a^2-a^3$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_466916 (u v w a : ℝ) (huv : u + v + w = 1) (hu : 0 < u) (hv : 0 < v) (hw : 0 < w) (h1 : 0 < a ∧ a ≤ 1) : (1 / u - a) * (1 / v - a) * (1 / w - a) ≥ 27 - 27 * a + 9 * a ^ 2 - a ^ 3  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to carefully map each component of the statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Variables and Assumptions:**\n   - The informal statement involves four variables: \\( u, v, w, \\) and \\( a \\), all of which are positive real numbers.\n   - The condition \\( u + v + w = 1 \\) is given, along with \\( 0 < a \\leq 1 \\).\n\n2. **Defining the Variables in Lean:**\n   - In Lean, we declare the variables \\( u, v, w, \\) and \\( a \\) as real numbers using the type `ℝ`.\n   - The assumptions about these variables are expressed as hypotheses in the theorem.\n\n3. **Expressing the Conditions:**\n   - The condition \\( u + v + w = 1 \\) is directly translated to `huv : u + v + w = 1`.\n   - The positivity conditions \\( 0 < u \\), \\( 0 < v \\), and \\( 0 < w \\) are translated to `hu : 0 < u`, `hv : 0 < v`, and `hw : 0 < w`.\n   - The condition \\( 0 < a \\leq 1 \\) is expressed as a conjunction `h1 : 0 < a ∧ a ≤ 1`.\n\n4. **Formulating the Inequality:**\n   - The inequality \\(\\left(\\frac{1}{u}-a\\right)\\left(\\frac{1}{v}-a\\right)\\left(\\frac{1}{w}-a\\right) \\geq 27-27a+9a^2-a^3\\) is directly translated into Lean as:\n     ```lean\n     (1 / u - a) * (1 / v - a) * (1 / w - a) ≥ 27 - 27 * a + 9 * a ^ 2 - a ^ 3\n     ```\n   - The operators `*` and `-` are used for multiplication and subtraction, respectively, and `^` is used for exponentiation.\n\n5. **Structuring the Theorem:**\n   - The theorem is named `extract_aug_466916`, which is a placeholder name and can be replaced with a more descriptive"}
{"source_file": "herald_data/sample_500.jsonl", "line": 114, "id": 116974, "informal_statement": "For any category $\\mathcal{C}$ with zero morphisms, objects $X, Y, Z \\in \\mathcal{C}$, a morphism $f : X \\to Y$, and another morphism $h : Y \\to Z$, given that the kernel of $f$ and the kernel of the composition $f \\circ h$ exist, show that the composition of the arrow of the subobject kernel of $f$, with $f$ and then with $h$, is equal to the zero morphism, i.e., $(\\text{kernelSubobject } f).arrow \\circ f \\circ h = 0$.", "formal_statement": "import Mathlib\nopen CategoryTheory CategoryTheory.Category CategoryTheory.Limits CategoryTheory.Subobject Opposite\nlemma kernelSubobject_comp_le_tac_7768 [Category.{v, u} C] (X : C) (Y : C) [HasZeroMorphisms C] (f : X ⟶ Y) [HasKernel f] (Z : C) (h : Y ⟶ Z) [HasKernel (f ≫ h)] : (kernelSubobject f).arrow ≫ f ≫ h = 0 := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that involves understanding both the mathematical concepts and how they are represented in Lean's category theory library. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context**:\n   - We are working within the framework of category theory, specifically in a category $\\mathcal{C}$ that has zero morphisms. This means that for any two objects in the category, there is a distinguished morphism between them called the zero morphism, which acts as an additive identity in the hom-sets.\n\n2. **Identifying the Objects and Morphisms**:\n   - We have three objects $X, Y, Z \\in \\mathcal{C}$.\n   - There are two morphisms: $f : X \\to Y$ and $h : Y \\to Z$.\n\n3. **Kernel and Composition**:\n   - The statement involves the kernel of a morphism, which is a concept in category theory representing a universal morphism that factors through any morphism that composes to zero with the given morphism.\n   - We are given that the kernel of $f$ and the kernel of the composition $f \\circ h$ exist.\n\n4. **Subobject Kernel**:\n   - The subobject kernel of a morphism $f$, denoted as $\\text{kernelSubobject } f$, is a specific representation of the kernel as a subobject in the category. It has an associated arrow, denoted as $(\\text{kernelSubobject } f).arrow$, which is the morphism from the kernel object to the domain of $f$.\n\n5. **Formalizing the Statement**:\n   - The goal is to show that the composition of the arrow of the subobject kernel of $f$, with $f$, and then with $h$, results in the zero morphism. This is expressed as $(\\text{kernelSubobject } f).arrow \\circ f \\circ h = 0$.\n\n6. **Lean4 Code Explanation**:\n   - `import Mathlib`: Import the Mathlib library, which contains the necessary category theory constructs.\n   - `open CategoryTheory ...`: Open the relevant namespaces to access category theory definitions and notations.\n   - `lemma kernelSubobject_comp_le_tac_7768`: Define a lemma with a descriptive name indicating the result about kernel subobject composition."}
{"source_file": "herald_data/sample_500.jsonl", "line": 118, "id": 486821, "informal_statement": "Given $a \\ge b \\ge c$, prove that $(a-b)^2(a+c-b) + (b-c)^2(b+a-c) + (c-a)^2(c+b-a) \\ge 0$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_486821 (a b c : ℝ) (h₁ : a ≥ b ∧ b ≥ c) :\n  (a - b) ^ 2 * (a + c - b) + (b - c) ^ 2 * (b + a - c) + (c - a) ^ 2 * (c + b - a) ≥ 0  :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach:\n\n1. **Identify the Variables and Their Types**:\n   - The variables involved are \\(a\\), \\(b\\), and \\(c\\), which are real numbers. In Lean, real numbers are represented by `ℝ`.\n\n2. **State the Given Conditions**:\n   - The condition \\(a \\ge b \\ge c\\) is expressed as two inequalities: \\(a \\ge b\\) and \\(b \\ge c\\). In Lean, this is represented using the `≥` operator, and the conjunction of these conditions is expressed using `∧`.\n\n3. **Express the Inequality to Prove**:\n   - The expression \\((a-b)^2(a+c-b) + (b-c)^2(b+a-c) + (c-a)^2(c+b-a) \\ge 0\\) is a mathematical inequality. In Lean, the `^` operator is used for exponentiation, and `≥` is used for the inequality.\n\n4. **Structure the Theorem**:\n   - The theorem is named `extract_aug_486821`, which is a unique identifier for this specific theorem.\n   - The theorem takes three arguments \\(a\\), \\(b\\), and \\(c\\) of type `ℝ`, and a hypothesis `h₁` which is a conjunction of the inequalities \\(a \\ge b\\) and \\(b \\ge c`.\n   - The goal is to prove that the given expression is non-negative.\n\n5. **Use of Lean Syntax**:\n   - The `theorem` keyword is used to define a theorem.\n   - The `:` symbol separates the theorem's name and parameters from its statement.\n   - The `by sorry` part indicates that the proof is not provided, which is common in formalizations when the focus is on the statement rather than the proof itself.\n\n6. **Import Necessary Libraries**:\n   - The `import Mathlib` statement is used to include the necessary mathematical libraries that provide definitions and theorems for real numbers and inequalities.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to bring relevant definitions and notations into scope, although not all may be directly necessary for this specific theorem.\n\nBy following these steps, the informal statement is accurately translated into a formal Lean4 theorem, capturing the essence of"}
{"source_file": "herald_data/sample_500.jsonl", "line": 120, "id": 276187, "informal_statement": "For any commutative ring \\( R \\) and any quaternion \\( a \\) in \\( \\mathbb{H}[R] \\), show that the real part of the product \\( a \\cdot \\overline{a} \\) is equal to itself, i.e., \\(\\mathrm{Re}(a \\cdot \\overline{a}) = \\mathrm{Re}(a \\cdot \\overline{a})\\).", "formal_statement": "import Mathlib\nopen Quaternion\nopen MulOpposite\nopen MulOpposite\nlemma self_mul_star_tac_35277 [CommRing R] (a : ℍ[R]) : ↑(a * star a).re = ↑(a * star a).re := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: \n   - The statement involves a commutative ring \\( R \\) and quaternions over \\( R \\), denoted as \\( \\mathbb{H}[R] \\). In Lean, this is represented by `CommRing R` for the commutative ring and `ℍ[R]` for the quaternions over \\( R \\).\n\n2. **Understand the Operations**:\n   - The operation \\( a \\cdot \\overline{a} \\) involves quaternion multiplication and the conjugate (denoted as `star` in Lean). The real part of a quaternion is accessed using `.re`.\n\n3. **Formalize the Statement**:\n   - The informal statement asks to show that the real part of the product \\( a \\cdot \\overline{a} \\) is equal to itself. This is a tautology in logic, as any expression is equal to itself. In Lean, this is expressed as `↑(a * star a).re = ↑(a * star a).re`.\n\n4. **Structure the Lean Code**:\n   - Import necessary modules: `Mathlib` is imported to access mathematical structures and operations.\n   - Open relevant namespaces: `Quaternion` and `MulOpposite` are opened to use quaternion operations and handle multiplicative opposites if needed.\n   - Define the lemma: The lemma is named `self_mul_star_tac_35277`, which is a unique identifier. It states that for any quaternion `a` in `ℍ[R]`, the real part of `a * star a` is equal to itself.\n\n5. **Use of `sorry`**:\n   - The `sorry` keyword is used as a placeholder for the proof. Since the statement is trivially true (a tautology), the proof is omitted, and `sorry` indicates that the proof is not provided.\n\nBy following these steps, the informal statement is accurately translated into a formal Lean4 statement, capturing the essence of the mathematical assertion."}
{"source_file": "herald_data/sample_500.jsonl", "line": 121, "id": 536027, "informal_statement": "For a positive reals $ x_{1},...,x_{n} $ prove inequlity: $ \\frac{1}{x_{1}+1}+...+\\frac{1}{x_{n}+1}\\le \\frac{n}{1+\\frac{n}{\\frac{1}{x_{1}}+...+\\frac{1}{x_{n}}}}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_536027 (n : ℕ) (x : ℕ → ℝ) (hx: ∀ i, 0 < x i) : (∑ i in Finset.range n, 1/(x i + 1)) ≤ n / (1 + n / (∑ i in Finset.range n, 1 / x i))   :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to break down the components of the statement and understand how they map to Lean's syntax and libraries.\n\n1. **Understanding the Context**: \n   - The informal statement involves a sequence of positive real numbers \\( x_1, \\ldots, x_n \\) and an inequality involving sums and reciprocals. \n   - The goal is to prove an inequality for these numbers.\n\n2. **Lean Imports and Setup**:\n   - `import Mathlib`: This imports the Mathlib library, which contains a wide range of mathematical tools and theorems.\n   - `open BigOperators`: This allows the use of the `∑` notation for sums, which is crucial for expressing the summations in the inequality.\n   - `open Real Nat Topology`: These open the namespaces for real numbers, natural numbers, and topology, providing access to relevant functions and theorems.\n\n3. **Defining the Theorem**:\n   - `theorem extract_aug_536027`: This declares a new theorem named `extract_aug_536027`. The name is arbitrary and can be chosen to reflect the content or context of the theorem.\n   - `(n : ℕ)`: This specifies that \\( n \\) is a natural number, representing the number of terms in the sequence.\n   - `(x : ℕ → ℝ)`: This defines \\( x \\) as a function from natural numbers to real numbers, representing the sequence \\( x_1, \\ldots, x_n \\).\n   - `(hx: ∀ i, 0 < x i)`: This is a hypothesis stating that for all indices \\( i \\), the corresponding \\( x_i \\) is positive. This matches the condition that the numbers are positive reals.\n\n4. **Formalizing the Inequality**:\n   - `∑ i in Finset.range n, 1/(x i + 1)`: This represents the left-hand side of the inequality, which is the sum of \\( \\frac{1}{x_i + 1} \\) for \\( i \\) from 0 to \\( n-1 \\). `Finset.range n` generates the set of indices from 0 to \\( n-1 \\).\n   - `≤`: This is the less than or equal to symbol, representing the inequality.\n   - `n / (1 + n / (∑"}
{"source_file": "herald_data/sample_500.jsonl", "line": 122, "id": 187334, "informal_statement": "For any natural number $N$ such that $4096 \\leq N$, and given the inequality $12 \\cdot \\log 2 \\leq \\log N$, show that $2 < 2^1$.", "formal_statement": "import Mathlib\nopen Nat hiding log\nopen Finset Metric Real\nopen scoped Pointwise\nopen scoped Filter Topology\nopen Real\nlemma le_sqrt_log_tac_13029 (N : ℕ) (hN : 4096 ≤ N) (this : ↑12 * log 2 ≤ log ↑N) : 2 < rexp 1 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a series of logical steps that map the components of the informal statement to their formal counterparts in Lean. Here's the breakdown:\n\n1. **Understanding the Context**:\n   - The informal statement involves natural numbers, logarithms, and an inequality. The goal is to show a specific inequality involving exponentiation.\n\n2. **Identifying the Variables**:\n   - The informal statement mentions a natural number \\( N \\). In Lean, this is represented as `(N : ℕ)`, indicating that \\( N \\) is a natural number.\n\n3. **Translating the Conditions**:\n   - The condition \\( 4096 \\leq N \\) is directly translated to `(hN : 4096 ≤ N)`. Here, `hN` is a hypothesis that \\( N \\) is at least 4096.\n   - The inequality \\( 12 \\cdot \\log 2 \\leq \\log N \\) is translated to `(this : ↑12 * log 2 ≤ log ↑N)`. In Lean, `↑12` and `↑N` are used to lift the natural numbers to real numbers, as logarithms in Lean are typically defined for real numbers. `log` is the natural logarithm function.\n\n4. **Understanding the Goal**:\n   - The goal is to show \\( 2 < 2^1 \\). In Lean, this is expressed as `2 < rexp 1`. The function `rexp` is used to denote the real exponentiation function, which is consistent with the context of real numbers and logarithms.\n\n5. **Structuring the Lemma**:\n   - The lemma is named `le_sqrt_log_tac_13029`, which is a unique identifier for this particular statement.\n   - The lemma takes three arguments: `N`, `hN`, and `this`, which correspond to the natural number \\( N \\), the condition \\( 4096 \\leq N \\), and the inequality \\( 12 \\cdot \\log 2 \\leq \\log N \\), respectively.\n   - The conclusion of the lemma is `2 < rexp 1`, which is the formal statement of the goal.\n\n6. **Using Lean's Libraries**:\n   - The imports at the beginning (`import Mathlib`) and the various `open` statements are used to bring necessary mathematical functions and"}
{"source_file": "herald_data/sample_500.jsonl", "line": 123, "id": 543473, "informal_statement": "Let $a, b, c, d$ be real numbers such that $(a-b)(b-c)(c-d)(d-a)=-3$ and $a^2+b^2+c^2+d^2=14$. Prove that $(a+c)(b+d)\\leq 8$. Equality holds when $a=-2,b=-1,c=0,d=-3$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_543473 (a b c d : ℝ) (h1 : (a - b) * (b - c) * (c - d) * (d - a) = -3) (h2 : a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = 14) : (a + c) * (b + d) ≤ 8   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow a structured approach to formalize each component of the problem. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves four real numbers: \\(a\\), \\(b\\), \\(c\\), and \\(d\\). In Lean, these are represented as variables of type `ℝ` (the type for real numbers in Lean).\n\n2. **State the Given Conditions**:\n   - The first condition is \\((a-b)(b-c)(c-d)(d-a) = -3\\). In Lean, this is expressed using the multiplication operator `*` and subtraction `-`. The condition is written as `(a - b) * (b - c) * (c - d) * (d - a) = -3`.\n   - The second condition is \\(a^2 + b^2 + c^2 + d^2 = 14\\). In Lean, exponentiation is denoted by `^`, and addition is `+`. This condition is written as `a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = 14`.\n\n3. **State the Conclusion to Prove**:\n   - The goal is to prove \\((a+c)(b+d) \\leq 8\\). In Lean, this is expressed using the multiplication operator `*` and the less than or equal to operator `≤`. The conclusion is written as `(a + c) * (b + d) ≤ 8`.\n\n4. **Structure the Theorem**:\n   - The theorem is named `extract_aug_543473`, which is a unique identifier for this specific theorem.\n   - The theorem takes four real numbers \\(a\\), \\(b\\), \\(c\\), and \\(d\\) as inputs, along with the two conditions `h1` and `h2` as hypotheses.\n   - The theorem statement is structured as follows:\n     ```lean\n     theorem extract_aug_543473 (a b c d : ℝ) \n       (h1 : (a - b) * (b - c) * (c - d) * (d - a) = -3) \n       (h2 : a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 ="}
{"source_file": "herald_data/sample_500.jsonl", "line": 126, "id": 543454, "informal_statement": "Solve in R : \\n\\n $ x + y + xy = - 4$ \\n\\n $ y + z + yz = 11$ \\n\\n $ z + x + zx = - 5$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_543454 (x y z : ℝ) : x + y + x*y = -4 ∧ y + z + y*z = 11 ∧ z + x + z*x = -5 ↔ x = -3 ∧ y = 2 ∧ z = 1   :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Problem**: The informal statement presents a system of three equations involving three real variables \\( x, y, \\) and \\( z \\). The goal is to find the values of these variables that satisfy all three equations simultaneously.\n\n2. **Identifying the Variables and Domain**: The variables \\( x, y, \\) and \\( z \\) are specified to be real numbers, which is denoted by \\( \\mathbb{R} \\) in mathematics. In Lean, this is represented by the type `ℝ`.\n\n3. **Translating the Equations**: Each equation in the system is translated directly into Lean syntax:\n   - The first equation \\( x + y + xy = -4 \\) is written as `x + y + x*y = -4`.\n   - The second equation \\( y + z + yz = 11 \\) is written as `y + z + y*z = 11`.\n   - The third equation \\( z + x + zx = -5 \\) is written as `z + x + z*x = -5`.\n\n4. **Combining the Equations**: The conjunction of these three equations is expressed using the logical `∧` (and) operator in Lean. Thus, the system of equations is represented as:\n   ```lean\n   x + y + x*y = -4 ∧ y + z + y*z = 11 ∧ z + x + z*x = -5\n   ```\n\n5. **Expressing the Solution**: The solution to the system is given as specific values for \\( x, y, \\) and \\( z \\). In Lean, this is expressed as:\n   ```lean\n   x = -3 ∧ y = 2 ∧ z = 1\n   ```\n\n6. **Formulating the Theorem**: The goal is to prove that the system of equations is equivalent to the specific solution. This is expressed as a bi-conditional (if and only if) statement using the `↔` operator in Lean:\n   ```lean\n   x + y + x*y = -4 ∧ y + z + y*z = 11 ∧ z + x + z*x = -5 ↔ x = -3 ∧ y = 2 ∧ z = 1"}
{"source_file": "herald_data/sample_500.jsonl", "line": 125, "id": 312946, "informal_statement": "For any commutative monoid \\(\\alpha\\), given two multisets \\(s, z \\in \\alpha\\), if \\(s\\) is less than or equal to \\(s + z\\) (under multiset ordering), then the product of elements in \\(s\\) divides the product of elements in \\(s + z\\), i.e., \\(s.\\prod \\mid (s + z).\\prod\\).", "formal_statement": "import Mathlib\n\nlemma prod_dvd_prod_of_le_tac_7264 [CommMonoid α] (s : Multiset α) (z : Multiset α) (h : s ≤ s + z) : s.prod ∣ (s + z).prod := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: \n   - The informal statement involves a \"commutative monoid\" and \"multisets\". In Lean, a commutative monoid is represented by the type class `CommMonoid α`, where `α` is the type of elements in the monoid. Multisets are collections of elements that allow for multiple occurrences of the same element and are represented by `Multiset α`.\n\n2. **Define the Variables**:\n   - The informal statement mentions two multisets, \\(s\\) and \\(z\\). In Lean, these are represented as `s : Multiset α` and `z : Multiset α`, indicating that both `s` and `z` are multisets of elements of type `α`.\n\n3. **Express the Condition**:\n   - The condition given is \\(s \\leq s + z\\) under multiset ordering. In Lean, this is expressed as `h : s ≤ s + z`. The `≤` operator for multisets in Lean represents the multiset inclusion, meaning every element of `s` is also in `s + z` with at least the same multiplicity.\n\n4. **State the Conclusion**:\n   - The conclusion is that the product of elements in \\(s\\) divides the product of elements in \\(s + z\\). In Lean, the product of elements in a multiset `s` is written as `s.prod`. The divisibility condition is expressed using the `∣` operator, so `s.prod ∣ (s + z).prod` means the product of `s` divides the product of `s + z`.\n\n5. **Formulate the Lemma**:\n   - The lemma is named `prod_dvd_prod_of_le_tac_7264`, which is a unique identifier for this specific result. The lemma takes as input a commutative monoid `α`, two multisets `s` and `z`, and a hypothesis `h` that `s ≤ s + z`. The conclusion is that `s.prod ∣ (s + z).prod`.\n\n6. **Use of `sorry`**:\n   - The `:= sorry` at the end of the lemma indicates that the proof is not provided. In Lean, `sorry` is a placeholder that allows the code to"}
{"source_file": "herald_data/sample_500.jsonl", "line": 127, "id": 208577, "informal_statement": "For any set $s$ in a group with zero $\\alpha$ where equality is decidable, show that the set resulting from dividing every element of $s$ by zero is a subset of the set containing only the zero element, i.e., $s / 0 \\subseteq \\{0\\}$.", "formal_statement": "import Mathlib\nopen Function MulOpposite\nopen scoped Pointwise\nopen Pointwise\nopen Pointwise\nopen Pointwise\nlemma div_zero_subset_tac_35061 [DecidableEq α] [GroupWithZero α] (s : Finset α) : s / 0 ⊆ 0 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down the components of the statement and understand how they map to Lean's syntax and semantics.\n\n1. **Understanding the Context**:\n   - We are working within the context of a group with zero, denoted as `α`. In Lean, this is represented by the type class `GroupWithZero α`, which combines the properties of a group and a monoid with zero.\n   - The statement involves a set `s` of elements from this group. In Lean, finite sets are often represented as `Finset α`, which is a finite set of elements of type `α`.\n\n2. **Decidability of Equality**:\n   - The informal statement mentions that equality is decidable. In Lean, this is expressed by the type class `DecidableEq α`, which provides a way to decide whether any two elements of type `α` are equal.\n\n3. **Division by Zero**:\n   - The operation of dividing every element of the set `s` by zero is denoted as `s / 0`. In Lean, this is interpreted using pointwise operations on sets, specifically `Finset α`. The division operation is applied to each element of the set `s`.\n\n4. **Subset Relation**:\n   - The goal is to show that the result of this division is a subset of the set containing only the zero element. In Lean, the subset relation is denoted by `⊆`.\n\n5. **Formalizing the Statement**:\n   - The lemma is named `div_zero_subset_tac_35061`, which is a placeholder name and can be replaced with a more descriptive one.\n   - The lemma takes as input a finite set `s` of type `Finset α`.\n   - The statement `s / 0 ⊆ 0` is the formalization of the informal goal. Here, `0` on the right-hand side represents the singleton set `{0}` in the context of `Finset α`.\n\n6. **Imports and Namespace**:\n   - The code imports `Mathlib`, which is a library containing mathematical definitions and theorems.\n   - The `open` and `open scoped` statements bring into scope various operations and notations, such as pointwise operations on sets, which are necessary for interpreting `s / 0`.\n\n7. **Conclusion**:\n   - The lemma is stated but not yet proven,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 124, "id": 111583, "informal_statement": "For any integer $d$ and any element $x$ in the ring of integers extended by the square root of $d$, show that the product of $x$ and its conjugate is equal to itself, i.e., $x \\cdot \\overline{x} = x \\cdot \\overline{x}$.", "formal_statement": "import Mathlib\nopen Int in\nopen Int in\nlemma norm_neg_tac_14867 (d : ℤ) (x : ℤ√d) : x * star x = x * star x := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Mathematical Context**:\n   - The statement involves the ring of integers extended by the square root of an integer \\( d \\), denoted as \\( \\mathbb{Z}[\\sqrt{d}] \\).\n   - An element \\( x \\) in this ring can be expressed as \\( a + b\\sqrt{d} \\) where \\( a, b \\) are integers.\n   - The conjugate of \\( x \\), denoted \\( \\overline{x} \\), is \\( a - b\\sqrt{d} \\).\n   - The product \\( x \\cdot \\overline{x} \\) is a common operation in this ring, often used to compute the norm.\n\n2. **Identifying the Components in Lean**:\n   - **Integers**: In Lean, integers are represented by `ℤ`.\n   - **Ring of Integers Extended by \\(\\sqrt{d}\\)**: This is represented by `ℤ√d` in Lean, which is a type for elements of the form \\( a + b\\sqrt{d} \\).\n   - **Conjugate Operation**: The conjugate of an element \\( x \\) is represented by `star x` in Lean.\n\n3. **Formalizing the Statement**:\n   - The goal is to show that for any integer \\( d \\) and any element \\( x \\) in \\( \\mathbb{Z}[\\sqrt{d}] \\), the equation \\( x \\cdot \\overline{x} = x \\cdot \\overline{x} \\) holds trivially.\n   - This is a tautology, as it states that an expression is equal to itself.\n\n4. **Lean Code Explanation**:\n   - `import Mathlib`: This imports the Mathlib library, which contains definitions and theorems for mathematical structures, including integers and operations on them.\n   - `open Int`: This command opens the integer namespace, allowing us to use integer-related definitions and operations without prefixing them with `Int.`.\n   - `lemma norm_neg_tac_14867`: This declares a new lemma named `norm_neg_tac_14867`.\n   - `(d : ℤ)`: This specifies that \\( d \\) is an integer.\n   - `(x : ℤ√d)`: This specifies that \\("}
{"source_file": "herald_data/sample_500.jsonl", "line": 129, "id": 398980, "informal_statement": "For any finite cardinal $c$, prove that $\\text{succ}(c) = c + 1$.", "formal_statement": "import Mathlib\nopen Mathlib (Vector)\nopen Function Set Order\nopen Sum\nlemma succ_eq_of_lt_aleph0 {c : Cardinal} (h : c < ℵ₀) : Order.succ c = c + 1 := sorry", "explanation": "To translate the informal statement \"For any finite cardinal $c$, prove that $\\text{succ}(c) = c + 1$\" into the formal Lean4 statement, we follow these steps:\n\n1. **Identify the Domain**: The informal statement refers to \"any finite cardinal $c$\". In Lean, cardinals are represented by the type `Cardinal`. The condition of being finite is expressed by the inequality $c < \\aleph_0$, where $\\aleph_0$ (aleph-null) is the smallest infinite cardinal. This is captured in Lean by the hypothesis `(h : c < ℵ₀)`.\n\n2. **Express the Succ Function**: The informal statement uses the function $\\text{succ}(c)$, which refers to the successor cardinal of $c$. In Lean, this is represented by `Order.succ c`, where `Order.succ` is the function that gives the successor cardinal.\n\n3. **Express the Addition**: The informal statement equates the successor of $c$ to $c + 1$. In Lean, cardinal addition is denoted by `c + 1`, where `+` is the addition operation on cardinals.\n\n4. **Formulate the Lemma**: The goal is to prove that for any finite cardinal $c$, the successor of $c$ is equal to $c + 1$. This is expressed in Lean as a lemma: `lemma succ_eq_of_lt_aleph0 {c : Cardinal} (h : c < ℵ₀) : Order.succ c = c + 1`.\n\n5. **Structure of the Lemma**: \n   - `lemma` indicates that we are stating a proposition to be proved.\n   - `succ_eq_of_lt_aleph0` is the name of the lemma, which suggests that it relates the successor function to finite cardinals (those less than $\\aleph_0$).\n   - `{c : Cardinal}` introduces the variable `c` of type `Cardinal`.\n   - `(h : c < ℵ₀)` is the hypothesis that `c` is a finite cardinal.\n   - `: Order.succ c = c + 1` is the conclusion that the successor of `c` is `c + 1`.\n\n6. **Use of `sorry`**: The `:= sorry` at the end indicates that the proof is not provided. In Lean"}
{"source_file": "herald_data/sample_500.jsonl", "line": 128, "id": 160267, "informal_statement": "For any complex number $s$, show that the multiplicative inverse of $\\cos\\left(s \\cdot \\pi \\cdot \\frac{1}{2}\\right)$ is equal to itself, i.e., $\\left(\\cos\\left(s \\cdot \\pi \\cdot \\frac{1}{2}\\right)\\right)^{-1} = \\left(\\cos\\left(s \\cdot \\pi \\cdot \\frac{1}{2}\\right)\\right)^{-1}$.", "formal_statement": "import Mathlib\nopen Filter Topology Asymptotics Real Set MeasureTheory\nopen Complex hiding abs_of_nonneg\nlemma Gammaℝ_one_sub_mul_Gammaℝ_one_add_tac_6206 (s : ℂ) : (cos (s * ↑π * (1 / 2)))⁻¹ = (cos (s * ↑π * (1 / 2)))⁻¹ := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Understanding the Informal Statement**: The statement involves complex numbers and the cosine function. It asserts that the multiplicative inverse of the cosine of a specific expression involving a complex number \\( s \\) is equal to itself. This is trivially true because any expression is equal to itself.\n\n2. **Setting Up the Lean Environment**: The formal statement begins with importing necessary modules from Mathlib, which is a library in Lean that provides a wide range of mathematical definitions and theorems. The imports include modules for filters, topology, asymptotics, real numbers, sets, and measure theory, as well as the complex number module with some specific functions hidden.\n\n3. **Defining the Lemma**: The lemma is named `Gammaℝ_one_sub_mul_Gammaℝ_one_add_tac_6206`. The name is not descriptive of the content but is likely auto-generated or chosen for a specific context. The lemma takes a single argument `s` of type `ℂ`, which represents a complex number.\n\n4. **Formalizing the Expression**: The expression inside the lemma `(cos (s * ↑π * (1 / 2)))⁻¹ = (cos (s * ↑π * (1 / 2)))⁻¹` directly mirrors the informal statement. Here:\n   - `cos` is the cosine function applied to complex numbers.\n   - `s * ↑π * (1 / 2)` represents the argument of the cosine function. `↑π` is the Lean notation for the real number \\(\\pi\\) lifted to the complex numbers.\n   - `(1 / 2)` is the division of 1 by 2, a real number, which is automatically coerced to a complex number in the expression.\n   - `⁻¹` denotes the multiplicative inverse of the cosine value.\n\n5. **Trivial Equality**: The statement `(cos (s * ↑π * (1 / 2)))⁻¹ = (cos (s * ↑π * (1 / 2)))⁻¹` is trivially true because it asserts that an expression is equal to itself. In Lean, such statements are often placeholders or starting points for more complex proofs.\n\n6. **Conclusion with `sorry`**: The lemma ends with `:= sorry`, which is a placeholder in Lean indicating that"}
{"source_file": "herald_data/sample_500.jsonl", "line": 132, "id": 567268, "informal_statement": "Given a prime $p$ that divides the nth Fermat number $F_n = 2^{2^n} + 1$, prove that $p$ can be expressed as $2^{n+2}k + 1$, where $k$ is an integer.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_567268 (p n : ℕ) (hp : p.Prime) (h : p ∣ (2^(2^n) + 1)) : ∃ k : ℕ, p = 2^(n + 2) * k + 1   :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a structured approach to formalize each component of the statement. Here's a step-by-step explanation:\n\n1. **Understanding the Informal Statement**:\n   - We are given a prime number \\( p \\) that divides the nth Fermat number \\( F_n = 2^{2^n} + 1 \\).\n   - We need to prove that \\( p \\) can be expressed in the form \\( 2^{n+2}k + 1 \\) for some integer \\( k \\).\n\n2. **Identifying the Components**:\n   - **Prime \\( p \\)**: This is a natural number that is prime.\n   - **nth Fermat Number**: Defined as \\( F_n = 2^{2^n} + 1 \\).\n   - **Divisibility**: \\( p \\mid F_n \\) means \\( p \\) divides \\( F_n \\).\n   - **Expression of \\( p \\)**: We need to show \\( p = 2^{n+2}k + 1 \\) for some integer \\( k \\).\n\n3. **Translating to Lean4**:\n   - **Imports and Setup**: \n     - `import Mathlib` is used to bring in necessary mathematical libraries.\n     - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to access various mathematical operations and types.\n\n4. **Formalizing the Theorem**:\n   - **Theorem Declaration**: \n     - `theorem extract_aug_567268` is the name of the theorem.\n     - `(p n : ℕ)` declares \\( p \\) and \\( n \\) as natural numbers.\n     - `(hp : p.Prime)` asserts that \\( p \\) is a prime number.\n     - `(h : p ∣ (2^(2^n) + 1))` states that \\( p \\) divides the nth Fermat number \\( F_n = 2^{2^n} + 1 \\).\n\n5. **Existential Quantifier**:\n   - `∃ k : ℕ, p = 2^(n + 2) * k + 1`:\n     - `∃ k : ℕ` indicates there exists a natural number \\( k \\).\n     - `p = 2^(n + 2"}
{"source_file": "herald_data/sample_500.jsonl", "line": 131, "id": 576738, "informal_statement": "prove that $\\sum_{cyc}\\frac{a^{3}}{b^{2}-bc+c^{2}}\\ge\\frac{3(bc+ba+ac)}{a+b+c}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_576738 (a b c : ℝ) : (a^3 / (b^2 - b * c + c^2) + b^3 / (c^2 - c * a + a^2) + c^3 / (a^2 - a * b + b^2)) ≥ (3 * (b * c + c * a + a * b)) / (a + b + c)   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The variables \\(a\\), \\(b\\), and \\(c\\) are real numbers. In Lean, real numbers are represented by `ℝ`.\n\n2. **Understand the Cyclic Sum**:\n   - The expression \\(\\sum_{cyc}\\frac{a^{3}}{b^{2}-bc+c^{2}}\\) represents a cyclic sum over the variables \\(a\\), \\(b\\), and \\(c\\). This means we need to consider the terms:\n     - \\(\\frac{a^3}{b^2 - bc + c^2}\\)\n     - \\(\\frac{b^3}{c^2 - ca + a^2}\\)\n     - \\(\\frac{c^3}{a^2 - ab + b^2}\\)\n\n3. **Translate the Cyclic Sum into Lean**:\n   - In Lean, we explicitly write out each term of the cyclic sum and add them together. This is done by:\n     ```lean\n     a^3 / (b^2 - b * c + c^2) + b^3 / (c^2 - c * a + a^2) + c^3 / (a^2 - a * b + b^2)\n     ```\n\n4. **Translate the Right-Hand Side of the Inequality**:\n   - The right-hand side of the inequality is \\(\\frac{3(bc+ba+ac)}{a+b+c}\\).\n   - In Lean, this is written as:\n     ```lean\n     (3 * (b * c + c * a + a * b)) / (a + b + c)\n     ```\n\n5. **Formulate the Inequality**:\n   - The goal is to prove that the cyclic sum is greater than or equal to the right-hand side. In Lean, this is expressed using the `≥` operator:\n     ```lean\n     (a^3 / (b^2 - b * c + c^2) + b^3 / (c^2 - c * a + a^2) + c^3 / (a^2 - a * b + b^2)) ≥ (3 * (b * c + c * a + a * b)) / (a +"}
{"source_file": "herald_data/sample_500.jsonl", "line": 133, "id": 599, "informal_statement": "For any two subgroups \\(H\\) and \\(K\\) of a group \\(G\\), if \\(H\\) and \\(K\\) are commensurable, then show that the commensurator of \\(H\\) is equal to the commensurator of \\(K\\).", "formal_statement": "import Mathlib\nopen Pointwise\ntheorem eq_extracted [Group G] {H K : Subgroup G} :\n Commensurable H K → Commensurable.commensurator H = Commensurable.commensurator K := sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow these steps:\n\n1. **Understand the Mathematical Concepts**:\n   - **Subgroups**: \\(H\\) and \\(K\\) are subgroups of a group \\(G\\).\n   - **Commensurable Subgroups**: Two subgroups \\(H\\) and \\(K\\) are commensurable if their intersection has finite index in both \\(H\\) and \\(K\\).\n   - **Commensurator**: The commensurator of a subgroup \\(H\\) in \\(G\\) is the set of elements \\(g \\in G\\) such that \\(gHg^{-1}\\) is commensurable with \\(H\\).\n\n2. **Identify the Goal**:\n   - We need to prove that if \\(H\\) and \\(K\\) are commensurable, then their commensurators in \\(G\\) are equal.\n\n3. **Translate the Concepts to Lean**:\n   - **Group G**: In Lean, we use `[Group G]` to denote that \\(G\\) is a group.\n   - **Subgroups H and K**: `{H K : Subgroup G}` specifies that \\(H\\) and \\(K\\) are subgroups of \\(G\\).\n   - **Commensurable**: `Commensurable H K` is a predicate indicating that \\(H\\) and \\(K\\) are commensurable.\n   - **Commensurator**: `Commensurable.commensurator H` denotes the commensurator of \\(H\\).\n\n4. **Formalize the Theorem**:\n   - The theorem is stated as `theorem eq_extracted [Group G] {H K : Subgroup G} : Commensurable H K → Commensurable.commensurator H = Commensurable.commensurator K`.\n   - This states that given a group \\(G\\) and subgroups \\(H\\) and \\(K\\), if \\(H\\) and \\(K\\) are commensurable, then their commensurators are equal.\n\n5. **Use Lean's Syntax and Libraries**:\n   - `import Mathlib` is used to import necessary mathematical libraries that provide definitions and theorems related to groups and subgroups.\n   - `open Pointwise` allows us to use pointwise operations and properties on subgroups, which might be necessary for"}
{"source_file": "herald_data/sample_500.jsonl", "line": 130, "id": 169400, "informal_statement": "For any element \\(a\\) in a commutative group \\(α\\) that is also a lattice, and where multiplication is covariant with respect to the lattice's partial order, show that the division of \\(a\\) by the magnitude of \\(a\\) (\\(mabs\\) a) is equal to itself, i.e., \\(\\frac{a}{mabs\\, a} = \\frac{a}{mabs\\, a}\\).", "formal_statement": "import Mathlib\nopen Function\nlemma div_mabs_eq_inv_leOnePart_sq_tac_7953 [Lattice α] [CommGroup α] [CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] (a : α) : a / mabs a = a / mabs a := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and understand how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Context**:\n   - The informal statement involves a commutative group that is also a lattice. In Lean, this is represented by the type `α` which has both `Lattice` and `CommGroup` structures. These are specified using typeclass instances `[Lattice α]` and `[CommGroup α]`.\n\n2. **Covariant Class**:\n   - The statement mentions that multiplication is covariant with respect to the lattice's partial order. This is captured in Lean using the `CovariantClass` typeclass. The specific instance used here is `[CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]`, which indicates that multiplication (`fun x x_1 => x * x_1`) is covariant with respect to the partial order (`fun x x_1 => x ≤ x_1`).\n\n3. **Element and Operation**:\n   - The element \\(a\\) in the commutative group is represented as `(a : α)` in Lean, indicating that `a` is an element of the type `α`.\n\n4. **Magnitude Function**:\n   - The informal statement uses `mabs a` to denote the magnitude of `a`. In Lean, `mabs` is assumed to be a function that takes an element of `α` and returns its magnitude. The exact definition of `mabs` is not provided in the lemma, but it is assumed to be defined elsewhere in the context.\n\n5. **Division Operation**:\n   - The division operation \\(\\frac{a}{mabs\\, a}\\) is represented in Lean as `a / mabs a`. This uses the division operation defined in the `CommGroup` structure.\n\n6. **Equality Statement**:\n   - The informal statement asserts that \\(\\frac{a}{mabs\\, a} = \\frac{a}{mabs\\, a}\\). In Lean, this is directly translated to `a / mabs a = a / mabs a`. This is a tautological statement, meaning it is trivially true, which is why the proof is marked as `sorry`, indicating that the proof is omitted or trivial"}
{"source_file": "herald_data/sample_500.jsonl", "line": 134, "id": 341011, "informal_statement": "Prove that the cardinality of the continuum, $\\mathfrak{c}$, is not zero.", "formal_statement": "import Mathlib\nopen Cardinal\ntheorem continuum_ne_zero : 𝔠 ≠ 0 := sorry", "explanation": "To translate the informal statement \"Prove that the cardinality of the continuum, $\\mathfrak{c}$, is not zero\" into Lean4, we follow these steps:\n\n1. **Understanding the Informal Statement**: The statement is about the cardinality of the continuum, denoted by $\\mathfrak{c}$, which represents the size of the set of real numbers. The task is to prove that this cardinality is not zero.\n\n2. **Identifying the Lean4 Libraries**: We need to work with cardinal numbers in Lean4. The `Mathlib` library provides tools for dealing with cardinalities, so we import it using `import Mathlib`.\n\n3. **Opening the Cardinal Namespace**: To access the definitions and theorems related to cardinal numbers conveniently, we use `open Cardinal`. This allows us to refer to cardinal numbers and operations without prefixing them with `Cardinal.`.\n\n4. **Formalizing the Continuum**: In Lean4, the cardinality of the continuum is represented by the symbol `𝔠`. This is a predefined constant in the `Cardinal` namespace that corresponds to the cardinality of the real numbers.\n\n5. **Stating the Theorem**: We need to express the statement \"the cardinality of the continuum is not zero\" formally. In Lean4, this is done by stating a theorem. We name the theorem `continuum_ne_zero`, which is a descriptive name indicating that the continuum is not zero.\n\n6. **Expressing the Inequality**: The statement \"is not zero\" is expressed in Lean4 using the inequality `≠`. Therefore, the formal statement of the theorem is `𝔠 ≠ 0`.\n\n7. **Completing the Theorem**: The theorem is stated as `theorem continuum_ne_zero : 𝔠 ≠ 0 := sorry`. The `:= sorry` part is a placeholder indicating that the proof is not yet provided. In a complete development, this would be replaced with an actual proof.\n\nBy following these steps, we have translated the informal mathematical statement into a formal Lean4 theorem statement."}
{"source_file": "herald_data/sample_500.jsonl", "line": 138, "id": 386210, "informal_statement": "For any natural number $b$, the set $Iio(b)$ of all natural numbers less than $b$ has cardinality $b$, i.e., $|Iio(b)| = b$.", "formal_statement": "import Mathlib\nopen Finset Fin Function\n@[simp]\ntheorem card_Iio : (Iio b).card = b := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down the components of the statement and understand how they map to Lean constructs:\n\n1. **Understanding the Informal Statement**:\n   - We are given a natural number \\( b \\).\n   - We define a set \\( Iio(b) \\) which consists of all natural numbers less than \\( b \\).\n   - We claim that the cardinality of this set \\( Iio(b) \\) is \\( b \\).\n\n2. **Lean4 Constructs**:\n   - **Natural Numbers**: In Lean, natural numbers are represented by the type `ℕ`.\n   - **Set of Natural Numbers Less Than \\( b \\)**: In Lean, the set of all natural numbers less than \\( b \\) is represented by `Iio b`, where `Iio` stands for \"interval open on the right\" and is a standard notation in Lean for intervals.\n   - **Cardinality**: The cardinality of a finite set in Lean is obtained using the `.card` method.\n\n3. **Formalizing the Statement**:\n   - We need to prove that the cardinality of the set `Iio b` is equal to \\( b \\).\n   - The theorem is named `card_Iio`, which is a descriptive name indicating that it deals with the cardinality of the interval `Iio`.\n\n4. **Lean4 Code Explanation**:\n   - `import Mathlib`: This line imports the Mathlib library, which contains a wealth of mathematical definitions and theorems, including those related to finite sets and their cardinalities.\n   - `open Finset Fin Function`: This line opens the namespaces `Finset`, `Fin`, and `Function`, making their contents directly accessible without needing to prefix them with the namespace name. This is useful because `Iio` and `.card` are part of these namespaces.\n   - `@[simp]`: This attribute is used to mark the theorem as a simplification rule, which means it can be used automatically by Lean's simplifier to simplify expressions.\n   - `theorem card_Iio : (Iio b).card = b := sorry`: This line states the theorem. It declares that for any natural number \\( b \\), the cardinality of the set `Iio b` is \\( b \\). The `:= sorry` part is a placeholder indicating that the proof is not yet provided.\n\nIn summary, the informal statement"}
{"source_file": "herald_data/sample_500.jsonl", "line": 137, "id": 117305, "informal_statement": "For any topological space $\\alpha$, equipped with a measurable space, a Borel space, and a measure $\\mu$ that is finite, and assuming $\\alpha$ is a compact space, for any two continuous functions $f, g : \\alpha \\to \\mathbb{K}$, where $\\mathbb{K}$ is a ring-like field, demonstrate that the inner product of the $L^2$-integrable functions derived from $f$ and $g$ via the continuous map to $L^2$ space is equal to the integral over $\\alpha$ with respect to $\\mu$ of the pointwise product of the star-ring endomorphism of $\\mathbb{K}$ applied to $f(x)$ and $g(x)$.", "formal_statement": "import Mathlib\nopen TopologicalSpace MeasureTheory MeasureTheory.Lp Filter\nopen scoped NNReal ENNReal MeasureTheory\nopen scoped ComplexConjugate\nopen scoped BoundedContinuousFunction ComplexConjugate\nlemma inner_toLp_tac_13519 [TopologicalSpace α] [MeasurableSpace α] [BorelSpace α] [RCLike 𝕜] (μ : Measure α) [IsFiniteMeasure μ] [CompactSpace α] (f : C(α, 𝕜)) (g : C(α, 𝕜)) : ⟪(ContinuousMap.toLp 2 μ 𝕜) f, (ContinuousMap.toLp 2 μ 𝕜) g⟫_𝕜 = ∫ (x : α), (starRingEnd 𝕜) (f x) * g x ∂μ := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it corresponds to the constructs in Lean4. Here's the step-by-step explanation:\n\n1. **Topological Space and Measurable Space**: \n   - The informal statement begins with \"For any topological space $\\alpha$, equipped with a measurable space, a Borel space...\". In Lean, this is represented by `[TopologicalSpace α]`, `[MeasurableSpace α]`, and `[BorelSpace α]`. These are typeclass instances that specify that `α` is a topological space, a measurable space, and a Borel space, respectively.\n\n2. **Measure and Finite Measure**:\n   - The measure $\\mu$ is described as finite. In Lean, this is represented by `(μ : Measure α)` and `[IsFiniteMeasure μ]`. The first part declares `μ` as a measure on `α`, and the second part asserts that this measure is finite.\n\n3. **Compact Space**:\n   - The statement assumes that $\\alpha$ is a compact space. This is captured in Lean by `[CompactSpace α]`, indicating that `α` is a compact topological space.\n\n4. **Continuous Functions**:\n   - The functions $f$ and $g$ are continuous functions from $\\alpha$ to $\\mathbb{K}$. In Lean, this is represented by `(f : C(α, 𝕜)) (g : C(α, 𝕜))`, where `C(α, 𝕜)` denotes the space of continuous functions from `α` to `𝕜`.\n\n5. **Ring-like Field**:\n   - The field $\\mathbb{K}$ is described as a ring-like field. In Lean, this is represented by `[RCLike 𝕜]`, which is a typeclass that captures the properties of a ring-like field.\n\n6. **Inner Product in $L^2$ Space**:\n   - The statement involves the inner product of $L^2$-integrable functions derived from $f$ and $g$. In Lean, this is expressed as `⟪(ContinuousMap.toLp 2 μ 𝕜) f, (ContinuousMap.toLp 2 μ 𝕜) g⟫_𝕜`. Here, `Continuous"}
{"source_file": "herald_data/sample_500.jsonl", "line": 135, "id": 523450, "informal_statement": "Let $ a,b,c> 0 .$ Prove that \\n $$\\dfrac{1}{\\sqrt{\\frac{a}{b+c}}+\\sqrt{ \\frac{b}{ c+a }}+\\frac{1}{2}}+\\dfrac{1}{ \\sqrt{ \\frac{b}{ c+a } }+\\sqrt{\\frac{c}{ a+b } }+\\frac{1}{2}}+\\dfrac{1}{ \\sqrt{\\frac{c}{ a+b } }+\\sqrt{\\frac{a}{b+c}}+\\frac{1}{2}} \\geq \\dfrac{6(2\\sqrt 2-1)}{7}$$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_523450 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : (1 / (Real.sqrt (a / (b + c)) + Real.sqrt (b / (c + a)) + 1 / 2) + 1 / (Real.sqrt (b / (c + a)) + Real.sqrt (c / (a + b)) + 1 / 2) + 1 / (Real.sqrt (c / (a + b)) + Real.sqrt (a / (b + c)) + 1 / 2)) ≥ (6 * (2 * Real.sqrt 2 - 1)) / 7   :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach to ensure that all components of the statement are accurately represented in the formal language. Here's a step-by-step explanation of the translation process:\n\n1. **Variables and Assumptions**:\n   - The informal statement begins with \"Let \\( a, b, c > 0 \\).\" This indicates that \\( a, b, \\) and \\( c \\) are positive real numbers.\n   - In Lean, we declare these variables as real numbers and specify their positivity using hypotheses. This is done with `(a b c : ℝ)` to declare the variables as real numbers, and `(ha : 0 < a) (hb : 0 < b) (hc : 0 < c)` to assert that each is positive.\n\n2. **Expression Construction**:\n   - The main expression involves fractions with square roots in the denominators. In Lean, we use `Real.sqrt` to denote the square root function.\n   - The expression \\(\\sqrt{\\frac{a}{b+c}}\\) is translated to `Real.sqrt (a / (b + c))`. Similarly, other square root expressions are translated using the same pattern.\n\n3. **Denominator Structure**:\n   - Each term in the sum has a denominator of the form \\(\\sqrt{\\frac{x}{y+z}} + \\sqrt{\\frac{y}{z+x}} + \\frac{1}{2}\\).\n   - In Lean, this is represented as `Real.sqrt (x / (y + z)) + Real.sqrt (y / (z + x)) + 1 / 2`.\n\n4. **Summation of Terms**:\n   - The informal statement has three such terms added together. In Lean, this is expressed as a sum of three fractions, each with the structure described above.\n\n5. **Inequality**:\n   - The inequality \\(\\geq \\frac{6(2\\sqrt{2}-1)}{7}\\) is directly translated to `≥ (6 * (2 * Real.sqrt 2 - 1)) / 7`.\n   - The `≥` symbol in Lean is used to denote \"greater than or equal to.\"\n\n6. **Theorem Declaration**:\n   - The entire statement is encapsulated in a theorem declaration. In Lean, this is done using the `theorem` keyword followed by a name for the theorem, e.g"}
{"source_file": "herald_data/sample_500.jsonl", "line": 136, "id": 20422, "informal_statement": "For any point \\( p \\) in a set \\( S \\) of points, if \\( p \\) belongs to \\( S \\), then \\( p \\) is also contained in the affine span of \\( S \\), denoted by \\( \\text{spanPoints}_k(S) \\).", "formal_statement": "import Mathlib\nopen Affine\nopen Set\ntheorem mem_spanPoints_extracted (k : Type u_1) [Ring k] [AddCommGroup V] [Module k V]\n [AffineSpace V P] (p : P) (s : Set P) : p ∈ s → p ∈ spanPoints k s := sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Understand the Context and Definitions**:\n   - The informal statement involves a set \\( S \\) of points and a point \\( p \\).\n   - The statement asserts that if \\( p \\) is in \\( S \\), then \\( p \\) is also in the affine span of \\( S \\), denoted as \\( \\text{spanPoints}_k(S) \\).\n\n2. **Identify the Mathematical Structures**:\n   - We are dealing with an affine space, which involves points and vectors. In Lean, this is typically represented using a module over a ring.\n   - The affine span is a concept from affine geometry, which can be formalized using the `spanPoints` function in Lean.\n\n3. **Set Up the Lean Environment**:\n   - Import necessary modules: `Mathlib` is imported to access mathematical libraries, including affine spaces.\n   - Open relevant namespaces: `Affine` and `Set` are opened to use their definitions and functions without prefixing them.\n\n4. **Declare the Theorem**:\n   - The theorem is named `mem_spanPoints_extracted`, indicating it is about membership in the affine span.\n   - The parameters are declared:\n     - `k : Type u_1`: The type of scalars, which is a ring.\n     - `[Ring k]`: `k` is a ring.\n     - `[AddCommGroup V]`: `V` is an additive commutative group, representing the vector space.\n     - `[Module k V]`: `V` is a module over the ring `k`.\n     - `[AffineSpace V P]`: `P` is an affine space with `V` as the associated vector space.\n\n5. **Formalize the Hypothesis and Conclusion**:\n   - `(p : P)`: `p` is a point in the affine space `P`.\n   - `(s : Set P)`: `s` is a set of points in `P`.\n   - `p ∈ s → p ∈ spanPoints k s`: This is the core statement. It asserts that if `p` is in the set `s`, then `p` is also in the affine span of `s` over the ring `k`.\n\n6. **Use of `sorry`**:\n   - The `sorry` keyword is used as a placeholder for"}
{"source_file": "herald_data/sample_500.jsonl", "line": 139, "id": 322456, "informal_statement": "For any functions $f, g : \\mathbb{N} \\to \\mathbb{C}$, complex number $s$, natural number $n \\neq 0$, demonstrate that the sum over the antidiagonal of $n$'s divisors, $\\sum_{p \\in n.\\text{divisorsAntidiagonal}} \\text{term}\\ f\\ s\\ p_1 \\cdot \\text{term}\\ g\\ s\\ p_2$, is equal to the same sum but indexed by $x$, $\\sum_{x \\in n.\\text{divisorsAntidiagonal}} \\text{term}\\ f\\ s\\ x_1 \\cdot \\text{term}\\ g\\ s\\ x_2$.", "formal_statement": "import Mathlib\nopen scoped LSeries.notation\nopen Complex LSeries\nopen Nat\nopen Set in\nlemma term_convolution'_tac_6127 (f : ℕ → ℂ) (g : ℕ → ℂ) (s : ℂ) (n : ℕ) (hn : n ≠ 0) : ∑ p ∈ n.divisorsAntidiagonal, term f s p.1 * term g s p.2 = ∑ x ∈ n.divisorsAntidiagonal, term f s x.1 * term g s x.2 := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the statement in a precise and formal manner. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context**: \n   - We are dealing with functions from natural numbers to complex numbers, denoted as \\( f, g : \\mathbb{N} \\to \\mathbb{C} \\).\n   - We have a complex number \\( s \\) and a natural number \\( n \\) which is non-zero.\n   - The goal is to show the equality of two sums over the antidiagonal of divisors of \\( n \\).\n\n2. **Identifying the Key Components**:\n   - **Divisors Antidiagonal**: This refers to pairs \\((p_1, p_2)\\) such that \\( p_1 \\cdot p_2 = n \\). In Lean, this is represented by `n.divisorsAntidiagonal`.\n   - **Term Function**: The function `term` is applied to \\( f, g, s \\) and the components of the pairs from the antidiagonal.\n\n3. **Formalizing the Statement**:\n   - **Imports and Setup**: The code begins with importing necessary modules from Mathlib, which provides the required mathematical structures and operations.\n   - **Open Scopes**: The `open scoped LSeries.notation` and other open statements make certain notations and operations available without prefixing them with their module names.\n\n4. **Defining the Lemma**:\n   - **Lemma Name**: `term_convolution'_tac_6127` is a unique identifier for this lemma.\n   - **Parameters**: The lemma takes as parameters the functions \\( f, g \\), the complex number \\( s \\), and the natural number \\( n \\). The hypothesis `hn : n ≠ 0` ensures \\( n \\) is non-zero.\n   - **Statement of Equality**: The core of the lemma is the equality of two sums:\n     - The first sum: `∑ p ∈ n.divisorsAntidiagonal, term f s p.1 * term g s p.2`\n     - The second sum: `∑ x ∈ n.divisorsAntidiagonal, term f s x.1 * term g s x.2`\n   - Both"}
{"source_file": "herald_data/sample_500.jsonl", "line": 142, "id": 252576, "informal_statement": "For a matroid $M$ over the set $\\alpha$ and a subset $I$ of $\\alpha$, show that $I$ is independent in $M$ if and only if $I$ is not dependent in $M$ and $I$ is a subset of the ground set $M.E$.", "formal_statement": "import Mathlib\nopen Set\nlemma indep_iff_not_dep_tac_24191 (M : Matroid α) (I : Set α) : M.Indep I ↔ ¬M.Dep I ∧ I ⊆ M.E := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: \n   - The statement involves a matroid \\( M \\) over a set \\(\\alpha\\), a subset \\( I \\) of \\(\\alpha\\), and properties of independence and dependence within the matroid context.\n\n2. **Translate the Matroid and Set Concepts**:\n   - In Lean, a matroid over a set \\(\\alpha\\) is represented as `Matroid α`. This is a type that encapsulates the matroid structure and its properties.\n   - A subset \\( I \\) of \\(\\alpha\\) is represented as `Set α` in Lean, which is a type for sets over the type \\(\\alpha\\).\n\n3. **Formalize the Independence and Dependence Conditions**:\n   - The informal statement requires showing that \\( I \\) is independent in \\( M \\) if and only if it is not dependent in \\( M \\) and is a subset of the ground set \\( M.E \\).\n   - In Lean, the independence of a set \\( I \\) in a matroid \\( M \\) is expressed as `M.Indep I`.\n   - The dependence of a set \\( I \\) in a matroid \\( M \\) is expressed as `M.Dep I`.\n   - The ground set of the matroid \\( M \\) is denoted as `M.E`.\n\n4. **Construct the Logical Equivalence**:\n   - The statement \"if and only if\" translates to a logical equivalence, denoted by `↔` in Lean.\n   - The condition \"not dependent\" is expressed using negation, `¬M.Dep I`.\n   - The condition \"is a subset of the ground set\" is expressed as `I ⊆ M.E`, where `⊆` denotes the subset relation.\n\n5. **Combine the Conditions**:\n   - The right-hand side of the equivalence combines the two conditions using a logical conjunction, denoted by `∧` in Lean. Thus, `¬M.Dep I ∧ I ⊆ M.E` represents the condition that \\( I \\) is not dependent and is a subset of the ground set.\n\n6. **Formulate the Lemma**:\n   - The lemma is named `indep_iff_not_dep_tac_24191`, which is a unique identifier for"}
{"source_file": "herald_data/sample_500.jsonl", "line": 140, "id": 251087, "informal_statement": "For any functions \\(f : \\alpha \\to \\beta\\), sets \\(S \\subseteq \\alpha\\), matroid \\(N\\) over \\(\\beta\\), subsets \\(E, I \\subseteq \\alpha\\), matroid \\(M\\) over \\(\\alpha\\) that is finitary, and a subset \\(X \\subseteq \\alpha\\), demonstrate that the restriction of matroid \\(M\\) to the subtype defined by \\(X\\), denoted as \\(M.restrictSubtype X\\), is also finitary.", "formal_statement": "import Mathlib\nopen Set Function Set.Notation\nlemma instFinitaryElemRestrictSubtype_tac_33931 (f : α → β) (s : Set α) (N : Matroid β) (E : Set α) (I : Set α) (M : Matroid α) [M.Finitary] (X : Set α) : (M.restrictSubtype X).Finitary := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understand the Context and Definitions**:\n   - We are dealing with matroids, which are combinatorial structures that generalize the notion of linear independence in vector spaces.\n   - The statement involves functions, sets, and matroids over different types, specifically \\(\\alpha\\) and \\(\\beta\\).\n   - The concept of a matroid being \"finitary\" means that every independent set in the matroid is finite.\n\n2. **Identify the Components**:\n   - **Functions**: \\(f : \\alpha \\to \\beta\\) is a function from type \\(\\alpha\\) to type \\(\\beta\\).\n   - **Sets**: \\(S, E, I, X \\subseteq \\alpha\\) are subsets of \\(\\alpha\\).\n   - **Matroids**: \\(N\\) is a matroid over \\(\\beta\\), and \\(M\\) is a matroid over \\(\\alpha\\) that is specified to be finitary.\n\n3. **Translate the Informal Statement**:\n   - The goal is to show that the restriction of the matroid \\(M\\) to the subset \\(X\\) is also finitary. In Lean, this is expressed as \\((M.restrictSubtype X).Finitary\\).\n\n4. **Formalize in Lean**:\n   - **Imports and Setup**: The code begins with `import Mathlib`, which is necessary to access the mathematical library that includes definitions and theorems about matroids.\n   - **Open Notations**: `open Set Function Set.Notation` allows us to use set and function notations conveniently.\n   - **Lemma Declaration**: The lemma is named `instFinitaryElemRestrictSubtype_tac_33931`, which is a unique identifier for this specific result.\n   - **Parameters**: The parameters of the lemma include:\n     - `f : α → β`: A function from \\(\\alpha\\) to \\(\\beta\\).\n     - `s : Set α`: A set \\(S\\) which is a subset of \\(\\alpha\\).\n     - `N : Matroid β`: A matroid over \\(\\beta\\).\n     - `E, I : Set α`: Subsets of \\(\\alpha\\).\n     - `M : Matroid α`: A mat"}
{"source_file": "herald_data/sample_500.jsonl", "line": 145, "id": 520700, "informal_statement": "Find all functions f from the set R of real numbers into R such that the identity $ f(f(x)+f(y))-f(x+y)=f(f(x)-f(y))-f(x-y)$ is satisfied for all real numbers x and y.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_520700 (f : ℝ → ℝ): (∀ x y, f (f x + f y) - f (x + y) = f (f x - f y) - f (x - y)) ↔ ∀ x, f x = x ∨ ∀ x, f x = -x   :=  by sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Domain and Codomain**: The problem involves functions from the set of real numbers \\( \\mathbb{R} \\) to itself. In Lean, this is represented as `ℝ → ℝ`.\n\n2. **Express the Functional Equation**: The core of the problem is the functional equation:\n   \\[\n   f(f(x) + f(y)) - f(x + y) = f(f(x) - f(y)) - f(x - y)\n   \\]\n   In Lean, this is expressed using the lambda notation for functions and the universal quantifier `∀` for all real numbers \\( x \\) and \\( y \\). The equation is written as:\n   ```lean\n   ∀ x y, f (f x + f y) - f (x + y) = f (f x - f y) - f (x - y)\n   ```\n\n3. **State the Problem as a Theorem**: The problem asks to find all functions \\( f \\) satisfying the given equation. In Lean, this is typically expressed as a theorem. The theorem states that the given functional equation holds if and only if \\( f(x) = x \\) for all \\( x \\) or \\( f(x) = -x \\) for all \\( x \\). This is expressed using the logical equivalence `↔`:\n   ```lean\n   (∀ x y, f (f x + f y) - f (x + y) = f (f x - f y) - f (x - y)) ↔ ∀ x, f x = x ∨ ∀ x, f x = -x\n   ```\n\n4. **Formalize the Theorem in Lean**: The theorem is named `extract_aug_520700`, and it is defined with the function `f` as a parameter. The theorem statement is then written as:\n   ```lean\n   theorem extract_aug_520700 (f : ℝ → ℝ): (∀ x y, f (f x + f y) - f (x + y) = f (f x - f y) - f (x - y)) ↔ ∀ x, f x = x ∨ ∀ x, f x = -x\n   ```\n\n5. **Use Lean Libraries"}
{"source_file": "herald_data/sample_500.jsonl", "line": 141, "id": 60741, "informal_statement": "For any family of sets $s: \\kappa \\to \\mathcal{P}(\\beta \\times \\beta)$, any property $p: \\kappa \\to \\text{Prop}$, and any family of functions $F: \\iota \\to \\beta \\to \\alpha$, suppose that the uniform structure on $\\beta$ has a basis given by $s$ and $p$. Show that the family $F$ is uniformly equicontinuous if and only if for every neighborhood $U$ of the diagonal in $\\alpha$, there exists some $k$ such that $p(k)$ holds and for any $x, y \\in \\beta$, if $(x, y) \\in s(k)$, then for all $i \\in \\iota$, $(F(i, x), F(i, y)) \\in U$.", "formal_statement": "import Mathlib\nopen UniformSpace Filter Set Uniformity Topology UniformConvergence Function\nopen UniformFun\ntheorem uniformEquicontinuous_iff_left_extracted [uα : UniformSpace α] [uβ : UniformSpace β] {p : κ → Prop}\n {s : κ → Set (β × β)} {F : ι → β → α} :\n (uniformity β).HasBasis p s →\n (UniformEquicontinuous F ↔ ∀ U ∈ uniformity α, ∃ k, p k ∧ ∀ (x y : β), (x, y) ∈ s k → ∀ (i : ι), (F i x, F i y) ∈ U) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the informal statement using Lean's syntax and logical constructs. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context and Definitions**:\n   - The informal statement involves concepts from topology and uniform spaces, specifically dealing with uniform structures, families of sets, properties, and functions.\n   - The goal is to show a characterization of uniform equicontinuity for a family of functions.\n\n2. **Identifying the Components**:\n   - **Family of Sets**: $s: \\kappa \\to \\mathcal{P}(\\beta \\times \\beta)$ is a function that assigns to each element of $\\kappa$ a subset of $\\beta \\times \\beta$.\n   - **Property**: $p: \\kappa \\to \\text{Prop}$ is a predicate on $\\kappa$.\n   - **Family of Functions**: $F: \\iota \\to \\beta \\to \\alpha$ is a function that takes an element of $\\iota$ and returns a function from $\\beta$ to $\\alpha$.\n   - **Uniform Structure Basis**: The uniform structure on $\\beta$ is given by the basis $s$ and property $p$.\n\n3. **Formalizing the Uniform Structure Basis**:\n   - In Lean, the uniform structure on a space $\\beta$ is represented by `(uniformity β)`.\n   - The basis for this uniformity is expressed using `HasBasis`, which is a Lean construct to specify that a filter (here, the uniformity) has a basis given by certain sets and properties.\n\n4. **Formalizing Uniform Equicontinuity**:\n   - The concept of uniform equicontinuity for a family of functions $F$ is captured by `UniformEquicontinuous F` in Lean.\n   - The goal is to express the equivalence between this property and a condition involving neighborhoods in $\\alpha$.\n\n5. **Expressing the Condition**:\n   - The condition involves neighborhoods $U$ of the diagonal in $\\alpha$, which are elements of the uniformity on $\\alpha`.\n   - The condition states that for every such neighborhood $U$, there exists some $k$ such that $p(k)$ holds, and for any $x, y \\in \\beta$, if $(x, y) \\in"}
{"source_file": "herald_data/sample_500.jsonl", "line": 144, "id": 89818, "informal_statement": "For any nonempty set $s$ in the domain of a function $f : \\alpha \\to \\beta$, where $\\beta$ is a semilattice with infimum, and $s^{-1}$ denotes the set under the inverse image of $f$, show that the infimum of $f$ over $s^{-1}$ is equal to the infimum of $f$'s inverse function over $s$, formally $\\inf'_{s^{-1}} f = \\inf'_{s} f^{-1}$.", "formal_statement": "import Mathlib\nopen Function MulOpposite\nopen scoped Pointwise\ntheorem inf'_inv_extracted [DecidableEq α] [Inv α] [SemilatticeInf β] {s : Finset α}\n (hs : s⁻¹.Nonempty) (f : α → β) : s⁻¹.inf' hs f = s.inf' ⋯ fun x => f x⁻¹ := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and semantics.\n\n1. **Understanding the Context**:\n   - We have a function \\( f : \\alpha \\to \\beta \\).\n   - The codomain \\(\\beta\\) is a semilattice with an infimum operation.\n   - We are dealing with a nonempty set \\( s \\) in the domain of \\( f \\).\n\n2. **Set Inversion**:\n   - The informal statement mentions \\( s^{-1} \\), which refers to the set under the inverse image of \\( f \\). In Lean, this is represented as `s⁻¹`, using the `Inv` typeclass to denote inversion.\n\n3. **Infimum in Lean**:\n   - The infimum operation over a set in Lean is represented by `inf'`. The notation `s.inf'` indicates the infimum of the function over the set \\( s \\).\n   - The `inf'` function requires a proof that the set is nonempty, which is provided by `hs : s⁻¹.Nonempty`.\n\n4. **Formalizing the Statement**:\n   - The goal is to show that the infimum of \\( f \\) over \\( s^{-1} \\) is equal to the infimum of \\( f^{-1} \\) over \\( s \\).\n   - In Lean, this is expressed as `s⁻¹.inf' hs f = s.inf' ⋯ fun x => f x⁻¹`.\n\n5. **Lean Syntax and Typeclasses**:\n   - `DecidableEq α` ensures that equality on type \\(\\alpha\\) is decidable, which is often required for operations on finite sets.\n   - `Inv α` indicates that the type \\(\\alpha\\) supports an inversion operation, which is used to define \\( s^{-1} \\).\n   - `SemilatticeInf β` provides the infimum operation on \\(\\beta\\).\n\n6. **Theorem Structure**:\n   - The theorem `inf'_inv_extracted` is defined with the necessary typeclass constraints and assumptions.\n   - The hypothesis `hs : s⁻¹.Nonempty` ensures that the set \\( s^{-1} \\) is nonempty, which is required for the `inf'` operation.\n   - The conclusion `s⁻¹.inf"}
{"source_file": "herald_data/sample_500.jsonl", "line": 143, "id": 82585, "informal_statement": "For any surjective function $f_1 : \\alpha_1 \\to \\alpha_2$ and a family of surjective functions $f_2 : \\beta_1 a \\to \\beta_2 (f_1 a)$ indexed by $a \\in \\alpha_1$, show that the product function $\\Sigma.map f_1 f_2 : \\Sigma \\alpha_1 \\beta_1 a \\to \\Sigma \\alpha_2 \\beta_2 (f_1 a)$ is also surjective.", "formal_statement": "import Mathlib\nopen Function\ntheorem sigma_map_extracted {β₁ : α₁ → Type u_5} {β₂ : α₂ → Type u_6} {f₁ : α₁ → α₂}\n {f₂ : (a : α₁) → β₁ a → β₂ (f₁ a)} : Surjective f₁ → (∀ (a : α₁), Surjective (f₂ a)) → Surjective (Sigma.map f₁ f₂) := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down the components of the statement and understand how they map to Lean's syntax and semantics.\n\n1. **Understanding the Types and Functions:**\n   - We have two types, `α₁` and `α₂`, and a function `f₁ : α₁ → α₂` which is surjective. In Lean, this is represented by the type `Surjective f₁`.\n   - We also have a family of types `β₁ : α₁ → Type u_5` and `β₂ : α₂ → Type u_6`. These are dependent types, meaning for each `a : α₁`, `β₁ a` is a type, and similarly for `β₂`.\n   - There is a family of functions `f₂ : (a : α₁) → β₁ a → β₂ (f₁ a)`, which are also surjective for each `a`. In Lean, this is expressed as `∀ (a : α₁), Surjective (f₂ a)`.\n\n2. **Sigma Types:**\n   - The sigma type `Σ α β` in Lean represents a dependent pair, where the first component is of type `α` and the second component is of type `β a` for some `a : α`.\n   - The function `Sigma.map f₁ f₂` is a map between sigma types. It takes a pair `(a, b)` where `a : α₁` and `b : β₁ a`, and maps it to `(f₁ a, f₂ a b)` where `f₁ a : α₂` and `f₂ a b : β₂ (f₁ a)`.\n\n3. **Surjectivity of Sigma.map:**\n   - The goal is to show that `Sigma.map f₁ f₂` is surjective. This means for every element in the target type `Σ α₂ β₂`, there exists an element in the source type `Σ α₁ β₁` that maps to it.\n   - In Lean, this is expressed as `Surjective (Sigma.map f₁ f₂)`.\n\n4. **Formalizing the Theorem:**\n   - The theorem `sigma_map_extracted` is defined with the necessary parameters and assumptions:\n     - `{β₁ :"}
{"source_file": "herald_data/sample_500.jsonl", "line": 146, "id": 72577, "informal_statement": "For a \\(p^k\\)-th cyclotomic field \\(K\\) over the rationals \\(\\mathbb{Q}\\), where \\(p\\) is a prime number, the absolute discriminant of \\(K\\) is given by \\((-1)^{\\frac{\\varphi(p^k)}{2}} \\cdot p^{(p^{k-1})(p-1)k-1}\\), where \\(\\varphi\\) denotes Euler's totient function. Note that in the cases \\(p^k = 1\\) and \\(p^k = 2\\), the formula involves the interpretation of \\(1/2 = 0\\) and \\(0 - 1 = 0\\), respectively.", "formal_statement": "import Mathlib\nopen Algebra IsCyclotomicExtension Polynomial NumberField\nopen scoped Cyclotomic Nat\nopen IsCyclotomicExtension.Rat\nopen nonZeroDivisors IsPrimitiveRoot\ntheorem absdiscr_prime_pow_extracted (p : ℕ+) (k : ℕ) (K : Type u) [Field K] [hp : Fact (Nat.Prime ↑p)] [CharZero K]\n [IsCyclotomicExtension {p ^ k} ℚ K] :\n NumberField.discr K = (-1) ^ (φ (↑p ^ k) / 2) * ↑↑p ^ (↑p ^ (k - 1) * ((↑p - 1) * k - 1)) := sorry", "explanation": "To translate the given informal mathematical statement into Lean4 code, we need to follow a structured approach that involves understanding both the mathematical concepts and how they are represented in Lean4. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Mathematical Context**:\n   - We are dealing with a cyclotomic field \\(K\\) over the rationals \\(\\mathbb{Q}\\), specifically a \\(p^k\\)-th cyclotomic field.\n   - The absolute discriminant of this field is given by a specific formula involving Euler's totient function \\(\\varphi\\).\n\n2. **Identifying Key Components**:\n   - **Prime Number \\(p\\)**: This is represented as a positive natural number in Lean, denoted by `ℕ+` (non-zero natural numbers).\n   - **Exponent \\(k\\)**: This is a natural number, represented by `ℕ`.\n   - **Cyclotomic Field \\(K\\)**: This is a type in Lean, represented by `Type u`, where `u` is a universe level. It is a field, so we use `[Field K]`.\n   - **Prime Fact**: We need to assert that \\(p\\) is a prime number, which is done using `[Fact (Nat.Prime ↑p)]`.\n\n3. **Setting Up the Cyclotomic Extension**:\n   - We use the `IsCyclotomicExtension` typeclass to specify that \\(K\\) is a cyclotomic extension of \\(\\mathbb{Q}\\) with the set `{p ^ k}`. This is represented by `[IsCyclotomicExtension {p ^ k} ℚ K]`.\n\n4. **Characterizing the Field**:\n   - We specify that the field \\(K\\) has characteristic zero using `[CharZero K]`.\n\n5. **Expressing the Discriminant Formula**:\n   - The discriminant of the number field \\(K\\) is expressed using `NumberField.discr K`.\n   - The formula involves the totient function \\(\\varphi\\), which is represented by `φ` in Lean.\n   - The expression \\((-1)^{\\frac{\\varphi(p^k)}{2}}\\) is represented by `(-1) ^ (φ (↑p ^ k) / 2)`.\n   - The power of \\(p\\) in the formula is represented by `↑↑p ^ ("}
{"source_file": "herald_data/sample_500.jsonl", "line": 148, "id": 131873, "informal_statement": "For a function $f : \\alpha \\to \\beta \\to \\gamma$, sets $s \\subseteq \\alpha$, $t \\subseteq \\beta$, and given that for every $a \\in s$, $f(a, \\cdot)$ is injective, and that the family of images $f(a)''t$ for $a \\in s$ is pairwise disjoint, show that if $(x, y) \\in s \\times t$ and $(x_1, x_2) = x$, $(y_1, y_2) = y$, and $f(x_1, x_2) = f(y_1, y_2)$, then $f(y_1, y_2) \\in f(y_1)''t$.", "formal_statement": "import Mathlib\nopen Function Order Set\nlemma pairwiseDisjoint_image_right_iff_tac_16018 (f : α → β → γ) (s : Set α) (t : Set β) (hf : ∀ a ∈ s, Injective (f a)) (hs : s.PairwiseDisjoint fun a => f a '' t) (x : α × β) (hx : x ∈ s ×ˢ t) (y : α × β) (hy : y ∈ s ×ˢ t) (h : f x.1 x.2 = (fun p => f p.1 p.2) y) : (fun p => f p.1 p.2) y ∈ f y.1 '' t := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to carefully map each component of the informal statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Function and Sets Declaration**:\n   - The informal statement involves a function \\( f : \\alpha \\to \\beta \\to \\gamma \\) and sets \\( s \\subseteq \\alpha \\) and \\( t \\subseteq \\beta \\).\n   - In Lean, we declare the function as `f : α → β → γ` and the sets as `s : Set α` and `t : Set β`.\n\n2. **Injectivity Condition**:\n   - The condition \"for every \\( a \\in s \\), \\( f(a, \\cdot) \\) is injective\" is expressed in Lean using the `Injective` predicate.\n   - This is formalized as `hf : ∀ a ∈ s, Injective (f a)`, meaning for each \\( a \\) in \\( s \\), the function \\( f(a, \\cdot) \\) is injective.\n\n3. **Pairwise Disjoint Condition**:\n   - The statement \"the family of images \\( f(a)''t \\) for \\( a \\in s \\) is pairwise disjoint\" is captured using the `PairwiseDisjoint` predicate.\n   - In Lean, this is written as `hs : s.PairwiseDisjoint (fun a => f a '' t)`, indicating that for any two distinct elements \\( a_1, a_2 \\in s \\), the images \\( f(a_1)''t \\) and \\( f(a_2)''t \\) are disjoint.\n\n4. **Elements in Cartesian Product**:\n   - The elements \\( (x, y) \\in s \\times t \\) are represented in Lean using the Cartesian product notation `s ×ˢ t`.\n   - We have two elements, `x` and `y`, both of which are pairs in the Cartesian product, formalized as `x : α × β` and `y : α × β` with conditions `hx : x ∈ s ×ˢ t` and `hy : y ∈ s ×ˢ t`.\n\n5. **Equality Condition**:\n   - The condition \\( f(x_1, x_2) = f(y_1, y"}
{"source_file": "herald_data/sample_500.jsonl", "line": 147, "id": 569737, "informal_statement": "Let $a, b, c>0$ . Prove that \\n $\\frac{1}{(a+b)^2+\\frac{15}{14}(b-c)^2}+\\frac{1}{(b+c)^2+\\frac{15}{14}(c-a)^2}+\\frac{1}{(c+a)^2+\\frac{15}{14}(a-b)^2}\\ge\\frac{9}{4(a^2+b^2+c^2)}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_569737 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : (1 / ((a + b) ^ 2 + 15 / 14 * (b - c) ^ 2) + 1 / ((b + c) ^ 2 + 15 / 14 * (c - a) ^ 2) + 1 / ((c + a) ^ 2 + 15 / 14 * (a - b) ^ 2) ≥ 9 / (4 * (a ^ 2 + b ^ 2 + c ^ 2)))   :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we follow these steps:\n\n1. **Identify the Variables and Assumptions**:\n   - The informal statement involves three positive real numbers \\(a\\), \\(b\\), and \\(c\\). This is translated into Lean by declaring \\(a\\), \\(b\\), and \\(c\\) as real numbers (`ℝ`) and adding assumptions that each is greater than zero (`0 < a`, `0 < b`, `0 < c`).\n\n2. **Structure the Theorem**:\n   - The theorem is named `extract_aug_569737`, which is a placeholder name. In Lean, theorem names are identifiers and can be arbitrary, but they should be descriptive in practice.\n   - The theorem takes three arguments: `a`, `b`, and `c`, all of type `ℝ`, and three hypotheses: `ha`, `hb`, and `hc`, which are proofs that `0 < a`, `0 < b`, and `0 < c`, respectively.\n\n3. **Translate the Inequality**:\n   - The left-hand side of the inequality in the informal statement consists of three terms, each of the form \\(\\frac{1}{(x+y)^2 + \\frac{15}{14}(y-z)^2}\\). In Lean, this is expressed using division (`/`) and exponentiation (`^`), with the appropriate arithmetic operations.\n   - The right-hand side of the inequality is \\(\\frac{9}{4(a^2 + b^2 + c^2)}\\), which is directly translated using division and multiplication.\n\n4. **Formalize the Inequality**:\n   - The inequality itself is expressed using the `≥` operator in Lean, which corresponds to the mathematical \"greater than or equal to\" symbol.\n\n5. **Complete the Theorem Statement**:\n   - The theorem statement is completed with `:= by sorry`, indicating that the proof is not provided. In Lean, `sorry` is a placeholder that allows the theorem to be accepted by the system without a proof, useful during development.\n\n6. **Import Necessary Modules**:\n   - The code begins with `import Mathlib`, which is a common practice to include necessary mathematical libraries.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to bring various mathematical notations and operations into scope, such as real number"}
{"source_file": "herald_data/sample_500.jsonl", "line": 152, "id": 277936, "informal_statement": "For any category $\\mathcal{C}$, let $P$ be a property of morphisms in $\\mathcal{C}$ satisfying the condition that for all morphisms $f, g$ in $\\mathcal{C}$, if $f$ is isomorphic to $g$, then $P(f)$ implies $P(g)$. Given objects $X, Y, Z$ in $\\mathcal{C}$ and an isomorphism $e$ from $Y$ to $Z$, show that for any morphism $f : X \\to Y$ from $X$ to $Y$, if $P(f)$ holds, then $P(f \\circ e)$ also holds, where $f \\circ e$ denotes the composition of $f$ followed by $e$.", "formal_statement": "import Mathlib\nopen CategoryTheory Opposite\nlemma of_respects_arrow_iso_tac_6290 [Category.{v, u} C] (P : MorphismProperty C) (hP : ∀ (f g : Arrow C), (f ≅ g) → P f.hom → P g.hom) (X : C) (Y : C) (Z : C) (e : Y ≅ Z) : ∀ (f : X ⟶ Y), P f → P (f ≫ e.hom) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the statement within the framework of category theory in Lean. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context**: \n   - We are working within the context of category theory, which is a branch of mathematics that deals with abstract structures and relationships between them.\n   - The statement involves a category $\\mathcal{C}$, morphisms, and a property $P$ of these morphisms.\n\n2. **Defining the Category and Morphism Property**:\n   - In Lean, we use `Category.{v, u} C` to define a category `C` with objects and morphisms. The parameters `{v, u}` denote the universe levels for the objects and morphisms.\n   - `MorphismProperty C` is a type that represents a property `P` of morphisms in the category `C`.\n\n3. **Expressing the Condition on Property $P$**:\n   - The condition given is that if two morphisms `f` and `g` are isomorphic, then the property $P$ is preserved between them. This is expressed in Lean as:\n     ```lean\n     ∀ (f g : Arrow C), (f ≅ g) → P f.hom → P g.hom\n     ```\n   - Here, `Arrow C` represents a morphism in the category `C`, and `f.hom` and `g.hom` are the actual morphisms (arrows) associated with `f` and `g`.\n\n4. **Defining Objects and Isomorphism**:\n   - We introduce objects `X`, `Y`, and `Z` in the category `C` using `(X : C) (Y : C) (Z : C)`.\n   - An isomorphism `e` from `Y` to `Z` is represented as `(e : Y ≅ Z)`. In Lean, `Y ≅ Z` denotes an isomorphism between objects `Y` and `Z`.\n\n5. **Stating the Main Lemma**:\n   - The goal is to show that for any morphism `f : X ⟶ Y`, if `P(f)` holds, then `P(f \\circ e)` also holds. In Lean, this is expressed as:\n     ```lean"}
{"source_file": "herald_data/sample_500.jsonl", "line": 153, "id": 564458, "informal_statement": "Let $a$ , $b$ , $c$ and $k$ be positive numbers. Prove that:\\n $\\sqrt{\\frac{kb+c}{a}}+\\sqrt{\\frac{kc+a}{b}}+\\sqrt{\\frac{ka+b}{c}}\\leq\\sqrt{k+1}\\left(\\frac{a}{b}+\\frac{b}{c}+\\frac{c}{a}\\right)$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_564458 (a b c k : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : (Real.sqrt ((k * b + c) / a) + Real.sqrt ((k * c + a) / b) + Real.sqrt ((k * a + b) / c)) ≤ Real.sqrt (k + 1) * (a / b + b / c + c / a)   :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow a structured approach:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves four variables: \\(a\\), \\(b\\), \\(c\\), and \\(k\\), all of which are positive numbers. In Lean, these are represented as real numbers (`ℝ`), and their positivity is expressed using inequalities.\n\n2. **Import Necessary Libraries**:\n   - The code begins with `import Mathlib`, which is a comprehensive library in Lean that includes various mathematical tools and theorems. Additionally, `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to access specific functionalities related to real numbers, natural numbers, and topology.\n\n3. **Define the Theorem**:\n   - The theorem is named `extract_aug_564458`, which is a unique identifier for this particular statement. The parameters of the theorem are the real numbers \\(a\\), \\(b\\), \\(c\\), and \\(k\\).\n\n4. **State the Positivity Conditions**:\n   - The conditions `ha : 0 < a`, `hb : 0 < b`, and `hc : 0 < c` are included as hypotheses in the theorem. These ensure that \\(a\\), \\(b\\), and \\(c\\) are positive, aligning with the informal statement.\n\n5. **Translate the Mathematical Expression**:\n   - The left-hand side of the inequality in the informal statement is \\(\\sqrt{\\frac{kb+c}{a}} + \\sqrt{\\frac{kc+a}{b}} + \\sqrt{\\frac{ka+b}{c}}\\). In Lean, this is expressed using `Real.sqrt` for the square root and standard arithmetic operations for addition and division.\n   - The right-hand side is \\(\\sqrt{k+1}\\left(\\frac{a}{b} + \\frac{b}{c} + \\frac{c}{a}\\right)\\). Similarly, `Real.sqrt` is used for the square root, and multiplication is represented by `*`.\n\n6. **Formulate the Inequality**:\n   - The inequality is expressed using `≤`, which is the Lean syntax for \"less than or equal to\". The entire expression is enclosed within the theorem statement, ensuring that the inequality is the main focus of the proof.\n\n7. **Conclude with a Placeholder for the Proof"}
{"source_file": "herald_data/sample_500.jsonl", "line": 150, "id": 509458, "informal_statement": "Given $a=x^2, b=y^2, c=z^2$ and $x^2+y^2+z^2=3$, prove $4(x^3+y^3+z^3)+15xyz \\ge 27$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_509458 (x y z : ℝ) (h : x ^ 2 + y ^ 2 + z ^ 2 = 3) :\n  4 * (x ^ 3 + y ^ 3 + z ^ 3) + 15 * x * y * z ≥ 27   :=  by sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves real numbers \\(x\\), \\(y\\), and \\(z\\). In Lean, these are represented as variables of type `ℝ` (the type for real numbers).\n\n2. **Express the Given Conditions**:\n   - The condition \\(x^2 + y^2 + z^2 = 3\\) is a hypothesis in the theorem. In Lean, this is expressed as `h : x ^ 2 + y ^ 2 + z ^ 2 = 3`, where `h` is the name given to this hypothesis.\n\n3. **State the Conclusion to Prove**:\n   - The goal is to prove the inequality \\(4(x^3 + y^3 + z^3) + 15xyz \\ge 27\\). In Lean, this is expressed using the `≥` operator for greater than or equal to, resulting in `4 * (x ^ 3 + y ^ 3 + z ^ 3) + 15 * x * y * z ≥ 27`.\n\n4. **Structure the Theorem**:\n   - The theorem is structured using the `theorem` keyword, followed by a name for the theorem (`extract_aug_509458`), and the list of variables and hypotheses. The conclusion follows after the colon.\n\n5. **Use of Lean Libraries**:\n   - The `import Mathlib` statement is used to import necessary mathematical libraries that provide definitions and theorems for real numbers and inequalities.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to bring into scope various operations and properties related to real numbers, natural numbers, and topological concepts, which might be useful for the proof.\n\n6. **Proof Placeholder**:\n   - The `:= by sorry` part indicates that the proof is not yet provided. The `sorry` keyword is a placeholder that allows the theorem to be accepted by Lean without a complete proof.\n\nBy following these steps, the informal statement is translated into a formal Lean theorem that sets up the problem correctly, ready for a proof to be constructed."}
{"source_file": "herald_data/sample_500.jsonl", "line": 151, "id": 173152, "informal_statement": "For a commutative ring $R$, an additive commutative group $M$, and $M$ a module over $R$, let $I$ be an ideal of $R$, $F$ and $F'$ be filtrations of $M$ by $I$. Given that $F$'s zeroth term is less than or equal to $F'$'s zeroth term, and for all $n \\geq n_0$, the $n$th term of $F$ multiplied by $I$ is equal to the $(n+1)$th term of $F$, there exists an $n_0$ such that for all $n \\in \\mathbb{N}$, the $(n+n_0)$th term of $F$ is less than or equal to the $n$th term of $F'$.", "formal_statement": "import Mathlib\nopen Polynomial\nopen scoped Polynomial\nlemma exists_forall_le_tac_7580 [CommRing R] [AddCommGroup M] [Module R M] (I : Ideal R) (F : I.Filtration M) (F' : I.Filtration M) (e : F.N 0 ≤ F'.N 0) (n₀ : ℕ) (hF : ∀ n ≥ n₀, I • F.N n = F.N (n + 1)) : ∃ n₀, ∀ (n : ℕ), F.N (n + n₀) ≤ F'.N n := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it corresponds to the Lean4 constructs:\n\n1. **Commutative Ring and Module Setup**:\n   - The informal statement begins by specifying a commutative ring \\( R \\) and an additive commutative group \\( M \\), where \\( M \\) is a module over \\( R \\). In Lean, this is expressed using type classes: `[CommRing R]` for the commutative ring and `[AddCommGroup M] [Module R M]` for the module structure over \\( R \\).\n\n2. **Ideal and Filtrations**:\n   - An ideal \\( I \\) of \\( R \\) is represented as `I : Ideal R` in Lean. \n   - Filtrations \\( F \\) and \\( F' \\) of \\( M \\) by \\( I \\) are represented as `F : I.Filtration M` and `F' : I.Filtration M`. This assumes that `I.Filtration M` is a type that represents a filtration of the module \\( M \\) by the ideal \\( I \\).\n\n3. **Initial Condition on Filtrations**:\n   - The condition that \\( F \\)'s zeroth term is less than or equal to \\( F' \\)'s zeroth term is expressed as `e : F.N 0 ≤ F'.N 0`. Here, `F.N 0` and `F'.N 0` represent the zeroth terms of the filtrations \\( F \\) and \\( F' \\), respectively.\n\n4. **Condition on Filtration Terms**:\n   - The condition that for all \\( n \\geq n_0 \\), the \\( n \\)th term of \\( F \\) multiplied by \\( I \\) is equal to the \\( (n+1) \\)th term of \\( F \\) is expressed as `hF : ∀ n ≥ n₀, I • F.N n = F.N (n + 1)`. This uses the `•` operator to denote the action of the ideal \\( I \\) on the \\( n \\)th term of the filtration.\n\n5. **Existence of \\( n_0 \\) with Desired Property**:\n   - The goal is to show the existence of an \\( n_0 \\) such that"}
{"source_file": "herald_data/sample_500.jsonl", "line": 154, "id": 454713, "informal_statement": "Prove that if $ x\\geq0$ $ y\\geq0$ ,then $ x^{4}+y^{4}+1 \\geq x^{3}y+y^{3}+1$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_454713 (x y : ℝ) (hx: x >= 0 ∧ y >= 0) : x^4 + y^4 + 1 >= x^3 * y + y^3 + 1  :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves two variables, \\( x \\) and \\( y \\), which are real numbers. In Lean, real numbers are represented by the type `ℝ`.\n\n2. **Express the Conditions**:\n   - The conditions given are \\( x \\geq 0 \\) and \\( y \\geq 0 \\). In Lean, these conditions are expressed using the `>=` operator. The conjunction of these conditions is represented using the logical `∧` (and).\n\n3. **State the Inequality**:\n   - The inequality to prove is \\( x^4 + y^4 + 1 \\geq x^3y + y^3 + 1 \\). In Lean, exponentiation is represented by the `^` operator, and multiplication is represented by `*`. The inequality itself is expressed using `>=`.\n\n4. **Structure the Theorem**:\n   - The theorem is structured using the `theorem` keyword, followed by a name for the theorem (`extract_aug_454713` in this case). The variables \\( x \\) and \\( y \\) are declared with their type `ℝ`.\n   - The hypothesis `hx` is introduced to encapsulate the conditions \\( x \\geq 0 \\) and \\( y \\geq 0 \\).\n   - The conclusion of the theorem is the inequality \\( x^4 + y^4 + 1 \\geq x^3y + y^3 + 1 \\).\n\n5. **Use of Lean Libraries**:\n   - The `import Mathlib` statement is used to bring in necessary mathematical libraries that provide definitions and theorems for real numbers and inequalities.\n   - The `open BigOperators`, `open Real`, `open Nat`, and `open Topology` statements are used to make various mathematical operations and properties available without needing to prefix them with their module names.\n\n6. **Proof Placeholder**:\n   - The `:= by sorry` part indicates that the proof is not yet provided. The `sorry` keyword is a placeholder that allows the theorem to be syntactically correct without a proof.\n\nBy following these steps, the informal statement is translated into a formal Lean theorem that correctly represents the mathematical assertion and its conditions."}
{"source_file": "herald_data/sample_500.jsonl", "line": 156, "id": 576651, "informal_statement": "Let $a, b, c$ be nonegative numbers satisfied $ab + bc + ca >0$ . Prove that:\\n $\\dfrac{a}{b+c} + \\dfrac{b}{a+c} + \\dfrac{c}{b+a} + 4\\sqrt{2}\\sqrt{\\dfrac{ab+bc+ca}{a^2 + b^2 + c^2}} \\geq 6$ .", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_576651 (a b c : ℝ) (habpbcpcageq0 : a * b + b * c + c * a > 0) (ha : a ≥ 0) (hb : b ≥ 0) (hc : c ≥ 0) : a / (b + c) + b / (a + c) + c / (b + a) + 4 * Real.sqrt 2 * Real.sqrt ((a * b + b * c + c * a) / (a ^ 2 + b ^ 2 + c ^ 2)) ≥ 6   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow a structured approach to ensure that all components of the statement are accurately represented in the formal language. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Variables and Assumptions:**\n   - The informal statement involves three non-negative real numbers \\(a\\), \\(b\\), and \\(c\\).\n   - The condition \\(ab + bc + ca > 0\\) is given.\n\n2. **Define the Variables in Lean:**\n   - In Lean, we declare the variables \\(a\\), \\(b\\), and \\(c\\) as real numbers using `(a b c : ℝ)`.\n   - The type `ℝ` denotes real numbers in Lean.\n\n3. **State the Assumptions:**\n   - The condition \\(ab + bc + ca > 0\\) is translated to `(habpbcpcageq0 : a * b + b * c + c * a > 0)`.\n   - The non-negativity of \\(a\\), \\(b\\), and \\(c\\) is expressed as `(ha : a ≥ 0)`, `(hb : b ≥ 0)`, and `(hc : c ≥ 0)`.\n\n4. **Translate the Expression to be Proved:**\n   - The expression \\(\\frac{a}{b+c} + \\frac{b}{a+c} + \\frac{c}{b+a} + 4\\sqrt{2}\\sqrt{\\frac{ab+bc+ca}{a^2 + b^2 + c^2}} \\geq 6\\) is translated directly into Lean syntax.\n   - Division is represented by `/`, and addition by `+`.\n   - The square root function is `Real.sqrt`.\n   - The power operation is represented by `^`, so \\(a^2\\) is written as `a ^ 2`.\n\n5. **Construct the Theorem Statement:**\n   - The theorem is named `extract_aug_576651`, which is a placeholder name.\n   - The theorem statement includes all the assumptions and the expression to be proved, ending with `≥ 6`.\n\n6. **Use of Lean Libraries:**\n   - The `import Mathlib` statement is used to include necessary mathematical libraries.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are"}
{"source_file": "herald_data/sample_500.jsonl", "line": 155, "id": 222090, "informal_statement": "For any commutative ring $R$, any additive commutative group $M$, and given $M$ is a module over $R$, let $f : M \\rightarrow_{\\mathbb{L}[R]} M$ be an $R$-linear map, $p, q \\in R[X]$ be polynomials over $R$, and $v \\in M$ be an element such that $v$ is in the kernel of the evaluation of $f$ on the polynomial $p \\cdot q$. Further, let $p', q' \\in R[X]$ be polynomials such that $p' \\cdot p + q' \\cdot q = 1$, and suppose $(\\text{aeval } f)(q \\cdot (p \\cdot p'))v = 0$. Show that $0 = 0$.\n\nNote: The statement $0 = 0$ is a trivial equality and might indicate a placeholder or a simplification step in the context of the proof.", "formal_statement": "import Mathlib\nopen Polynomial\nopen Finset\nopen Polynomial\nlemma sup_ker_aeval_eq_ker_aeval_mul_of_coprime_tac_42720 [CommRing R] [AddCommGroup M] [Module R M] (f : M →ₗ[R] M) (p : R[X]) (q : R[X]) (v : M) (hv : v ∈ LinearMap.ker ((aeval f) (p * q))) (p' : R[X]) (q' : R[X]) (hpq' : p' * p + q' * q = 1) (h_eval₂_qpp' : ((aeval f) (q * (p * p'))) v = 0) : 0 = 0 := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the mathematical concepts and their relationships. Here's a step-by-step explanation of the translation:\n\n1. **Identify the Mathematical Structures:**\n   - The informal statement involves a commutative ring \\( R \\), an additive commutative group \\( M \\), and a module structure of \\( M \\) over \\( R \\). In Lean, these are represented by type classes `CommRing R`, `AddCommGroup M`, and `Module R M`.\n\n2. **Define the Linear Map:**\n   - The map \\( f : M \\rightarrow_{\\mathbb{L}[R]} M \\) is an \\( R \\)-linear map. In Lean, this is represented by `f : M →ₗ[R] M`, where `→ₗ[R]` denotes an \\( R \\)-linear map.\n\n3. **Polynomials and Elements:**\n   - The polynomials \\( p, q \\in R[X] \\) are elements of the polynomial ring over \\( R \\). In Lean, these are simply `p : R[X]` and `q : R[X]`.\n   - The element \\( v \\in M \\) is represented as `v : M`.\n\n4. **Kernel Condition:**\n   - The condition that \\( v \\) is in the kernel of the evaluation of \\( f \\) on the polynomial \\( p \\cdot q \\) is expressed as `v ∈ LinearMap.ker ((aeval f) (p * q))`. Here, `aeval f` is the evaluation of the polynomial at the linear map \\( f \\), and `LinearMap.ker` denotes the kernel of a linear map.\n\n5. **Coprime Polynomials:**\n   - The polynomials \\( p', q' \\in R[X] \\) satisfy the condition \\( p' \\cdot p + q' \\cdot q = 1 \\). This is expressed in Lean as `p' * p + q' * q = 1`, indicating that \\( p \\) and \\( q \\) are coprime.\n\n6. **Additional Evaluation Condition:**\n   - The condition \\((\\text{aeval } f)(q \\cdot (p \\cdot p'))v = 0\\) is represented as `((aeval f) (q *"}
{"source_file": "herald_data/sample_500.jsonl", "line": 158, "id": 326863, "informal_statement": "For any commutative ring $R$ and natural numbers $n$ and $\\nu$, the derivative of the Bernstein polynomial $B_{n+1, \\nu+1}$ in $R$ is equal to $(n + 1)$ times the difference between the Bernstein polynomials $B_{n, \\nu}$ and $B_{n, \\nu+1}$ in $R$. In formula, this is expressed as $\\frac{d}{dx}B_{n+1, \\nu+1}(x) = (n + 1) \\cdot (B_{n, \\nu}(x) - B_{n, \\nu+1}(x))$.", "formal_statement": "import Mathlib\nopen Nat (choose)\nopen Polynomial (X)\nopen scoped Polynomial\nlemma derivative_succ_aux_tac_3181 [CommRing R] (n : ℕ) (ν : ℕ) : Polynomial.derivative (bernsteinPolynomial R (n + 1) (ν + 1)) =\n  (↑n + 1) * (bernsteinPolynomial R n ν - bernsteinPolynomial R n (ν + 1)) := sorry", "explanation": "To translate the given informal mathematical statement into Lean4 code, we need to follow a series of steps that involve understanding both the mathematical concepts and how they are represented in Lean4. Here's a detailed breakdown of the translation process:\n\n1. **Understanding the Context**: \n   - The statement involves Bernstein polynomials, which are a family of polynomials used in approximation theory.\n   - We are working within the context of a commutative ring \\( R \\), which is a common setting for polynomial operations.\n\n2. **Identifying the Mathematical Objects**:\n   - The informal statement mentions Bernstein polynomials \\( B_{n+1, \\nu+1} \\), \\( B_{n, \\nu} \\), and \\( B_{n, \\nu+1} \\).\n   - The derivative of a polynomial is also involved, as well as operations like multiplication and subtraction of polynomials.\n\n3. **Formalizing the Ring and Polynomials**:\n   - In Lean, we specify that \\( R \\) is a commutative ring using `[CommRing R]`.\n   - Bernstein polynomials are represented by a function `bernsteinPolynomial` which takes the ring \\( R \\), and indices \\( n \\) and \\( \\nu \\).\n\n4. **Translating the Derivative**:\n   - The derivative of a polynomial in Lean is represented by `Polynomial.derivative`.\n   - The expression `Polynomial.derivative (bernsteinPolynomial R (n + 1) (ν + 1))` captures the derivative of the Bernstein polynomial \\( B_{n+1, \\nu+1} \\).\n\n5. **Translating the Polynomial Operations**:\n   - The multiplication by \\( n + 1 \\) is represented as `(↑n + 1) *`, where `↑n` is the coercion of the natural number \\( n \\) to the ring \\( R \\).\n   - The subtraction of Bernstein polynomials is expressed as `(bernsteinPolynomial R n ν - bernsteinPolynomial R n (ν + 1))`.\n\n6. **Constructing the Lemma**:\n   - The lemma is named `derivative_succ_aux_tac_3181`, which is a placeholder name and can be replaced with a more descriptive one.\n   - The lemma states the equality between the derivative and the expression involving the difference of Bernstein polynomials, multiplied by \\( n + 1 \\).\n\n7. **Using Lean's Syntax**:"}
{"source_file": "herald_data/sample_500.jsonl", "line": 149, "id": 134632, "informal_statement": "For any measurable space $m$ on $\\alpha$, a signed measure $s$ on $\\alpha$, sets $i, j \\subset \\alpha$, given that the restriction of the zero vector measure to $i$ is less than or equal to the restriction of $s$ to $i$, and that $i$ is a measurable set, show that the measure obtained from $s$ by restricting it to $i$ and ensuring it is non-negative is strictly less than the top element when applied to the universal set.", "formal_statement": "import Mathlib\nopen NNReal ENNReal MeasureTheory\nopen Set MeasureTheory\nopen Classical in\nopen Classical in\nopen Measure\nopen Classical in\nopen Classical in\nopen MeasureTheory\nopen Classical in\nopen VectorMeasure\nopen MeasureTheory\nlemma toMeasureOfZeroLE_finite_tac_46975 (m : MeasurableSpace α) (s : SignedMeasure α) (i : Set α) (j : Set α) (hi : VectorMeasure.restrict 0 i ≤ VectorMeasure.restrict s i) (hi₁ : MeasurableSet i) : (s.toMeasureOfZeroLE i hi₁ hi) univ < ⊤ := sorry", "explanation": "To translate the given informal mathematical statement into the provided Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Measurable Space and Signed Measure**:\n   - The informal statement begins with \"For any measurable space $m$ on $\\alpha$, a signed measure $s$ on $\\alpha$\". In Lean, this is represented by the parameters `(m : MeasurableSpace α)` and `(s : SignedMeasure α)`. Here, `α` is a type, `m` is a measurable space on `α`, and `s` is a signed measure on `α`.\n\n2. **Sets $i$ and $j$**:\n   - The sets $i$ and $j$ are subsets of $\\alpha$. In Lean, these are represented as `(i : Set α)` and `(j : Set α)`. These are simply subsets of the type `α`.\n\n3. **Restriction of Zero Vector Measure**:\n   - The condition \"the restriction of the zero vector measure to $i$ is less than or equal to the restriction of $s$ to $i$\" is formalized as `(hi : VectorMeasure.restrict 0 i ≤ VectorMeasure.restrict s i)`. Here, `VectorMeasure.restrict 0 i` represents the restriction of the zero vector measure to the set `i`, and `VectorMeasure.restrict s i` represents the restriction of the signed measure `s` to `i`. The inequality `≤` indicates that the zero vector measure is less than or equal to the signed measure `s` on the set `i`.\n\n4. **Measurable Set $i$**:\n   - The condition \"and that $i$ is a measurable set\" is represented by `(hi₁ : MeasurableSet i)`. This asserts that the set `i` is measurable in the measurable space `m`.\n\n5. **Measure from Signed Measure**:\n   - The goal is to show that \"the measure obtained from $s$ by restricting it to $i$ and ensuring it is non-negative is strictly less than the top element when applied to the universal set\". In Lean, this is expressed as `(s.toMeasureOfZeroLE i hi₁ hi) univ < ⊤`. Here, `s.toMeasureOfZeroLE i hi₁ hi"}
{"source_file": "herald_data/sample_500.jsonl", "line": 159, "id": 428213, "informal_statement": "For any sets $s$ and $t$, show that $s \\text{ ite } s \\ t = s \\cup t$.", "formal_statement": "import Mathlib\nopen Function\nopen scoped symmDiff\n@[simp]\ntheorem ite_left (s t : Set α) : s.ite s t = s ∪ t := sorry", "explanation": "To translate the informal statement \"For any sets \\( s \\) and \\( t \\), show that \\( s \\text{ ite } s \\ t = s \\cup t \\)\" into the formal Lean4 statement, we follow these steps:\n\n1. **Understanding the Informal Statement**: \n   - We are given two sets \\( s \\) and \\( t \\).\n   - The operation \\( s \\text{ ite } s \\ t \\) is a conditional operation that selects elements from \\( s \\) or \\( t \\) based on membership in \\( s \\).\n   - The goal is to show that this operation results in the union of \\( s \\) and \\( t \\), denoted \\( s \\cup t \\).\n\n2. **Identifying Lean Constructs**:\n   - In Lean, sets are typically represented using the `Set` type.\n   - The union of two sets \\( s \\) and \\( t \\) is represented as `s ∪ t`.\n   - The `ite` function in Lean is a conditional function that stands for \"if-then-else\". In the context of sets, `s.ite s t` means \"if an element is in \\( s \\), then include it from \\( s \\); otherwise, include it from \\( t \\)\".\n\n3. **Formalizing the Statement in Lean**:\n   - We start by importing necessary modules. `Mathlib` is imported to access mathematical constructs and theorems.\n   - We open the `Function` namespace to use function-related utilities.\n   - We use `open scoped symmDiff` to ensure that operations related to symmetric differences and similar set operations are available.\n   - We define a theorem named `ite_left` which takes two sets \\( s \\) and \\( t \\) of type `Set α`, where `α` is an arbitrary type.\n   - The statement of the theorem is `s.ite s t = s ∪ t`, which asserts that the conditional operation results in the union of the two sets.\n\n4. **Annotation and Proof**:\n   - The `@[simp]` attribute is used to mark this theorem as a simplification rule, allowing Lean's simplifier to automatically use it to simplify expressions involving `ite` and set unions.\n   - The proof is left as `sorry`, indicating that the proof is not provided here but needs to be completed.\n\nBy following these steps, we translate the informal mathematical statement into"}
{"source_file": "herald_data/sample_500.jsonl", "line": 160, "id": 398408, "informal_statement": "For any sets \\(\\alpha\\) and \\(\\beta\\), if there exists a bijection \\(f: \\alpha \\to \\beta\\), then \\(\\left| \\alpha \\right| = \\left| \\beta \\right|\\).", "formal_statement": "import Mathlib\nopen Cardinal Function\ntheorem card_eq_of_bijective (f : α → β) (hf : Function.Bijective f) : Nat.card α = Nat.card β := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down the components of the statement and map them to their corresponding Lean constructs:\n\n1. **Sets \\(\\alpha\\) and \\(\\beta\\):** \n   - In Lean, sets are often represented by types. Here, \\(\\alpha\\) and \\(\\beta\\) are represented as types `α` and `β`.\n\n2. **Existence of a bijection \\(f: \\alpha \\to \\beta\\):**\n   - A function \\(f\\) from \\(\\alpha\\) to \\(\\beta\\) is represented as `f : α → β` in Lean.\n   - The property of being a bijection is captured by `Function.Bijective f`, which is a predicate in Lean that asserts \\(f\\) is both injective and surjective.\n\n3. **Equality of cardinalities \\(\\left| \\alpha \\right| = \\left| \\beta \\right|\\):**\n   - The cardinality of a type in Lean can be expressed using `Nat.card`, which gives the cardinality of a type as a natural number.\n   - Therefore, the statement \\(\\left| \\alpha \\right| = \\left| \\beta \\right|\\) translates to `Nat.card α = Nat.card β`.\n\n4. **Theorem structure:**\n   - The statement is formalized as a theorem named `card_eq_of_bijective`.\n   - The theorem takes two arguments: a function `f : α → β` and a proof `hf : Function.Bijective f` that \\(f\\) is bijective.\n   - The conclusion of the theorem is the equality of cardinalities: `Nat.card α = Nat.card β`.\n\n5. **Imports and namespace:**\n   - The code begins with `import Mathlib` to access mathematical libraries.\n   - `open Cardinal Function` is used to bring the relevant definitions and theorems into scope, specifically those related to cardinalities and functions.\n\n6. **Proof placeholder:**\n   - The `:= sorry` at the end of the theorem indicates that the proof is not provided. In Lean, `sorry` is a placeholder for an incomplete proof.\n\nBy following these steps, the informal mathematical statement is accurately translated into the formal Lean4 code."}
{"source_file": "herald_data/sample_500.jsonl", "line": 157, "id": 210926, "informal_statement": "For any ordered commutative monoid \\(N\\), and given a function \\(f\\) from index set \\(\\iota\\) to \\(N\\), and a finite set \\(s\\) of \\(\\iota\\), if for all \\(i\\) in \\(s\\), \\(1 \\leq f(i)\\), prove that the product of \\(f(i)\\) over all \\(i\\) in \\(s\\) equals 1 if and only if for all \\(i\\) in \\(s\\), \\(f(i) = 1\\).", "formal_statement": "import Mathlib\nopen Function\nlemma prod_eq_one_iff_of_one_le'_tac_7440 [OrderedCommMonoid N] (f : ι → N) (s : Finset ι) : (∀ i ∈ s, 1 ≤ f i) → (∏ i ∈ s, f i = 1 ↔ ∀ i ∈ s, f i = 1) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Ordered Commutative Monoid \\(N\\):**\n   - In the informal statement, \\(N\\) is specified as an \"ordered commutative monoid.\" In Lean, this is represented by the type class `[OrderedCommMonoid N]`. This type class ensures that \\(N\\) has a commutative binary operation (usually multiplication), an identity element (usually 1), and a partial order that is compatible with the monoid operation.\n\n2. **Function \\(f\\) from index set \\(\\iota\\) to \\(N\\):**\n   - The function \\(f : \\iota \\to N\\) is directly translated to `f : ι → N` in Lean. Here, `ι` is a type representing the index set \\(\\iota\\), and `N` is the target type of the function, which is the ordered commutative monoid.\n\n3. **Finite set \\(s\\) of \\(\\iota\\):**\n   - The finite set \\(s\\) is represented by `s : Finset ι` in Lean. `Finset` is a Lean data structure used to represent finite sets, and `ι` is the type of elements in the set, corresponding to the index set \\(\\iota\\).\n\n4. **Condition \\(1 \\leq f(i)\\) for all \\(i\\) in \\(s\\):**\n   - The condition \"for all \\(i\\) in \\(s\\), \\(1 \\leq f(i)\\)\" is expressed as `∀ i ∈ s, 1 ≤ f i` in Lean. This uses the universal quantifier `∀` to state that for every element `i` in the finite set `s`, the inequality `1 ≤ f i` holds.\n\n5. **Product of \\(f(i)\\) over all \\(i\\) in \\(s\\):**\n   - The product of \\(f(i)\\) over all \\(i\\) in \\(s\\) is represented by `∏ i ∈ s, f i` in Lean. The symbol `∏` denotes the product over a finite set, similar to the summation symbol `∑` but for"}
{"source_file": "herald_data/sample_500.jsonl", "line": 161, "id": 470417, "informal_statement": "Let $x,y,z$ be real numbers such that $x^2+y^2+z^2-2xyz=1$ . Prove that $(1+x)(1+y)(1+z)\\le 4+4xyz.$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_470417 (x y z : ℝ) (h : x ^ 2 + y ^ 2 + z ^ 2 - 2 * x * y * z = 1) :\n  (1 + x) * (1 + y) * (1 + z) ≤ 4 + 4 * x * y * z  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow a structured approach:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves three variables: \\(x\\), \\(y\\), and \\(z\\), which are specified to be real numbers. In Lean, real numbers are represented by the type `ℝ`.\n\n2. **Express the Given Condition**:\n   - The condition given in the problem is \\(x^2 + y^2 + z^2 - 2xyz = 1\\). In Lean, this is expressed using the arithmetic operations and the equality operator. The expression `x ^ 2` represents \\(x^2\\), and `2 * x * y * z` represents \\(2xyz\\). The condition is then written as `x ^ 2 + y ^ 2 + z ^ 2 - 2 * x * y * z = 1`.\n\n3. **State the Conclusion to Prove**:\n   - The conclusion we need to prove is \\((1+x)(1+y)(1+z) \\le 4 + 4xyz\\). In Lean, multiplication is represented by `*`, and addition by `+`. The inequality is represented by `≤`. Thus, the conclusion is written as `(1 + x) * (1 + y) * (1 + z) ≤ 4 + 4 * x * y * z`.\n\n4. **Structure the Theorem**:\n   - In Lean, a theorem is declared using the `theorem` keyword, followed by a name for the theorem. Here, it is named `extract_aug_470417`.\n   - The variables \\(x\\), \\(y\\), and \\(z\\) are introduced as arguments to the theorem, each of type `ℝ`.\n   - The given condition is introduced as a hypothesis `h`, which is a proposition that must hold true for the theorem to be applicable.\n\n5. **Combine the Elements**:\n   - The theorem statement combines the variables, the hypothesis, and the conclusion. The hypothesis `h` is included as a premise, and the conclusion is the goal to be proved.\n   - The `by sorry` part indicates that the proof is not provided here, but the structure is set up for a proof to be inserted.\n\n6. **Import Necessary Libraries**:\n   - The `import Mathlib` statement is used to include the necessary"}
{"source_file": "herald_data/sample_500.jsonl", "line": 163, "id": 484472, "informal_statement": "Let $a,b,c$ be the positive real numbers such that $a+b+c=3$ . Prove that $\\sqrt{b^2-bc+c^2}+\\sqrt{c^2-ca+a^2}+\\sqrt{a^2-ab+b^2} \\le 3.$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_484472 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hab : a + b + c = 3) : Real.sqrt (b^2 - b * c + c^2) + Real.sqrt (c^2 - c * a + a^2) + Real.sqrt (a^2 - a * b + b^2) ≤ 3  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow a structured approach that captures the essence of the problem and its constraints. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves three variables \\(a\\), \\(b\\), and \\(c\\), which are specified as positive real numbers. In Lean, real numbers are represented by the type `ℝ`.\n   - We declare these variables in the theorem statement as `(a b c : ℝ)`.\n\n2. **Express the Positivity Condition**:\n   - The condition that \\(a\\), \\(b\\), and \\(c\\) are positive is expressed in Lean using inequalities. Specifically, `0 < a`, `0 < b`, and `0 < c`.\n   - These conditions are added as hypotheses in the theorem: `(ha : 0 < a) (hb : 0 < b) (hc : 0 < c)`.\n\n3. **Express the Sum Condition**:\n   - The condition \\(a + b + c = 3\\) is a straightforward equality in Lean. We express this as `(hab : a + b + c = 3)`.\n\n4. **Translate the Inequality to Prove**:\n   - The goal is to prove the inequality \\(\\sqrt{b^2-bc+c^2}+\\sqrt{c^2-ca+a^2}+\\sqrt{a^2-ab+b^2} \\le 3\\).\n   - In Lean, the square root function is `Real.sqrt`, and the arithmetic operations are expressed using standard operators.\n   - The left-hand side of the inequality is translated as `Real.sqrt (b^2 - b * c + c^2) + Real.sqrt (c^2 - c * a + a^2) + Real.sqrt (a^2 - a * b + b^2)`.\n   - The inequality itself is expressed using `≤`.\n\n5. **Structure the Theorem**:\n   - The theorem is structured with the name `extract_aug_484472`, followed by the variable declarations, hypotheses, and the statement to be proved.\n   - The theorem statement is: \n     ```lean\n     theorem extract_aug_484472 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0"}
{"source_file": "herald_data/sample_500.jsonl", "line": 165, "id": 259951, "informal_statement": "For any element \\(a\\) in a commutative group \\(α\\) equipped with a lattice structure and a covariant class for multiplication and the partial order, show that the square of the absolute value of \\(a\\) equals the square of the absolute value of \\(a\\), i.e., \\((a⁺ᵐ)^2 = (a⁺ᵐ)^2\\).", "formal_statement": "import Mathlib\nopen Function\nlemma mul_mabs_eq_oneLePart_sq_tac_7576 [Lattice α] [CommGroup α] [CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] (a : α) : a⁺ᵐ ^ 2 = a⁺ᵐ ^ 2 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down the components of the statement and understand how they map to Lean's formal language:\n\n1. **Understanding the Context**:\n   - The informal statement involves a commutative group \\(α\\) with a lattice structure and a covariant class for multiplication and partial order. This suggests that \\(α\\) is a type that supports both group operations and lattice operations, and there is a specific interaction between multiplication and the order structure.\n\n2. **Lean Imports and Setup**:\n   - The line `import Mathlib` indicates that we are using the Lean mathematical library, which provides the necessary definitions and theorems for working with algebraic structures like groups and lattices.\n   - `open Function` is used to bring function-related definitions and theorems into the current namespace, although it is not directly used in the lemma.\n\n3. **Defining the Lemma**:\n   - The lemma is named `mul_mabs_eq_oneLePart_sq_tac_7576`. The name is not descriptive of the mathematical content but is likely generated automatically or chosen arbitrarily.\n   - The lemma statement begins with several typeclass constraints: `[Lattice α]`, `[CommGroup α]`, and `[CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]`. These constraints specify the properties of the type \\(α\\):\n     - `[Lattice α]` indicates that \\(α\\) has a lattice structure, meaning it supports operations like `sup` (join) and `inf` (meet).\n     - `[CommGroup α]` indicates that \\(α\\) is a commutative group, meaning it supports a binary operation (here, multiplication) that is associative, commutative, has an identity element, and each element has an inverse.\n     - `[CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]` specifies a covariant relationship between multiplication and the partial order. This means that multiplication respects the order: if \\(x ≤ y\\), then \\(a * x ≤ a * y\\) for any \\(a\\).\n\n4. **Formalizing the Statement**:\n   - The lemma takes an element `a : α` as input, which corresponds to the element"}
{"source_file": "herald_data/sample_500.jsonl", "line": 162, "id": 553857, "informal_statement": "Let $a,b,c\\geq 0.$ Prove that $\\frac{a}{b+c}+\\frac{b+c}{ a}+\\frac{2(ab+bc+ca)}{a^2+b^2+c^2} \\geq 3$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_553857 (a b c : ℝ) (ha : 0 ≤ a) (hb : 0 ≤ b) (hc : 0 ≤ c) : (a / (b + c) + (b + c) / a + (2 * (a * b + b * c + c * a)) / (a ^ 2 + b ^ 2 + c ^ 2)) ≥ 3   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow a series of steps to ensure that the formal statement accurately represents the problem. Here's a detailed breakdown of the translation process:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves three variables \\(a\\), \\(b\\), and \\(c\\), which are real numbers. In Lean, we represent real numbers using the type `ℝ`.\n\n2. **State the Non-negativity Conditions**:\n   - The conditions \\(a, b, c \\geq 0\\) are translated into Lean as hypotheses that each variable is greater than or equal to zero. This is done using the inequalities `0 ≤ a`, `0 ≤ b`, and `0 ≤ c`.\n\n3. **Translate the Expression**:\n   - The expression \\(\\frac{a}{b+c} + \\frac{b+c}{a} + \\frac{2(ab+bc+ca)}{a^2+b^2+c^2}\\) is translated into Lean using arithmetic operations and parentheses to ensure correct order of operations:\n     - `a / (b + c)` represents \\(\\frac{a}{b+c}\\).\n     - `(b + c) / a` represents \\(\\frac{b+c}{a}\\).\n     - `(2 * (a * b + b * c + c * a)) / (a ^ 2 + b ^ 2 + c ^ 2)` represents \\(\\frac{2(ab+bc+ca)}{a^2+b^2+c^2}\\).\n\n4. **Formulate the Inequality**:\n   - The goal is to prove that the entire expression is greater than or equal to 3. This is directly translated into Lean as `≥ 3`.\n\n5. **Structure the Theorem**:\n   - The theorem is named `extract_aug_553857`, which is a unique identifier for this particular theorem.\n   - The theorem takes three arguments `a`, `b`, and `c` of type `ℝ`, and three hypotheses `ha`, `hb`, and `hc` representing the non-negativity conditions.\n   - The conclusion of the theorem is the inequality involving the expression and the number 3.\n\n6. **Use of Lean Libraries**:\n   - The `import Mathlib` statement is used to bring in necessary mathematical libraries that provide definitions and theorems for real numbers and inequalities"}
{"source_file": "herald_data/sample_500.jsonl", "line": 164, "id": 126886, "informal_statement": "For any semiring \\( R \\) and any element \\( r \\in R \\), show that the Taylor polynomial of order 1 centered at \\( r \\) for the polynomial \\( 1 \\) is the constant polynomial \\( C1 \\), where \\( C1 \\) is the constant polynomial with coefficient 1.", "formal_statement": "import Mathlib\nopen Polynomial\nlemma taylor_one_tac_1632 [Semiring R] (r : R) : (taylor r) 1 = C 1 := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand the components involved in both the informal and formal statements and how they correspond to each other.\n\n1. **Understanding the Context**:\n   - We are working within the context of a semiring \\( R \\). In Lean, this is indicated by `[Semiring R]`, which specifies that \\( R \\) is a type that satisfies the semiring properties (i.e., it has addition, multiplication, and appropriate distributive laws).\n   - The element \\( r \\in R \\) is represented as `(r : R)` in Lean, indicating that \\( r \\) is an element of the semiring \\( R \\).\n\n2. **Taylor Polynomial**:\n   - The informal statement refers to the \"Taylor polynomial of order 1 centered at \\( r \\) for the polynomial \\( 1 \\).\" In Lean, the function `taylor` is used to compute the Taylor expansion of a polynomial. The expression `(taylor r) 1` represents the Taylor polynomial of the polynomial `1` centered at the point `r`.\n   - The polynomial `1` in Lean is simply represented as `1`, which is the constant polynomial with value 1.\n\n3. **Constant Polynomial**:\n   - The informal statement specifies that the result should be the constant polynomial \\( C1 \\), which is the constant polynomial with coefficient 1. In Lean, constant polynomials are represented using `C`, where `C a` is the constant polynomial with value `a`. Therefore, `C 1` is the constant polynomial with coefficient 1.\n\n4. **Formalizing the Statement**:\n   - The lemma is named `taylor_one_tac_1632`, which is a unique identifier for this particular result.\n   - The statement of the lemma is `(taylor r) 1 = C 1`, which asserts that the Taylor polynomial of the constant polynomial `1` centered at `r` is equal to the constant polynomial `C 1`.\n\n5. **Conclusion**:\n   - The `:= sorry` part indicates that the proof of this lemma is not provided and is left as a placeholder (`sorry` is used in Lean to indicate an incomplete proof).\n\nIn summary, the Lean code formalizes the informal statement by specifying the context of a semiring, using the `taylor` function to compute the Taylor polynomial, and representing constant polynomials with `C`. The lemma"}
{"source_file": "herald_data/sample_500.jsonl", "line": 166, "id": 235616, "informal_statement": "For any commutative rings $R$ and $A$, with $A$ an $R$-algebra, let $\\mathcal{A} : \\iota \\to \\text{Submodule}_R(A)$ be a family of $R$-submodules of $A$ indexed by $\\iota$, where $(\\iota, +)$ is an additive commutative monoid with decidable equality. Suppose further that $\\mathcal{A}$ forms a graded algebra structure on $A$. If $\\mathfrak{p}$ is a prime ideal of $A$, and if a contradiction $0 = 1$ in $A$ is given, then it can be concluded that $\\mathbf{False}$ holds.", "formal_statement": "import Mathlib\nopen DirectSum Pointwise\nopen DirectSum SetLike\nopen SetLike.GradedMonoid Submodule\nopen HomogeneousLocalization HomogeneousLocalization.NumDenSameDeg\nopen HomogeneousLocalization HomogeneousLocalization.NumDenSameDeg\nlemma instNontrivialAtPrime_tac_19654 [CommRing R] [CommRing A] [Algebra R A] (𝒜 : ι → Submodule R A) (x : Submonoid A) [AddCommMonoid ι] [DecidableEq ι] [GradedAlgebra 𝒜] (𝔭 : Ideal A) [𝔭.IsPrime] (r : 0 = 1) : False := sorry", "explanation": "To translate the given informal mathematical statement into the provided Lean4 code, we need to follow a structured approach that captures the essence of each component in the formal language of Lean. Here's a step-by-step explanation:\n\n1. **Commutative Rings and Algebra**:\n   - The informal statement begins by considering commutative rings \\( R \\) and \\( A \\), with \\( A \\) being an \\( R \\)-algebra. In Lean, this is expressed using type classes:\n     - `[CommRing R]` and `[CommRing A]` declare that \\( R \\) and \\( A \\) are commutative rings.\n     - `[Algebra R A]` indicates that \\( A \\) is an \\( R \\)-algebra.\n\n2. **Indexed Family of Submodules**:\n   - The family of \\( R \\)-submodules \\( \\mathcal{A} : \\iota \\to \\text{Submodule}_R(A) \\) is represented in Lean as `(𝒜 : ι → Submodule R A)`. Here, `𝒜` is a function from an index set \\( \\iota \\) to submodules of \\( A \\).\n\n3. **Index Set as an Additive Commutative Monoid**:\n   - The index set \\( \\iota \\) is an additive commutative monoid with decidable equality. This is captured by:\n     - `[AddCommMonoid ι]` which specifies that \\( \\iota \\) is an additive commutative monoid.\n     - `[DecidableEq ι]` which ensures that equality on \\( \\iota \\) is decidable.\n\n4. **Graded Algebra Structure**:\n   - The statement that \\( \\mathcal{A} \\) forms a graded algebra structure on \\( A \\) is formalized by `[GradedAlgebra 𝒜]`. This indicates that the family \\( \\mathcal{A} \\) provides a graded algebra structure on \\( A \\).\n\n5. **Prime Ideal**:\n   - The informal statement introduces a prime ideal \\( \\mathfrak{p} \\) of \\( A \\). In Lean, this is represented as `(𝔭 : Ideal A)` with an additional condition `[𝔭.IsPrime]` to specify that \\( \\mathfrak{p} \\) is a prime ideal.\n\n6. **Contradiction \\("}
{"source_file": "herald_data/sample_500.jsonl", "line": 169, "id": 22056, "informal_statement": "Show that the sine function is injective on the closed interval from $-\\frac{\\pi}{2}$ to $\\frac{\\pi}{2}$, i.e., $\\sin$ is one-to-one on $[-\\frac{\\pi}{2}, \\frac{\\pi}{2}]$.", "formal_statement": "import Mathlib\nopen scoped Classical\nopen Topology Filter Set\nopen Lean.Meta Qq\nopen Real\nopen Real NNReal\nopen Real\ntheorem injOn_sin_extracted : InjOn Real.sin (Icc (-(Real.pi / 2)) (Real.pi / 2)) := sorry", "explanation": "To formalize the informal statement \"Show that the sine function is injective on the closed interval from $-\\frac{\\pi}{2}$ to $\\frac{\\pi}{2}$\" in Lean4, we need to translate the mathematical concepts into Lean's syntax and semantics. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Informal Statement**:\n   - We need to show that the sine function, denoted as `sin`, is injective (one-to-one) on the interval $[-\\frac{\\pi}{2}, \\frac{\\pi}{2}]$.\n   - Injectivity means that if $\\sin(x) = \\sin(y)$ for $x, y$ in the interval, then $x = y$.\n\n2. **Lean's Mathematical Libraries**:\n   - We start by importing necessary modules from Lean's math library, `Mathlib`, which contains definitions and theorems about real numbers and trigonometric functions.\n\n3. **Opening Necessary Namespaces**:\n   - `open scoped Classical` allows the use of classical logic, which is often necessary for real analysis.\n   - `open Topology Filter Set` provides tools for dealing with topological spaces, filters, and sets, which might be useful for handling intervals and continuity.\n   - `open Lean.Meta Qq` and `open Real NNReal` are included to access meta-programming facilities and real number operations, respectively.\n\n4. **Defining the Interval**:\n   - The interval $[-\\frac{\\pi}{2}, \\frac{\\pi}{2}]$ is represented using `Icc`, which stands for \"interval, closed-closed\". In Lean, `Icc a b` denotes the set of all real numbers $x$ such that $a \\leq x \\leq b$.\n   - `Real.pi` is the Lean representation of the mathematical constant $\\pi$.\n\n5. **Formalizing Injectivity**:\n   - The property of being injective on a set is expressed using `InjOn`. The expression `InjOn Real.sin (Icc (-(Real.pi / 2)) (Real.pi / 2))` states that the sine function is injective on the interval $[-\\frac{\\pi}{2}, \\frac{\\pi}{2}]`.\n\n6. **Theorem Statement**:\n   - We declare a theorem named `injOn_sin_extracted` to encapsulate the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 168, "id": 357222, "informal_statement": "For a ring $\\kappa$, a normed additive commutative group $E$ which is a $\\kappa$-module, any submodule $s$ of $E$ is a normed additive commutative group, inheriting the norm from $E$.", "formal_statement": "import Mathlib\n\n/-- A submodule of a normed group is also a normed group, with the restriction of the norm. -/\ninstance normedAddCommGroup [Ring 𝕜] [NormedAddCommGroup E] [Module 𝕜 E]\n    (s : Submodule 𝕜 E) : NormedAddCommGroup s := sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to break down the components of the statement and understand how they map to Lean's type classes and structures. Here's the step-by-step explanation:\n\n1. **Identify the Mathematical Structures:**\n   - The informal statement involves a ring $\\kappa$, a normed additive commutative group $E$ which is also a $\\kappa$-module, and a submodule $s$ of $E$.\n   - In Lean, these structures are represented by type classes and instances.\n\n2. **Translate the Ring $\\kappa$:**\n   - In Lean, a ring is represented by the type class `Ring`. The type variable for the ring is denoted as `𝕜` in the formal statement.\n\n3. **Translate the Normed Additive Commutative Group $E$:**\n   - A normed additive commutative group is represented by the type class `NormedAddCommGroup`. The type variable for this group is `E`.\n   - The statement also specifies that $E$ is a $\\kappa$-module, which in Lean is represented by the type class `Module 𝕜 E`.\n\n4. **Translate the Submodule $s$:**\n   - A submodule of a module in Lean is represented by the structure `Submodule 𝕜 E`. The submodule `s` is an instance of this structure.\n\n5. **Formalize the Inheritance of the Norm:**\n   - The informal statement claims that any submodule $s$ of $E$ inherits the norm from $E$. In Lean, this is expressed by creating an instance of `NormedAddCommGroup` for the submodule `s`.\n   - The instance declaration `instance normedAddCommGroup ... : NormedAddCommGroup s` indicates that `s` is a normed additive commutative group.\n\n6. **Use of `sorry`:**\n   - The keyword `sorry` is a placeholder in Lean, indicating that the proof or construction of the instance is omitted. In a complete formalization, this would be replaced with the actual implementation that shows how the norm is inherited.\n\n7. **Importing Necessary Libraries:**\n   - The statement begins with `import Mathlib`, which is necessary to access the definitions and theorems related to rings, modules, and normed groups in Lean's mathematical library.\n\nBy following these steps, the informal"}
{"source_file": "herald_data/sample_500.jsonl", "line": 167, "id": 67139, "informal_statement": "For any formally unramified algebra $A$ over a ring $R$, and any commutative ring $C$ with an $R$-algebra structure, given a ring homomorphism $f : B \\to C$ that is also an $R$-algebra homomorphism, and assuming the kernel of $f$ as a ring homomorphism is nilpotent, if there are two $R$-algebra homomorphisms $g_1, g_2 : A \\to B$ such that the composition of $f$ with $g_1$ equals the composition of $f$ with $g_2$, then $g_1$ and $g_2$ are equal.", "formal_statement": "import Mathlib\nopen scoped TensorProduct\ntheorem lift_unique'_extracted [CommSemiring R] [Semiring A] [Algebra R A] \n [CommRing B] [Algebra R B] [Algebra.FormallyUnramified R A] \n [CommRing C] [Algebra R C] (f : B →ₐ[R] C) :\n IsNilpotent (RingHom.ker ↑f) → ∀ (g₁ g₂ : A →ₐ[R] B), f.comp g₁ = f.comp g₂ → g₁ = g₂ := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to carefully map each component of the informal statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of this translation:\n\n1. **Context and Imports**:\n   - The statement involves algebraic structures over rings, so we start by importing the necessary modules from Lean's math library, specifically `Mathlib`, which contains the algebraic structures and properties we need.\n\n2. **Open Scoped TensorProduct**:\n   - The `open scoped TensorProduct` line is included to ensure that any tensor product operations, if needed, are available in the current scope. This is a preparatory step, although tensor products are not directly used in the theorem.\n\n3. **Theorem Declaration**:\n   - We declare a theorem named `lift_unique'_extracted`. This name is chosen to reflect the uniqueness property of the lift (or homomorphism) being discussed.\n\n4. **Typeclass Assumptions**:\n   - `[CommSemiring R]`: `R` is a commutative semiring, which is a generalization of a ring where multiplication is commutative.\n   - `[Semiring A]`: `A` is a semiring, which is a ring without the requirement of additive inverses.\n   - `[Algebra R A]`: `A` is an `R`-algebra, meaning it has a compatible structure with `R`.\n   - `[CommRing B]`: `B` is a commutative ring.\n   - `[Algebra R B]`: `B` is also an `R`-algebra.\n   - `[Algebra.FormallyUnramified R A]`: `A` is formally unramified over `R`, a property indicating that certain types of extensions do not introduce new ramification.\n   - `[CommRing C]`: `C` is a commutative ring.\n   - `[Algebra R C]`: `C` is an `R`-algebra.\n\n5. **Function and Property Definitions**:\n   - `(f : B →ₐ[R] C)`: `f` is an `R`-algebra homomorphism from `B` to `C`. The notation `→ₐ[R]` indicates that `f` respects the `R`-algebra structure.\n\n6. **Assumptions and Goal**:\n   - `IsNil"}
{"source_file": "herald_data/sample_500.jsonl", "line": 171, "id": 230918, "informal_statement": "For a finite set $\\alpha$ with decidable equality, given a multiset $m$ of natural numbers where every element $a$ satisfies $2 \\leq a$, and a list $p$ of lists of elements from $\\alpha$ with the following properties:\n- The lengths of the lists in $p$ correspond to the elements of $m$,\n- No list in $p$ contains duplicate elements,\n- Any two lists in $p$ are disjoint,\n- Every list $x$ in $p$ has at least two elements.\n\nFor any list $x$ in $p$ with no duplicates, prove that $x$ has at least two elements.", "formal_statement": "import Mathlib\n\nlemma exists_with_cycleType_iff_tac_2375 [DecidableEq α] (m : Multiset ℕ) (h2c : ∀ a ∈ m, 2 ≤ a) (p : List (List α)) (hp_length : List.map List.length p = m.toList) (hp_nodup : ∀ s ∈ p, s.Nodup) (hp_disj : List.Pairwise List.Disjoint p) (hp2 : ∀ x ∈ p, 2 ≤ x.length) (x : List α) (hx : x ∈ p) (hx_nodup : x.Nodup) : 2 ≤ x.length := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to carefully map each component of the informal description to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation:\n\n1. **Finite Set with Decidable Equality**: \n   - The informal statement mentions a finite set $\\alpha$ with decidable equality. In Lean, this is represented by `[DecidableEq α]`. This typeclass constraint ensures that equality between elements of type `α` can be decided, which is necessary for operations like checking for duplicates.\n\n2. **Multiset of Natural Numbers**:\n   - The multiset `m` of natural numbers is represented as `m : Multiset ℕ` in Lean. A multiset allows for multiple occurrences of elements, unlike a set.\n\n3. **Condition on Elements of Multiset**:\n   - The condition that every element `a` in `m` satisfies $2 \\leq a$ is expressed as `h2c : ∀ a ∈ m, 2 ≤ a`. This is a predicate that must hold for all elements `a` in the multiset `m`.\n\n4. **List of Lists from $\\alpha$**:\n   - The list `p` of lists of elements from $\\alpha` is represented as `p : List (List α)`. This is a list where each element is itself a list of elements from the type `α`.\n\n5. **Lengths Correspond to Elements of Multiset**:\n   - The property that the lengths of the lists in `p` correspond to the elements of `m` is captured by `hp_length : List.map List.length p = m.toList`. This states that if you map the `length` function over each list in `p`, you get a list of natural numbers that matches the list representation of the multiset `m`.\n\n6. **No Duplicates in Lists**:\n   - The condition that no list in `p` contains duplicate elements is expressed as `hp_nodup : ∀ s ∈ p, s.Nodup`. This states that for every list `s` in `p`, the list `s` is `Nodup`, meaning it has no duplicate elements.\n\n7. **Disjoint Lists**:\n   - The property that any two lists in `p` are disjoint is represented by `hp_disj : List.Pairwise List.Disjoint p`. This uses"}
{"source_file": "herald_data/sample_500.jsonl", "line": 172, "id": 7540, "informal_statement": "For any measurable spaces $m$ and $m_0$ on $\\alpha$ with $m \\leq m_0$, and for any measure $\\mu$ on $\\alpha$, if a function $f : \\alpha \\to \\beta$ is almost everywhere measurable with respect to the trimmed measure $\\mu.trim(hm)$, then $f$ is also almost everywhere measurable with respect to the original measure $\\mu$.", "formal_statement": "import Mathlib\nopen MeasureTheory MeasureTheory.Measure Filter Set Function ENNReal\ntheorem aemeasurable_of_aemeasurable_trim_extracted [MeasurableSpace β] {m m0 : MeasurableSpace α} {μ : Measure α} (hm : m ≤ m0)\n {f : α → β} : AEMeasurable f (μ.trim hm) → AEMeasurable f μ := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it corresponds to Lean's syntax and semantics.\n\n1. **Understanding the Context**:\n   - We are dealing with measurable spaces and measures, which are fundamental concepts in measure theory.\n   - The statement involves a comparison between two measurable spaces on the same set, denoted by `m` and `m0`, with a condition `m ≤ m0`.\n   - The function `f` is a mapping from a set `α` to another set `β`, and we are concerned with its measurability properties.\n\n2. **Lean Imports and Setup**:\n   - The import statement `import Mathlib` is used to bring in the necessary libraries for measure theory and related concepts.\n   - The `open` statement is used to make certain namespaces available, such as `MeasureTheory`, `MeasureTheory.Measure`, `Filter`, `Set`, `Function`, and `ENNReal`. These provide the necessary definitions and theorems related to measures, filters, sets, functions, and extended non-negative reals.\n\n3. **Formalizing Measurable Spaces and Measures**:\n   - `MeasurableSpace α` and `MeasurableSpace β` are types representing measurable spaces on sets `α` and `β`, respectively.\n   - `Measure α` is a type representing a measure on the set `α`.\n\n4. **Formalizing the Hypotheses**:\n   - The hypothesis `m ≤ m0` is expressed in Lean as `hm : m ≤ m0`. This indicates that the σ-algebra `m` is a sub-σ-algebra of `m0`.\n   - The function `f : α → β` is declared as `f : α → β`, indicating a function from `α` to `β`.\n\n5. **Understanding AEMeasurable**:\n   - `AEMeasurable f (μ.trim hm)` means that the function `f` is almost everywhere measurable with respect to the trimmed measure `μ.trim hm`.\n   - `AEMeasurable f μ` means that `f` is almost everywhere measurable with respect to the original measure `μ`.\n\n6. **Theorem Statement**:\n   - The theorem is named `aemeasurable_of_aemeasurable_trim_extracted`, which suggests that it extracts the almost everywhere measurability of"}
{"source_file": "herald_data/sample_500.jsonl", "line": 174, "id": 61736, "informal_statement": "For a bounded continuous function $f: \\alpha \\to \\mathbb{R}$, the composition of its norm component function and the norm operation is equal to the norm of $f$, i.e., $(f.normComp : \\alpha \\to \\mathbb{R}) = \\norm{\\cdot} \\circ f$.", "formal_statement": "import Mathlib\nopen Topology Bornology NNReal uniformity UniformConvergence\nopen Set Filter Metric Function\ntheorem coe_normComp_extracted [TopologicalSpace α] [SeminormedAddCommGroup β]\n (f : BoundedContinuousFunction α β) : ⇑f.normComp = norm ∘ ⇑f := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and understand how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Context**:\n   - The informal statement involves a bounded continuous function \\( f: \\alpha \\to \\mathbb{R} \\). In Lean, this is represented by `BoundedContinuousFunction α β`, where `α` is the domain and `β` is the codomain. Here, `β` is a seminormed additive commutative group, which is a generalization that includes real numbers.\n\n2. **Lean Imports and Setup**:\n   - The code begins with importing necessary modules from Mathlib, such as `Topology`, `Bornology`, `NNReal`, `uniformity`, and `UniformConvergence`. These imports provide the necessary definitions and theorems related to topology, bounded functions, and norms.\n\n3. **Opening Modules**:\n   - The `open` statements make certain namespaces available without qualification, such as `Set`, `Filter`, `Metric`, and `Function`. This allows for more concise code by using functions and types directly from these modules.\n\n4. **Theorem Declaration**:\n   - The theorem is named `coe_normComp_extracted`, which suggests it deals with the coercion of the norm component function.\n   - The theorem is parameterized by `[TopologicalSpace α]` and `[SeminormedAddCommGroup β]`, indicating that `α` is a topological space and `β` is a seminormed additive commutative group.\n\n5. **Function and Norm Components**:\n   - The function `f` is of type `BoundedContinuousFunction α β`, which means it is a continuous function from `α` to `β` that is also bounded.\n   - `f.normComp` refers to the norm component function of `f`. In Lean, `⇑f` is the coercion of the bounded continuous function to a regular function from `α` to `β`.\n\n6. **Equality of Functions**:\n   - The statement `⇑f.normComp = norm ∘ ⇑f` asserts that the norm component function of `f` is equal to the composition of the norm function with `f`. In Lean, `norm ∘ ⇑f` represents the composition of the norm function with the function `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 170, "id": 241296, "informal_statement": "For any element \\(a\\) in a group with zero \\(G_0\\), given that \\(a\\) is not equal to zero, show that \\(a\\) is equal to itself, i.e., \\(a = a\\).", "formal_statement": "import Mathlib\nopen Function\nlemma mul_inv_mul_cancel_tac_10657 [GroupWithZero G₀] (a : G₀) (h : ¬a = 0) : a = a := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structure**: The statement involves a group with zero, which is a structure in algebra that combines the properties of a group with an additional zero element. In Lean, this is represented by `GroupWithZero G₀`, where `G₀` is the type of the group.\n\n2. **Define the Element and Assumptions**: The statement involves an element \\(a\\) of the group \\(G_0\\) and the condition that \\(a\\) is not equal to zero. In Lean, we declare \\(a\\) as a variable of type `G₀` and express the condition using the hypothesis `h : ¬a = 0`.\n\n3. **State the Goal**: The goal is to show that \\(a = a\\), which is a trivial identity. In Lean, this is directly stated as `a = a`.\n\n4. **Structure the Lemma**: The lemma is structured to take the group with zero, the element \\(a\\), and the hypothesis as inputs, and then prove the goal. The lemma is named `mul_inv_mul_cancel_tac_10657`, which is a placeholder name and not particularly descriptive of the content.\n\n5. **Use of `sorry`**: The proof is not provided, as indicated by `sorry`. In Lean, `sorry` is used as a placeholder for a proof, allowing the code to compile even though the proof is incomplete. In this case, the proof is trivial because \\(a = a\\) is a tautology, but `sorry` is used to bypass writing out the trivial proof.\n\n6. **Importing Necessary Libraries**: The code begins with `import Mathlib`, which is necessary to access the definitions and theorems related to algebraic structures like `GroupWithZero`.\n\n7. **Opening Necessary Namespaces**: The `open Function` statement is included, although it is not directly relevant to this specific lemma. It is a common practice to open namespaces that might be useful for more complex proofs.\n\nBy following these steps, the informal statement is formalized in Lean4 as a lemma that asserts the identity \\(a = a\\) for any non-zero element \\(a\\) in a group with zero."}
{"source_file": "herald_data/sample_500.jsonl", "line": 173, "id": 74444, "informal_statement": "For any property \\(q\\) defined on elements satisfying condition \\(p\\), show that there exists an element \\(x\\) with a proof that \\(x\\) satisfies \\(p\\), such that \\(q\\) holds for \\(x\\) and its proof, if and only if there exists an element in the subtype of elements satisfying \\(p\\), for which \\(q\\) holds when evaluated on the element and its membership proof. In other words, prove the equivalence between the existence of an element in the subtype satisfying \\(q\\) and the direct existential statement of such an element with its proof that it satisfies both \\(p\\) and \\(q\\).", "formal_statement": "import Mathlib\nopen Function\ntheorem exists'_extracted {α : Sort u_1} {p : α → Prop} {q : (x : α) → p x → Prop} : (∃ x h, q x h) ↔ ∃ x, q ↑x ⋯ := sorry", "explanation": "To translate the given informal statement into the formal Lean4 code, we need to understand the components involved and how they relate to each other in both the informal and formal contexts.\n\n1. **Understanding the Informal Statement:**\n   - We have a property \\( q \\) that depends on an element \\( x \\) and a proof that \\( x \\) satisfies a condition \\( p \\).\n   - We need to show an equivalence between two existential quantifications:\n     - The first is a direct existential quantification over elements \\( x \\) and their proofs \\( h \\) that they satisfy \\( p \\), such that \\( q(x, h) \\) holds.\n     - The second is an existential quantification over elements in the subtype of elements satisfying \\( p \\), where \\( q \\) is evaluated on the element and its membership proof.\n\n2. **Formalizing the Statement in Lean4:**\n   - **Type Declaration:** We start by declaring a type `α` which represents the universe of discourse. This is done using `{α : Sort u_1}`. The `Sort u_1` allows for a general type, which can be a type, a proposition, or a higher universe.\n   - **Predicate `p`:** We define a predicate `p : α → Prop` which is a property that elements of type `α` may satisfy.\n   - **Property `q`:** We define a property `q : (x : α) → p x → Prop`. This means `q` is a property that depends on an element `x` of type `α` and a proof that `x` satisfies `p`.\n   - **Existential Quantification (Direct):** The expression `(∃ x h, q x h)` represents the direct existential quantification. It states that there exists an element `x` and a proof `h` that `x` satisfies `p`, such that `q x h` holds.\n   - **Existential Quantification (Subtype):** The expression `∃ x, q ↑x ⋯` represents the existential quantification over the subtype. Here, `x` is an element of the subtype `{x // p x}`, which means `x` is a pair consisting of an element and a proof that it satisfies `p`. The notation `↑x` is used to extract the element from the subtype.\n   - **Equivalence:** The theorem `exists'_extracted"}
{"source_file": "herald_data/sample_500.jsonl", "line": 175, "id": 240066, "informal_statement": "For any category \\( C \\) enriched with zero morphisms, given two homological complexes \\( K \\) and \\( L \\) over a complex shape \\( c \\), a morphism \\( f \\) from \\( K \\) to \\( L \\), and an index \\( i \\) for which both \\( K \\) and \\( L \\) have homology, if the homology of the subcomplex \\( (K.sc \\, i) \\) at \\( i \\) is zero, then prove that the homology map induced by \\( f \\) at \\( i \\) being an isomorphism implies the homology of the subcomplex \\( (L.sc \\, i) \\) at \\( i \\) is zero.", "formal_statement": "import Mathlib\nopen CategoryTheory Limits\nopen HomologicalComplex\nlemma quasiIsoAt_iff_exactAt_tac_2215 [Category.{v, u} C] [HasZeroMorphisms C] (c : ComplexShape ι) (K : HomologicalComplex C c) (L : HomologicalComplex C c) (f : K ⟶ L) (i : ι) [K.HasHomology i] [L.HasHomology i] (hK : IsZero (K.sc i).homology) : IsIso (ShortComplex.homologyMap ((shortComplexFunctor C c i).map f)) → IsZero (L.sc i).homology := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the mathematical concepts and their relationships in the Lean4 language. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context**: \n   - We are dealing with categories enriched with zero morphisms, which is a common setting in homological algebra.\n   - We have two homological complexes \\( K \\) and \\( L \\) over a complex shape \\( c \\).\n   - There is a morphism \\( f \\) from \\( K \\) to \\( L \\).\n   - We are interested in the homology at a specific index \\( i \\).\n\n2. **Identifying the Key Components**:\n   - **Category \\( C \\)**: This is represented by `[Category.{v, u} C]` in Lean, indicating a category with objects and morphisms.\n   - **Zero Morphisms**: The presence of zero morphisms is indicated by `[HasZeroMorphisms C]`.\n   - **Complex Shape \\( c \\)**: This is a parameter of type `ComplexShape ι`, which defines the shape of the complexes.\n   - **Homological Complexes \\( K \\) and \\( L \\)**: These are instances of `HomologicalComplex C c`, representing complexes over the category \\( C \\) with shape \\( c \\).\n\n3. **Formalizing the Hypotheses**:\n   - **Morphism \\( f \\)**: The morphism from \\( K \\) to \\( L \\) is represented as `f : K ⟶ L`.\n   - **Index \\( i \\)**: The index at which we are considering the homology is `i : ι`.\n   - **Homology Existence**: The assumptions that \\( K \\) and \\( L \\) have homology at \\( i \\) are represented by `[K.HasHomology i]` and `[L.HasHomology i]`.\n   - **Zero Homology of Subcomplex**: The condition that the homology of the subcomplex \\( (K.sc \\, i) \\) is zero is expressed as `hK : IsZero (K.sc i).homology`.\n\n4. **Expressing the Conclusion**:\n   - **Isomorphism of Homology Map**: The condition that the homology map induced by \\( f \\) at \\( i \\) is an isom"}
{"source_file": "herald_data/sample_500.jsonl", "line": 177, "id": 32941, "informal_statement": "For any functions $f$ and $g$, and sets $s$ and $t$, if $f$ is eventually equal to $g$ with respect to the filter $l$ restricted to $s$ and $s$ is eventually equal to $t$ with respect to the filter $l$, then the product of the indicator function of $s$ with $f$ is eventually equal to the product of the indicator function of $t$ with $g$ with respect to the filter $l$.", "formal_statement": "import Mathlib\nopen Set Filter\ntheorem mulIndicator_eventuallyEq_extracted [One M] {s t : Set α} {f g : α → M} {l : Filter α} :\n f =ᶠ[l ⊓ 𝓟 s] g → s =ᶠ[l] t → s.mulIndicator f =ᶠ[l] t.mulIndicator g := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Context and Imports**:\n   - The code begins with `import Mathlib`, which is necessary to access mathematical libraries in Lean that provide definitions and theorems related to sets, filters, and functions.\n   - `open Set Filter` is used to bring the definitions and notations related to sets and filters into the current namespace, allowing us to use them without prefixing them with `Set.` or `Filter.`.\n\n2. **Theorem Declaration**:\n   - `theorem mulIndicator_eventuallyEq_extracted` is the name of the theorem. It suggests that the theorem is about the eventual equality of products of indicator functions.\n\n3. **Typeclass and Variable Declarations**:\n   - `[One M]` indicates that `M` is a type with a multiplicative identity (1). This is necessary because we are dealing with products of functions.\n   - `{s t : Set α}` declares `s` and `t` as sets of type `α`.\n   - `{f g : α → M}` declares `f` and `g` as functions from `α` to `M`.\n   - `{l : Filter α}` declares `l` as a filter on `α`.\n\n4. **Hypotheses**:\n   - `f =ᶠ[l ⊓ 𝓟 s] g` is the formalization of \"f is eventually equal to g with respect to the filter l restricted to s\". \n     - `=ᶠ` is the notation for eventual equality with respect to a filter.\n     - `l ⊓ 𝓟 s` represents the infimum (greatest lower bound) of the filter `l` and the principal filter generated by `s` (`𝓟 s`). This restricts the filter to the set `s`.\n   - `s =ᶠ[l] t` is the formalization of \"s is eventually equal to t with respect to the filter l\". This means that the sets `s` and `t` are eventually equal under the filter `l`.\n\n5. **Conclusion**:\n   - `s.mulIndicator f =ᶠ[l] t.mulIndicator g` is the conclusion that \"the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 176, "id": 70677, "informal_statement": "For any ring homomorphisms $f : A \\to B$ and $g : B \\to C$, where $f$ has a right inverse $f_{\\text{inv}}$ and $g$ satisfies the condition that the kernel of $f$ is contained in the kernel of $g$, there exists a unique ring homomorphism $\\varphi : A \\to C$ such that $\\varphi \\circ f = g$.", "formal_statement": "import Mathlib\nopen Pointwise\nopen Function\ndef liftOfRightInverse_extracted : →\n →\n →\n [Ring A] →\n [Ring B] →\n [Ring C] →\n (f : A →+* B) →\n (f_inv : B → A) → Function.RightInverse f_inv ⇑f → { g // RingHom.ker f ≤ RingHom.ker g } ≃ (B →+* C) := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to break down each component of the statement and map it to the corresponding Lean constructs. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context**:\n   - We are dealing with ring homomorphisms between rings \\( A \\), \\( B \\), and \\( C \\).\n   - The goal is to construct a unique ring homomorphism \\(\\varphi : A \\to C\\) under certain conditions.\n\n2. **Identifying the Components**:\n   - **Ring Homomorphisms**: In Lean, ring homomorphisms are represented by the type `A →+* B`, which denotes a homomorphism from ring \\( A \\) to ring \\( B \\).\n   - **Right Inverse**: The statement mentions that \\( f \\) has a right inverse \\( f_{\\text{inv}} \\). In Lean, this is expressed using `Function.RightInverse f_inv ⇑f`, meaning that \\( f_{\\text{inv}} \\) is a right inverse of \\( f \\).\n\n3. **Kernel Condition**:\n   - The condition that the kernel of \\( f \\) is contained in the kernel of \\( g \\) is expressed in Lean as `{ g // RingHom.ker f ≤ RingHom.ker g }`. This uses a subtype to represent the set of homomorphisms \\( g \\) such that the kernel of \\( f \\) is a subset of the kernel of \\( g \\).\n\n4. **Existence and Uniqueness of \\(\\varphi\\)**:\n   - The statement asserts the existence of a unique homomorphism \\(\\varphi\\) such that \\(\\varphi \\circ f = g\\). In Lean, this is captured by constructing an equivalence `≃` between the set of such \\( g \\) and the set of homomorphisms from \\( B \\) to \\( C \\), denoted as `(B →+* C)`.\n\n5. **Formalizing the Statement**:\n   - The Lean definition `liftOfRightInverse_extracted` is a function that takes the following parameters:\n     - `A`, `B`, `C`: Rings, denoted by `[Ring A]`, `[Ring B]`, `[Ring C]`.\n     - `f : A →+* B`: A ring homomorphism from \\( A \\) to \\( B"}
{"source_file": "herald_data/sample_500.jsonl", "line": 179, "id": 74302, "informal_statement": "For a separable field extension $E/F$ of exponential characteristic $q$, and for any subset $S$ of $E$ and any natural number $n$, demonstrate that the field $F(S)$ is equal to the field $F(S^{q^n})$, where $S^{q^n}$ denotes the set $\\{s^{q^n} \\mid s \\in S\\}$.", "formal_statement": "import Mathlib\nopen FiniteDimensional Polynomial IntermediateField Field Finsupp\nopen separableClosure in\ntheorem adjoin_eq_adjoin_pow_expChar_pow_of_isSeparable'_extracted (F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]\n [Algebra.IsSeparable F E] (S : Set E) (q : ℕ) [ExpChar F q] (n : ℕ) :\n adjoin F S = adjoin F ((fun x => x ^ q ^ n) '' S) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the mathematical concepts and their relationships. Here's a step-by-step explanation of the translation:\n\n1. **Understand the Context**: \n   - We are dealing with a field extension \\( E/F \\) that is separable and has an exponential characteristic \\( q \\).\n   - We need to show that for any subset \\( S \\) of \\( E \\) and any natural number \\( n \\), the field generated by \\( S \\) over \\( F \\), denoted \\( F(S) \\), is equal to the field generated by the set \\( S^{q^n} \\).\n\n2. **Identify the Mathematical Structures**:\n   - **Field Extension**: \\( E/F \\) is a field extension, which in Lean is represented by having \\( E \\) and \\( F \\) as types with the `Field` typeclass.\n   - **Separable Extension**: The extension is separable, which is indicated by the `Algebra.IsSeparable` typeclass.\n   - **Exponential Characteristic**: The field \\( F \\) has an exponential characteristic \\( q \\), represented by the `ExpChar` typeclass.\n\n3. **Translate the Informal Statement**:\n   - **Subset \\( S \\)**: In Lean, a subset of a type is represented as `Set E`.\n   - **Field Adjoin**: The operation of adjoining a set to a field is represented by `adjoin F S`, which constructs the smallest field containing both \\( F \\) and \\( S \\).\n   - **Power Set \\( S^{q^n} \\)**: The set \\( S^{q^n} \\) is constructed by applying the function \\( x \\mapsto x^{q^n} \\) to each element of \\( S \\). In Lean, this is done using the image of a function over a set, denoted by `(fun x => x ^ q ^ n) '' S`.\n\n4. **Formalize the Theorem**:\n   - **Theorem Statement**: The theorem is named `adjoin_eq_adjoin_pow_expChar_pow_of_isSeparable'_extracted`, which reflects the main result about the equality of the adjoined fields.\n   - **Parameters**: The theorem takes the following parameters:\n     - `F` and `E` as types with `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 180, "id": 550268, "informal_statement": "Let $a$ , $b$ and $c$ positive numbers. Prove that: $\\frac{a^2}{6a+b+c}+\\frac{b^2}{6b+a+c}+\\frac{c^2}{6c+a+b}\\leq\\frac{(a+b+c)^2}{8\\sqrt{3(ab+ac+bc)}}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_550268 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : (a^2 / (6 * a + b + c) + b^2 / (6 * b + a + c) + c^2 / (6 * c + a + b) ≤ (a + b + c)^2 / (8 * Real.sqrt (3 * (a * b + a * c + b * c))))   :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach to ensure that all components of the statement are accurately represented in the formal language. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves three positive numbers: \\(a\\), \\(b\\), and \\(c\\). In Lean, these are represented as real numbers (`ℝ`), and we need to specify that they are positive.\n\n2. **Declare the Variables**:\n   - In Lean, we declare the variables \\(a\\), \\(b\\), and \\(c\\) as real numbers using `(a b c : ℝ)`. This sets up the context for the theorem.\n\n3. **State the Positivity Conditions**:\n   - The informal statement specifies that \\(a\\), \\(b\\), and \\(c\\) are positive. In Lean, this is expressed using the conditions `(ha : 0 < a)`, `(hb : 0 < b)`, and `(hc : 0 < c)`. These are hypotheses that will be used in the proof.\n\n4. **Translate the Inequality**:\n   - The inequality to be proven is \\(\\frac{a^2}{6a+b+c} + \\frac{b^2}{6b+a+c} + \\frac{c^2}{6c+a+b} \\leq \\frac{(a+b+c)^2}{8\\sqrt{3(ab+ac+bc)}}\\).\n   - In Lean, division is represented by `/`, multiplication by `*`, and addition by `+`. The left-hand side of the inequality is expressed as `a^2 / (6 * a + b + c) + b^2 / (6 * b + a + c) + c^2 / (6 * c + a + b)`.\n   - The right-hand side involves a square and a square root. The square of a sum is written as `(a + b + c)^2`, and the square root is represented by `Real.sqrt`. Thus, the right-hand side is `(a + b + c)^2 / (8 * Real.sqrt (3 * (a * b + a * c + b * c)))`.\n\n5. **Formulate the Theorem**:\n   - The theorem is named `extract_aug_550268`, which is a placeholder"}
{"source_file": "herald_data/sample_500.jsonl", "line": 181, "id": 249569, "informal_statement": "For a set $s$ of natural numbers such that for any $k_1, k_2 \\in \\mathbb{N}$, if $k_1 \\leq k_2$ and $k_1 \\in s$, then $k_2 \\in s$, and for any natural number $k$, suppose the greatest lower bound of $s$ is $k + 1$. Show that $k + 1 \\leq k + 1$ and it is not the case that $k + 1 \\leq k$.", "formal_statement": "import Mathlib\nopen Set\nopen scoped Classical\nlemma sInf_upward_closed_eq_succ_iff_tac_3555 (s : Set ℕ) (hs : ∀ (k₁ k₂ : ℕ), k₁ ≤ k₂ → k₁ ∈ s → k₂ ∈ s) (k : ℕ) (H : sInf s = k + 1) : k + 1 ≤ k + 1 ∧ ¬k + 1 ≤ k := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and logical framework.\n\n1. **Understanding the Set and Conditions**:\n   - The informal statement begins with a set \\( s \\) of natural numbers. In Lean, this is represented as `s : Set ℕ`, where `Set ℕ` denotes a set of natural numbers.\n   - The condition that for any \\( k_1, k_2 \\in \\mathbb{N} \\), if \\( k_1 \\leq k_2 \\) and \\( k_1 \\in s \\), then \\( k_2 \\in s \\), describes an upward-closed set. This is formalized in Lean as a hypothesis `hs : ∀ (k₁ k₂ : ℕ), k₁ ≤ k₂ → k₁ ∈ s → k₂ ∈ s`.\n\n2. **Greatest Lower Bound (Infimum)**:\n   - The statement mentions the greatest lower bound (infimum) of the set \\( s \\) being \\( k + 1 \\). In Lean, the infimum of a set is denoted by `sInf s`, and the condition is expressed as `H : sInf s = k + 1`.\n\n3. **Conclusion to Prove**:\n   - The goal is to show two things: \\( k + 1 \\leq k + 1 \\) and it is not the case that \\( k + 1 \\leq k \\). In Lean, this is expressed as the conjunction `k + 1 ≤ k + 1 ∧ ¬k + 1 ≤ k`.\n\n4. **Structure of the Lemma**:\n   - The lemma is named `sInf_upward_closed_eq_succ_iff_tac_3555`, which is a unique identifier for this particular result.\n   - The lemma takes as inputs the set `s`, the upward-closed condition `hs`, the natural number `k`, and the infimum condition `H`.\n   - The conclusion of the lemma is the conjunction of the two inequalities, which is the formal statement to be proved.\n\n5. **Use of Lean Libraries**:\n   - The `import Mathlib` statement brings in the necessary mathematical libraries that provide definitions and theorems about sets, natural numbers, and order relations."}
{"source_file": "herald_data/sample_500.jsonl", "line": 184, "id": 224647, "informal_statement": "For any natural numbers $m$ and $n$, a function $f$ from the finitely indexed set of size $m \\times n$ to a type $\\alpha$, and any elements $i$ and $j$ in the finitely indexed sets of size $n$ and $m$ respectively, show that $m$ times the natural number value of $i$ plus $m$ equals $m$ times the natural number value of $i$ plus $m$. This simplifies to the identity $m + m = m + m$.", "formal_statement": "import Mathlib\nopen Nat\nlemma ofFn_mul'_tac_5872 (m : ℕ) (n : ℕ) (f : Fin (m * n) → α) (i : Fin n) (j : Fin m) : m * ↑i + m = m * ↑i + m := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to break down the components of the statement and understand how they map to Lean's syntax and semantics.\n\n1. **Understanding the Context**: \n   - We are dealing with natural numbers \\( m \\) and \\( n \\).\n   - There is a function \\( f \\) from a finitely indexed set of size \\( m \\times n \\) to a type \\( \\alpha \\).\n   - We have elements \\( i \\) and \\( j \\) from finitely indexed sets of sizes \\( n \\) and \\( m \\), respectively.\n\n2. **Lean's Representation of Finite Sets**:\n   - In Lean, `Fin k` represents the finite set of natural numbers less than \\( k \\). Thus, `Fin (m * n)` represents the set of indices for a set of size \\( m \\times n \\).\n   - Similarly, `Fin n` and `Fin m` represent the sets of indices for sizes \\( n \\) and \\( m \\), respectively.\n\n3. **Function \\( f \\)**:\n   - The function \\( f : \\text{Fin} (m \\times n) \\to \\alpha \\) is a mapping from the finite set of indices of size \\( m \\times n \\) to some type \\( \\alpha \\). This is a typical way to represent functions over finite sets in Lean.\n\n4. **Elements \\( i \\) and \\( j \\)**:\n   - The elements \\( i : \\text{Fin} n \\) and \\( j : \\text{Fin} m \\) are indices within their respective finite sets.\n\n5. **The Expression \\( m \\times \\text{value of } i + m \\)**:\n   - The expression \\( m \\times \\text{value of } i + m \\) is represented in Lean as `m * ↑i + m`. Here, `↑i` is the coercion of the finite index `i` to a natural number, which is necessary for arithmetic operations.\n\n6. **The Identity \\( m + m = m + m \\)**:\n   - The statement \\( m \\times \\text{value of } i + m = m \\times \\text{value of } i + m \\) simplifies to the identity \\( m + m = m + m \\). This is a tautology and is trivially true.\n\n7. **Formalizing the Lem"}
{"source_file": "herald_data/sample_500.jsonl", "line": 178, "id": 348304, "informal_statement": "In the category of topological spaces, the terminal object is the one-point space, denoted as \\( \\text{PUnit} \\). This means that for any topological space \\( X \\), there exists a unique continuous map from \\( X \\) to \\( \\text{PUnit} \\).", "formal_statement": "import Mathlib\nopen TopologicalSpace CategoryTheory CategoryTheory.Limits Opposite\n/-- The terminal object of `Top` is `PUnit`. -/\ndef isTerminalPUnit : IsTerminal (TopCat.of PUnit.{u + 1}) := sorry", "explanation": "To translate the informal statement into Lean4, we need to formalize the concept of a terminal object in the category of topological spaces, denoted as `Top`. Here's the step-by-step explanation:\n\n1. **Understanding the Category of Topological Spaces**:\n   - In category theory, a category consists of objects and morphisms (arrows) between these objects. The category of topological spaces, denoted as `Top`, has topological spaces as objects and continuous maps as morphisms.\n\n2. **Terminal Object Definition**:\n   - A terminal object in a category is an object such that there exists a unique morphism from any object in the category to this terminal object. In the context of `Top`, this means for any topological space \\( X \\), there is a unique continuous map from \\( X \\) to the terminal object.\n\n3. **Identifying the Terminal Object**:\n   - The informal statement claims that the one-point space, denoted as `PUnit`, is the terminal object in `Top`. The space `PUnit` is a topological space consisting of a single point, which trivially satisfies the topology requirements.\n\n4. **Formalizing in Lean**:\n   - We need to express that `PUnit` is the terminal object in the category `Top`. In Lean, this is done using the `IsTerminal` structure, which captures the essence of a terminal object.\n\n5. **Lean Code Breakdown**:\n   - `import Mathlib`: This imports the necessary mathematical libraries, including category theory and topology.\n   - `open TopologicalSpace CategoryTheory CategoryTheory.Limits Opposite`: This line opens the relevant namespaces, making it easier to refer to concepts from topology and category theory.\n   - `def isTerminalPUnit : IsTerminal (TopCat.of PUnit.{u + 1}) := sorry`: This line defines a new constant `isTerminalPUnit` which asserts that `PUnit` is a terminal object in the category of topological spaces.\n     - `IsTerminal`: This is a structure in Lean that represents the property of being a terminal object.\n     - `TopCat.of PUnit.{u + 1}`: This constructs the object in the category `Top` corresponding to the topological space `PUnit`. The `.of` function is used to convert a topological space into an object of the category `TopCat`.\n     - `:= sorry`: The `sorry` keyword"}
{"source_file": "herald_data/sample_500.jsonl", "line": 182, "id": 292008, "informal_statement": "For any ideal $I$ in a division semiring $K$, if $1$ is not an element of $I$, then $I$ is equal to the bottom element $\\bot$.", "formal_statement": "import Mathlib\nopen Set Function\nopen Pointwise\nlemma eq_bot_or_top_tac_24664 [DivisionSemiring K] (I : Ideal K) : 1 ∉ I → I = ⊥ := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to understand the components involved in both the informal and formal statements and how they correspond to each other.\n\n1. **Understanding the Context**:\n   - The informal statement is about ideals in a division semiring. A division semiring is a type of algebraic structure where division is possible (except by zero), and it includes a multiplicative identity, denoted as `1`.\n   - An ideal in this context is a subset of the semiring that is closed under addition and multiplication by any element of the semiring.\n\n2. **Identifying the Components**:\n   - **\"For any ideal $I$ in a division semiring $K$\"**: This part specifies the context and the objects we are dealing with. In Lean, this is represented by `[DivisionSemiring K]` and `(I : Ideal K)`. The former declares that `K` is a division semiring, and the latter declares `I` as an ideal of `K`.\n   - **\"if $1$ is not an element of $I$\"**: This is a condition on the ideal `I`. In Lean, this is expressed as `1 ∉ I`, meaning `1` is not a member of the set `I`.\n   - **\"then $I$ is equal to the bottom element $\\bot$\"**: This is the conclusion of the statement. In Lean, `I = ⊥` means that the ideal `I` is equal to the bottom element of the lattice of ideals, which is the smallest ideal, typically the zero ideal.\n\n3. **Formalizing the Statement**:\n   - The Lean lemma is named `eq_bot_or_top_tac_24664`, which is a placeholder name and not directly relevant to the translation.\n   - The lemma takes as input an ideal `I` of a division semiring `K` and asserts that if `1` is not in `I`, then `I` must be the bottom element `⊥`.\n   - The use of `→` in `1 ∉ I → I = ⊥` indicates a logical implication, directly translating the \"if...then...\" structure of the informal statement.\n\n4. **Understanding the Lean Syntax**:\n   - `import Mathlib` is used to import the necessary mathematical library that contains definitions and theorems about division semirings and ideals"}
{"source_file": "herald_data/sample_500.jsonl", "line": 187, "id": 506716, "informal_statement": "Prove that $(x^3+y^3+z^3)+2(x^2y+y^2z+z^2x)\\ge 3(x^2z+z^2y+y^2x)$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_506716 (x y z : ℝ) : (x ^ 3 + y ^ 3 + z ^ 3) + 2 * (x ^ 2 * y + y ^ 2 * z + z ^ 2 * x) ≥ 3 * (x ^ 2 * z + z ^ 2 * y + y ^ 2 * x)   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Variables and Domain**: \n   - The variables involved in the inequality are \\(x\\), \\(y\\), and \\(z\\). The domain is the set of real numbers, \\(\\mathbb{R}\\).\n\n2. **Translate Mathematical Operations**:\n   - The operations involved are addition, multiplication, exponentiation, and comparison (greater than or equal to).\n   - In Lean, addition is represented by `+`, multiplication by `*`, exponentiation by `^`, and the comparison by `≥`.\n\n3. **Structure the Expression**:\n   - The left-hand side of the inequality is \\((x^3 + y^3 + z^3) + 2(x^2y + y^2z + z^2x)\\).\n   - The right-hand side is \\(3(x^2z + z^2y + y^2x)\\).\n\n4. **Formalize the Expression in Lean**:\n   - The expression \\(x^3\\) is written as `x ^ 3`.\n   - The expression \\(x^2y\\) is written as `x ^ 2 * y`.\n   - The entire left-hand side becomes `(x ^ 3 + y ^ 3 + z ^ 3) + 2 * (x ^ 2 * y + y ^ 2 * z + z ^ 2 * x)`.\n   - The right-hand side becomes `3 * (x ^ 2 * z + z ^ 2 * y + y ^ 2 * x)`.\n\n5. **Formulate the Theorem**:\n   - The theorem is named `extract_aug_506716`, which is a unique identifier for this particular theorem.\n   - The theorem statement in Lean is structured as `theorem extract_aug_506716 (x y z : ℝ) : ... := by sorry`.\n   - The `: ℝ` indicates that \\(x\\), \\(y\\), and \\(z\\) are real numbers.\n\n6. **Use Lean's Syntax for Theorems**:\n   - The keyword `theorem` is used to declare a theorem.\n   - The colon `:` separates the theorem's name and parameters from its statement.\n   - The `:= by sorry` part indicates that the proof is not yet provided. The `sorry` is a"}
{"source_file": "herald_data/sample_500.jsonl", "line": 183, "id": 520096, "informal_statement": "We have a system of two equations: $l = $ Amount Sold Last Week $t = $ Amount Sold This Week From there we get our first equation based on the fact that she sold this week six more than three times last week $l = 3t + 6$ and our second one based on the fact that the amount sold last week and this week totals to $110$ . $l + t = 110$ We transform the second equation like so: $l + t - l = 110 - l$ $t = 110 - l$ From there we plug in the newly transformed second equation into the first to get $l = 3(110 -l) + 6$ This simplifies to $l = 330 - 3l + 6$ or $l = 84$ Then we substitute $l$ into the second equation to get $t = 110 - (84)$ or $t = 26$ Therefore, she sold $84$ CD's on the first week and $26$ on the second.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_520096 (l t : ℕ) (h₁ : l = 3 * t + 6) (h₂ : l + t = 110) : l = 84 ∧ t = 26   :=  by sorry", "explanation": "To formalize the given informal mathematical statement into Lean4, we need to translate the problem description and solution process into a theorem statement and proof structure. Here's a step-by-step explanation of how this is done:\n\n1. **Understanding the Variables**: \n   - The informal statement introduces two variables: `l` for the amount sold last week and `t` for the amount sold this week. In Lean, these are represented as natural numbers (`ℕ`), which are non-negative integers.\n\n2. **Translating the Equations**:\n   - The first equation is given as `l = 3t + 6`. In Lean, this is expressed as a hypothesis `h₁ : l = 3 * t + 6`.\n   - The second equation is `l + t = 110`. In Lean, this is another hypothesis `h₂ : l + t = 110`.\n\n3. **Formulating the Goal**:\n   - The goal is to find specific values for `l` and `t` that satisfy both equations. The informal solution finds `l = 84` and `t = 26`. In Lean, the goal is expressed as `l = 84 ∧ t = 26`, meaning both conditions must hold simultaneously.\n\n4. **Structuring the Theorem**:\n   - The theorem is named `extract_aug_520096`, which is a unique identifier for this particular problem.\n   - The theorem takes `l` and `t` as natural number inputs and assumes the hypotheses `h₁` and `h₂`.\n   - The conclusion of the theorem is the conjunction `l = 84 ∧ t = 26`.\n\n5. **Proof Strategy**:\n   - The proof is not provided (`by sorry`), but the strategy would involve algebraic manipulation similar to the informal solution:\n     - Substitute `t = 110 - l` from the second equation into the first equation.\n     - Solve the resulting equation for `l`.\n     - Substitute the found value of `l` back into `t = 110 - l` to find `t`.\n     - Verify that these values satisfy both original equations.\n\n6. **Lean Syntax and Libraries**:\n   - The `import Mathlib` statement includes necessary mathematical libraries.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to bring relevant mathematical operations and types into scope,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 185, "id": 576586, "informal_statement": "prove that: $\\sqrt[6]{\\frac{(a+b)(b+c)(c+a)(a+d)(d+b)(d+c)}{64}} \\geq \\sqrt[3]{\\frac{abc+bcd+cda+adb}{4}}$, where $a;b;c;d>0$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_576586 (a b c d : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) : ((a + b) * (b + c) * (c + a) * (a + d) * (d + b) * (d + c) / 64)^(1 / 6) ≥ (a * b * c + b * c * d + c * d * a + d * a * b / 4)^(1 / 3)   :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a series of steps that involve understanding the mathematical concepts and how they are represented in Lean's syntax and libraries. Here's a detailed breakdown of the translation process:\n\n1. **Identify the Variables and Their Types**:\n   - The variables \\(a\\), \\(b\\), \\(c\\), and \\(d\\) are real numbers, and the condition \\(a, b, c, d > 0\\) indicates they are positive. In Lean, we represent real numbers using the type `ℝ` from the `Real` module.\n\n2. **Express the Conditions**:\n   - The conditions \\(a > 0\\), \\(b > 0\\), \\(c > 0\\), and \\(d > 0\\) are expressed as hypotheses in the theorem. In Lean, these are written as `ha : 0 < a`, `hb : 0 < b`, `hc : 0 < c`, and `hd : 0 < d`.\n\n3. **Translate the Expression Inside the Sixth Root**:\n   - The expression \\((a+b)(b+c)(c+a)(a+d)(d+b)(d+c)\\) is a product of sums. In Lean, this is written as `(a + b) * (b + c) * (c + a) * (a + d) * (d + b) * (d + c)`.\n   - This product is divided by 64, which is written as `/ 64` in Lean.\n\n4. **Apply the Sixth Root**:\n   - The sixth root of a number \\(x\\) is expressed as \\(x^{1/6}\\). In Lean, exponentiation is done using the `^` operator, so the sixth root is written as `^(1 / 6)`.\n\n5. **Translate the Expression Inside the Cube Root**:\n   - The expression \\(abc + bcd + cda + adb\\) is a sum of products. In Lean, this is written as `a * b * c + b * c * d + c * d * a + d * a * b`.\n   - This sum is divided by 4, which is written as `/ 4` in Lean.\n\n6. **Apply the Cube Root**:\n   - The cube root of a number \\(y\\) is expressed as \\(y^{1/3}\\)."}
{"source_file": "herald_data/sample_500.jsonl", "line": 188, "id": 254805, "informal_statement": "For a prime number $p \\in \\mathbb{N}$ and an element $x$ in the ring of $p$-adic integers $\\mathbb{Z}_p$, show that the function $x.appr$ is monotone. Here, $x.appr$ refers to the approximation function associated with $x$ in the context of $p$-adic integers.", "formal_statement": "import Mathlib\nopen scoped Classical\nopen Nat LocalRing Padic\nlemma appr_mono_tac_11597 (p : ℕ) (hp_prime : Fact (Nat.Prime p)) (x : ℤ_[p]) : Monotone x.appr := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Objects**:\n   - The informal statement involves a prime number \\( p \\) and an element \\( x \\) in the ring of \\( p \\)-adic integers \\( \\mathbb{Z}_p \\).\n   - The function \\( x.appr \\) is mentioned, which is an approximation function associated with \\( x \\).\n\n2. **Translate the Prime Number**:\n   - In Lean, a prime number \\( p \\) is represented as a natural number \\( p : \\mathbb{N} \\) with an additional condition that it is prime.\n   - This is expressed using `Fact (Nat.Prime p)`, which is a way to assert that \\( p \\) is a prime number in Lean.\n\n3. **Translate the \\( p \\)-adic Integer**:\n   - The element \\( x \\) in the ring of \\( p \\)-adic integers \\( \\mathbb{Z}_p \\) is represented as \\( x : \\mathbb{Z}_p \\) in Lean.\n   - Here, `ℤ_[p]` is the Lean notation for the ring of \\( p \\)-adic integers.\n\n4. **Translate the Monotonicity of the Function**:\n   - The statement requires showing that the function \\( x.appr \\) is monotone.\n   - In Lean, a function is monotone if it preserves the order, which is expressed using the `Monotone` predicate.\n   - Therefore, `Monotone x.appr` asserts that the approximation function \\( x.appr \\) is monotone.\n\n5. **Structure the Lean Lemma**:\n   - The lemma is named `appr_mono_tac_11597`, which is a unique identifier for this particular result.\n   - The lemma takes three arguments: a natural number \\( p \\), a proof that \\( p \\) is prime (`hp_prime : Fact (Nat.Prime p)`), and an element \\( x \\) in the \\( p \\)-adic integers.\n   - The goal of the lemma is to prove that `Monotone x.appr`.\n\n6. **Import Necessary Libraries**:\n   - The code begins with `import Mathlib`, which includes necessary mathematical libraries.\n   - The `open scoped Classical` line allows the use of classical logic, which is often needed in"}
{"source_file": "herald_data/sample_500.jsonl", "line": 191, "id": 199663, "informal_statement": "For any topological spaces $X$ and $Y$, a set $s \\subseteq X$, and functions $f, g : X \\to Y$, assuming $s$ is open, $f$ and $g$ are continuous, and for every $x \\in X$, $f$ specializes to $g$ at $x$. If for any open set $U \\subseteq Y$, the preimage of $U$ under $g$ is contained in the preimage of $U$ under $f$, then for any open set $s_1 \\subseteq Y$, the preimage of $s_1$ under the piecewise function that maps $x$ to $f(x)$ if $x \\in s$ and $g(x)$ if $x \\not\\in s$ is also open.", "formal_statement": "import Mathlib\nopen Set Filter Function Topology List\nlemma continuous_piecewise_of_specializes_tac_7072 [TopologicalSpace X] [TopologicalSpace Y] (s : Set X) (f : X → Y) (g : X → Y) [DecidablePred fun x => x ∈ s] (hs : IsOpen s) (hf : Continuous f) (hg : Continuous g) (hspec : ∀ (x : X), f x ⤳ g x) (this : ∀ (U : Set Y), IsOpen U → g ⁻¹' U ⊆ f ⁻¹' U) : ∀ (s_1 : Set Y), IsOpen s_1 → IsOpen (s.piecewise f g ⁻¹' s_1) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and see how it corresponds to the elements in the Lean code. Here's the step-by-step explanation:\n\n1. **Topological Spaces and Functions**:\n   - The informal statement begins with \"For any topological spaces $X$ and $Y$,\" which is represented in Lean by `[TopologicalSpace X] [TopologicalSpace Y]`. These are typeclass instances that declare `X` and `Y` as topological spaces.\n\n2. **Set and Functions**:\n   - The set $s \\subseteq X$ is represented by `(s : Set X)`, indicating that `s` is a subset of `X`.\n   - The functions $f, g : X \\to Y$ are represented by `(f : X → Y) (g : X → Y)`, indicating that `f` and `g` are functions from `X` to `Y`.\n\n3. **Decidability of Membership**:\n   - The phrase \"assuming $s$ is open\" is represented by `(hs : IsOpen s)`, where `IsOpen` is a predicate indicating that `s` is an open set in the topology on `X`.\n   - `[DecidablePred fun x => x ∈ s]` is included to ensure that membership in `s` is decidable, which is necessary for defining piecewise functions in Lean.\n\n4. **Continuity of Functions**:\n   - The assumption that $f$ and $g$ are continuous is represented by `(hf : Continuous f) (hg : Continuous g)`, where `Continuous` is a predicate indicating that the functions are continuous with respect to the topologies on `X` and `Y`.\n\n5. **Specialization**:\n   - The condition \"for every $x \\in X$, $f$ specializes to $g$ at $x$\" is represented by `(hspec : ∀ (x : X), f x ⤳ g x)`. The symbol `⤳` denotes the specialization relation in topology, meaning that $f(x)$ is in the closure of $\\{g(x)\\}$.\n\n6. **Preimage Condition**:\n   - The condition \"for any open set $U \\subseteq Y$, the preimage of $U$ under $g$ is contained in the preimage of $U"}
{"source_file": "herald_data/sample_500.jsonl", "line": 186, "id": 138743, "informal_statement": "For any ordinals $a$, $b$, and $c$, show that $a + b < a + c$ if and only if $b < c$.", "formal_statement": "import Mathlib\nopen Function Cardinal Set Equiv Order\nopen scoped Ordinal\nlemma add_lt_add_iff_left'_tac_5332 (a : Ordinal.{u_4}) (b : Ordinal.{u_4}) (c : Ordinal.{u_4}) : a + b < a + c ↔ b < c := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Objects**: The statement involves ordinals, which are a well-defined concept in set theory. In Lean, ordinals are represented by the type `Ordinal`.\n\n2. **Quantification over Ordinals**: The informal statement begins with \"For any ordinals $a$, $b$, and $c$,\" which indicates universal quantification over these variables. In Lean, this is expressed by introducing these variables as arguments to the lemma. Each variable is declared with its type, `Ordinal.{u_4}`, where `{u_4}` is a universe level that allows for flexibility in the size of the ordinals.\n\n3. **Expressing the Inequality**: The core of the statement is the inequality $a + b < a + c$. In Lean, addition of ordinals is denoted by `+`, and the less-than relation is denoted by `<`. Thus, `a + b < a + c` is directly translated to `a + b < a + c` in Lean.\n\n4. **Logical Equivalence**: The phrase \"if and only if\" in the informal statement is translated to a logical equivalence in Lean, denoted by `↔`. This connects the two conditions: `a + b < a + c` and `b < c`.\n\n5. **Expressing the Second Inequality**: The condition $b < c$ is straightforwardly translated to `b < c` in Lean, using the same less-than operator `<`.\n\n6. **Constructing the Lemma**: The entire statement is encapsulated in a lemma, which is a type of theorem in Lean. The lemma is named `add_lt_add_iff_left'_tac_5332`, which is a unique identifier for this particular result. The lemma takes the ordinals `a`, `b`, and `c` as parameters and asserts the equivalence `a + b < a + c ↔ b < c`.\n\n7. **Using `sorry`**: The keyword `sorry` is used as a placeholder for the proof. It indicates that the proof is not yet provided, but the statement is syntactically correct and can be checked by Lean.\n\n8. **Importing Necessary Libraries**: The statement begins with `import Mathlib`, which is necessary to access the definitions and theorems related to"}
{"source_file": "herald_data/sample_500.jsonl", "line": 192, "id": 98911, "informal_statement": "For integers \\(i\\), \\(j\\), and \\(k\\), and given \\(i + 1 = j\\) and \\(j + 1 = k\\), show that the composition of the mapping cone differential \\((mappingCone \\(\\varphi\\)).d\\) from \\(i\\) to \\(j\\) followed by the first component of the first projection of \\(\\varphi\\), \\((fst \\(\\varphi\\)).1.v\\), from \\(j\\) to \\(k\\), equals the negative of the composition of \\((fst \\(\\varphi\\)).1.v\\) from \\(i\\) to \\(j\\) followed by the differential \\(F.d\\) from \\(j\\) to \\(k\\).", "formal_statement": "import Mathlib\nopen CategoryTheory Limits\nopen HomologicalComplex\nopen HomComplex\ntheorem d_fst_v_extracted [Category.{u_3 : u_1} C] [Preadditive C] {F G : CochainComplex C ℤ} (φ : F ⟶ G)\n [HomologicalComplex.HasHomotopyCofiber φ] (i j k : ℤ) (hij : i + 1 = j) (hjk : j + 1 = k),\n (CochainComplex.mappingCone φ).d i j ≫ (↑(CochainComplex.mappingCone.fst φ)).v j k hjk =\n -(↑(CochainComplex.mappingCone.fst φ)).v i j hij ≫ F.d j k := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and understand how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Context and Imports**:\n   - The code begins with `import Mathlib`, which is necessary to access the mathematical libraries in Lean.\n   - `open CategoryTheory Limits` and `open HomologicalComplex` are used to bring relevant definitions and theorems into scope, specifically those related to category theory and homological complexes.\n\n2. **Category and Preadditive Structure**:\n   - `[Category.{u_3 : u_1} C]` indicates that `C` is a category. The universe levels `u_3` and `u_1` are used to manage the hierarchy of types.\n   - `[Preadditive C]` specifies that the category `C` is preadditive, meaning it has an abelian group structure on its hom-sets, which is necessary for discussing differentials and compositions in homological algebra.\n\n3. **Cochain Complexes and Morphisms**:\n   - `{F G : CochainComplex C ℤ}` declares `F` and `G` as cochain complexes over the category `C` indexed by integers (`ℤ`).\n   - `(φ : F ⟶ G)` introduces a morphism `φ` between these cochain complexes.\n\n4. **Homotopy Cofiber**:\n   - `[HomologicalComplex.HasHomotopyCofiber φ]` asserts that the morphism `φ` has a homotopy cofiber, which is a construction used in homological algebra to study the mapping cone.\n\n5. **Indices and Equalities**:\n   - `(i j k : ℤ)` declares `i`, `j`, and `k` as integers, corresponding to the indices in the cochain complexes.\n   - `(hij : i + 1 = j)` and `(hjk : j + 1 = k)` are hypotheses that establish the relationships between these indices, as given in the informal statement.\n\n6. **Mapping Cone Differential**:\n   - `(CochainComplex.mappingCone φ).d i j` refers to the differential of the mapping cone of `φ` from index `i` to `j`. This matches the informal statement's \"composition of the mapping cone differential.\"\n\n7. **First Component"}
{"source_file": "herald_data/sample_500.jsonl", "line": 194, "id": 463020, "informal_statement": "Let $ x,y\\geq 0$ .Prove that: \\n\\n $ (x^2+y^2)^2+x^3+y^3+4xy^2+x^2+y^2\\geq 3x^3y+5xy^2+xy$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_463020 (x y : ℝ) (hx : 0 ≤ x) (hy : 0 ≤ y) : (x^2 + y^2)^2 + x^3 + y^3 + 4 * x * y^2 + x^2 + y^2 ≥ 3 * x^3 * y + 5 * x * y^2 + x * y  :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Import Necessary Libraries**: \n   - The Lean code begins with `import Mathlib`, which is a common practice to import the mathematical library that contains various useful definitions and theorems.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to bring into scope the necessary operations and types from these modules. This allows us to use real numbers and their operations directly.\n\n2. **Define the Theorem**:\n   - The theorem is named `extract_aug_463020`. Naming conventions in Lean are flexible, but it's common to use descriptive names or identifiers.\n   - The theorem takes two arguments, `x` and `y`, both of type `ℝ`, which represents real numbers in Lean.\n\n3. **State the Assumptions**:\n   - The assumptions `hx : 0 ≤ x` and `hy : 0 ≤ y` are included to specify that `x` and `y` are non-negative. This corresponds to the informal statement's condition that $x, y \\geq 0$.\n\n4. **Express the Inequality**:\n   - The inequality to be proved is written as `(x^2 + y^2)^2 + x^3 + y^3 + 4 * x * y^2 + x^2 + y^2 ≥ 3 * x^3 * y + 5 * x * y^2 + x * y`.\n   - In Lean, `^` is used for exponentiation, and `*` is used for multiplication. The expression is a direct translation of the informal statement's inequality.\n\n5. **Use the `by sorry` Placeholder**:\n   - The `by sorry` at the end of the theorem is a placeholder indicating that the proof is not yet provided. In Lean, `sorry` is used to temporarily bypass the proof requirement, allowing the statement to be checked for syntactic correctness without a complete proof.\n\nBy following these steps, the informal mathematical statement is accurately translated into a formal statement in Lean4, ready for further proof development."}
{"source_file": "herald_data/sample_500.jsonl", "line": 189, "id": 507033, "informal_statement": "Prove that $\\cos\\frac{18\\pi}{21}-\\cos\\frac{14\\pi}{21}+\\cos\\frac{12\\pi}{21}+\\cos\\frac{6\\pi}{21}=0$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_507033 : cos (18 * π / 21) - cos (14 * π / 21) + cos (12 * π / 21) + cos (6 * π / 21) = 0   :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Informal Statement**: The statement involves proving an equation involving trigonometric functions, specifically the cosine function, with arguments that are fractions of π. The goal is to show that the sum of these cosine terms equals zero.\n\n2. **Setting Up the Lean Environment**: \n   - The `import Mathlib` statement is used to bring in the necessary mathematical libraries that contain definitions and theorems related to trigonometric functions and other mathematical operations.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to make various mathematical notations and operations available without needing to prefix them with their module names. Specifically, `Real` is important here as it provides access to real number operations and trigonometric functions.\n\n3. **Formalizing the Trigonometric Expression**:\n   - The expression involves cosine terms with specific arguments: \\( \\frac{18\\pi}{21} \\), \\( \\frac{14\\pi}{21} \\), \\( \\frac{12\\pi}{21} \\), and \\( \\frac{6\\pi}{21} \\).\n   - In Lean, these are expressed using the `cos` function from the `Real` module, and the arguments are written as `18 * π / 21`, `14 * π / 21`, `12 * π / 21`, and `6 * π / 21`. This directly translates the informal fractions into Lean's syntax for division and multiplication.\n\n4. **Constructing the Theorem**:\n   - The theorem is named `extract_aug_507033`. Naming conventions in Lean can vary, but typically they are descriptive or follow a pattern for easy reference.\n   - The statement of the theorem is written as `cos (18 * π / 21) - cos (14 * π / 21) + cos (12 * π / 21) + cos (6 * π / 21) = 0`. This directly mirrors the informal statement, with the arithmetic operations (`-` and `+`) and the equality `= 0` clearly indicating the equation to be proved.\n\n5. **Proof Placeholder**:\n   - The `:= by sorry` part indicates that the proof is not yet provided. In Lean, `sorry` is a placeholder that allows the theorem to be stated"}
{"source_file": "herald_data/sample_500.jsonl", "line": 197, "id": 442081, "informal_statement": "For non-negatives $x$ , $y$ and $z$ such that $xy+xz+yz+6xyz=9$ prove that:\\n $\\frac{x}{x+1}+\\frac{y}{y+1}+\\frac{z}{z+1}\\leq\\frac{3}{2}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_442081 (x y z : ℝ) (hx : 0 ≤ x) (hy : 0 ≤ y) (hz : 0 ≤ z) (h : x*y + x*z + y*z + 6*x*y*z = 9) : x/(x + 1) + y/(y + 1) + z/(z + 1) ≤ 3/2  :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understand the Variables and Domain**:\n   - The informal statement involves three non-negative real numbers \\( x \\), \\( y \\), and \\( z \\). In Lean, these are represented as variables of type `ℝ` (real numbers).\n\n2. **Non-negativity Conditions**:\n   - The conditions \\( x \\geq 0 \\), \\( y \\geq 0 \\), and \\( z \\geq 0 \\) are expressed in Lean as hypotheses `hx : 0 ≤ x`, `hy : 0 ≤ y`, and `hz : 0 ≤ z`. These are included as assumptions in the theorem.\n\n3. **Equation Constraint**:\n   - The equation \\( xy + xz + yz + 6xyz = 9 \\) is another condition that must hold for the variables. In Lean, this is expressed as `h : x*y + x*z + y*z + 6*x*y*z = 9`.\n\n4. **Inequality to Prove**:\n   - The goal is to prove the inequality \\( \\frac{x}{x+1} + \\frac{y}{y+1} + \\frac{z}{z+1} \\leq \\frac{3}{2} \\). In Lean, this is written as `x/(x + 1) + y/(y + 1) + z/(z + 1) ≤ 3/2`.\n\n5. **Theorem Declaration**:\n   - The theorem is declared with the name `extract_aug_442081`. It takes the variables \\( x \\), \\( y \\), and \\( z \\) as inputs, along with the hypotheses `hx`, `hy`, `hz`, and `h`.\n\n6. **Imports and Namespace**:\n   - The code begins with `import Mathlib`, which is a placeholder for importing necessary libraries. The `open BigOperators`, `open Real`, `open Nat`, and `open Topology` lines make certain mathematical operations and types available without needing to prefix them with their module names.\n\n7. **Proof Placeholder**:\n   - The `:= by sorry` at the end of the theorem indicates that the proof is not yet provided. The `sorry` keyword is a placeholder in Lean, used when the proof is incomplete or omitted.\n\nBy following these steps, the informal"}
{"source_file": "herald_data/sample_500.jsonl", "line": 190, "id": 437631, "informal_statement": "For any filter $\\mathcal{F}$ on a set $X$, show that the intersection of all sets in $\\mathcal{F}$ is equal to the set $\\{x \\in X \\mid x \\leq l\\}$, where $l$ is an element of $X$.", "formal_statement": "import Mathlib\nopen Set Filter TopologicalSpace\nopen Filter Topology\ntheorem sInter_nhds (l : Filter α) : ⋂₀ { s | s ∈ 𝓝 l } = Iic l := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down the components of the statement and understand how they map to Lean's syntax and library functions.\n\n1. **Understanding the Informal Statement**:\n   - We are given a filter $\\mathcal{F}$ on a set $X$.\n   - We need to show that the intersection of all sets in $\\mathcal{F}$ is equal to a specific set $\\{x \\in X \\mid x \\leq l\\}$, where $l$ is an element of $X$.\n\n2. **Identifying Key Concepts**:\n   - **Filter**: In Lean, a filter is a structure that represents a collection of sets with certain properties (non-empty, closed under supersets, and closed under finite intersections).\n   - **Intersection of Sets**: The intersection of all sets in a filter is represented using `⋂₀` in Lean, which denotes the intersection of a set of sets.\n   - **Set Notation**: The set $\\{x \\in X \\mid x \\leq l\\}$ is represented in Lean using the interval notation `Iic l`, which stands for the interval of all elements less than or equal to `l`.\n\n3. **Mapping to Lean Syntax**:\n   - **Filter on a Set**: In Lean, a filter on a type `α` is denoted as `Filter α`.\n   - **Intersection of Sets in a Filter**: The intersection of all sets in a filter `𝓝 l` (the neighborhood filter at `l`) is written as `⋂₀ { s | s ∈ 𝓝 l }`.\n   - **Interval Notation**: The set $\\{x \\in X \\mid x \\leq l\\}$ is represented as `Iic l` in Lean, where `Iic` stands for \"interval including closed\" on the left.\n\n4. **Formalizing the Theorem**:\n   - The theorem is named `sInter_nhds`, which suggests it is about the intersection (`sInter`) of neighborhoods (`nhds`).\n   - The theorem takes a filter `l` of type `Filter α` as an argument.\n   - The statement asserts that the intersection of all sets in the neighborhood filter `𝓝 l` is equal to the interval `Iic l`.\n\n5. **Lean Code Explanation**:"}
{"source_file": "herald_data/sample_500.jsonl", "line": 195, "id": 376113, "informal_statement": "For any function \\( f : \\mathbb{N} \\to \\alpha \\), prove that the range of \\( f \\) is equal to the union of the set containing \\( f(0) \\) and the range of \\( f \\) composed with the successor function, i.e., \\(\\operatorname{range}(f) = \\{f(0)\\} \\cup \\operatorname{range}(f \\circ \\text{succ})\\).", "formal_statement": "import Mathlib\nopen Set\ntheorem range_of_succ (f : ℕ → α) : {f 0} ∪ range (f ∘ succ) = range f := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Understand the Informal Statement**: The statement involves a function \\( f \\) from natural numbers \\( \\mathbb{N} \\) to some type \\( \\alpha \\). We are asked to prove that the range of \\( f \\) is equal to the union of the set containing the value of \\( f \\) at 0 and the range of \\( f \\) composed with the successor function.\n\n2. **Identify Key Components**:\n   - **Function \\( f \\)**: This is a function from natural numbers to some type \\( \\alpha \\), denoted in Lean as `f : ℕ → α`.\n   - **Range of \\( f \\)**: The range of a function \\( f \\) is the set of all values that \\( f \\) can take. In Lean, this is expressed as `range f`.\n   - **Successor Function**: The successor function, denoted as `succ`, maps a natural number \\( n \\) to \\( n + 1 \\). In Lean, this is simply `succ`.\n   - **Composition**: The composition of \\( f \\) with the successor function is written as `f ∘ succ` in Lean, which means applying `succ` first and then `f`.\n\n3. **Formalize the Statement**:\n   - **Set Notation**: The set containing a single element \\( f(0) \\) is written as `{f 0}` in Lean.\n   - **Union of Sets**: The union of two sets \\( A \\) and \\( B \\) is denoted as `A ∪ B` in Lean.\n   - **Equality of Sets**: We need to show that two sets are equal, which in Lean is expressed with `=`.\n\n4. **Construct the Theorem**:\n   - The theorem is named `range_of_succ`, which is descriptive of what it proves.\n   - The statement of the theorem is: for any function `f : ℕ → α`, the union of the set `{f 0}` and the range of the composition `f ∘ succ` is equal to the range of `f`.\n   - In Lean, this is written as:\n     ```lean\n     theorem range_of_succ (f : ℕ → α) : {f 0} ∪ range (f"}
{"source_file": "herald_data/sample_500.jsonl", "line": 193, "id": 101643, "informal_statement": "For any elements \\(x, y\\) in a Lie module \\(M\\) over a Lie algebra \\(L\\) with coefficients in a ring \\(R\\), if \\(y\\) is in the center of \\(M\\), then the endomorphisms induced by \\(x\\) and \\(y\\) on \\(M\\) commute, i.e., \\([y, x]_M = 0\\) implies \\([toEnd_R^L^M(y), toEnd_R^L^M(x)] = 0\\).", "formal_statement": "import Mathlib\n\ntheorem commute_toEnd_of_mem_center_right_extracted (M : Type w) [CommRing R] [LieRing L] [LieAlgebra R L]\n [AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M] {x : L} :\n x ∈ LieAlgebra.center R L → ∀ (y : L), Commute ((LieModule.toEnd R L M) y) ((LieModule.toEnd R L M) x) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a structured approach that maps each component of the informal statement to its formal counterpart in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Context**:\n   - We are dealing with a Lie module \\(M\\) over a Lie algebra \\(L\\) with coefficients in a ring \\(R\\).\n   - The informal statement involves elements \\(x\\) and \\(y\\) from the Lie algebra \\(L\\) and their action on the module \\(M\\).\n\n2. **Identifying the Mathematical Structures**:\n   - **Lie Module**: A module \\(M\\) that is also a Lie module over a Lie algebra \\(L\\).\n   - **Lie Algebra**: A structure \\(L\\) with a Lie bracket operation.\n   - **Ring**: A commutative ring \\(R\\) that serves as the base ring for the module and algebra.\n\n3. **Formalizing the Hypotheses**:\n   - The condition \\(y\\) is in the center of \\(M\\) is expressed as \\(y \\in \\text{center}(L)\\). In Lean, this is represented by `x ∈ LieAlgebra.center R L`.\n   - The center of a Lie algebra consists of elements that commute with all other elements under the Lie bracket.\n\n4. **Formalizing the Conclusion**:\n   - The conclusion \\([toEnd_R^L^M(y), toEnd_R^L^M(x)] = 0\\) is about the commutativity of endomorphisms induced by \\(x\\) and \\(y\\).\n   - In Lean, this is expressed using the `Commute` predicate: `Commute ((LieModule.toEnd R L M) y) ((LieModule.toEnd R L M) x)`.\n   - `LieModule.toEnd R L M` is a function that takes an element of the Lie algebra and returns the corresponding endomorphism on the module \\(M\\).\n\n5. **Structuring the Theorem**:\n   - The theorem is named `commute_toEnd_of_mem_center_right_extracted`, indicating its purpose and the context.\n   - The theorem takes as input the module \\(M\\), the ring \\(R\\), the Lie algebra \\(L\\), and the element \\(x\\) from \\(L\\).\n   - The hypothesis is that \\(x\\"}
{"source_file": "herald_data/sample_500.jsonl", "line": 198, "id": 500790, "informal_statement": "Prove that $x^3 + y^3 = (x+y)(x^2 - xy + y^2)$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_500790 (x y : ℝ) : x^3 + y^3 = (x + y) * (x^2 - x*y + y^2)   :=  by sorry", "explanation": "To translate the informal mathematical statement \"Prove that \\(x^3 + y^3 = (x+y)(x^2 - xy + y^2)\\)\" into the formal Lean4 code, we follow these steps:\n\n1. **Identify the Mathematical Objects**: The statement involves real numbers \\(x\\) and \\(y\\), and an algebraic identity involving their cubes and a factorization.\n\n2. **Choose the Appropriate Lean4 Libraries**: Since the statement involves real numbers and algebraic operations, we import the `Mathlib` library, which provides a comprehensive set of tools for dealing with real numbers and algebraic expressions.\n\n3. **Open Necessary Namespaces**: We open the `BigOperators`, `Real`, `Nat`, and `Topology` namespaces. While not all are strictly necessary for this specific theorem, they are commonly used in mathematical proofs involving real numbers and algebraic operations.\n\n4. **Define the Theorem**: We declare a theorem named `extract_aug_500790`. The name is arbitrary and can be chosen to reflect the context or source of the theorem.\n\n5. **Specify the Variables and Their Types**: We specify that \\(x\\) and \\(y\\) are variables of type `ℝ`, which represents real numbers in Lean.\n\n6. **State the Equality**: We express the equality \\(x^3 + y^3 = (x+y)(x^2 - xy + y^2)\\) directly in Lean syntax. The `^` operator is used for exponentiation, and `*` is used for multiplication.\n\n7. **Use the `by sorry` Placeholder**: The `:= by sorry` part indicates that the proof is not yet provided. In Lean, `sorry` is a placeholder that allows the theorem to be accepted syntactically without a proof, useful during the development phase.\n\nThe formal statement in Lean4 is thus a direct translation of the informal statement, with the necessary setup to handle real numbers and algebraic expressions. The theorem is ready to be proved once the `sorry` is replaced with a valid proof."}
{"source_file": "herald_data/sample_500.jsonl", "line": 196, "id": 455175, "informal_statement": "Prove that if $p$ is a prime and $n$ is a positive integer such that $p^2$ divides $\\prod^n_{k=1} (k^2+1)$, then $p<2n$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_455175 (p n : ℕ) (hp : p.Prime) (h : p^2 ∣ (∏ k in Finset.range n, (k^2 + 1))) : p < 2 * n  :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a structured approach to formalize each component of the statement. Here's a step-by-step explanation:\n\n1. **Identify the Variables and Their Types:**\n   - The informal statement involves a prime number \\( p \\) and a positive integer \\( n \\). In Lean, these are represented as natural numbers (`ℕ`), since primes are a subset of natural numbers and positive integers are also natural numbers.\n\n2. **Prime Number Condition:**\n   - The condition that \\( p \\) is a prime is expressed using `p.Prime` in Lean. This utilizes Lean's built-in support for prime numbers, which is part of the `Mathlib` library.\n\n3. **Product Notation:**\n   - The product \\(\\prod^n_{k=1} (k^2+1)\\) is expressed using Lean's big operators. Specifically, `∏ k in Finset.range n, (k^2 + 1)` represents the product from \\( k = 0 \\) to \\( k = n-1 \\). This is because `Finset.range n` generates the set \\(\\{0, 1, \\ldots, n-1\\}\\).\n\n4. **Divisibility Condition:**\n   - The condition \\( p^2 \\mid \\prod^n_{k=1} (k^2+1) \\) is expressed using the divisibility operator `∣` in Lean. The expression `p^2 ∣ (∏ k in Finset.range n, (k^2 + 1))` checks if \\( p^2 \\) divides the product.\n\n5. **Inequality Conclusion:**\n   - The conclusion \\( p < 2n \\) is directly translated to `p < 2 * n` in Lean. The multiplication and comparison operators are straightforward translations.\n\n6. **Theorem Declaration:**\n   - The entire statement is wrapped in a theorem declaration. The theorem is named `extract_aug_455175`, which is a placeholder name. The parameters `(p n : ℕ)` declare the variables \\( p \\) and \\( n \\) as natural numbers. The hypotheses `(hp : p.Prime)` and `(h : p^2 ∣ (∏ k in Finset.range n, (k^2 + 1)))` capture the conditions of the problem."}
{"source_file": "herald_data/sample_500.jsonl", "line": 202, "id": 432430, "informal_statement": "For any real numbers $z > 0$ and $0 \\leq x < 1$, show that $x^z < 1$.", "formal_statement": "import Mathlib\nopen scoped Classical\nopen Real ComplexConjugate\nopen Finset Set\nopen Real\nopen Lean Meta Qq\ntheorem rpow_lt_one {x z : ℝ} (hx1 : 0 ≤ x) (hx2 : x < 1) (hz : 0 < z) : x ^ z < 1 := sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves two real numbers, \\( z \\) and \\( x \\). In Lean, these are represented as variables of type `ℝ`, which stands for real numbers.\n\n2. **State the Conditions**:\n   - The conditions given are \\( z > 0 \\) and \\( 0 \\leq x < 1 \\). These are translated into Lean as hypotheses for the theorem:\n     - `hz : 0 < z` represents the condition \\( z > 0 \\).\n     - `hx1 : 0 ≤ x` and `hx2 : x < 1` represent the condition \\( 0 \\leq x < 1 \\).\n\n3. **Formulate the Conclusion**:\n   - The conclusion we want to prove is \\( x^z < 1 \\). In Lean, this is expressed as `x ^ z < 1`, where `^` denotes exponentiation.\n\n4. **Structure the Theorem**:\n   - The theorem is named `rpow_lt_one`, which is descriptive of the result it proves: that a real power of a number less than one is also less than one.\n   - The theorem takes the form `theorem rpow_lt_one {x z : ℝ} (hx1 : 0 ≤ x) (hx2 : x < 1) (hz : 0 < z) : x ^ z < 1 := sorry`. Here, `sorry` is a placeholder indicating that the proof is not yet provided.\n\n5. **Import Necessary Libraries**:\n   - The code begins with importing several modules from Mathlib, which is a library for Lean. These imports provide the necessary definitions and theorems related to real numbers and exponentiation.\n\n6. **Open Relevant Namespaces**:\n   - The `open` and `open scoped` commands make certain namespaces available, which allows for more concise code by not requiring fully qualified names for functions and theorems related to real numbers.\n\nBy following these steps, the informal statement is accurately translated into a formal theorem in Lean4, ready for a proof to be constructed."}
{"source_file": "herald_data/sample_500.jsonl", "line": 199, "id": 56805, "informal_statement": "For a simple graph $G$ and a walk $p$ from vertex $u$ to vertex $v$ that is a path, denoted by $p.IsPath$, and given that $p$ is not empty ($\\neg p.Nil$), show that the tail of $p$, denoted by $p.tail$, is also a path, i.e., $(p.tail).IsPath$.", "formal_statement": "import Mathlib\nopen Function\ntheorem tail_extracted {G : SimpleGraph V} {u v : V} {p : G.Walk u v} : p.IsPath → ∀ (hp' : ¬p.Nil), (p.tail hp').IsPath := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and semantics.\n\n1. **Graph and Walk Definitions**:\n   - The informal statement refers to a \"simple graph $G$\" and a \"walk $p$ from vertex $u$ to vertex $v$\". In Lean, this is represented by `G : SimpleGraph V` and `p : G.Walk u v`. Here, `SimpleGraph V` denotes a simple graph with vertex type `V`, and `G.Walk u v` denotes a walk in the graph `G` from vertex `u` to vertex `v`.\n\n2. **Path Property**:\n   - The statement mentions that the walk `p` is a path, denoted by `p.IsPath`. In Lean, this is expressed as `p.IsPath`, which is a property of the walk `p` indicating that it is a path (i.e., it does not repeat vertices).\n\n3. **Non-Empty Walk**:\n   - The condition that the walk `p` is not empty is given by `¬p.Nil`. In Lean, `p.Nil` would be a property indicating that the walk is empty, so `¬p.Nil` asserts that the walk is not empty.\n\n4. **Tail of the Walk**:\n   - The informal statement refers to the \"tail of $p$\", denoted by `p.tail`. In Lean, `p.tail hp'` is used, where `hp'` is a proof or evidence that `p` is not empty. This is necessary because the operation of taking the tail of a walk is only valid if the walk is non-empty.\n\n5. **Conclusion**:\n   - The goal is to show that the tail of the walk is also a path, i.e., `(p.tail).IsPath`. In Lean, this is expressed as `(p.tail hp').IsPath`.\n\n6. **Theorem Statement**:\n   - The theorem is named `tail_extracted`, and it takes as input a simple graph `G`, vertices `u` and `v`, and a walk `p` from `u` to `v`. The theorem asserts that if `p` is a path (`p.IsPath`), then for any proof `hp'` that `p` is not empty (`¬p.Nil`), the tail of `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 204, "id": 114580, "informal_statement": "For natural numbers $a$, $y$, and $k$, with $y \\neq 0$, $k \\neq 0$, $y^k < a$, $y < a$, and $y \\leq a$, demonstrate that $0 \\leq a - y$.", "formal_statement": "import Mathlib\nopen Nat\nlemma eq_pow_of_pell_lem_tac_36871 (a : ℕ) (y : ℕ) (k : ℕ) (hy0 : y ≠ 0) (hk0 : k ≠ 0) (hyk : y ^ k < a) (hya : y < a) (this : y ≤ a) : 0 ≤ ↑a - ↑y := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a structured approach to formalize each part of the statement. Here's the step-by-step explanation:\n\n1. **Identify the Variables and Their Types:**\n   - The informal statement involves natural numbers $a$, $y$, and $k$. In Lean, natural numbers are represented by the type `ℕ`.\n   - Thus, we declare `a`, `y`, and `k` as variables of type `ℕ`.\n\n2. **State the Assumptions:**\n   - The informal statement provides several conditions: $y \\neq 0$, $k \\neq 0$, $y^k < a$, $y < a$, and $y \\leq a$.\n   - These are translated into Lean as hypotheses:\n     - `hy0 : y ≠ 0` for $y \\neq 0$.\n     - `hk0 : k ≠ 0` for $k \\neq 0$.\n     - `hyk : y ^ k < a` for $y^k < a$.\n     - `hya : y < a` for $y < a$.\n     - `this : y ≤ a` for $y \\leq a$.\n\n3. **State the Conclusion:**\n   - The goal is to demonstrate that $0 \\leq a - y$.\n   - In Lean, subtraction of natural numbers results in a natural number, but to express the inequality $0 \\leq a - y$, we need to work with integers. Thus, we use the coercion `↑` to convert `a` and `y` to integers.\n   - The conclusion is then stated as `0 ≤ ↑a - ↑y`.\n\n4. **Structure the Lemma:**\n   - The lemma is named `eq_pow_of_pell_lem_tac_36871`, which is a unique identifier for this particular result.\n   - The lemma takes the form of a function with parameters `a`, `y`, `k`, and the hypotheses `hy0`, `hk0`, `hyk`, `hya`, and `this`.\n   - The return type of the lemma is the proposition `0 ≤ ↑a - ↑y`.\n\n5. **Use of `sorry`:**\n   - The keyword `sorry` is used as a placeholder for the proof. It indicates that the proof is"}
{"source_file": "herald_data/sample_500.jsonl", "line": 201, "id": 63559, "informal_statement": "For any function \\(v: \\iota \\to M\\) from an index set \\(\\iota\\) to a module \\(M\\), if \\(v\\) is not injective, then the continuous alternating map \\(f\\) applied to \\(v\\) is equal to \\(0\\), i.e., \\(f(v) = 0\\).", "formal_statement": "import Mathlib\nopen Function Matrix\ntheorem map_eq_zero_of_not_injective_extracted [Semiring R] [AddCommMonoid M]\n [Module R M] [TopologicalSpace M] [AddCommMonoid N] [Module R N]\n [TopologicalSpace N] (f : M [⋀^ι]→L[R] N) (v : ι → M) : ¬Injective v → f v = 0 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understand the Context and Imports**:\n   - The statement involves modules, functions, and topological spaces, which are mathematical structures. In Lean, these are often part of libraries like `Mathlib`.\n   - The `import Mathlib` line indicates that we are using the Lean mathematical library, which provides definitions and theorems for these structures.\n\n2. **Define the Mathematical Structures**:\n   - The statement involves a module \\( M \\) over a ring \\( R \\). In Lean, this is expressed using type classes: `[Semiring R]` and `[AddCommMonoid M]` indicate that \\( R \\) is a semiring and \\( M \\) is an additive commutative monoid.\n   - `[Module R M]` specifies that \\( M \\) is a module over \\( R \\).\n   - `[TopologicalSpace M]` indicates that \\( M \\) has a topology, making it a topological space.\n\n3. **Define the Function and Its Properties**:\n   - The function \\( v: \\iota \\to M \\) is a map from an index set \\(\\iota\\) to the module \\( M \\). In Lean, this is represented as `v : ι → M`.\n   - The property of \\( v \\) being not injective is expressed as `¬Injective v`, where `Injective` is a predicate that checks if a function is injective.\n\n4. **Define the Alternating Map**:\n   - The continuous alternating map \\( f \\) is a linear map from the alternating power of \\( M \\) to another module \\( N \\). In Lean, this is represented as `f : M [⋀^ι]→L[R] N`.\n   - `[⋀^ι]` denotes the alternating power, and `→L[R]` indicates a continuous linear map over the ring \\( R \\).\n\n5. **State the Theorem**:\n   - The theorem `map_eq_zero_of_not_injective_extracted` states that if \\( v \\) is not injective, then applying \\( f \\) to \\( v \\) results in zero. This is expressed as `¬Injective v → f v = 0`.\n   - The `:= sorry` part is a placeholder indicating that the proof of the theorem is not"}
{"source_file": "herald_data/sample_500.jsonl", "line": 205, "id": 260739, "informal_statement": "For a normed division ring $\\mathbb{K}$, given $r \\in \\mathbb{K}$ such that $\\|r\\| < 1$, a natural number $k$, and assuming the series $\\sum_{n} \\left(\\binom{n + k}{k} r^n\\right)$ has a sum of $\\frac{1}{(1 - r)^{k + 1}}$, and the series $\\sum_{n} \\left\\|\\binom{n + k}{k} r^n\\right\\|$ is summable, show that $\\frac{1}{(1 - r)^{k + 1}(1 - r)}$ is equal to $\\frac{1}{(1 - r)^{k + 1}} \\cdot (1 - r)^{-1}$.", "formal_statement": "import Mathlib\nopen scoped Classical\nopen Set Function Filter Finset Metric Asymptotics\nopen scoped Classical\nopen Topology Nat uniformity NNReal ENNReal\nopen List in\nlemma hasSum_choose_mul_geometric_of_norm_lt_one_tac_20006 [NormedDivisionRing 𝕜] (r : 𝕜) (hr : ‖r‖ < 1) (k : ℕ) (ih : HasSum (fun n => ↑((n + k).choose k) * r ^ n) (1 / (1 - r) ^ (k + 1))) (I1 : Summable fun n => ‖↑((n + k).choose k) * r ^ n‖) : 1 / ((1 - r) ^ (k + 1) * (1 - r)) = 1 / (1 - r) ^ (k + 1) * (1 - r)⁻¹ := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully map each component of the statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Context and Imports**: \n   - The informal statement involves concepts from analysis, such as normed division rings, series, and summability. In Lean, these are handled by importing relevant libraries. The `Mathlib` import provides access to a wide range of mathematical definitions and theorems. The `open` statements make various namespaces available, which include operations and theorems related to sets, functions, filters, and more.\n\n2. **Typeclass and Variables**:\n   - The statement begins by specifying a normed division ring $\\mathbb{K}$. In Lean, this is represented by `[NormedDivisionRing 𝕜]`, where `𝕜` is a type variable representing the normed division ring.\n   - The variable `r : 𝕜` represents an element of the normed division ring, corresponding to $r \\in \\mathbb{K}$ in the informal statement.\n   - The condition $\\|r\\| < 1$ is expressed as `(hr : ‖r‖ < 1)` in Lean, where `hr` is a hypothesis name.\n\n3. **Natural Number and Series**:\n   - The natural number $k$ is represented as `(k : ℕ)` in Lean, where `ℕ` is the type of natural numbers.\n   - The series $\\sum_{n} \\left(\\binom{n + k}{k} r^n\\right)$ having a sum of $\\frac{1}{(1 - r)^{k + 1}}$ is formalized using the `HasSum` predicate. This is expressed as `(ih : HasSum (fun n => ↑((n + k).choose k) * r ^ n) (1 / (1 - r) ^ (k + 1)))`. Here, `HasSum` takes a function and a value, asserting that the series of the function converges to the given value. The binomial coefficient is represented by `(n + k).choose k`, and `↑` is used to lift natural numbers to the ring `𝕜`.\n\n4. **Summability Condition**:\n   - The condition that the series $\\sum_{n} \\left\\|\\"}
{"source_file": "herald_data/sample_500.jsonl", "line": 203, "id": 358637, "informal_statement": "The sum type `X ⊕ Y` is isomorphic to the categorical binary coproduct of types `X` and `Y` in the category `Type u`.", "formal_statement": "import Mathlib\nopen CategoryTheory Limits\nopen CategoryTheory.Limits.WalkingPair\n/-- The categorical binary coproduct in `Type u` is the sum `X ⊕ Y`. -/\nnoncomputable def binaryCoproductIso (X Y : Type u) : Limits.coprod X Y ≅ X ⊕ Y := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to understand both the mathematical concepts involved and how they are represented in Lean's category theory library.\n\n1. **Understanding the Informal Statement**:\n   - The statement involves the concept of a sum type `X ⊕ Y`, which in type theory is a type that can hold either a value of type `X` or a value of type `Y`.\n   - The categorical binary coproduct in the category of types (`Type u`) is a construction that, in this context, corresponds to the sum type `X ⊕ Y`.\n   - An isomorphism in category theory is a morphism that has an inverse, indicating that two objects are essentially the same in the categorical sense.\n\n2. **Lean4 Imports and Setup**:\n   - `import Mathlib`: This imports the Mathlib library, which contains a wide range of mathematical definitions and theorems, including category theory.\n   - `open CategoryTheory Limits`: This opens the namespaces for category theory and limits, making it easier to refer to definitions and theorems related to these concepts without fully qualifying their names.\n   - `open CategoryTheory.Limits.WalkingPair`: This opens the namespace for the specific category theory constructs related to binary products and coproducts.\n\n3. **Defining the Isomorphism**:\n   - `noncomputable def binaryCoproductIso (X Y : Type u)`: This line begins the definition of a noncomputable function named `binaryCoproductIso`. The function takes two types `X` and `Y` as arguments, both living in the universe `u`.\n   - `: Limits.coprod X Y ≅ X ⊕ Y`: This specifies the type of the function. It states that `binaryCoproductIso` is an isomorphism (`≅`) between `Limits.coprod X Y` and `X ⊕ Y`.\n     - `Limits.coprod X Y`: This refers to the categorical binary coproduct of `X` and `Y` in the category `Type u`. In Lean, this is a construction that represents the coproduct in the categorical sense.\n     - `X ⊕ Y`: This is the sum type in Lean, representing a type that can be either an `X` or a `Y`.\n\n4. **The `sorry` Placeholder**:\n   - `:= sorry`:"}
{"source_file": "herald_data/sample_500.jsonl", "line": 200, "id": 103202, "informal_statement": "For any elements $x, y$ in a space $\\beta$, show that the constant sequence of $x + y$ is equal to the sum of the constant sequences of $x$ and $y$, i.e., $\\text{const}(x + y) = \\text{const}(x) + \\text{const}(y)$.", "formal_statement": "import Mathlib\nopen IsAbsoluteValue\ntheorem const_add_extracted [LinearOrderedField α] [Ring β] {abv : β → α}\n [IsAbsoluteValue abv] (x y : β) : CauSeq.const abv (x + y) = CauSeq.const abv x + CauSeq.const abv y := sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and library functions.\n\n1. **Understanding the Context**: \n   - The informal statement involves elements \\( x \\) and \\( y \\) in a space \\(\\beta\\). In Lean, this is represented by specifying \\( x \\) and \\( y \\) as variables of type \\(\\beta\\).\n   - The operation involves constant sequences and their addition, which suggests the use of Cauchy sequences in a normed space or field.\n\n2. **Identifying the Mathematical Structures**:\n   - The space \\(\\beta\\) is a ring, as indicated by the use of addition and the context of sequences. In Lean, this is represented by `[Ring β]`.\n   - The absolute value function `abv` is used, which is a function from \\(\\beta\\) to some ordered field \\(\\alpha\\). This is represented by `{abv : β → α}`.\n   - The absolute value function satisfies certain properties, which are captured by `[IsAbsoluteValue abv]`.\n\n3. **Formalizing the Constant Sequence**:\n   - The constant sequence of an element \\( x \\) is represented in Lean by `CauSeq.const abv x`. This uses the `CauSeq` module, which deals with Cauchy sequences, and `const` is a function that creates a constant sequence from an element.\n\n4. **Formalizing the Statement**:\n   - The informal statement claims that the constant sequence of \\( x + y \\) is equal to the sum of the constant sequences of \\( x \\) and \\( y \\). In Lean, this is expressed as:\n     ```lean\n     CauSeq.const abv (x + y) = CauSeq.const abv x + CauSeq.const abv y\n     ```\n   - This equality is the core of the theorem we are proving.\n\n5. **Specifying the Theorem**:\n   - The theorem is named `const_add_extracted`, which is a descriptive name indicating the operation being performed (addition of constant sequences).\n   - The theorem is parameterized by the types and structures involved: `[LinearOrderedField α]`, `[Ring β]`, `{abv : β → α}`, and `[IsAbsoluteValue abv]`. These are the assumptions under which the theorem holds.\n\n6."}
{"source_file": "herald_data/sample_500.jsonl", "line": 206, "id": 200900, "informal_statement": "For any types $\\alpha$ and $\\beta$ equipped with decidable equality, and given partial equivalences $f, g : \\alpha \\dashrightarrow \\beta$, elements $a \\in \\alpha$ and $b \\in \\beta$, with conditions that $f$ and $g$ map $a$ to $b$ and $b$ to $a$ in a consistent manner (specified by $hf$ and $hg$), and under the assumptions that $f$ and $g$ map $b$ to the same element in $\\alpha$ (expressed by $h1$) and that $f$ and $g$ do not map $a$ to the same element in $\\beta$ (expressed by $h2$), prove that $f$ does not map $a$ to $b$ in $\\beta$.", "formal_statement": "import Mathlib\nopen Function Option\nlemma instSemilatticeInfOfDecidableEq_tac_13565 [DecidableEq α] [DecidableEq β] (f : α ≃. β) (g : α ≃. β) (a : α) (b : β) (hf : f.symm b = some a ↔ f a = some b) (hg : g.symm b = some a ↔ g a = some b) (h1 : f.symm b = g.symm b) (h2 : ¬f a = g a) : ¬f a = some b := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the problem and its constraints. Here's a step-by-step explanation of the translation:\n\n1. **Types and Decidable Equality**:\n   - The informal statement begins by specifying two types, $\\alpha$ and $\\beta$, each equipped with decidable equality. In Lean, this is expressed using the type class `[DecidableEq α]` and `[DecidableEq β]`. This ensures that equality checks between elements of these types can be performed in a computable manner.\n\n2. **Partial Equivalences**:\n   - The statement involves partial equivalences $f$ and $g$ from $\\alpha$ to $\\beta$. In Lean, partial equivalences are represented by `α ≃. β`, which denotes a partial equivalence between types $\\alpha$ and $\\beta`.\n\n3. **Elements and Conditions**:\n   - We have elements $a \\in \\alpha$ and $b \\in \\beta$. These are simply variables of types `α` and `β` in Lean.\n   - The conditions $f$ and $g$ map $a$ to $b$ and $b$ to $a$ in a consistent manner are expressed using the equivalences `hf` and `hg`. In Lean, this is written as `f.symm b = some a ↔ f a = some b` and `g.symm b = some a ↔ g a = some b`. This captures the idea that $f$ and $g$ are partial bijections between $a$ and $b$.\n\n4. **Assumptions**:\n   - The assumption that $f$ and $g$ map $b$ to the same element in $\\alpha$ is expressed by `h1 : f.symm b = g.symm b`. This means that the inverse images of $b$ under $f$ and $g$ are the same.\n   - The assumption that $f$ and $g$ do not map $a$ to the same element in $\\beta$ is expressed by `h2 : ¬f a = g a`. This indicates that the images of $a$ under $f$ and $g$ are different.\n\n5. **Conclusion**:\n   - The goal is to prove that $f$ does not map $a$ to $b$ in $\\beta$."}
{"source_file": "herald_data/sample_500.jsonl", "line": 207, "id": 199452, "informal_statement": "For any semiring \\(R\\), additive commutative monoid \\(M\\), and module \\(M\\) over \\(R\\), and given an element \\(b\\) in \\(M\\), a natural number \\(n\\), and the induction hypothesis \\(ih\\) that the scalar multiplication of \\(n\\) times \\(b\\) in \\(R\\) is equal to the natural number scalar multiplication of \\(n\\) times \\(b\\) in \\(M\\), show that the scalar multiplication of \\(n\\) times \\(b\\) in \\(R\\) plus the scalar multiplication of \\(1\\) times \\(b\\) in \\(R\\) is equal to the natural number scalar multiplication of \\(n + 1\\) times \\(b\\) in \\(M\\). That is, \\(\\left(\\uparrow n \\cdot b\\right) + \\left(1 \\cdot b\\right) = \\left(n + 1\\right) \\cdot b\\).", "formal_statement": "import Mathlib\nopen Function Set\nlemma cast_smul_eq_nsmul_tac_13024 [Semiring R] [AddCommMonoid M] [Module R M] (b : M) (n : ℕ) (ih : ↑n • b = n • b) : ↑n • b + 1 • b = (n + 1) • b := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a structured approach that aligns the mathematical concepts with their formal counterparts in Lean. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context**:\n   - We are dealing with a semiring \\( R \\), an additive commutative monoid \\( M \\), and a module \\( M \\) over \\( R \\). These structures are common in algebra and are used to define operations like addition and scalar multiplication.\n\n2. **Identifying the Elements and Operations**:\n   - The element \\( b \\) is in the module \\( M \\).\n   - The natural number \\( n \\) is used for scalar multiplication.\n   - The induction hypothesis \\( ih \\) states that the scalar multiplication of \\( n \\) times \\( b \\) in \\( R \\) is equal to the natural number scalar multiplication of \\( n \\) times \\( b \\) in \\( M \\).\n\n3. **Formalizing the Structures**:\n   - In Lean, we use type classes to represent algebraic structures. The semiring \\( R \\) is represented by `[Semiring R]`, the additive commutative monoid \\( M \\) by `[AddCommMonoid M]`, and the module structure by `[Module R M]`.\n\n4. **Formalizing the Hypothesis and Goal**:\n   - The hypothesis \\( ih \\) is formalized as `ih : ↑n • b = n • b`. Here, `↑n` represents the coercion of the natural number \\( n \\) into the semiring \\( R \\), and `•` denotes the scalar multiplication in the module.\n   - The goal is to show that `↑n • b + 1 • b = (n + 1) • b`. This translates the informal statement into a formal goal in Lean, where `1 • b` represents the scalar multiplication of \\( 1 \\) (coerced into \\( R \\)) with \\( b \\).\n\n5. **Using Lean's Syntax and Libraries**:\n   - The `import Mathlib` statement includes necessary mathematical libraries that provide definitions and theorems for semirings, monoids, and modules.\n   - The `open Function Set` statement is used to bring certain functions and set operations into scope, although they are not directly used in this lemma.\n   - The lemma is named `cast_smul_eq_nsmul"}
{"source_file": "herald_data/sample_500.jsonl", "line": 211, "id": 453394, "informal_statement": "Let $a, b, c >0$ . Prove that \\n $$\\left(\\frac{a}{b+c}\\right)^2+\\frac{b}{c+a}+\\left(\\frac{c}{a+b}\\right)^2\\geq 1$$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_453394 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : (a / (b + c))^2 + b / (c + a) + (c / (a + b))^2 >= 1  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves three variables \\(a\\), \\(b\\), and \\(c\\), which are all positive real numbers. In Lean, we represent real numbers using the type `ℝ`.\n\n2. **Express the Positivity Condition**:\n   - The condition \\(a, b, c > 0\\) is expressed in Lean as `0 < a`, `0 < b`, and `0 < c`. These are hypotheses that will be used in the theorem.\n\n3. **Translate the Inequality**:\n   - The inequality \\(\\left(\\frac{a}{b+c}\\right)^2 + \\frac{b}{c+a} + \\left(\\frac{c}{a+b}\\right)^2 \\geq 1\\) needs to be expressed using Lean's syntax for arithmetic operations and inequalities.\n   - Division is represented by `/`, exponentiation by `^`, and the greater than or equal to relation by `>=`.\n\n4. **Structure the Theorem**:\n   - In Lean, a theorem is declared using the `theorem` keyword, followed by the name of the theorem and its statement.\n   - The name `extract_aug_453394` is an arbitrary identifier for the theorem.\n   - The theorem statement includes the variables \\(a\\), \\(b\\), and \\(c\\) of type `ℝ`, and the hypotheses `ha`, `hb`, and `hc` representing the positivity conditions.\n   - The conclusion of the theorem is the inequality, written in Lean syntax.\n\n5. **Use of Lean Libraries**:\n   - The `import Mathlib` statement is used to include the necessary mathematical libraries that provide definitions and theorems for real numbers and inequalities.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to bring relevant definitions and theorems into scope, although not all may be directly necessary for this specific theorem.\n\n6. **Proof Placeholder**:\n   - The `:= by sorry` part indicates that the proof is not yet provided. In Lean, `sorry` is a placeholder that allows the theorem to be accepted syntactically without a proof.\n\nBy following these steps, the informal statement is translated into a formal Lean theorem that captures the essence of the problem and sets up"}
{"source_file": "herald_data/sample_500.jsonl", "line": 209, "id": 481457, "informal_statement": "Let $x,y,z\\geq 0,x+y+z=3$ ,prove that: $\\sqrt{2+y+z}+\\sqrt{2+z+x}+\\sqrt{2+y+x}\\geq \\sqrt{2}(\\sqrt{1+x}+\\sqrt{1+y}+\\sqrt{1+z})$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_481457 (x y z : ℝ) (hx : x ≥ 0 ∧ y ≥ 0 ∧ z ≥ 0 ∧ x + y + z = 3) :\n  Real.sqrt (2 + y + z) + Real.sqrt (2 + z + x) + Real.sqrt (2 + y + x) ≥ Real.sqrt 2 * (Real.sqrt (1 + x) + Real.sqrt (1 + y) + Real.sqrt (1 + z))  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow a structured approach to ensure that all components of the statement are accurately represented in the formal language. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Variables and Their Domain**:\n   - The informal statement involves three variables \\(x\\), \\(y\\), and \\(z\\) which are non-negative real numbers. This is expressed in Lean by declaring \\(x\\), \\(y\\), and \\(z\\) as real numbers (\\(\\mathbb{R}\\)) and adding a condition that they are greater than or equal to zero.\n\n2. **Express the Condition on the Variables**:\n   - The condition \\(x + y + z = 3\\) is a constraint on the variables. In Lean, this is expressed as part of the hypothesis \\(hx\\), which is a conjunction of inequalities and an equation: \\(x \\geq 0\\), \\(y \\geq 0\\), \\(z \\geq 0\\), and \\(x + y + z = 3\\).\n\n3. **Translate the Inequality to Prove**:\n   - The goal is to prove an inequality involving square roots. In Lean, the square root function is represented as `Real.sqrt`. The left-hand side of the inequality is the sum of three square roots: \\(\\sqrt{2+y+z} + \\sqrt{2+z+x} + \\sqrt{2+y+x}\\).\n   - The right-hand side is \\(\\sqrt{2}\\) multiplied by the sum of three other square roots: \\(\\sqrt{1+x} + \\sqrt{1+y} + \\sqrt{1+z}\\). The multiplication is expressed using the `*` operator.\n\n4. **Structure the Theorem in Lean**:\n   - The theorem is named `extract_aug_481457`, which is a placeholder name that can be replaced with a more descriptive one.\n   - The theorem takes three arguments \\(x\\), \\(y\\), and \\(z\\) of type `ℝ` (real numbers).\n   - The hypothesis \\(hx\\) is a conjunction of conditions on \\(x\\), \\(y\\), and \\(z\\), expressed using the `∧` (and) operator.\n   - The conclusion of the theorem is the inequality, expressed using the `≥` operator.\n\n5. **Use of Lean Libraries**:"}
{"source_file": "herald_data/sample_500.jsonl", "line": 212, "id": 192405, "informal_statement": "For a prime number \\( p \\) and \\( x \\) in the unit group of \\( \\mathbb{Z}/p\\mathbb{Z} \\), excluding the case where \\( p = 2 \\), show that there exists a \\( y \\) such that \\( y^2 = x \\) if and only if there exists a \\( c \\) such that \\( x = c^2 \\).", "formal_statement": "import Mathlib\nopen Nat\nlemma euler_criterion_units_tac_1704 (p : ℕ) [Fact (Nat.Prime p)] (x : (ZMod p)ˣ) (hc : ¬p = 2) : (∃ y, y ^ 2 = x) ↔ ∃ c, x = c ^ 2 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal Lean code:\n\n1. **Prime Number \\( p \\):**\n   - In the informal statement, \\( p \\) is specified as a prime number. In Lean, this is represented by the type `ℕ` (natural numbers) and the constraint `[Fact (Nat.Prime p)]`. The `Fact` typeclass is used to assert that \\( p \\) is a prime number, leveraging Lean's typeclass mechanism to carry this proof around implicitly.\n\n2. **Unit Group of \\( \\mathbb{Z}/p\\mathbb{Z} \\):**\n   - The unit group of the integers modulo \\( p \\), denoted \\( (\\mathbb{Z}/p\\mathbb{Z})^* \\), is represented in Lean by `(ZMod p)ˣ`. Here, `ZMod p` represents the integers modulo \\( p \\), and the `ˣ` symbol denotes the unit group, i.e., the invertible elements.\n\n3. **Excluding the Case where \\( p = 2 \\):**\n   - The condition \\( p \\neq 2 \\) is expressed in Lean by the hypothesis `(hc : ¬p = 2)`. This is a straightforward translation of the informal condition into a formal hypothesis that \\( p \\) is not equal to 2.\n\n4. **Existence of \\( y \\) such that \\( y^2 = x \\):**\n   - The informal statement asks to show the existence of a \\( y \\) such that \\( y^2 = x \\). In Lean, this is expressed as `∃ y, y ^ 2 = x`. The `∃` symbol denotes existential quantification, and `y ^ 2 = x` is the equation that \\( y \\) must satisfy.\n\n5. **Existence of \\( c \\) such that \\( x = c^2 \\):**\n   - Similarly, the existence of a \\( c \\) such that \\( x = c^2 \\) is expressed in Lean as `∃ c, x = c ^ 2`. This mirrors the structure of the previous existential quantification, with the roles of \\( x \\) and \\( c \\) swapped.\n\n6. **If and Only If (↔):**\n   - The informal statement involves"}
{"source_file": "herald_data/sample_500.jsonl", "line": 210, "id": 146995, "informal_statement": "For any ordinal \\(\\alpha\\) with a well-order \\(r\\), assuming there exists a function \\(h\\) such that for all \\(x < \\#\\alpha\\), \\(2^x < \\#\\alpha\\), and \\(\\alpha\\) is a strong limit cardinal, and \\(\\aleph_0 \\leq \\#\\alpha\\), show that the cardinality of the union over all \\(i\\) of the power set of elements \\(j\\) such that \\(r j i\\) is less than or equal to the cardinality of \\(\\alpha\\), i.e., \\(\\#\\left(\\bigcup_i \\mathcal{P}\\{j \\mid r j i\\}\\right) \\leq \\#\\alpha\\).", "formal_statement": "import Mathlib\nopen Function Cardinal Set Order\nopen scoped Ordinal\nopen Ordinal\nlemma mk_bounded_subset_tac_33258 (h : ∀ x < #α, 2 ^ x < #α) (r : α → α → Prop) [IsWellOrder α r] (h' : (#α).IsStrongLimit) (ha : ℵ₀ ≤ #α) (this : {s | Bounded r s} = ⋃ i, 𝒫{j | r j i}) : #↑(⋃ i, 𝒫{j | r j i}) ≤ #α := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and semantics.\n\n1. **Understanding the Context and Imports:**\n   - The code begins with `import Mathlib`, which is necessary to access the mathematical libraries in Lean that provide definitions and theorems related to ordinals, cardinals, sets, and orders.\n   - The `open` and `open scoped` commands are used to bring specific namespaces and notations into the current context, making it easier to refer to functions and types like `Function`, `Cardinal`, `Set`, `Order`, `Ordinal`, and their associated operations.\n\n2. **Defining the Lemma:**\n   - The lemma is named `mk_bounded_subset_tac_33258`, which is a unique identifier for this particular result.\n   - The parameters of the lemma are defined as follows:\n     - `h : ∀ x < #α, 2 ^ x < #α`: This is a hypothesis stating that for any cardinality `x` less than the cardinality of `α` (denoted `#α`), the cardinality of the power set of `x` (i.e., `2^x`) is also less than `#α`. This is a property of `α` being a strong limit cardinal.\n     - `r : α → α → Prop`: This defines `r` as a binary relation on `α`, which is assumed to be a well-order.\n     - `[IsWellOrder α r]`: This is a typeclass assumption that `r` is a well-order on `α`.\n     - `h' : (#α).IsStrongLimit`: This states that `#α` is a strong limit cardinal, reinforcing the property given by `h`.\n     - `ha : ℵ₀ ≤ #α`: This asserts that the cardinality of `α` is at least `ℵ₀`, the cardinality of the natural numbers, ensuring `α` is infinite.\n     - `this : {s | Bounded r s} = ⋃ i, 𝒫{j | r j i}`: This hypothesis equates the set of all bounded subsets under the relation `r` to the union over all `i` of the power sets of sets `{j | r j i}`.\n\n3. **Formalizing"}
{"source_file": "herald_data/sample_500.jsonl", "line": 208, "id": 573492, "informal_statement": "Prove that every ring of order $p^2$ with identity is commutative, where $p$ is a prime number.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_573492 (R : Type*) [Ring R] [Fintype R] (hp : Nat.Prime p) (hR : Fintype.card R = p^2) : CommRing R   :=  by sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to break down the components of the statement and understand how they map to Lean's formal language.\n\n1. **Understanding the Context**: \n   - The informal statement is about a ring of a specific order, specifically $p^2$, where $p$ is a prime number. The goal is to prove that such a ring is commutative.\n\n2. **Identifying the Components**:\n   - **Ring with identity**: In Lean, this is represented by the type class `Ring R`, which includes the existence of an identity element.\n   - **Order $p^2$**: This refers to the number of elements in the ring, which is captured by `Fintype.card R = p^2`. The `Fintype` type class is used to indicate that the type `R` has a finite number of elements.\n   - **Prime number $p$**: This is represented by `Nat.Prime p`, indicating that `p` is a prime number.\n\n3. **Formalizing the Statement**:\n   - The theorem is named `extract_aug_573492`, which is a placeholder name and can be replaced with a more descriptive one.\n   - The parameters of the theorem are:\n     - `R : Type*`: This indicates that `R` is a type, which in this context is the ring we are considering.\n     - `[Ring R]`: This is a type class constraint that ensures `R` is a ring with an identity.\n     - `[Fintype R]`: This ensures that `R` is a finite type, meaning it has a finite number of elements.\n     - `(hp : Nat.Prime p)`: This is an assumption that `p` is a prime number.\n     - `(hR : Fintype.card R = p^2)`: This is an assumption that the number of elements in `R` is $p^2$.\n\n4. **Conclusion**:\n   - The goal is to prove that `R` is a commutative ring, which is expressed as `CommRing R`. In Lean, `CommRing` is a type class that extends `Ring` with the commutativity property of multiplication.\n\n5. **Proof Placeholder**:\n   - The `by sorry` indicates that the proof is not provided. In a complete formalization, this would be replaced with a proof"}
{"source_file": "herald_data/sample_500.jsonl", "line": 217, "id": 475699, "informal_statement": "Solve the system of equations:\\n\\\\(\\\\sqrt{3x}\\\\left(1+\\\\frac{1}{x+y}\\\\right)=2\\\\) and \\\\(\\\\sqrt{7y}\\\\left(1-\\\\frac{1}{x+y}\\\\right)=4\\\\sqrt{2}.\\\\)", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_475699 (x y : ℝ) : (Real.sqrt (3 * x) * (1 + 1 / (x + y)) = 2 ∧ Real.sqrt (7 * y) * (1 - 1 / (x + y)) = 4 * Real.sqrt 2) ↔ x = 1 ∧ y = 1  :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Domain**: \n   - The variables in the system of equations are \\(x\\) and \\(y\\). Since the equations involve square roots and division, \\(x\\) and \\(y\\) must be real numbers. In Lean, we represent real numbers using `ℝ`.\n\n2. **Translate the Equations**:\n   - The first equation is \\(\\sqrt{3x}\\left(1+\\frac{1}{x+y}\\right)=2\\). In Lean, the square root function is `Real.sqrt`, multiplication is implicit, and division is represented by `/`. Therefore, this equation translates to `Real.sqrt (3 * x) * (1 + 1 / (x + y)) = 2`.\n   - The second equation is \\(\\sqrt{7y}\\left(1-\\frac{1}{x+y}\\right)=4\\sqrt{2}\\). Similarly, this translates to `Real.sqrt (7 * y) * (1 - 1 / (x + y)) = 4 * Real.sqrt 2`.\n\n3. **Combine the Equations**:\n   - The system of equations is expressed as a conjunction (logical \"and\") of the two equations. In Lean, conjunction is represented by `∧`. Thus, the system is written as `(Real.sqrt (3 * x) * (1 + 1 / (x + y)) = 2 ∧ Real.sqrt (7 * y) * (1 - 1 / (x + y)) = 4 * Real.sqrt 2)`.\n\n4. **Express the Solution**:\n   - The problem asks to solve the system, which means finding values of \\(x\\) and \\(y\\) that satisfy both equations. The solution given is \\(x = 1\\) and \\(y = 1\\). In Lean, equality is expressed with `=` and conjunction with `∧`, so the solution is written as `x = 1 ∧ y = 1`.\n\n5. **Formulate the Theorem**:\n   - The theorem states that the system of equations is equivalent to the solution \\(x = 1\\) and \\(y = 1\\). In Lean, equivalence is represented by `↔`. Therefore, the theorem is formulated as:\n     ```lean"}
{"source_file": "herald_data/sample_500.jsonl", "line": 213, "id": 292079, "informal_statement": "For any ring $R$ and modules $X, Y$ over $R$, given a module homomorphism $f : X \\to Y$, show that $f$ is an epimorphism if and only if the underlying function of $f$ is surjective.", "formal_statement": "import Mathlib\nopen CategoryTheory\nlemma epi_iff_surjective_tac_1580 [Ring R] (X : ModuleCat R) (Y : ModuleCat R) (f : X ⟶ Y) : Epi f ↔ Function.Surjective ⇑f := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understand the Context**: The statement involves rings, modules, and module homomorphisms. In Lean, these concepts are often handled within the framework of category theory, where modules over a ring form a category, and module homomorphisms are morphisms in this category.\n\n2. **Identify the Structures**:\n   - **Ring \\( R \\)**: In Lean, a ring is typically represented by a type with a `Ring` typeclass. This is indicated by `[Ring R]` in the Lean code, which means `R` is a type that has a ring structure.\n   - **Modules \\( X, Y \\)**: In Lean, modules over a ring \\( R \\) are represented as objects in the category of \\( R \\)-modules, denoted as `ModuleCat R`. Thus, `X` and `Y` are declared as `ModuleCat R`, meaning they are modules over the ring \\( R \\).\n\n3. **Module Homomorphism \\( f : X \\to Y \\)**:\n   - In category theory, a homomorphism between objects \\( X \\) and \\( Y \\) in a category is denoted by `X ⟶ Y`. In Lean, `f : X ⟶ Y` indicates that `f` is a morphism (module homomorphism) from module \\( X \\) to module \\( Y \\).\n\n4. **Epimorphism and Surjectivity**:\n   - **Epimorphism**: In category theory, an epimorphism is a morphism that is right-cancellable. In Lean, this is represented by `Epi f`.\n   - **Surjectivity**: A function is surjective if every element in the codomain has a preimage. In Lean, this is expressed as `Function.Surjective ⇑f`, where `⇑f` denotes the underlying function of the morphism `f`.\n\n5. **Formalizing the Statement**:\n   - The goal is to show that `f` is an epimorphism if and only if the underlying function of `f` is surjective. This is expressed as the equivalence `Epi f ↔ Function.Surjective ⇑f`.\n   - The lemma is named `epi_iff_surjective_tac_1580`, which is a unique identifier for this"}
{"source_file": "herald_data/sample_500.jsonl", "line": 218, "id": 102668, "informal_statement": "Show that the union of all closed intervals of the form $[a + n \\cdot p, a + (n + 1) \\cdot p]$ for $n \\in \\mathbb{Z}$ is equal to the entire real line, i.e., $\\bigcup_{n \\in \\mathbb{Z}} [a + n \\cdot p, a + (n + 1) \\cdot p] = \\mathbb{R}$.", "formal_statement": "import Mathlib\nopen List in\nopen AddCommGroup\nopen AddCommGroup\nopen AddCommGroup\nopen Set Int\ntheorem iUnion_Icc_add_zsmul_extracted [LinearOrderedAddCommGroup α] [Archimedean α] {p : α} :\n 0 < p → ∀ (a : α), ⋃ n, Set.Icc (a + n • p) (a + (n + 1) • p) = Set.univ := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and semantics.\n\n1. **Understanding the Informal Statement**:\n   - We are given a family of closed intervals of the form $[a + n \\cdot p, a + (n + 1) \\cdot p]$ where $n \\in \\mathbb{Z}$.\n   - The task is to show that the union of all these intervals over all integers $n$ covers the entire real line $\\mathbb{R}$.\n\n2. **Lean4 Setup**:\n   - We start by importing necessary modules from Lean's math library (`Mathlib`) which provides the required mathematical structures and operations.\n   - We open relevant namespaces such as `Set` and `Int` to access set operations and integer operations without prefixing them with the module name.\n\n3. **Type and Structure Declarations**:\n   - The theorem is stated for a general linearly ordered additive commutative group `α` with an Archimedean property. This is more general than just the real numbers, but it includes them as a special case.\n   - The type `α` is equipped with a linear order and an additive group structure, which allows us to perform operations like addition and scalar multiplication.\n\n4. **Parameters and Hypotheses**:\n   - `p : α` is a parameter representing the period of the intervals. The hypothesis `0 < p` ensures that the intervals are non-degenerate and properly spaced.\n   - `a : α` is another parameter representing the starting point of the intervals.\n\n5. **Formalizing the Union of Intervals**:\n   - `⋃ n, Set.Icc (a + n • p) (a + (n + 1) • p)` represents the union of all closed intervals $[a + n \\cdot p, a + (n + 1) \\cdot p]$ for $n \\in \\mathbb{Z}$.\n   - `Set.Icc` is the Lean representation of a closed interval, and `n • p` denotes the scalar multiplication of `n` (an integer) with `p`.\n\n6. **Equality to the Universal Set**:\n   - `= Set.univ` asserts that the union of these intervals is equal to the universal set, which in"}
{"source_file": "herald_data/sample_500.jsonl", "line": 216, "id": 79049, "informal_statement": "For any natural number $n$, show that the result of the `div2` function applied to $n$ is equal to $n$ divided by $2$, i.e., $\\text{div2}(n) = \\frac{n}{2}$.", "formal_statement": "import Mathlib\n\ntheorem div2_val_extracted (n : ℕ) : n.div2 = n / 2 := sorry", "explanation": "To formalize the given informal statement in Lean4, we need to translate the mathematical concepts and operations into their corresponding Lean constructs. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Domain**: The informal statement specifies \"any natural number $n$\". In Lean, natural numbers are represented by the type `ℕ`. Therefore, we start by declaring a variable `n` of type `ℕ`.\n\n2. **Function Identification**: The statement involves a function `div2`. In Lean, `div2` is a predefined function for natural numbers that computes the integer division of a number by 2. This function is directly available as `n.div2` for a natural number `n`.\n\n3. **Mathematical Operation**: The informal statement also involves the division of `n` by 2, denoted as $\\frac{n}{2}$. In Lean, division for natural numbers is represented by the operator `/`. Thus, `n / 2` in Lean corresponds to the integer division of `n` by 2.\n\n4. **Equality Assertion**: The goal is to show that the result of `div2` applied to `n` is equal to `n / 2`. In Lean, this is expressed using the equality operator `=`.\n\n5. **Theorem Declaration**: We encapsulate the above logic in a theorem. The theorem is named `div2_val_extracted`, which is a descriptive name indicating that it extracts the value of `div2` in terms of division by 2.\n\n6. **Formal Statement Construction**: The complete formal statement in Lean is:\n   ```lean\n   theorem div2_val_extracted (n : ℕ) : n.div2 = n / 2 := sorry\n   ```\n   - `theorem` declares a new theorem.\n   - `div2_val_extracted` is the name of the theorem.\n   - `(n : ℕ)` specifies that `n` is a natural number.\n   - `: n.div2 = n / 2` is the type of the theorem, stating that `n.div2` is equal to `n / 2`.\n   - `:= sorry` is a placeholder indicating that the proof is not yet provided.\n\n7. **Importing Necessary Libraries**: The statement begins with `import Mathlib`, which is necessary to access mathematical functions and theorems, including `div2"}
{"source_file": "herald_data/sample_500.jsonl", "line": 214, "id": 496171, "informal_statement": "Choose positive numbers $x= \\frac{b+c-a}{2}, y =\\frac{a+c-b}{2}, z = \\frac{a+b-c}{2}$, which satisfy $x+y = c$ and so on. WLOG assume $x \\geqslant y \\geqslant z$. We now want to show: $\\frac{1}{2x} + \\frac{1}{2y} + \\frac{1}{2z} \\geqslant \\frac{1}{y+z} + \\frac{1}{x+z} + \\frac{1}{x+y}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_496171 (x y z : ℝ) (h : x ≥ y ∧ y ≥ z) (hx : x + y = c) (hy : y + z = a) (hz : z + x = b) : 1 / (2 * x) + 1 / (2 * y) + 1 / (2 * z) ≥ 1 / (y + z) + 1 / (x + z) + 1 / (x + y)  :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow a structured approach:\n\n1. **Identify Variables and Their Roles**: \n   - The informal statement introduces three positive numbers \\( x, y, z \\) defined in terms of \\( a, b, c \\). These are expressed as:\n     \\[\n     x = \\frac{b+c-a}{2}, \\quad y = \\frac{a+c-b}{2}, \\quad z = \\frac{a+b-c}{2}\n     \\]\n   - The conditions \\( x+y = c \\), \\( y+z = a \\), and \\( z+x = b \\) are derived from these definitions.\n\n2. **Assumptions and Conditions**:\n   - The statement \"WLOG assume \\( x \\geqslant y \\geqslant z \\)\" is a common mathematical technique to simplify the problem by assuming a specific order of the variables. This is translated into the condition \\( x \\ge y \\) and \\( y \\ge z \\).\n\n3. **Formalizing the Theorem**:\n   - The goal is to prove an inequality involving the reciprocals of these variables:\n     \\[\n     \\frac{1}{2x} + \\frac{1}{2y} + \\frac{1}{2z} \\geq \\frac{1}{y+z} + \\frac{1}{x+z} + \\frac{1}{x+y}\n     \\]\n   - This is directly translated into Lean as the main statement of the theorem.\n\n4. **Lean Syntax and Structure**:\n   - The theorem is defined using the `theorem` keyword, followed by a name (`extract_aug_496171`).\n   - The variables \\( x, y, z \\) are declared as real numbers (`ℝ`).\n   - The assumptions are included as hypotheses:\n     - `h : x ≥ y ∧ y ≥ z` captures the ordering assumption.\n     - `hx : x + y = c`, `hy : y + z = a`, and `hz : z + x = b` capture the conditions derived from the definitions of \\( x, y, z \\).\n\n5. **Imports and Namespace**:\n   - The `import Mathlib` statement is used to bring in necessary mathematical libraries.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology"}
{"source_file": "herald_data/sample_500.jsonl", "line": 219, "id": 53048, "informal_statement": "For any set $s$ in $\\beta$ and any inducing map $f$, show that the restriction of the preimage of $s$ under $f$ is also an inducing map.", "formal_statement": "import Mathlib\nopen TopologicalSpace Set Filter\nopen Topology Filter\ntheorem restrictPreimage_inducing_extracted [TopologicalSpace α] [TopologicalSpace β] {f : α → β} (s : Set β) :\n Inducing f → Inducing (s.restrictPreimage f) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understand the Context**: The statement involves topological spaces and maps between them. Specifically, it deals with the concept of an \"inducing map,\" which in topology refers to a map that induces a topology on its domain that makes the map continuous.\n\n2. **Identify the Components**:\n   - **Set $s$ in $\\beta$**: This is a subset of the topological space $\\beta$.\n   - **Inducing map $f$**: A function $f : \\alpha \\to \\beta$ that induces a topology on $\\alpha$ from $\\beta$.\n   - **Restriction of the preimage**: This refers to the function obtained by restricting the domain of $f$ to the preimage of $s$ under $f$.\n\n3. **Formalize the Components in Lean**:\n   - **Topological Spaces**: In Lean, these are represented by `[TopologicalSpace α]` and `[TopologicalSpace β]`, indicating that `α` and `β` are topological spaces.\n   - **Function $f$**: This is represented as `{f : α → β}`, a function from `α` to `β`.\n   - **Set $s$**: This is represented as `(s : Set β)`, a subset of `β`.\n\n4. **Translate the Inducing Map**:\n   - The property of being an inducing map is represented by `Inducing f`, which is a predicate in Lean that asserts `f` is an inducing map.\n\n5. **Translate the Restriction of the Preimage**:\n   - The function `s.restrictPreimage f` represents the restriction of the preimage of `s` under `f`. This is a common operation in topology where you consider the map restricted to the preimage of a set.\n\n6. **Formulate the Theorem**:\n   - The goal is to show that if `f` is an inducing map, then `s.restrictPreimage f` is also an inducing map. This is expressed in Lean as `Inducing f → Inducing (s.restrictPreimage f)`.\n\n7. **Structure of the Theorem**:\n   - The theorem is named `restrictPreimage_inducing_extracted`, which is descriptive of its content.\n   - The theorem is stated with the necessary"}
{"source_file": "herald_data/sample_500.jsonl", "line": 215, "id": 261945, "informal_statement": "For any group \\(G\\) and elements \\(a, b \\in G\\), show that in the abelianization of \\(G\\), denoted \\(Abelianization\\ G\\), the following equality holds: \\([b^{-1}, a^{-1}]\\) = \\((ab)^{-1} \\cdot ba\\), where \\([,\\ ]\\) denotes the commutator.", "formal_statement": "import Mathlib\nopen Subgroup (centralizer)\nlemma commGroup_tac_3525 [Group G] (x : Abelianization G) (y : Abelianization G) (a : G) (b : G) : ⁅b⁻¹, a⁻¹⁆ = ((fun x x_1 => x * x_1) a b)⁻¹ * (fun x x_1 => x * x_1) b a := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a series of steps that map the concepts and operations from the informal language to their formal counterparts in Lean4. Here's the step-by-step explanation:\n\n1. **Understanding the Context**:\n   - We are dealing with a group \\( G \\) and its abelianization, denoted as \\( \\text{Abelianization}\\ G \\).\n   - The abelianization of a group is a construction that makes the group abelian by factoring out the commutator subgroup.\n\n2. **Identifying the Elements**:\n   - The elements \\( a \\) and \\( b \\) are elements of the group \\( G \\).\n   - In the Lean code, these are represented as `a : G` and `b : G`.\n\n3. **Working in the Abelianization**:\n   - The elements \\( x \\) and \\( y \\) in the Lean code are elements of the abelianization of \\( G \\), represented as `x : Abelianization G` and `y : Abelianization G`.\n\n4. **Commutator Notation**:\n   - The commutator \\([b^{-1}, a^{-1}]\\) is a group operation that in Lean is denoted by `⁅b⁻¹, a⁻¹⁆`.\n   - This notation is used to express the commutator of the inverses of \\( b \\) and \\( a \\).\n\n5. **Expression of the Right-Hand Side**:\n   - The expression \\((ab)^{-1} \\cdot ba\\) involves two operations:\n     - The product \\( ab \\) is expressed using a lambda function `(fun x x_1 => x * x_1) a b`, which represents the multiplication of \\( a \\) and \\( b \\).\n     - The inverse of this product is denoted by appending `⁻¹`.\n     - The product \\( ba \\) is similarly expressed as `(fun x x_1 => x * x_1) b a`.\n\n6. **Equality in Abelianization**:\n   - The goal is to show that the commutator of the inverses is equal to the expression \\((ab)^{-1} \\cdot ba\\) in the abelianization.\n   - This is captured in the lemma statement: `lemma commGroup_tac_3525 [Group G]"}
{"source_file": "herald_data/sample_500.jsonl", "line": 222, "id": 97797, "informal_statement": "For any two non-negative rational numbers $p$ and $q$, the canonical map from non-negative rational numbers to rational numbers preserves division, i.e., $\\left(\\frac{p}{q}\\right) = \\frac{p}{q}$.", "formal_statement": "import Mathlib\n\ntheorem coe_div_extracted (p q : ℚ≥0) : ↑(p / q) = ↑p / ↑q := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Domain and Codomain**: The informal statement involves non-negative rational numbers, denoted as $\\mathbb{Q}_{\\ge 0}$, and rational numbers, denoted as $\\mathbb{Q}$. In Lean, non-negative rational numbers are represented by `ℚ≥0`, and rational numbers by `ℚ`.\n\n2. **Understand the Operation**: The operation in question is division. The informal statement asserts that division in the domain of non-negative rationals is preserved when mapped to the domain of rationals.\n\n3. **Canonical Map**: The canonical map from non-negative rationals to rationals is the coercion operation, which is denoted by `↑` in Lean. This operation takes a non-negative rational number and views it as a rational number.\n\n4. **Formalize the Statement**: The goal is to show that for any non-negative rationals `p` and `q`, the result of dividing `p` by `q` in the non-negative rationals, when coerced to rationals, is the same as dividing `p` and `q` directly as rationals.\n\n5. **Lean Syntax**: \n   - The theorem is named `coe_div_extracted`.\n   - The parameters `p` and `q` are specified to be of type `ℚ≥0`.\n   - The statement `↑(p / q) = ↑p / ↑q` expresses that the coercion of the division of `p` by `q` in `ℚ≥0` is equal to the division of the coerced values `↑p` and `↑q` in `ℚ`.\n\n6. **Structure of the Theorem**: \n   - `import Mathlib`: This line imports the necessary mathematical library that includes definitions and theorems about rational numbers and their operations.\n   - `theorem coe_div_extracted (p q : ℚ≥0) : ↑(p / q) = ↑p / ↑q := sorry`: This line declares the theorem, specifying the types of `p` and `q`, and states the equality to be proven. The `:= sorry` part indicates that the proof is not yet provided.\n\nBy following these steps, the informal statement is accurately translated into a formal statement in Lean4, capturing the essence of the preservation"}
{"source_file": "herald_data/sample_500.jsonl", "line": 221, "id": 15474, "informal_statement": "For any $x$ in vector space $E$ and any $y$ in vector space $F$, show that $y$ is in the polar set of $\\{x\\}$ with respect to bilinear form $B$ if and only if the norm of $B(x, y)$ is less than or equal to $1$, i.e., $y \\in B.polar\\{x\\} \\Leftrightarrow \\|B(x, y)\\| \\leq 1$.", "formal_statement": "import Mathlib\nopen Topology\ntheorem mem_polar_singleton_extracted [NormedCommRing 𝕜] [AddCommMonoid E]\n [AddCommMonoid F] [Module 𝕜 E] [Module 𝕜 F] (B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜) {x : E} (y : F) :\n y ∈ B.polar {x} ↔ ‖(B x) y‖ ≤ 1 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a series of steps that map the mathematical concepts to their formal counterparts in Lean. Here's the breakdown:\n\n1. **Understanding the Context**:\n   - We are dealing with vector spaces \\( E \\) and \\( F \\) over a field \\( \\mathbb{𝕜} \\).\n   - There is a bilinear form \\( B \\) that takes an element from \\( E \\) and an element from \\( F \\) and returns a scalar in \\( \\mathbb{𝕜} \\).\n\n2. **Identifying the Structures**:\n   - The vector spaces \\( E \\) and \\( F \\) are modeled as `AddCommMonoid E` and `AddCommMonoid F` in Lean, which are basic structures for additive commutative monoids.\n   - They are also `Module 𝕜 E` and `Module 𝕜 F`, indicating that they are modules over the field \\( \\mathbb{𝕜} \\).\n\n3. **Bilinear Form Representation**:\n   - The bilinear form \\( B \\) is represented as `E →ₗ[𝕜] F →ₗ[𝕜] 𝕜`, which is a linear map from \\( E \\) to the space of linear maps from \\( F \\) to \\( \\mathbb{𝕜} \\). This captures the bilinear nature of \\( B \\).\n\n4. **Polar Set Definition**:\n   - The polar set of a set \\( \\{x\\} \\) with respect to \\( B \\) is denoted as `B.polar {x}`. In Lean, this is a predefined concept that relates to the duality and polar sets in functional analysis.\n\n5. **Norm and Inequality**:\n   - The norm of the scalar \\( B(x, y) \\) is represented as `‖(B x) y‖`. The norm is a standard operation in Lean for elements of normed spaces.\n   - The inequality \\( \\|B(x, y)\\| \\leq 1 \\) is directly translated to `‖(B x) y‖ ≤ 1`.\n\n6. **Formalizing the Theorem**:\n   - The theorem is named `mem_polar_singleton_extracted`, indicating it is about membership in the polar set of a"}
{"source_file": "herald_data/sample_500.jsonl", "line": 220, "id": 578010, "informal_statement": "Prove that: $\\frac{2AB}{A+B}\\leq\\frac{A+B}{2}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_578010 (A B : ℝ) : (2 * A * B) / (A + B) ≤ (A + B) / 2   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves two variables, \\( A \\) and \\( B \\), which are not explicitly defined in terms of their types. In the context of the inequality, these are real numbers. Therefore, in Lean, we declare \\( A \\) and \\( B \\) as variables of type `ℝ` (the type for real numbers in Lean).\n\n2. **Translate the Mathematical Expression**:\n   - The expression \\(\\frac{2AB}{A+B}\\) is translated to `(2 * A * B) / (A + B)` in Lean. Here, `*` denotes multiplication, and `/` denotes division.\n   - The expression \\(\\frac{A+B}{2}\\) is translated to `(A + B) / 2` in Lean.\n\n3. **Formulate the Inequality**:\n   - The informal statement is an inequality: \\(\\frac{2AB}{A+B} \\leq \\frac{A+B}{2}\\). In Lean, this is expressed using the `≤` operator, which is used for inequalities. Thus, the inequality is written as `(2 * A * B) / (A + B) ≤ (A + B) / 2`.\n\n4. **Structure the Theorem**:\n   - In Lean, a theorem is declared using the `theorem` keyword, followed by a name for the theorem. Here, it is named `extract_aug_578010`.\n   - The variables \\( A \\) and \\( B \\) are introduced in the theorem statement as `(A B : ℝ)`, indicating that they are real numbers.\n   - The body of the theorem is the inequality we formulated: `(2 * A * B) / (A + B) ≤ (A + B) / 2`.\n\n5. **Use of `by sorry`**:\n   - The `:= by sorry` part indicates that the proof of the theorem is not provided. In Lean, `sorry` is a placeholder that allows the theorem to be accepted by the system without a proof, useful during the development phase.\n\n6. **Importing Necessary Libraries**:\n   - The statement begins with `import Mathlib`, which is a common practice to import the mathematical library in Lean that contains definitions and theorems for real numbers and other"}
{"source_file": "herald_data/sample_500.jsonl", "line": 223, "id": 247865, "informal_statement": "For any fields $K$ and $L$, with $K$ being a subalgebra of $L$, and for any intermediate fields $E_1$ and $E_2$ between $K$ and $L$ such that elements of $E_1$ are algebraic over $K$, show that the subalgebra generated by the supremum of $E_1$ and $E_2$ is equal to the supremum of their respective subalgebras, i.e., $(E_1 \\sup E_2).{\\text{subalgebra}} = E_1.{\\text{subalgebra}} \\sup E_2.{\\text{subalgebra}}$.", "formal_statement": "import Mathlib\nopen FiniteDimensional Polynomial\nopen Lean in\nopen Lean PrettyPrinter.Delaborator SubExpr in\nlemma sup_toSubalgebra_of_isAlgebraic_left_tac_24170 [Field K] [Field L] [Algebra K L] (E1 : IntermediateField K L) (E2 : IntermediateField K L) [Algebra.IsAlgebraic K ↥E1] : (E1 ⊔ E2).toSubalgebra = E1.toSubalgebra ⊔ E2.toSubalgebra := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Structures**: \n   - The informal statement involves fields \\( K \\) and \\( L \\), with \\( K \\) being a subalgebra of \\( L \\). In Lean, this is represented using the `Field` and `Algebra` typeclasses. \n   - Intermediate fields \\( E_1 \\) and \\( E_2 \\) are subfields of \\( L \\) containing \\( K \\). In Lean, these are represented using the `IntermediateField` structure.\n\n2. **Expressing Algebraic Conditions**:\n   - The condition that elements of \\( E_1 \\) are algebraic over \\( K \\) is expressed using the `Algebra.IsAlgebraic` typeclass in Lean. This indicates that every element of \\( E_1 \\) satisfies a polynomial equation with coefficients in \\( K \\).\n\n3. **Supremum and Subalgebra**:\n   - The supremum of \\( E_1 \\) and \\( E_2 \\) is denoted by \\( E_1 \\sup E_2 \\). In Lean, this is represented by the `⊔` (supremum) operator on `IntermediateField`.\n   - The subalgebra generated by an intermediate field is obtained using the `toSubalgebra` method. This converts an `IntermediateField` to a `Subalgebra`.\n\n4. **Formalizing the Statement**:\n   - The goal is to show that the subalgebra generated by the supremum of \\( E_1 \\) and \\( E_2 \\) is equal to the supremum of their respective subalgebras. This is expressed in Lean as `(E1 ⊔ E2).toSubalgebra = E1.toSubalgebra ⊔ E2.toSubalgebra`.\n\n5. **Lean Syntax and Imports**:\n   - The code begins with necessary imports from the `Mathlib` library, which provides the definitions and theorems related to fields, algebras, and intermediate fields.\n   - The `open` statements make certain namespaces available, such as `FiniteDimensional` and `Polynomial`, which might be relevant for handling algebraic elements.\n   - The `lemma` keyword introduces a new lemma named `sup_toSubalgebra_of_isAlgebraic_left_tac_24170`,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 224, "id": 174393, "informal_statement": "For any commutative ring $F$, a ring $E$, and an algebra $E$ over $F$ with the strong rank condition on $F$, if $S$ is a subalgebra of $E$ over $F$ and the rank of $S$ considered as an $F$-module is $1$ and $S$ is a free $F$-module, show that the rank of $S$ as an $F$-module is at most $1$.", "formal_statement": "import Mathlib\nopen Cardinal Submodule Set FiniteDimensional\nlemma eq_bot_of_finrank_one_tac_11488 [CommRing F] [StrongRankCondition F] [Ring E] [Algebra F E] (S : Subalgebra F E) (h : Module.rank F ↥S = 1) [Module.Free F ↥S] : Module.rank F ↥S ≤ 1 := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully map each component of the informal statement to its formal counterpart in Lean. Here's a step-by-step explanation of how this is done:\n\n1. **Commutative Ring $F$**: In Lean, a commutative ring is represented by the type class `CommRing F`. This is a standard way to specify that `F` is a commutative ring.\n\n2. **Strong Rank Condition on $F$**: The strong rank condition is a property of rings that ensures certain rank-related properties hold. In Lean, this is represented by the type class `StrongRankCondition F`.\n\n3. **Ring $E$ and Algebra $E$ over $F$**: The ring $E$ is specified by the type class `Ring E`. The fact that $E$ is an algebra over $F$ is represented by `Algebra F E`. This indicates that $E` has a compatible structure as an algebra over the ring `F`.\n\n4. **Subalgebra $S$ of $E$ over $F$**: In Lean, a subalgebra of `E` over `F` is represented by `Subalgebra F E`. The variable `S` is declared to be of this type, indicating that it is a subalgebra.\n\n5. **Rank of $S$ as an $F$-module is $1$**: The rank of a module in Lean is given by `Module.rank F ↥S`, where `↥S` is the coercion of the subalgebra `S` to a module over `F`. The condition that this rank is `1` is expressed as `Module.rank F ↥S = 1`.\n\n6. **$S$ is a free $F$-module**: In Lean, a module being free is represented by the type class `Module.Free F ↥S`. This indicates that `S` is a free module over `F`.\n\n7. **Conclusion: Rank of $S$ as an $F$-module is at most $1$**: The conclusion that the rank is at most `1` is expressed as `Module.rank F ↥S ≤ 1`.\n\n8. **Lemma Declaration**: The entire statement is wrapped in a lemma declaration. The lemma is named `eq_bot_of_finrank_one_tac_11488`, which is a"}
{"source_file": "herald_data/sample_500.jsonl", "line": 227, "id": 515839, "informal_statement": "prove that : $\\sum_{cyc}\\frac{x}{\\sqrt{x+y}}<\\frac{3}{2}$ if $x,y,z,w$ are positive real numbers satisfy $x+y+z+w=1$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_515839 (x y z w : ℝ) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z) (hw : 0 < w) (h : x + y + z + w = 1) : (x / Real.sqrt (x + y) + y / Real.sqrt (y + z) + z / Real.sqrt (z + w) + w / Real.sqrt (w + x)) < 3 / 2   :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves four variables \\(x, y, z, w\\), which are positive real numbers. In Lean, these are represented as `ℝ` (the type for real numbers).\n   - The conditions \\(x, y, z, w > 0\\) are expressed using inequalities in Lean: `0 < x`, `0 < y`, `0 < z`, `0 < w`.\n\n2. **Express the Constraint**:\n   - The constraint \\(x + y + z + w = 1\\) is directly translated into Lean as `x + y + z + w = 1`.\n\n3. **Translate the Cyclic Sum**:\n   - The cyclic sum \\(\\sum_{cyc}\\frac{x}{\\sqrt{x+y}}\\) is expressed in Lean as `x / Real.sqrt (x + y) + y / Real.sqrt (y + z) + z / Real.sqrt (z + w) + w / Real.sqrt (w + x)`.\n   - Here, `Real.sqrt` is used to denote the square root function in Lean.\n\n4. **State the Inequality**:\n   - The inequality \\(\\sum_{cyc}\\frac{x}{\\sqrt{x+y}} < \\frac{3}{2}\\) is directly translated to Lean as `(x / Real.sqrt (x + y) + y / Real.sqrt (y + z) + z / Real.sqrt (z + w) + w / Real.sqrt (w + x)) < 3 / 2`.\n\n5. **Structure the Theorem**:\n   - The theorem is defined using the `theorem` keyword, followed by a name (`extract_aug_515839` in this case).\n   - The variables and their conditions are listed in the parentheses after the theorem name: `(x y z w : ℝ) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z) (hw : 0 < w) (h : x + y + z + w = 1)`.\n   - The statement of the theorem follows the colon `:`, which is the inequality we want to prove.\n\n6. **Use of `by sorry`**:\n   - The `by sorry` at the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 228, "id": 224134, "informal_statement": "For any non-empty standard Borel space $\\Omega$, any measurable space $\\beta$, a finite measure $\\rho$ on $\\beta \\times \\Omega$, a function $f : \\beta \\times \\Omega \\to E$ where $E$ is a normed additive commutative group and also a normed space over $\\mathbb{R}$, and given that $f$ is integrable with respect to the product measure of $\\rho$'s first projection and its conditional kernel, show that the double integral of $f(b, \\omega)$ over $\\beta$ and $\\Omega$ with respect to the conditional kernel of $\\rho$ and its first projection equals the integral of $f$ over $\\beta \\times \\Omega$ with respect to the product measure of $\\rho$'s first projection and its conditional kernel.", "formal_statement": "import Mathlib\nopen MeasureTheory ProbabilityTheory MeasurableSpace\nopen scoped ENNReal\nlemma integral_condKernel_tac_9916 (mβ : MeasurableSpace β) [MeasurableSpace Ω] [StandardBorelSpace Ω] [Nonempty Ω] (ρ : Measure (β × Ω)) [IsFiniteMeasure ρ] (f : β × Ω → E) [NormedAddCommGroup E] [NormedSpace ℝ E] (hf : Integrable f (ρ.fst ⊗ₘ ρ.condKernel)) : ∫ (b : β), ∫ (ω : Ω), f (b, ω) ∂ρ.condKernel b ∂ρ.fst = ∫ (x : β × Ω), f x ∂ρ.fst ⊗ₘ ρ.condKernel := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the mathematical concepts and their relationships. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Mathematical Structures:**\n   - The informal statement involves several mathematical structures: a non-empty standard Borel space $\\Omega$, a measurable space $\\beta$, a finite measure $\\rho$ on $\\beta \\times \\Omega$, and a function $f : \\beta \\times \\Omega \\to E$ where $E$ is a normed additive commutative group and a normed space over $\\mathbb{R}$.\n\n2. **Translate the Spaces and Measures:**\n   - In Lean, we represent measurable spaces using `MeasurableSpace`. The space $\\Omega$ is a standard Borel space, which is captured by the typeclass `StandardBorelSpace`. The non-emptiness of $\\Omega$ is represented by the typeclass `Nonempty Ω`.\n   - The measure $\\rho$ on the product space $\\beta \\times \\Omega$ is represented as `Measure (β × Ω)`. The fact that $\\rho$ is a finite measure is captured by the typeclass `IsFiniteMeasure ρ`.\n\n3. **Translate the Function and its Properties:**\n   - The function $f : \\beta \\times \\Omega \\to E$ is directly translated as `f : β × Ω → E`.\n   - The space $E$ being a normed additive commutative group and a normed space over $\\mathbb{R}$ is represented by the typeclasses `NormedAddCommGroup E` and `NormedSpace ℝ E`.\n\n4. **Express the Integrability Condition:**\n   - The integrability of $f$ with respect to the product measure of $\\rho$'s first projection and its conditional kernel is expressed using the `Integrable` predicate in Lean: `Integrable f (ρ.fst ⊗ₘ ρ.condKernel)`. Here, `ρ.fst` represents the first projection of the measure $\\rho`, and `ρ.condKernel` represents the conditional kernel.\n\n5. **Formalize the Double Integral Equality:**\n   - The goal is to show the equality of two integrals. The left-hand side is the double integral of $f(b, \\omega)$ over $\\beta$ and $\\Omega$ with respect to"}
{"source_file": "herald_data/sample_500.jsonl", "line": 225, "id": 436896, "informal_statement": "For a non-empty set \\(\\alpha\\) and a list \\(l \\in \\alpha^*\\), prove that \\(l\\) is invariant under a single rotation if and only if \\(l\\) is a uniform list of some \\(a \\in \\alpha\\), i.e., \\(l.rotate\\ 1 = l\\) if and only if \\(l = \\text{List.replicate}\\ l.length\\ a\\) for some \\(a \\in \\alpha\\).", "formal_statement": "import Mathlib\nopen Nat Function\ntheorem rotate_one_eq_self_iff_eq_replicate [Nonempty α] {l : List α} :\n    l.rotate 1 = l ↔ ∃ a : α, l = List.replicate l.length a := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and semantics.\n\n1. **Non-empty set \\(\\alpha\\):** \n   - In Lean, a non-empty type \\(\\alpha\\) is represented by the type class `Nonempty α`. This is a way to assert that there exists at least one element of type \\(\\alpha\\). The informal statement mentions a non-empty set \\(\\alpha\\), which corresponds to the assumption `[Nonempty α]` in the theorem.\n\n2. **List \\(l \\in \\alpha^*\\):**\n   - The notation \\(\\alpha^*\\) typically denotes the set of all lists with elements from \\(\\alpha\\). In Lean, a list of elements of type \\(\\alpha\\) is represented as `List α`. The variable `l` is declared as `{l : List α}` in the theorem, indicating that `l` is a list of elements from the type \\(\\alpha\\).\n\n3. **Invariant under a single rotation:**\n   - The informal statement says that the list \\(l\\) is invariant under a single rotation, which means that rotating the list by one position results in the same list. In Lean, this is expressed as `l.rotate 1 = l`. The function `rotate` is a method on lists that rotates the list by the specified number of positions.\n\n4. **Uniform list of some \\(a \\in \\alpha\\):**\n   - A uniform list of some element \\(a \\in \\alpha\\) means that every element in the list is the same and equal to \\(a\\). In Lean, this is represented by `List.replicate l.length a`, which creates a list of length `l.length` where every element is `a`.\n\n5. **Existential quantifier for some \\(a \\in \\alpha\\):**\n   - The informal statement uses the phrase \"for some \\(a \\in \\alpha\\)\", which corresponds to the existential quantifier in logic. In Lean, this is expressed as `∃ a : α, ...`, meaning \"there exists an element \\(a\\) of type \\(\\alpha\\) such that...\".\n\n6. **Equivalence (if and only if):**\n   - The informal statement uses \"if and only if\", which is a logical equivalence. In Lean, this is represented"}
{"source_file": "herald_data/sample_500.jsonl", "line": 230, "id": 61486, "informal_statement": "Show that the less than relation $(· < ·)$ is well-founded on the set of non-zero natural numbers $\\mathbb{N} \\setminus \\{0\\}$.", "formal_statement": "import Mathlib\nopen Ordinal Order\nopen Lean in\nopen ONote\ntheorem lt_wf_extracted : WellFounded fun x x_1 => x < x_1 := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Understanding the Informal Statement**: The statement asks us to show that the \"less than\" relation is well-founded on the set of non-zero natural numbers, denoted as \\(\\mathbb{N} \\setminus \\{0\\}\\). A relation is well-founded if every non-empty subset has a minimal element.\n\n2. **Identifying the Components**:\n   - **Set**: The set in question is \\(\\mathbb{N} \\setminus \\{0\\}\\), which is the set of natural numbers excluding zero.\n   - **Relation**: The relation is the standard \"less than\" relation, \\(<\\).\n\n3. **Formalizing the Set**: In Lean, the natural numbers are represented by `Nat`. The set \\(\\mathbb{N} \\setminus \\{0\\}\\) can be represented by considering natural numbers greater than zero.\n\n4. **Formalizing the Relation**: The relation \\(x < x_1\\) is directly represented in Lean as `x < x_1`.\n\n5. **Well-Foundedness in Lean**: Lean has a built-in concept of well-foundedness, represented by the type `WellFounded`. To show that a relation is well-founded, we need to prove that every non-empty subset has a minimal element under this relation.\n\n6. **Constructing the Theorem**:\n   - We define a theorem named `lt_wf_extracted`.\n   - The theorem states that the relation `fun x x_1 => x < x_1` is well-founded.\n   - The `WellFounded` type is used to express this property.\n\n7. **Using Lean's Libraries**: The code imports necessary modules from Lean's math library (`Mathlib`) to access definitions and theorems related to ordinals and order theory, which might be useful for proving well-foundedness.\n\n8. **Theorem Statement**: The theorem is stated as:\n   ```lean\n   theorem lt_wf_extracted : WellFounded fun x x_1 => x < x_1 := sorry\n   ```\n   - `WellFounded fun x x_1 => x < x_1` asserts that the \"less than\" relation is well-founded.\n   - `:= sorry` is a placeholder indicating that the proof is not provided here.\n\nIn summary, the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 226, "id": 520334, "informal_statement": "We have the identity $ 2cos x \\cdot cos y=cos(x-y)+cos(y+x)$ .", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_520334 : 2 * cos x * cos y = cos (x - y) + cos (x + y)   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Mathematical Components**: The informal statement involves trigonometric functions, specifically the cosine function, and an identity involving these functions. The identity is expressed in terms of two variables, \\( x \\) and \\( y \\).\n\n2. **Understand the Context**: The statement is a trigonometric identity, which is a well-known formula in trigonometry. It expresses a relationship between the product of cosines and the sum of cosines.\n\n3. **Translate Mathematical Functions**: In Lean4, trigonometric functions like cosine are part of the `Real` namespace. Therefore, `cos` is used to represent the cosine function.\n\n4. **Structure the Theorem**: The theorem is structured using the `theorem` keyword in Lean4. The name of the theorem, `extract_aug_520334`, is a placeholder and can be any valid identifier. It is followed by a colon and the statement of the theorem.\n\n5. **Express the Identity**: The identity \\( 2 \\cos x \\cdot \\cos y = \\cos(x - y) + \\cos(x + y) \\) is directly translated into Lean4 syntax. The multiplication is represented by `*`, and the addition by `+`. The expression `2 * cos x * cos y` represents the left-hand side, and `cos (x - y) + cos (x + y)` represents the right-hand side.\n\n6. **Specify the Proof**: The `:= by sorry` part indicates that the proof of the theorem is not provided. The `by sorry` is a placeholder indicating that the proof needs to be completed.\n\n7. **Import Necessary Libraries**: The `import Mathlib` statement is used to import the necessary mathematical libraries that include definitions and theorems related to real numbers and trigonometric functions. The `open` statements make certain namespaces available, such as `Real` for real number operations and trigonometric functions.\n\nBy following these steps, the informal statement is formalized into a Lean4 theorem that states the trigonometric identity using Lean's syntax and mathematical libraries."}
{"source_file": "herald_data/sample_500.jsonl", "line": 229, "id": 430605, "informal_statement": "For any natural numbers $n$ and $k$, and any prime number $p$, show that the multiplicity of $p$ in $n$ is at most the sum of the multiplicity of $p$ in $\\binom{n}{k}$ and the multiplicity of $p$ in $k$.", "formal_statement": "import Mathlib\nopen Finset Nat multiplicity\nopen Nat\n/-- A lower bound on the multiplicity of `p` in `choose n k`. -/\ntheorem multiplicity_le_multiplicity_choose_add {p : ℕ} (hp : p.Prime) :\n    ∀ n k : ℕ, multiplicity p n ≤ multiplicity p (choose n k) + multiplicity p k := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to break down the components of the statement and understand how they map to Lean's syntax and library functions.\n\n1. **Understanding the Informal Statement**:\n   - We are given three variables: natural numbers \\( n \\) and \\( k \\), and a prime number \\( p \\).\n   - The statement involves the concept of \"multiplicity,\" which refers to the power of a prime \\( p \\) in the prime factorization of a number.\n   - The goal is to show that the multiplicity of \\( p \\) in \\( n \\) is at most the sum of the multiplicity of \\( p \\) in the binomial coefficient \\(\\binom{n}{k}\\) and the multiplicity of \\( p \\) in \\( k \\).\n\n2. **Translating to Lean4**:\n   - **Imports and Setup**: \n     - We start by importing necessary modules from Lean's math library. `Mathlib` is a comprehensive library that includes number theory and combinatorics.\n     - We open namespaces `Finset`, `Nat`, and `multiplicity` to access functions and theorems related to natural numbers, finite sets, and multiplicity without needing to prefix them.\n\n   - **Defining the Theorem**:\n     - We define a theorem named `multiplicity_le_multiplicity_choose_add`.\n     - The theorem takes a prime number `p` as an argument, indicated by `{p : ℕ}`. The curly braces `{}` denote an implicit argument, meaning Lean can infer it from context.\n     - The hypothesis `hp : p.Prime` asserts that `p` is a prime number. This is crucial because the concept of multiplicity is defined in terms of prime factorization.\n\n   - **Quantifying Variables**:\n     - The statement `∀ n k : ℕ` introduces universal quantification over natural numbers `n` and `k`. This matches the \"for any natural numbers \\( n \\) and \\( k \\)\" part of the informal statement.\n\n   - **Expressing Multiplicity**:\n     - `multiplicity p n` represents the multiplicity of `p` in `n`.\n     - `choose n k` is Lean's function for the binomial coefficient \\(\\binom{n}{k}\\).\n     - The inequality `multiplicity p n ≤ multiplicity p (choose n k) + multiplicity"}
{"source_file": "herald_data/sample_500.jsonl", "line": 234, "id": 418186, "informal_statement": "For any ordinal $a$, $a < 1 \\iff a = 0$.", "formal_statement": "import Mathlib\nopen Function Cardinal Set Equiv Order\nopen scoped Cardinal InitialSeg\nopen Function\n@[simp]\ntheorem lt_one_iff_zero {a : Ordinal} : a < 1 ↔ a = 0 := sorry", "explanation": "To translate the informal statement \"For any ordinal $a$, $a < 1 \\iff a = 0$\" into Lean4, we need to follow these steps:\n\n1. **Identify the Mathematical Context**: The statement involves ordinals, which are a well-defined concept in set theory. In Lean, ordinals are typically handled within a specific library that deals with set theory and ordinals.\n\n2. **Set Up the Environment**: The formal statement begins with importing necessary modules from the Lean mathematical library (`Mathlib`). This includes modules for functions, cardinals, sets, equivalences, and orders, which are relevant for working with ordinals.\n\n3. **Open Necessary Namespaces**: The `open` and `open scoped` commands are used to bring certain namespaces and notations into the current context. This makes it easier to refer to functions and types related to ordinals without needing to prefix them with their module names.\n\n4. **Define the Theorem**: The theorem is defined using the `@[simp]` attribute, which suggests that this theorem is a simplification rule that can be used by Lean's simplifier. The theorem is named `lt_one_iff_zero`, which is descriptive of its content.\n\n5. **Specify the Type of `a`**: The statement `a : Ordinal` specifies that `a` is an ordinal. This is crucial because the properties and operations we use are specific to ordinals.\n\n6. **Formalize the Statement**: The core of the theorem is the equivalence `a < 1 ↔ a = 0`. In Lean, `<` is the standard less-than relation for ordinals, and `↔` denotes logical equivalence. The statement asserts that an ordinal `a` is less than 1 if and only if `a` is equal to 0.\n\n7. **Proof Placeholder**: The `:= sorry` part indicates that the proof of the theorem is not provided. In a complete formalization, this would be replaced with a proof that demonstrates the equivalence.\n\nBy following these steps, the informal mathematical statement is accurately translated into a formal Lean theorem, ready for further proof development."}
{"source_file": "herald_data/sample_500.jsonl", "line": 232, "id": 404833, "informal_statement": "Consider the space of all sequences of natural numbers, \\(\\mathbb{N} \\to \\mathbb{N}\\). Define a metric \\(d\\) on this space such that for any two sequences \\(x\\) and \\(y\\), the distance \\(d(x, y) = (1/2)^n\\), where \\(n\\) is the smallest index at which \\(x\\) and \\(y\\) differ. This metric space structure is not globally instantiated by default.", "formal_statement": "import Mathlib\nopen Topology TopologicalSpace Set Metric Filter Function\nopen Classical in\nopen List\nopen Classical in\n/-- Metric space structure on `ℕ → ℕ` where the distance is given by `dist x y = (1/2)^n`,\nwhere `n` is the smallest index where `x` and `y` differ.\nNot registered as a global instance by default. -/\ndef metricSpaceNatNat : MetricSpace (ℕ → ℕ) := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Understand the Domain and Codomain**: The informal statement describes a space of sequences of natural numbers, which can be represented in Lean as the type `ℕ → ℕ`. This is a function type where each function (or sequence) maps natural numbers to natural numbers.\n\n2. **Define the Metric**: The metric \\(d\\) is defined such that for any two sequences \\(x\\) and \\(y\\), the distance \\(d(x, y) = (1/2)^n\\), where \\(n\\) is the smallest index at which \\(x\\) and \\(y\\) differ. This requires us to:\n   - Identify the smallest index \\(n\\) where the sequences differ.\n   - Compute the distance as \\((1/2)^n\\).\n\n3. **Formalize the Metric Space**: In Lean, a metric space is defined by providing a distance function that satisfies the properties of a metric (non-negativity, identity of indiscernibles, symmetry, and triangle inequality). The informal statement specifies the distance function but does not explicitly verify these properties, which would be necessary for a complete formalization.\n\n4. **Lean Syntax and Libraries**: The code begins with importing necessary libraries from Mathlib, which provide definitions and theorems related to topology, metric spaces, and other mathematical structures. The `open` statements make certain namespaces available without qualification, simplifying the code.\n\n5. **Define the Metric Space**: The definition `def metricSpaceNatNat : MetricSpace (ℕ → ℕ) := sorry` is a placeholder indicating where the full definition of the metric space should be provided. The `MetricSpace` type class in Lean requires a distance function and proofs of the metric properties.\n\n6. **Non-global Instance**: The comment `Not registered as a global instance by default` indicates that this metric space structure is defined locally and not automatically available as a global instance. This means it won't be used by default in Lean's type class inference system unless explicitly specified.\n\n7. **Use of `sorry`**: The `sorry` keyword is a placeholder in Lean that allows the code to compile without providing a complete proof or definition. It indicates that the detailed implementation of the metric space is omitted.\n\nIn summary, the formal statement sets up the framework for defining a metric space on sequences of natural numbers"}
{"source_file": "herald_data/sample_500.jsonl", "line": 233, "id": 2260, "informal_statement": "For any family of functions \\(f : \\iota \\to (M \\to \\mathbb{R})\\) indexed by \\(\\iota\\), where \\(M\\) is a measurable space, and given that the functions \\(f_i\\) are measurable for all \\(i \\in \\iota\\), and also that the family of functions \\((f_i)_{i \\in \\iota}\\) are independent with respect to the measure \\(\\mu\\), show that for any four distinct indices \\(i, j, k, l \\in \\iota\\), the product functions \\(f_i \\cdot f_j\\) and \\(f_k \\cdot f_l\\) are independent with respect to the measure \\(\\mu\\). That is, prove that if \\(i \\neq k\\), \\(i \\neq l\\), \\(j \\neq k\\), and \\(j \\neq l\\), then the functions \\(f_i \\cdot f_j\\) and \\(f_k \\cdot f_l\\) are \\(\\mu\\)-independent.", "formal_statement": "import Mathlib\nopen MeasureTheory MeasurableSpace Set\nopen scoped MeasureTheory ENNReal\nopen Finset in\ntheorem indepFun_mul_mul_extracted {_mΩ : MeasurableSpace Ω} {μ : Measure Ω} {m : MeasurableSpace β}\n [Mul β] [MeasurableMul₂ β] {f : ι → Ω → β} :\n ProbabilityTheory.iIndepFun (fun x => m) f μ →\n (∀ (i : ι), Measurable (f i)) →\n ∀ (i j k l : ι), i ≠ k → i ≠ l → j ≠ k → j ≠ l → ProbabilityTheory.IndepFun (f i * f j) (f k * f l) μ := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully map each component of the informal statement to its formal counterpart in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context**:\n   - We are dealing with a family of functions \\( f : \\iota \\to (M \\to \\mathbb{R}) \\), where each function \\( f_i \\) is measurable and the family is independent with respect to a measure \\(\\mu\\).\n   - The goal is to show that for any four distinct indices \\( i, j, k, l \\), the product functions \\( f_i \\cdot f_j \\) and \\( f_k \\cdot f_l \\) are independent with respect to \\(\\mu\\).\n\n2. **Setting Up the Environment**:\n   - We import necessary modules from Lean's math library, specifically those related to measure theory and probability.\n   - We open relevant namespaces to simplify the notation, such as `MeasureTheory`, `MeasurableSpace`, and `Set`.\n\n3. **Defining the Theorem**:\n   - We declare a theorem named `indepFun_mul_mul_extracted`.\n   - We specify the types and assumptions needed for the theorem:\n     - `_mΩ : MeasurableSpace Ω` and `μ : Measure Ω` define the measurable space and measure on the space \\(\\Omega\\).\n     - `m : MeasurableSpace β` specifies the measurable space structure on the codomain \\(\\beta\\).\n     - `[Mul β]` and `[MeasurableMul₂ β]` indicate that \\(\\beta\\) has a multiplication operation and that multiplication is measurable.\n\n4. **Formalizing the Family of Functions**:\n   - `f : ι → Ω → β` represents the family of functions indexed by \\(\\iota\\), mapping from \\(\\Omega\\) to \\(\\beta\\).\n\n5. **Expressing Independence and Measurability**:\n   - `ProbabilityTheory.iIndepFun (fun x => m) f μ` asserts that the family of functions \\( f \\) is independent with respect to the measure \\(\\mu\\) and the measurable space \\( m \\).\n   - `∀ (i : ι), Measurable (f i)` ensures that each function \\( f_i \\) is measurable.\n\n6. **Stating the Independence of Product Functions**:"}
{"source_file": "herald_data/sample_500.jsonl", "line": 237, "id": 299109, "informal_statement": "For any positive number $n$, show that $2$ does not divide the natural number representation of $n.\\text{bit1}$, denoted as $\\lnot(2 \\mid \\text{nat.repr}(n.\\text{bit1}))$.", "formal_statement": "import Mathlib\n\nlemma minFac_to_nat_tac_2728 (n : PosNum) : ¬2 ∣ ↑n.bit1 := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand both the mathematical concepts involved and how they are represented in Lean.\n\n1. **Understanding the Informal Statement:**\n   - We are given a positive number \\( n \\).\n   - The operation \\( n.\\text{bit1} \\) refers to a binary operation that appends a '1' to the binary representation of \\( n \\). In binary, this operation effectively doubles the number and adds one, which results in an odd number.\n   - The statement asserts that 2 does not divide this resulting number, which is equivalent to saying the number is odd.\n\n2. **Lean4 Representation:**\n   - In Lean, `PosNum` is a type representing positive binary numbers. This aligns with the informal statement's \"positive number \\( n \\)\".\n   - The operation `n.bit1` in Lean corresponds to the binary operation described, which constructs a new `PosNum` by appending a '1' to the binary representation of \\( n \\).\n   - The expression `↑n.bit1` uses the coercion operator `↑` to convert the `PosNum` type to a natural number (`nat`). This is necessary because divisibility is typically defined for natural numbers in Lean.\n\n3. **Formalizing the Divisibility Statement:**\n   - The expression `¬2 ∣ ↑n.bit1` is the formal way to state that 2 does not divide the natural number representation of `n.bit1`.\n   - The symbol `∣` denotes divisibility in Lean, so `2 ∣ ↑n.bit1` would mean \"2 divides the natural number representation of `n.bit1`\".\n   - The negation `¬` in front of this expression indicates that 2 does not divide it, which is precisely the condition for the number being odd.\n\n4. **Putting It All Together:**\n   - The lemma is named `minFac_to_nat_tac_2728`, which is a placeholder name and not directly relevant to the translation.\n   - The lemma takes a single argument `n : PosNum`, representing the positive number \\( n \\).\n   - The statement of the lemma `¬2 ∣ ↑n.bit1` directly corresponds to the informal statement that 2 does not divide the natural number representation of `n.\\text{bit1}`.\n\nIn summary, the Lean4 code formalizes the informal statement by using"}
{"source_file": "herald_data/sample_500.jsonl", "line": 235, "id": 278089, "informal_statement": "For any ring $R$, add commutative groups $E$ and $F$, with $E$ a module over $R$ and $F$ a module over $R$, and given a submodule $g$ of $E \\times F$, if for all $x \\in g$, the condition $x.1 = 0$ implies $x.2 = 0$, then the range of the linear map associated with $g$ is equal to the image of $g$ under the projection map from $E \\times F$ to $F$.", "formal_statement": "import Mathlib\nopen Submodule\nopen scoped Classical in\nlemma toLinearPMap_range_tac_37206 [Ring R] [AddCommGroup E] [Module R E] [AddCommGroup F] [Module R F] (g : Submodule R (E × F)) (hg : ∀ x ∈ g, x.1 = 0 → x.2 = 0) : LinearMap.range g.toLinearPMap.toFun = map (LinearMap.snd R E F) g := sorry", "explanation": "To translate the given informal mathematical statement into the provided Lean4 code, we need to follow a series of steps that align the informal concepts with their formal counterparts in Lean. Here's the breakdown:\n\n1. **Understanding the Context**:\n   - We are dealing with a ring \\( R \\), and two additive commutative groups \\( E \\) and \\( F \\), both of which are modules over \\( R \\). This is expressed in Lean using type classes: `[Ring R]`, `[AddCommGroup E]`, `[Module R E]`, `[AddCommGroup F]`, and `[Module R F]`.\n\n2. **Defining the Submodule**:\n   - The informal statement mentions a submodule \\( g \\) of \\( E \\times F \\). In Lean, this is represented as `g : Submodule R (E × F)`. The `Submodule` type in Lean captures the idea of a submodule over a ring.\n\n3. **Stating the Condition**:\n   - The condition given is that for all \\( x \\in g \\), if \\( x.1 = 0 \\) then \\( x.2 = 0 \\). In Lean, this is expressed as a hypothesis `hg : ∀ x ∈ g, x.1 = 0 → x.2 = 0`. Here, `x.1` and `x.2` refer to the first and second components of the pair \\( x \\) in \\( E \\times F \\).\n\n4. **Linear Map and Projection**:\n   - The informal statement refers to the \"linear map associated with \\( g \\)\". In Lean, `g.toLinearPMap.toFun` represents this linear map. The `toLinearPMap` method converts the submodule into a linear partial map, and `toFun` extracts the function part of this map.\n   - The projection map from \\( E \\times F \\) to \\( F \\) is represented by `LinearMap.snd R E F`, which is the standard second projection linear map.\n\n5. **Expressing the Conclusion**:\n   - The conclusion is that the range of the linear map associated with \\( g \\) is equal to the image of \\( g \\) under the projection map. In Lean, this is expressed as `LinearMap.range g.toLinearPMap.toFun = map (LinearMap.snd R E F) g`.\n   - `LinearMap.range"}
{"source_file": "herald_data/sample_500.jsonl", "line": 231, "id": 172638, "informal_statement": "For any semiring \\(\\alpha\\) equipped with an invertible element \\(2\\), show that \\(0 = 0\\).", "formal_statement": "import Mathlib\nopen Function\nlemma nonAssocSemiring_tac_7449 [Semiring α] [Invertible 2] : 0 = 0 := sorry", "explanation": "To translate the informal statement \"For any semiring \\(\\alpha\\) equipped with an invertible element \\(2\\), show that \\(0 = 0\\)\" into the given Lean4 code, we follow these steps:\n\n1. **Identify the Mathematical Structures**: The statement involves a semiring \\(\\alpha\\) and an invertible element \\(2\\). In Lean, a semiring is a type equipped with addition, multiplication, and certain axioms. The concept of an invertible element is captured by the `Invertible` typeclass.\n\n2. **Import Necessary Libraries**: The code begins with `import Mathlib`, which is a common practice to bring in the necessary mathematical libraries and definitions that Lean provides. This ensures that the definitions for semirings and invertible elements are available.\n\n3. **Open Necessary Namespaces**: The line `open Function` is included to make certain functions and definitions from the `Function` namespace directly accessible, though it is not directly used in this lemma.\n\n4. **Define the Lemma**: The lemma is named `nonAssocSemiring_tac_7449`. The name is arbitrary and likely generated automatically, possibly by a tactic or tool, as it doesn't convey specific meaning about the content.\n\n5. **Specify the Typeclass Constraints**: The lemma is stated with the constraints `[Semiring α] [Invertible 2]`. This means that the lemma is universally quantified over all types \\(\\alpha\\) that are instances of the `Semiring` typeclass and have an instance of `Invertible 2`. This matches the informal statement's requirement of a semiring with an invertible element \\(2\\).\n\n6. **State the Proposition**: The proposition to be proved is `0 = 0`. This is a trivial equality, as zero is always equal to itself in any mathematical structure, including semirings.\n\n7. **Use `sorry` as a Placeholder**: The `:= sorry` at the end of the lemma indicates that the proof is not provided. In Lean, `sorry` is used as a placeholder to indicate that the proof is incomplete or omitted. In this case, the proof is trivial, but `sorry` is used to bypass the need for an explicit proof.\n\nIn summary, the Lean code formalizes the informal statement by specifying the necessary typeclass constraints for a semiring and an invertible element, and then stating the trivial equality `0 ="}
{"source_file": "herald_data/sample_500.jsonl", "line": 236, "id": 488169, "informal_statement": "For a given $n\\in\\mathbb N,n>1$, is the cardinality of the set of natural exponents of some primes $x=p^k$ such that $x|n^x-1$ finite?", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_488169 (n : ℕ) (hn : 1 < n) : Set.Finite {k : ℕ | ∃ p : ℕ, p.Prime ∧ p^k ∣ n^(p^k) - 1}  :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and semantics.\n\n1. **Understanding the Informal Statement:**\n   - We are given a natural number \\( n \\) such that \\( n > 1 \\).\n   - We are interested in the set of natural numbers \\( k \\) for which there exists a prime number \\( p \\) such that \\( p^k \\) divides \\( n^{p^k} - 1 \\).\n   - We want to determine if the cardinality of this set is finite.\n\n2. **Translating to Lean:**\n   - **Variables and Assumptions:**\n     - The variable \\( n \\) is a natural number, represented as `n : ℕ` in Lean.\n     - The condition \\( n > 1 \\) is expressed as `hn : 1 < n`.\n\n   - **Set Definition:**\n     - We define the set of interest as `{k : ℕ | ∃ p : ℕ, p.Prime ∧ p^k ∣ n^(p^k) - 1}`.\n     - This set comprehension involves:\n       - `k : ℕ`: \\( k \\) is a natural number.\n       - `∃ p : ℕ`: There exists a natural number \\( p \\).\n       - `p.Prime`: \\( p \\) is a prime number, using Lean's `Prime` predicate.\n       - `p^k ∣ n^(p^k) - 1`: The divisibility condition, where `∣` denotes divisibility in Lean.\n\n   - **Finiteness:**\n     - We want to prove that this set is finite, which is expressed as `Set.Finite`.\n\n3. **Theorem Statement:**\n   - The theorem is named `extract_aug_488169`.\n   - It takes two inputs: `n : ℕ` and `hn : 1 < n`.\n   - The conclusion is that the set is finite: `Set.Finite {k : ℕ | ∃ p : ℕ, p.Prime ∧ p^k ∣ n^(p^k) - 1}`.\n\n4. **Lean Imports and Setup:**\n   - `import Mathlib`: Imports the Mathlib library, which contains necessary mathematical definitions and theorems."}
{"source_file": "herald_data/sample_500.jsonl", "line": 238, "id": 454575, "informal_statement": "And we also have: $\\sin{\\frac{8\\pi}{17}}=\\cos{\\left(\\frac{\\pi}{2}-\\frac{8\\pi}{17} \\right)}=\\cos{\\frac{\\pi}{34}}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_454575 : Real.sin (8 * Real.pi / 17) = Real.cos (Real.pi / 34)  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Understand the Mathematical Identity**: The informal statement involves a trigonometric identity. Specifically, it states that the sine of an angle is equal to the cosine of its complementary angle. The identity used here is \\(\\sin(\\theta) = \\cos(\\frac{\\pi}{2} - \\theta)\\).\n\n2. **Identify the Angles**: The given angle in the sine function is \\(\\frac{8\\pi}{17}\\). According to the identity, the complementary angle for the cosine function is \\(\\frac{\\pi}{2} - \\frac{8\\pi}{17}\\).\n\n3. **Simplify the Complementary Angle**: Simplify the expression \\(\\frac{\\pi}{2} - \\frac{8\\pi}{17}\\):\n   - Convert \\(\\frac{\\pi}{2}\\) to a common denominator with \\(\\frac{8\\pi}{17}\\). The common denominator is 34.\n   - \\(\\frac{\\pi}{2} = \\frac{17\\pi}{34}\\).\n   - Subtract: \\(\\frac{17\\pi}{34} - \\frac{8\\pi}{34} = \\frac{9\\pi}{34}\\).\n\n4. **Use the Simplified Angle**: The cosine of the complementary angle \\(\\frac{9\\pi}{34}\\) is equivalent to \\(\\cos(\\frac{\\pi}{34})\\) due to periodicity and symmetry properties of the cosine function. Specifically, \\(\\cos(\\theta) = \\cos(\\pi - \\theta)\\).\n\n5. **Formalize in Lean**: The Lean theorem states that the sine of the angle \\(\\frac{8\\pi}{17}\\) is equal to the cosine of the angle \\(\\frac{\\pi}{34}\\). This is expressed in Lean as:\n   - `Real.sin (8 * Real.pi / 17) = Real.cos (Real.pi / 34)`\n\n6. **Lean Syntax and Libraries**: \n   - `import Mathlib` imports the necessary mathematical libraries.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` make various mathematical functions and constants available without needing to prefix them with their module names.\n   - The theorem is named `extract_aug_454575`, which is a placeholder name and can"}
{"source_file": "herald_data/sample_500.jsonl", "line": 240, "id": 162320, "informal_statement": "For any type \\(\\alpha\\), a family of types \\(\\delta : \\alpha \\to \\mathsf{Sort}\\ u_6\\), a set \\(s \\subseteq \\alpha\\), and functions \\(f, g : \\alpha \\to \\delta\\), assuming for any \\(j \\in \\alpha\\) the membership \\(j \\in s\\) is decidable, the type \\(\\alpha\\) has decidable equality, and for any \\(i \\in \\alpha\\) the membership \\(i \\in s \\cup \\{j\\}\\) is decidable, show that for any \\(i, j \\in \\alpha\\), the value of the function defined piecewise as \\(f(i)\\) if \\(i = j\\) or \\(i \\in s\\), and \\(g(i)\\) otherwise, is equal to the result of updating the function defined as \\(f(i)\\) if \\(i \\in s\\), and \\(g(i)\\) otherwise, at index \\(j\\) with value \\(f(j)\\), evaluated at \\(i\\). In other words, prove \\(\\left( \\text{if } i = j \\lor i \\in s \\text{ then } f(i) \\text{ else } g(i) \\right) = \\left( \\text{update } (\\lambda i. \\text{if } i \\in s \\text{ then } f(i) \\text{ else } g(i)) \\ j \\ (f(j)) \\right)(i)\\).", "formal_statement": "import Mathlib\nopen Equiv Equiv.Perm Function\nopen Function\nlemma piecewise_insert_tac_56448 (δ : α → Sort u_6) (s : Set α) (f : (i : α) → δ i) (g : (i : α) → δ i) [(j : α) → Decidable (j ∈ s)] [DecidableEq α] (j : α) [(i : α) → Decidable (i ∈ insert j s)] (i : α) : (if i = j ∨ i ∈ s then f i else g i) = update (fun i => if i ∈ s then f i else g i) j (f j) i := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and constructs.\n\n1. **Types and Sorts**:\n   - The informal statement begins with \"For any type \\(\\alpha\\), a family of types \\(\\delta : \\alpha \\to \\mathsf{Sort}\\ u_6\\)\". In Lean, this is expressed by declaring a type variable `α` and a dependent type `δ : α → Sort u_6`. This indicates that for each element of type `α`, there is a corresponding type in the universe `u_6`.\n\n2. **Subset and Functions**:\n   - The subset \\(s \\subseteq \\alpha\\) is represented in Lean as `s : Set α`. A `Set α` in Lean is a predicate on `α`, i.e., a function `α → Prop`.\n   - The functions \\(f, g : \\alpha \\to \\delta\\) are represented as `f : (i : α) → δ i` and `g : (i : α) → δ i`. This indicates that for each element `i` of type `α`, `f` and `g` return a value of type `δ i`.\n\n3. **Decidability Assumptions**:\n   - The assumption \"for any \\(j \\in \\alpha\\) the membership \\(j \\in s\\) is decidable\" is expressed as `[(j : α) → Decidable (j ∈ s)]`. This is a type class instance in Lean that provides a decision procedure for membership in `s`.\n   - The type \\(\\alpha\\) having decidable equality is expressed as `[DecidableEq α]`, another type class instance indicating that equality between elements of `α` can be decided.\n   - The assumption \"for any \\(i \\in \\alpha\\) the membership \\(i \\in s \\cup \\{j\\}\\) is decidable\" is expressed as `[(i : α) → Decidable (i ∈ insert j s)]`. The `insert j s` represents the set \\(s \\cup \\{j\\}\\).\n\n4. **Piecewise Function and Update**:\n   - The piecewise function defined as \\(f(i)\\) if \\(i = j\\) or \\(i \\in s\\), and \\(g(i)\\"}
{"source_file": "herald_data/sample_500.jsonl", "line": 239, "id": 521416, "informal_statement": "Prove that for complex numbers $a, b, c$ with $|a+b+c|=1$ and $|b|=|c|=1$, we have $|1+bc|\\geq |b+c|$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_521416 (a b c : ℂ) (h₁ : ‖a + b + c‖ = 1) (h₂ : ‖b‖ = 1) (h₃ : ‖c‖ = 1) : ‖1 + b * c‖ ≥ ‖b + c‖   :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves complex numbers \\(a\\), \\(b\\), and \\(c\\). In Lean, complex numbers are represented by the type `ℂ`.\n\n2. **Express the Given Conditions**:\n   - The condition \\(|a+b+c|=1\\) is expressed in Lean using the norm notation `‖a + b + c‖ = 1`. The norm `‖.‖` is used to denote the absolute value or magnitude of a complex number.\n   - Similarly, \\(|b|=1\\) and \\(|c|=1\\) are expressed as `‖b‖ = 1` and `‖c‖ = 1`, respectively.\n\n3. **State the Conclusion**:\n   - The conclusion \\(|1+bc|\\geq |b+c|\\) is expressed as `‖1 + b * c‖ ≥ ‖b + c‖`. Here, `b * c` represents the product of the complex numbers \\(b\\) and \\(c\\), and the norm `‖.‖` is used again to denote the magnitude.\n\n4. **Structure the Theorem**:\n   - The theorem is named `extract_aug_521416`. In Lean, theorem names are identifiers and can be chosen arbitrarily, but they often reflect the content or source of the theorem.\n   - The theorem takes the complex numbers \\(a\\), \\(b\\), and \\(c\\) as arguments, along with the hypotheses `h₁`, `h₂`, and `h₃` corresponding to the given conditions.\n\n5. **Use of Lean's Libraries**:\n   - The `import Mathlib` statement is used to include the necessary mathematical libraries that provide definitions and theorems related to complex numbers and norms.\n   - The `open BigOperators`, `open Real`, `open Nat`, and `open Topology` statements are used to bring various mathematical notations and operations into scope, which might be useful for the proof.\n\n6. **Proof Placeholder**:\n   - The `:= by sorry` part indicates that the proof is not yet provided. In Lean, `sorry` is a placeholder that allows the theorem to be stated without an immediate proof, which is useful"}
{"source_file": "herald_data/sample_500.jsonl", "line": 244, "id": 61327, "informal_statement": "For any topological space $X$ that is Lindelöf, show that the universal set $\\mathcal{U}$ (denoted as $univ$ in some contexts) of $X$ is a Lindelöf space, i.e., every open cover of $\\mathcal{U}$ has a countable subcover.", "formal_statement": "import Mathlib\nopen Set Filter Topology TopologicalSpace\ntheorem isLindelof_univ_extracted [TopologicalSpace X] [h : LindelofSpace X] : IsLindelof univ := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Context**: \n   - We are dealing with a topological space \\( X \\) that is Lindelöf. In topology, a space is Lindelöf if every open cover has a countable subcover.\n   - The goal is to show that the universal set (the entire space \\( X \\)) is also Lindelöf.\n\n2. **Lean4 Imports and Setup**:\n   - `import Mathlib`: This imports the Mathlib library, which contains a wide range of mathematical definitions and theorems, including those related to topology.\n   - `open Set Filter Topology TopologicalSpace`: This line opens several namespaces, making it easier to refer to definitions and theorems related to sets, filters, topology, and topological spaces without needing to prefix them with their namespace.\n\n3. **Defining the Theorem**:\n   - `theorem isLindelof_univ_extracted`: This begins the definition of a theorem named `isLindelof_univ_extracted`. The name suggests that it is about proving the Lindelöf property for the universal set.\n\n4. **Specifying the Context and Assumptions**:\n   - `[TopologicalSpace X]`: This is a type class assumption indicating that \\( X \\) is a topological space. In Lean, type classes are used to provide additional structure or properties to types.\n   - `[h : LindelofSpace X]`: This is another type class assumption stating that \\( X \\) is a Lindelöf space. The `h` is a label for this assumption, which can be used in the proof.\n\n5. **Stating the Conclusion**:\n   - `: IsLindelof univ`: This is the conclusion of the theorem. `IsLindelof` is a predicate that asserts a space is Lindelöf. `univ` refers to the universal set, which in the context of a topological space \\( X \\), is the entire space \\( X \\) itself.\n\n6. **Proof Placeholder**:\n   - `:= sorry`: The `sorry` keyword is a placeholder in Lean, indicating that the proof is not yet provided. It allows the theorem to be syntactically correct and checked by Lean, even though the proof is incomplete.\n\nIn summary, the Lean4 code formalizes"}
{"source_file": "herald_data/sample_500.jsonl", "line": 241, "id": 199126, "informal_statement": "For an ordinal number $o$, show that $o < \\omega$ if and only if there exists a natural number $n$ such that $o$ is equal to the canonical embedding of $n$ into the ordinals, i.e., $o = \\uparrow n$.", "formal_statement": "import Mathlib\nopen Function Cardinal Set Equiv Order\nopen scoped Ordinal\nopen Classical in\nopen Ordinal\nlemma lt_omega_tac_89111 (o : Ordinal.{u_1}) : o < ω ↔ ∃ n, o = ↑n := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Informal Statement**: \n   - We are dealing with ordinal numbers, specifically comparing an ordinal `o` with the smallest infinite ordinal, denoted by `ω` (omega).\n   - The statement asserts that `o` is less than `ω` if and only if there exists a natural number `n` such that `o` is the image of `n` under the canonical embedding of natural numbers into ordinals.\n\n2. **Identifying Key Components**:\n   - **Ordinal `o`**: This is a variable representing an ordinal number.\n   - **`ω` (omega)**: Represents the first infinite ordinal, which corresponds to the set of all natural numbers in the context of ordinals.\n   - **Canonical Embedding**: The process of embedding natural numbers into ordinals, often denoted by `↑n` or `ofNat n` in Lean, where `n` is a natural number.\n\n3. **Translating to Lean4**:\n   - **Imports and Setup**: \n     - `import Mathlib` is used to bring in necessary libraries for working with ordinals and other mathematical structures.\n     - `open` statements are used to bring various modules and namespaces into scope, such as `Function`, `Cardinal`, `Set`, `Equiv`, `Order`, and `Ordinal`.\n     - `open scoped Ordinal` ensures that ordinal-specific notations and operations are available.\n     - `open Classical` allows the use of classical logic, which is often necessary for non-constructive proofs involving ordinals.\n\n4. **Formalizing the Statement**:\n   - **Lemma Declaration**: \n     - `lemma lt_omega_tac_89111 (o : Ordinal.{u_1})` declares a lemma named `lt_omega_tac_89111` with a parameter `o` of type `Ordinal.{u_1}`. The `{u_1}` indicates a universe level, which is a technical detail in Lean to handle different sizes of types.\n   - **Statement of the Lemma**:\n     - `o < ω ↔ ∃ n, o = ↑n` is the core of the lemma. It states that `o` is less than `ω` if and only if there exists a natural number `n` such that"}
{"source_file": "herald_data/sample_500.jsonl", "line": 243, "id": 228279, "informal_statement": "For a positive natural number $m$ and a multiset $v$ of prime numbers, show that the multiset of prime factors of $m$ is less than or equal to $v$ if and only if $m$ divides the product of the elements in $v$. That is, demonstrate that $m$'s factor multiset being dominated by $v$ is equivalent to $m$ dividing the product of primes in $v$.", "formal_statement": "import Mathlib\n\nlemma factorMultiset_le_iff'_tac_11799 (m : ℕ+) (v : PrimeMultiset) (h : m.factorMultiset ≤ v ↔ m ∣ v.prod) : m.factorMultiset ≤ v ↔ m ∣ v.prod := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down the components of the statement and understand how they map to Lean constructs:\n\n1. **Positive Natural Number `m`:**\n   - In Lean, a positive natural number can be represented using `ℕ+`, which is a type for positive natural numbers. This ensures that `m` is always greater than zero.\n\n2. **Multiset `v` of Prime Numbers:**\n   - A multiset is a collection of elements that allows for multiple occurrences of the same element. In Lean, `PrimeMultiset` is used to represent a multiset of prime numbers. This type is likely defined elsewhere in the library to handle multisets specifically containing primes.\n\n3. **Multiset of Prime Factors of `m`:**\n   - The function `factorMultiset` is used to obtain the multiset of prime factors of a number `m`. This function returns a multiset where each prime factor of `m` is included with its multiplicity.\n\n4. **Multiset Dominance (`≤`):**\n   - The relation `≤` on multisets is used to express that one multiset is dominated by another. In this context, `m.factorMultiset ≤ v` means that every prime factor of `m` (with its multiplicity) is also present in `v` with at least the same multiplicity.\n\n5. **Divisibility (`∣`):**\n   - The notation `m ∣ v.prod` indicates that `m` divides the product of the elements in the multiset `v`. The function `v.prod` computes the product of all elements in the multiset `v`.\n\n6. **Equivalence (`↔`):**\n   - The statement `m.factorMultiset ≤ v ↔ m ∣ v.prod` is an equivalence. It asserts that `m`'s factor multiset being dominated by `v` is equivalent to `m` dividing the product of the primes in `v`.\n\n7. **Lemma Declaration:**\n   - The lemma `factorMultiset_le_iff'_tac_11799` is declared with parameters `m`, `v`, and a hypothesis `h` which is the equivalence we want to prove. The lemma's type is the equivalence itself, which is the statement we aim to demonstrate.\n\n8. **Proof Placeholder (`sorry`):**\n   - The `sorry`"}
{"source_file": "herald_data/sample_500.jsonl", "line": 242, "id": 311124, "informal_statement": "For any elements \\(x, y\\) in a module \\(M\\) over a strict ordered commutative semiring \\(R\\), where \\(M\\) is also an additive commutative monoid, if \\(x\\) and \\(y\\) are on the same ray (\\(hxy\\)), \\(x\\) is not the zero element (\\(hx\\)), and \\(y\\) and the zero element of \\(M\\) are on the same ray (\\(hyz\\)), given that if \\(y\\) is the zero element then either \\(x\\) is also the zero element or zero equals zero (\\(hy\\)), show that \\(x\\) and the zero element of \\(M\\) are on the same ray.", "formal_statement": "import Mathlib\n\nlemma trans_tac_2916 [StrictOrderedCommSemiring R] [AddCommMonoid M] [Module R M] (x : M) (y : M) (hxy : SameRay R x y) (hx : x ≠ 0) (hyz : SameRay R y 0) (hy : y = 0 → x = 0 ∨ 0 = 0) : SameRay R x 0 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to understand the components of the problem and how they map to Lean's formal language. Here's a step-by-step explanation:\n\n1. **Understanding the Context**:\n   - We are working within a module \\( M \\) over a strict ordered commutative semiring \\( R \\).\n   - The module \\( M \\) is also an additive commutative monoid. This means \\( M \\) has an addition operation that is associative, commutative, and has an identity element (zero).\n\n2. **Identifying the Elements and Properties**:\n   - We have elements \\( x \\) and \\( y \\) in the module \\( M \\).\n   - The statement involves the concept of \"same ray,\" which is a relation between elements in the module. In Lean, this is represented by `SameRay R x y`.\n\n3. **Translating the Hypotheses**:\n   - \\( x \\) and \\( y \\) are on the same ray: This is directly translated to `hxy : SameRay R x y`.\n   - \\( x \\) is not the zero element: This is translated to `hx : x ≠ 0`.\n   - \\( y \\) and the zero element are on the same ray: This is translated to `hyz : SameRay R y 0`.\n   - If \\( y \\) is the zero element, then either \\( x \\) is also the zero element or zero equals zero: This is translated to `hy : y = 0 → x = 0 ∨ 0 = 0`. The clause `0 = 0` is trivially true, but it is included to match the informal statement's structure.\n\n4. **Formulating the Conclusion**:\n   - We need to show that \\( x \\) and the zero element are on the same ray. This is the conclusion of the lemma, represented as `SameRay R x 0`.\n\n5. **Structuring the Lean Lemma**:\n   - The lemma is defined with the necessary type class constraints: `[StrictOrderedCommSemiring R]`, `[AddCommMonoid M]`, and `[Module R M]`. These constraints ensure that the operations and properties we use are valid in the context of \\( R \\) and \\( M \\).\n   - The lemma is named `trans_tac_2916`, which is a placeholder"}
{"source_file": "herald_data/sample_500.jsonl", "line": 245, "id": 579696, "informal_statement": "Nonnegative numbers $x,y,z$ satisfy $xy+xz+yx+xyz=4$. Prove that $ x+y+z \\geq xy+yz+zx$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_579696 (x y z : ℝ) (h : x * y + x * z + y * x + x * y * z = 4) :  x + y + z ≥ x * y + y * z + z * x   :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves three variables \\(x\\), \\(y\\), and \\(z\\), which are described as nonnegative numbers. In Lean, we typically represent real numbers using the type `ℝ` (real numbers). The nonnegativity condition is implicit in the problem setup, but it is not directly encoded in the theorem statement.\n\n2. **Understand the Given Condition**:\n   - The condition given in the problem is \\(xy + xz + yx + xyz = 4\\). In Lean, multiplication is represented by `*`, and addition by `+`. The condition is expressed as `x * y + x * z + y * x + x * y * z = 4`.\n\n3. **State the Conclusion**:\n   - The conclusion we need to prove is \\(x + y + z \\geq xy + yz + zx\\). In Lean, the sum is represented by `+`, and the inequality \\(\\geq\\) is represented by `≥`.\n\n4. **Structure the Theorem**:\n   - The theorem is structured with a name, `extract_aug_579696`, which is a placeholder and can be replaced with a more descriptive name.\n   - The theorem takes three arguments, `x`, `y`, and `z`, all of type `ℝ`.\n   - The hypothesis `h` is the condition \\(xy + xz + yx + xyz = 4\\).\n   - The conclusion is the inequality \\(x + y + z \\geq xy + yz + zx\\).\n\n5. **Use of Lean Syntax**:\n   - The `theorem` keyword is used to define a theorem.\n   - The colon `:` separates the theorem's name and parameters from its type, which is the statement to be proved.\n   - The `by sorry` part indicates that the proof is not provided. In a complete formalization, this would be replaced with a valid proof.\n\n6. **Importing Necessary Libraries**:\n   - The `import Mathlib` statement is used to import the necessary mathematical libraries that provide definitions and theorems for real numbers and other mathematical constructs.\n   - The `open` statements make certain namespaces available, such as `BigOperators`, `Real`, `Nat`, and `Topology`,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 246, "id": 63921, "informal_statement": "For any topological space $\\alpha$ and any two open sets $U, V$ in $\\alpha$ such that $U$ is a subset of $V$, there exists an open embedding from $U$ to $V$ given by the inclusion map.", "formal_statement": "import Mathlib\nopen Filter Function Order Set\nopen Topology\ntheorem openEmbedding_of_le_extracted [TopologicalSpace α] {U V : TopologicalSpace.Opens α} (i : U ≤ V) : OpenEmbedding (inclusion ⋯) := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Context**: The informal statement involves a topological space and open sets within that space. In Lean, this is represented using the `TopologicalSpace` type class and the `Opens` structure.\n\n2. **Topological Space Declaration**: The statement begins with \"For any topological space $\\alpha$,\" which in Lean is represented by `[TopologicalSpace α]`. This declares that `α` is a type equipped with a topology.\n\n3. **Open Sets in Lean**: The informal statement mentions open sets $U$ and $V$. In Lean, open sets within a topological space `α` are represented by `TopologicalSpace.Opens α`. These are bundled types that carry the property of being open.\n\n4. **Subset Condition**: The condition \"$U$ is a subset of $V$\" is expressed in Lean as `U ≤ V`. This uses the order relation on the `Opens` type, where `≤` denotes the subset relation between open sets.\n\n5. **Existence of Open Embedding**: The statement \"there exists an open embedding from $U$ to $V$\" is formalized by the type `OpenEmbedding`. This is a structure in Lean that encapsulates the concept of an open embedding between topological spaces.\n\n6. **Inclusion Map**: The inclusion map from $U$ to $V$ is represented by `inclusion`. This is a standard function in Lean that takes an element of a subset and views it as an element of the larger set.\n\n7. **Theorem Declaration**: The theorem is declared with `theorem openEmbedding_of_le_extracted`. This is a Lean theorem that states the existence of an open embedding given the subset condition.\n\n8. **Formal Parameters**: The parameters of the theorem include `[TopologicalSpace α]` to specify the topological space, `{U V : TopologicalSpace.Opens α}` to specify the open sets, and `(i : U ≤ V)` to specify the subset condition.\n\n9. **Conclusion**: The conclusion of the theorem is `OpenEmbedding (inclusion ⋯)`, which states that the inclusion map is an open embedding. The `⋯` indicates that additional arguments or context might be needed, but the core idea is that the inclusion map is the function being considered.\n\n10"}
{"source_file": "herald_data/sample_500.jsonl", "line": 247, "id": 328843, "informal_statement": "For any normed additive commutative group $E$, and given a function $f: \\mathbb{R} \\to E$ and a complex number $s \\in \\mathbb{C}$, show that the Mellin transform of the function $t \\mapsto f(t^{-1})$ at $s$ is equal to the Mellin transform of $f$ at $-s$, i.e., $\\mathcal{M}\\{f(t^{-1})\\}(s) = \\mathcal{M}\\{f\\}(-s)$.", "formal_statement": "import Mathlib\nopen MeasureTheory Set Filter Asymptotics TopologicalSpace\nopen Real\nopen Complex hiding exp log abs_of_nonneg\nopen scoped Topology\nlemma mellin_comp_inv_tac_7625 [NormedAddCommGroup E] [NormedSpace ℂ E] (f : ℝ → E) (s : ℂ) : mellin (fun t => f t⁻¹) s = mellin f (-s) := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to understand both the mathematical concepts involved and how they are represented in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context**:\n   - We are dealing with a normed additive commutative group \\( E \\). In Lean, this is represented by the type class `NormedAddCommGroup E`.\n   - Additionally, \\( E \\) is a normed space over the complex numbers \\( \\mathbb{C} \\). This is represented by the type class `NormedSpace ℂ E`.\n\n2. **Function and Domain**:\n   - The function \\( f: \\mathbb{R} \\to E \\) is a mapping from the real numbers to the group \\( E \\). In Lean, this is simply expressed as `f : ℝ → E`.\n\n3. **Complex Number**:\n   - The complex number \\( s \\in \\mathbb{C} \\) is a parameter for the Mellin transform. In Lean, this is expressed as `s : ℂ`.\n\n4. **Mellin Transform**:\n   - The Mellin transform is a mathematical operation that transforms a function \\( f(t) \\) into a function of a complex variable \\( s \\). In Lean, this is represented by the function `mellin`.\n\n5. **Transformation of the Function**:\n   - The informal statement involves transforming the function \\( f \\) by considering \\( f(t^{-1}) \\). In Lean, this is expressed as `fun t => f t⁻¹`, where `t⁻¹` denotes the multiplicative inverse of \\( t \\).\n\n6. **Equality of Mellin Transforms**:\n   - The goal is to show that the Mellin transform of \\( t \\mapsto f(t^{-1}) \\) at \\( s \\) is equal to the Mellin transform of \\( f \\) at \\(-s\\). This is expressed in Lean as `mellin (fun t => f t⁻¹) s = mellin f (-s)`.\n\n7. **Lemma Declaration**:\n   - The statement is formalized as a lemma in Lean, which is a proposition that can be proved. The lemma is named `mellin_comp_inv_tac_7625`, and it includes the necessary type class constraints and the function \\( f \\) and complex number \\( s \\"}
{"source_file": "herald_data/sample_500.jsonl", "line": 252, "id": 568079, "informal_statement": "Prove that if $a+b+c=3$, then $a^3+b^3+c^3-3abc \\geq \\frac94 (a^2+b^2-2ab)$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_568079 (a b c : ℝ) (h : a + b + c = 3) : a^3 + b^3 + c^3 - 3 * a * b * c ≥ (9 / 4) * (a^2 + b^2 - 2 * a * b)   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow a series of steps to ensure that each component of the statement is correctly represented in the formal language. Here's how the translation is achieved:\n\n1. **Identify the Variables and Their Types**:\n   - The variables involved in the statement are \\(a\\), \\(b\\), and \\(c\\). In the context of the problem, these are real numbers. In Lean, real numbers are represented by the type `ℝ`.\n\n2. **Express the Given Condition**:\n   - The condition given in the problem is \\(a + b + c = 3\\). In Lean, this is expressed as `h : a + b + c = 3`, where `h` is a hypothesis that will be used in the proof.\n\n3. **Translate the Expression to Prove**:\n   - The expression to prove is \\(a^3 + b^3 + c^3 - 3abc \\geq \\frac{9}{4} (a^2 + b^2 - 2ab)\\).\n   - In Lean, the power operation is represented by `^`, so \\(a^3\\) is written as `a^3`.\n   - The product \\(3abc\\) is written as `3 * a * b * c`.\n   - The inequality \\(\\geq\\) is represented by `≥` in Lean.\n   - The fraction \\(\\frac{9}{4}\\) is written as `(9 / 4)` in Lean.\n   - The expression \\(a^2 + b^2 - 2ab\\) is written as `a^2 + b^2 - 2 * a * b`.\n\n4. **Structure the Theorem**:\n   - The theorem is structured using the `theorem` keyword, followed by a name for the theorem, `extract_aug_568079`.\n   - The variables \\(a\\), \\(b\\), and \\(c\\) are declared as real numbers: `(a b c : ℝ)`.\n   - The hypothesis \\(a + b + c = 3\\) is included as `h : a + b + c = 3`.\n   - The conclusion of the theorem, which is the inequality to prove, is written after the colon `:`.\n   - The `:= by sorry` part indicates that the proof is not provided and is left as a placeholder with `sorry"}
{"source_file": "herald_data/sample_500.jsonl", "line": 249, "id": 52581, "informal_statement": "For any two sets $x$ and $y$ in the class of sets $ZFSet$, the union of $x$ and $y$ when coerced to a class is equal to the union of $x$ considered as a class and $y$, formally $\\uparrow(x \\cup y) = (x : Class) \\cup y$.", "formal_statement": "import Mathlib\nopen Function (OfArity)\nopen PSet\nopen PSet\ntheorem coe_union_extracted (x y : ZFSet) : ↑(x ∪ y) = ↑x ∪ ↑y := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Context**: The informal statement involves set theory concepts within the framework of Zermelo-Fraenkel set theory (ZFSet). The statement is about the union of two sets and their coercion to a class.\n\n2. **Identifying the Components**:\n   - **Sets**: The sets $x$ and $y$ are elements of the class of sets $ZFSet$.\n   - **Union**: The operation $x \\cup y$ denotes the union of sets $x$ and $y$.\n   - **Coercion to Class**: The notation $\\uparrow(x \\cup y)$ indicates that the union of $x$ and $y$ is being coerced to a class.\n   - **Class Union**: The expression $(x : Class) \\cup y$ represents the union of $x$ considered as a class and $y$.\n\n3. **Formalizing in Lean4**:\n   - **Importing Necessary Modules**: The code begins with `import Mathlib`, which is a standard import for mathematical libraries in Lean4, providing necessary definitions and theorems.\n   - **Opening Modules**: The `open Function (OfArity)` and `open PSet` lines are used to bring specific functions and definitions into scope, particularly those related to set theory and functions.\n   - **Defining the Theorem**: The theorem is named `coe_union_extracted`, which suggests it deals with the coercion of a union.\n   - **Parameters**: The parameters `(x y : ZFSet)` specify that $x$ and $y$ are elements of the type `ZFSet`, representing sets in Zermelo-Fraenkel set theory.\n   - **Coercion Notation**: The notation `↑(x ∪ y)` uses the coercion operator `↑` to convert the union of $x$ and $y$ into a class. In Lean, this is often done using type classes or specific coercion functions.\n   - **Class Union**: The expression `↑x ∪ ↑y` represents the union of $x$ and $y$ after each has been coerced to a class. This matches the informal statement's description of the union of $x$ as a class and $y$.\n\n4. **Conclusion"}
{"source_file": "herald_data/sample_500.jsonl", "line": 254, "id": 59645, "informal_statement": "For any simple graph \\(G\\) with vertices \\(V\\), and for any walk \\(p\\) in \\(G\\) from vertex \\(u\\) to vertex \\(v\\), show that the starting vertex \\(u\\) is an element of the support of the walk \\(p\\), i.e., \\(u \\in p.support\\).", "formal_statement": "import Mathlib\nopen Function\ntheorem start_mem_support_extracted {G : SimpleGraph V} {u v : V} (p : G.Walk u v) : u ∈ p.support := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Objects**: \n   - The informal statement involves a simple graph \\(G\\) with vertices \\(V\\), a walk \\(p\\) in \\(G\\) from vertex \\(u\\) to vertex \\(v\\), and the concept of the support of a walk.\n\n2. **Translate the Graph and Walk Concepts**:\n   - In Lean, a simple graph is represented by `SimpleGraph V`, where `V` is the type of vertices. This is indicated by `{G : SimpleGraph V}` in the theorem signature.\n   - A walk in a graph from vertex \\(u\\) to vertex \\(v\\) is represented by `G.Walk u v`. This is captured by the parameter `(p : G.Walk u v)` in the theorem.\n\n3. **Express the Goal**:\n   - The goal is to show that the starting vertex \\(u\\) is in the support of the walk \\(p\\). In Lean, the support of a walk is typically a list or set of vertices that the walk visits.\n   - The statement `u ∈ p.support` expresses that \\(u\\) is an element of the support of the walk \\(p\\).\n\n4. **Structure the Theorem**:\n   - The theorem is named `start_mem_support_extracted`, which suggests it is about the starting vertex being a member of the support.\n   - The theorem signature includes the graph `G`, vertices `u` and `v`, and the walk `p`. These are all necessary to define the context of the theorem.\n\n5. **Use of `sorry`**:\n   - The keyword `sorry` is used as a placeholder in Lean to indicate that the proof is not yet provided. It allows the theorem to be type-checked without a complete proof.\n\n6. **Importing Necessary Libraries**:\n   - The line `import Mathlib` suggests that the theorem might rely on definitions or theorems from the Mathlib library, which is a comprehensive library for Lean.\n\n7. **Open Necessary Namespaces**:\n   - The line `open Function` is included, which might be necessary for certain function-related operations or definitions used in the proof.\n\nBy following these steps, the informal statement is formalized into a Lean theorem that asserts the starting vertex of a walk is part of its support, with"}
{"source_file": "herald_data/sample_500.jsonl", "line": 250, "id": 511039, "informal_statement": "prove that \\n $ \\left( {\\frac {x}{y}}-\\frac{9}{2}+\\frac{3}{2}\\,\\sqrt {3} \\right) ^{2}+\\left( {\\frac {y}{z}}-\\frac{9}{2}+\\frac{3}{2}\\,\\sqrt {3} \\right) ^{2}+\\left( {\\frac {z}{x}}-\\frac{9}{2}+\\frac{3}{2}\\,\\sqrt {3} \\right) ^{2}\\geq 3\\, \\left( \\frac{7}{2}-\\frac{3}{2}\\,\\sqrt {3} \\right) ^{2}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_511039 (x y z: ℝ) : (x / y - 9 / 2 + 3 / 2 * Real.sqrt 3)^2 + (y / z - 9 / 2 + 3 / 2 * Real.sqrt 3)^2 + (z / x - 9 / 2 + 3 / 2 * Real.sqrt 3)^2 ≥ 3 * (7 / 2 - 3 / 2 * Real.sqrt 3)^2   :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach to ensure that each component of the expression is correctly represented in Lean's syntax and semantics.\n\n1. **Import Necessary Libraries**: \n   - The Lean code begins with `import Mathlib`, which is a common practice to bring in the mathematical library that contains definitions and theorems for real numbers, arithmetic operations, and other mathematical constructs.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to make specific namespaces available, which might be necessary for handling operations on real numbers and other mathematical functions.\n\n2. **Define the Theorem**:\n   - The theorem is named `extract_aug_511039`, which is a unique identifier for this particular statement. Naming conventions in Lean often use descriptive names, but here it seems to be an autogenerated or arbitrary name.\n   - The theorem takes three real number arguments `x`, `y`, and `z`, which are specified by `(x y z: ℝ)`. The `ℝ` denotes that these variables are real numbers.\n\n3. **Translate the Expression**:\n   - The expression inside the theorem is a direct translation of the informal statement. Each part of the expression is carefully translated to match Lean's syntax:\n     - `x / y` is the division of `x` by `y`, which is straightforward.\n     - `- 9 / 2` is the subtraction of `9/2` from the result of the division.\n     - `+ 3 / 2 * Real.sqrt 3` adds `3/2` times the square root of `3`. In Lean, `Real.sqrt 3` is used to denote the square root of `3`.\n   - The entire expression `(x / y - 9 / 2 + 3 / 2 * Real.sqrt 3)^2` is squared using the `^2` operator.\n   - This pattern is repeated for the terms `(y / z - 9 / 2 + 3 / 2 * Real.sqrt 3)^2` and `(z / x - 9 / 2 + 3 / 2 * Real.sqrt 3)^2`.\n\n4. **Construct the Inequality**:\n   - The sum of the three squared terms is compared to the right-hand side of the inequality using `≥`, which is Lean's syntax for \""}
{"source_file": "herald_data/sample_500.jsonl", "line": 253, "id": 165084, "informal_statement": "For any complex number $x$ such that $|x| \\leq 1$, any natural numbers $n, j$ with $0 < n$ and $j \\geq n$, demonstrate that the absolute value of the summation over the set of $m$ in the range of $j$ where $m \\geq n$, of the terms $\\frac{x^m}{m!}$, is equal to the absolute value of the summation over the same set of $m$, of the terms $x^n \\cdot \\frac{x^{m-n}}{m!}$.", "formal_statement": "import Mathlib\nopen CauSeq Finset IsAbsoluteValue\nopen scoped ComplexConjugate\nopen Complex\nopen Complex\nopen IsAbsoluteValue Nat\nlemma exp_bound_tac_40061 (x : ℂ) (hx : abs x ≤ 1) (n : ℕ) (hn : 0 < n) (j : ℕ) (hj : j ≥ n) : abs (∑ m ∈ filter (fun k => n ≤ k) (range j), x ^ m / ↑m.factorial) =\n  abs (∑ m ∈ filter (fun k => n ≤ k) (range j), x ^ n * (x ^ (m - n) / ↑m.factorial)) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and map it to its corresponding Lean constructs. Here's the step-by-step explanation:\n\n1. **Complex Number and Absolute Value Condition**:\n   - The informal statement begins with \"For any complex number $x$ such that $|x| \\leq 1$\". In Lean, complex numbers are represented by `ℂ`, and the absolute value function for complex numbers is `abs`. The condition `|x| ≤ 1` is expressed as `hx : abs x ≤ 1`.\n\n2. **Natural Numbers and Their Conditions**:\n   - The statement involves natural numbers $n$ and $j$ with conditions $0 < n$ and $j \\geq n$. In Lean, natural numbers are represented by `ℕ`. The conditions are expressed as `hn : 0 < n` and `hj : j ≥ n`.\n\n3. **Summation Over a Set**:\n   - The informal statement involves a summation over the set of $m$ in the range of $j$ where $m \\geq n$. In Lean, this is handled using `Finset` operations. The range of $j$ is represented by `range j`, and filtering for elements where $m \\geq n` is done using `filter (fun k => n ≤ k) (range j)`.\n\n4. **Terms in the Summation**:\n   - The terms in the summation are given as $\\frac{x^m}{m!}$ and $x^n \\cdot \\frac{x^{m-n}}{m!}$. In Lean, exponentiation is represented by `^`, and division by factorial is done using `↑m.factorial` to convert the factorial to a complex number. Thus, the terms are `x ^ m / ↑m.factorial` and `x ^ n * (x ^ (m - n) / ↑m.factorial)`.\n\n5. **Equality of Absolute Values**:\n   - The statement requires showing that the absolute value of the first summation is equal to the absolute value of the second summation. In Lean, this is expressed using `abs` around each summation and the equality operator `=`.\n\n6. **Formalizing the Lemma**:\n   - The lemma is named `exp_bound_tac_40061`, and it takes parameters `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 251, "id": 538401, "informal_statement": "if $ a,b,c$ are positive number,then $ \\sum_{cyc}\\frac {4a^2 - b^2 - c^2}{a(b + c)} \\leq 3$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_538401 (a b c : ℝ) : (4 * a ^ 2 - b ^ 2 - c ^ 2) / (a * (b + c)) + (4 * b ^ 2 - c ^ 2 - a ^ 2) / (b * (c + a)) + (4 * c ^ 2 - a ^ 2 - b ^ 2) / (c * (a + b)) ≤ 3   :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves three variables \\(a\\), \\(b\\), and \\(c\\), which are specified as positive numbers. In Lean, we typically represent real numbers using the type `ℝ` (real numbers). However, the statement does not explicitly enforce positivity in the formal theorem, which might be an oversight or assumed to be handled elsewhere.\n\n2. **Understand the Cyclic Sum**:\n   - The expression \\(\\sum_{cyc} \\frac{4a^2 - b^2 - c^2}{a(b + c)}\\) represents a cyclic sum over the permutations of \\(a\\), \\(b\\), and \\(c\\). This means we need to evaluate the expression for each permutation and sum the results:\n     - \\(\\frac{4a^2 - b^2 - c^2}{a(b + c)}\\)\n     - \\(\\frac{4b^2 - c^2 - a^2}{b(c + a)}\\)\n     - \\(\\frac{4c^2 - a^2 - b^2}{c(a + b)}\\)\n\n3. **Translate the Inequality**:\n   - The informal statement asserts that this cyclic sum is less than or equal to 3. In Lean, inequalities are expressed using `≤`.\n\n4. **Structure the Theorem in Lean**:\n   - The theorem is named `extract_aug_538401`, which is a placeholder name and can be replaced with a more descriptive one.\n   - The theorem takes three arguments \\(a\\), \\(b\\), and \\(c\\) of type `ℝ`.\n   - The body of the theorem is the inequality involving the cyclic sum and the constant 3.\n\n5. **Use Lean Syntax**:\n   - The expression for each term in the cyclic sum is written using Lean's arithmetic operations and syntax. For example, `4 * a ^ 2` represents \\(4a^2\\), and `a * (b + c)` represents \\(a(b + c)\\).\n   - The sum of these terms is written as a single expression using `+` to combine them.\n   - The inequality is expressed using `≤`.\n\n6. **Handle the Proof**:\n   - The theorem ends with `:= by"}
{"source_file": "herald_data/sample_500.jsonl", "line": 256, "id": 84005, "informal_statement": "For any family of sets $c$ in the type $\\alpha$, show that the union of all sets in $c$ equals the universal set if and only if for every element $a$ in $\\alpha$, there exists a set $b$ in $c$ such that $a$ is an element of $b$. In other words, prove that $\\bigcup_{0}c = \\mathbb{U} \\iff \\forall a, \\exists b \\in c, a \\in b$.", "formal_statement": "import Mathlib\nopen Function Set\ntheorem sUnion_eq_univ_iff_extracted {c : Set (Set α)} : ⋃₀ c = univ ↔ ∀ (a : α), ∃ b ∈ c, a ∈ b := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to understand the components of both the informal and formal statements and how they correspond to each other. Here's a step-by-step explanation:\n\n1. **Understanding the Informal Statement:**\n   - We have a family of sets `c` in a type `α`.\n   - We need to show that the union of all sets in `c` equals the universal set if and only if for every element `a` in `α`, there exists a set `b` in `c` such that `a` is an element of `b`.\n   - The informal statement uses set notation: `⋃₀ c` for the union of all sets in `c` and `𝕌` for the universal set.\n\n2. **Components of the Formal Statement:**\n   - `import Mathlib`: This imports the necessary Lean libraries for working with sets and functions.\n   - `open Function Set`: This line opens the namespaces for functions and sets, allowing us to use their definitions and notations without prefixing them.\n   - `theorem sUnion_eq_univ_iff_extracted`: This is the name of the theorem we are proving. It is a descriptive name indicating that we are dealing with the union of sets and its relation to the universal set.\n   - `{c : Set (Set α)}`: This declares `c` as a set of sets, where each set is of type `α`. This matches the informal description of `c` as a family of sets in the type `α`.\n   - `⋃₀ c = univ`: This is the formal way to express that the union of all sets in `c` equals the universal set. `⋃₀ c` is the Lean notation for the union of a set of sets, and `univ` is the Lean representation of the universal set.\n   - `↔`: This is the logical symbol for \"if and only if,\" which matches the informal statement's requirement to prove an equivalence.\n   - `∀ (a : α), ∃ b ∈ c, a ∈ b`: This part of the statement formalizes the condition that for every element `a` in `α`, there exists a set `b` in `c` such that `a` is an element of `b`. \n     - `∀ (a : α)`: This translates to \"for every"}
{"source_file": "herald_data/sample_500.jsonl", "line": 248, "id": 59945, "informal_statement": "For any element \\(x\\) in the total space of a trivialization \\(e\\) such that the projection of \\(x\\) is in the base set of \\(e\\), show that the pair consisting of the projection of \\(x\\) and the second component of the fiber of \\(x\\) is equal to \\(x\\) itself in the trivialization, i.e., \\((\\text{proj } x, (\\text{e } x).2) = \\text{e } x\\).", "formal_statement": "import Mathlib\nopen TopologicalSpace Filter Set Bundle Function\nopen scoped Topology\n  open_target : IsOpen target\n  open_baseSet : IsOpen baseSet\nopen Classical in\n  open_baseSet : IsOpen baseSet\ntheorem mk_proj_snd'_extracted [TopologicalSpace B] [TopologicalSpace F] {proj : Z → B}\n [TopologicalSpace Z] (e : Trivialization F proj) {x : Z} : proj x ∈ e.baseSet → (proj x, (↑e x).2) = ↑e x := sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to understand the components involved and how they relate to each other in the context of topology and fiber bundles. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context**: \n   - We are dealing with a fiber bundle, which is a structure consisting of a total space \\(Z\\), a base space \\(B\\), and a projection map \\(proj : Z \\to B\\).\n   - A trivialization \\(e\\) is a specific kind of map that provides a local product structure over a subset of the base space, called the base set of the trivialization.\n\n2. **Identifying the Components**:\n   - The total space \\(Z\\) is equipped with a topology, as is the base space \\(B\\) and the fiber \\(F\\).\n   - The trivialization \\(e\\) is a map that, for each point \\(x\\) in the total space, gives a pair \\((b, f)\\) where \\(b\\) is in the base space and \\(f\\) is in the fiber.\n\n3. **Formalizing the Hypothesis**:\n   - The hypothesis is that the projection of \\(x\\), \\(proj x\\), is in the base set of the trivialization \\(e\\). This is expressed in Lean as `proj x ∈ e.baseSet`.\n\n4. **Expressing the Conclusion**:\n   - The conclusion is that the pair \\((\\text{proj } x, (\\text{e } x).2)\\) is equal to \\(\\text{e } x\\).\n   - In Lean, this is expressed as `(proj x, (↑e x).2) = ↑e x`. Here, `↑e x` denotes the application of the trivialization \\(e\\) to \\(x\\), and `.2` extracts the second component of the resulting pair, which corresponds to the fiber component.\n\n5. **Structuring the Theorem**:\n   - The theorem is defined with the necessary type class instances for topological spaces on \\(B\\), \\(F\\), and \\(Z\\).\n   - The trivialization \\(e\\) is specified as a parameter of type `Trivialization F proj`, indicating it is a trivialization of the fiber \\(F\\) over the projection map \\(proj`.\n\n6. **Using Lean's Syntax**:\n   - The theorem is"}
{"source_file": "herald_data/sample_500.jsonl", "line": 255, "id": 543627, "informal_statement": "Find all the functions $f:\\mathbb{R}\\to\\mathbb{R}$ such that $f(x+f(y))=(f(y))^4+4x^3(f(y))+6x^2(f(y))^2+4x(f(y))^3+f(-x) \\quad \\forall x,y \\in\\mathbb R$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_543627 (f : ℝ → ℝ): (∀ x y, f (x + f y) = (f y)^4 + 4 * x^3 * (f y) + 6 * x^2 * (f y)^2 + 4 * x * (f y)^3 + f (- x)) ↔ ∃ l:ℝ, ∀ x, f x = l   :=  by sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Understanding the Problem Statement**: \n   - We are given a functional equation involving a function \\( f: \\mathbb{R} \\to \\mathbb{R} \\).\n   - The equation is \\( f(x + f(y)) = (f(y))^4 + 4x^3(f(y)) + 6x^2(f(y))^2 + 4x(f(y))^3 + f(-x) \\) for all real numbers \\( x \\) and \\( y \\).\n   - The task is to find all such functions \\( f \\).\n\n2. **Formalizing the Function and Variables**:\n   - In Lean, we define a function \\( f \\) from real numbers to real numbers as `f : ℝ → ℝ`.\n   - The universal quantification over \\( x \\) and \\( y \\) is expressed using `∀ x y`.\n\n3. **Expressing the Functional Equation**:\n   - The equation \\( f(x + f(y)) = (f(y))^4 + 4x^3(f(y)) + 6x^2(f(y))^2 + 4x(f(y))^3 + f(-x) \\) is directly translated into Lean syntax.\n   - The left-hand side is `f (x + f y)`.\n   - The right-hand side is `(f y)^4 + 4 * x^3 * (f y) + 6 * x^2 * (f y)^2 + 4 * x * (f y)^3 + f (- x)`.\n\n4. **Expressing the Solution**:\n   - The problem asks to find all such functions, which is equivalent to stating that there exists a constant \\( l \\) such that \\( f(x) = l \\) for all \\( x \\).\n   - This is expressed in Lean as `∃ l:ℝ, ∀ x, f x = l`.\n\n5. **Combining into a Theorem**:\n   - The theorem is named `extract_aug_543627`.\n   - The statement of the theorem is a bi-conditional (`↔`), indicating that the given functional equation holds if and only if there exists a constant \\( l \\) such that \\( f(x) = l \\) for all \\( x \\)."}
{"source_file": "herald_data/sample_500.jsonl", "line": 258, "id": 71852, "informal_statement": "For any integer $n$, show that the imaginary part of the complex number resulting from the embedding of $n$ into the complex numbers with a square root of $d$ is zero, i.e., $\\text{Im}(\\text{ofInt } n) = 0$.", "formal_statement": "import Mathlib\n\ntheorem ofInt_im_extracted {d : ℤ} (n : ℤ) : (Zsqrtd.ofInt n).im = 0 := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Understand the Context**: The problem involves complex numbers, specifically those formed by embedding integers into a complex-like structure with a square root of an integer `d`. In Lean, this is represented by `Zsqrtd`, which is a structure for numbers of the form `a + b√d` where `a` and `b` are integers.\n\n2. **Identify the Components**:\n   - **Integer Embedding**: The function `Zsqrtd.ofInt` is used to embed an integer `n` into this structure. This function takes an integer and returns a `Zsqrtd` number where the integer is the real part and the imaginary part is zero.\n   - **Imaginary Part Extraction**: The `.im` accessor is used to extract the imaginary part of a `Zsqrtd` number.\n\n3. **Formalize the Statement**:\n   - **Parameters**: The theorem is parameterized by `d` and `n`, both of which are integers. `d` is the integer whose square root is used in the `Zsqrtd` structure, and `n` is the integer being embedded.\n   - **Conclusion**: The goal is to show that the imaginary part of the result of `Zsqrtd.ofInt n` is zero.\n\n4. **Write the Theorem**:\n   - The theorem is named `ofInt_im_extracted`, indicating that it deals with extracting the imaginary part of an integer embedded in `Zsqrtd`.\n   - The parameters `{d : ℤ} (n : ℤ)` indicate that `d` is an implicit parameter (often a fixed context in such problems), and `n` is an explicit integer input.\n   - The conclusion `(Zsqrtd.ofInt n).im = 0` states that the imaginary part of the embedded integer is zero.\n\n5. **Use of `sorry`**: The `:= sorry` part indicates that the proof is not provided. In Lean, `sorry` is a placeholder for a proof, allowing the statement to be checked for correctness without providing the actual proof.\n\nBy following these steps, the informal statement is accurately translated into the formal Lean4 theorem."}
{"source_file": "herald_data/sample_500.jsonl", "line": 257, "id": 194855, "informal_statement": "For any natural numbers $a$ and $b$, given that both $a$ and $b$ are congruent to $3$ modulo $4$, and provided that for any natural number $n$ congruent to $3$ modulo $4$, $(-1)^{\\frac{n}{2}}$ equals $-1$, show that the negative of the Jacobi symbol $\\left(\\frac{b}{a}\\right)$ is equal to itself, i.e., $-\\left(\\frac{b}{a}\\right) = -\\left(\\frac{b}{a}\\right)$. Note: The Jacobi symbol is lifted from the natural numbers to the integers for the purposes of this statement.", "formal_statement": "import Mathlib\nopen Nat ZMod\nopen NumberTheorySymbols\nopen jacobiSym\nlemma quadratic_reciprocity_three_mod_four_tac_20797 (a : ℕ) (b : ℕ) (ha : a % 4 = 3) (hb : b % 4 = 3) (nop : ∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1) : -J(↑b | a) = -J(↑b | a) := sorry", "explanation": "To translate the given informal mathematical statement into Lean4 code, we need to follow a structured approach that captures the essence of the statement while adhering to Lean's syntax and logical framework. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context**: \n   - The statement involves natural numbers \\(a\\) and \\(b\\) with specific congruence conditions modulo 4.\n   - It involves properties of the Jacobi symbol, which is a generalization of the Legendre symbol to integers.\n   - The statement asserts a property about the Jacobi symbol when both numbers are congruent to 3 modulo 4.\n\n2. **Identifying the Variables**:\n   - The variables \\(a\\) and \\(b\\) are natural numbers, which in Lean are represented by `ℕ`.\n   - The congruence conditions \\(a \\equiv 3 \\pmod{4}\\) and \\(b \\equiv 3 \\pmod{4}\\) are expressed using the modulus operator `%`.\n\n3. **Formalizing the Hypotheses**:\n   - The congruence conditions are formalized as `ha : a % 4 = 3` and `hb : b % 4 = 3`.\n   - The additional hypothesis about powers of \\(-1\\) is given as `nop : ∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1`. This states that for any natural number \\(n\\) congruent to 3 modulo 4, \\((-1)^{n/2}\\) equals \\(-1\\).\n\n4. **Expressing the Jacobi Symbol**:\n   - The Jacobi symbol \\(\\left(\\frac{b}{a}\\right)\\) is represented in Lean using `J(↑b | a)`, where `↑b` denotes the coercion of \\(b\\) from natural numbers to integers. This is necessary because the Jacobi symbol is defined for integers.\n\n5. **Stating the Conclusion**:\n   - The conclusion \\(-\\left(\\frac{b}{a}\\right) = -\\left(\\frac{b}{a}\\right)\\) is trivially true, as it is an identity. In Lean, this is expressed as `-J(↑b | a) = -J(↑b | a)`.\n\n6. **Structuring"}
{"source_file": "herald_data/sample_500.jsonl", "line": 262, "id": 125714, "informal_statement": "For any two distinct prime natural numbers $p$ and $q$, and for any natural numbers $n$ and $m$, demonstrate that the $p$-adic valuation of $p^n$ plus the $p$-adic valuation of $q^m$ equals $n$, i.e., $\\nu_p(p^n) + \\nu_p(q^m) = n$.", "formal_statement": "import Mathlib\nopen Nat\nopen Rat\nopen multiplicity\nopen multiplicity\nopen Nat.maxPowDiv\nopen multiplicity\nopen multiplicity\nopen multiplicity\nlemma padicValNat_mul_pow_left_tac_21806 (p : ℕ) (q : ℕ) (hp : Fact (Nat.Prime p)) (hq : Fact (Nat.Prime q)) (n : ℕ) (m : ℕ) (neq : p ≠ q) : padicValNat p (p ^ n) + padicValNat p (q ^ m) = n := sorry", "explanation": "To translate the given informal mathematical statement into Lean4 code, we need to follow a structured approach that involves understanding both the mathematical concepts and how they are represented in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Informal Statement**:\n   - We are given two distinct prime numbers \\( p \\) and \\( q \\).\n   - We have two natural numbers \\( n \\) and \\( m \\).\n   - We need to show that the \\( p \\)-adic valuation of \\( p^n \\) plus the \\( p \\)-adic valuation of \\( q^m \\) equals \\( n \\).\n\n2. **Identifying Key Concepts**:\n   - **Prime Numbers**: In Lean, prime numbers are often represented using the `Nat.Prime` predicate.\n   - **Distinctness**: The condition \\( p \\neq q \\) ensures that the primes are distinct.\n   - **Natural Numbers**: Lean uses `ℕ` to denote natural numbers.\n   - **p-adic Valuation**: The \\( p \\)-adic valuation, denoted as \\(\\nu_p\\), is represented in Lean by the function `padicValNat`.\n\n3. **Formalizing the Statement in Lean**:\n   - **Parameters**: We need to define the parameters \\( p \\), \\( q \\), \\( n \\), and \\( m \\) as natural numbers. Additionally, we need to assert that \\( p \\) and \\( q \\) are prime and distinct.\n   - **Prime Assertions**: Use `Fact (Nat.Prime p)` and `Fact (Nat.Prime q)` to assert that \\( p \\) and \\( q \\) are prime.\n   - **Distinctness Condition**: Use `neq : p ≠ q` to assert that \\( p \\) and \\( q \\) are distinct.\n   - **p-adic Valuation**: Use `padicValNat p (p ^ n)` to represent the \\( p \\)-adic valuation of \\( p^n \\) and `padicValNat p (q ^ m)` for \\( q^m \\).\n\n4. **Constructing the Lean Lemma**:\n   - **Lemma Declaration**: Start with `lemma` to declare a new lemma.\n   - **Name and Parameters**: Name the lemma `padicValNat_mul_pow_left_tac_21806` and list the parameters \\( p \\),"}
{"source_file": "herald_data/sample_500.jsonl", "line": 259, "id": 71265, "informal_statement": "Show that the canonical map of the polynomial ring element \\(1 \\in \\text{Poly } \\alpha\\) is the constant function equal to \\(1\\).", "formal_statement": "import Mathlib\nopen Fin2 Function Nat Sum\ntheorem coe_one_extracted : ⇑1 = ⇑(Poly.const 1) := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to understand both the mathematical concepts involved and how they are represented in Lean.\n\n1. **Understanding the Informal Statement**: \n   - We are dealing with a polynomial ring over some type \\(\\alpha\\).\n   - The element \\(1\\) in this polynomial ring is the multiplicative identity.\n   - The \"canonical map\" refers to the function that evaluates or represents this polynomial as a function.\n   - We need to show that this function is the constant function equal to \\(1\\).\n\n2. **Lean4 Representation**:\n   - In Lean, polynomials are often represented using a specific type, such as `Poly α`, where `α` is the type over which the polynomial is defined.\n   - The element \\(1\\) in the polynomial ring is represented by `1` in Lean, which is the multiplicative identity in the context of polynomials.\n   - The notation `⇑1` is used to denote the function corresponding to the polynomial \\(1\\). This is the coercion of the polynomial to a function.\n   - `Poly.const 1` represents the constant polynomial function that always returns \\(1\\).\n\n3. **Formalizing the Statement**:\n   - The goal is to prove that the function obtained by coercing the polynomial \\(1\\) is the same as the constant function \\(1\\).\n   - In Lean, this is expressed as `⇑1 = ⇑(Poly.const 1)`.\n   - The `⇑` operator is used to denote the coercion from a polynomial to its corresponding function.\n\n4. **Theorem Declaration**:\n   - We declare a theorem named `coe_one_extracted` to encapsulate this statement.\n   - The `:= sorry` part indicates that the proof is not yet provided. In a complete development, this would be replaced with a proof showing the equality of the two functions.\n\n5. **Imports and Context**:\n   - The `import Mathlib` statement is used to bring in necessary mathematical libraries that define polynomials and their operations.\n   - The `open` statement is used to bring certain namespaces into scope, which might be necessary for handling polynomials and functions.\n\nBy following these steps, we translate the informal mathematical statement into a precise formal statement in Lean4, capturing the essence of the problem and setting up the framework for a proof."}
{"source_file": "herald_data/sample_500.jsonl", "line": 261, "id": 433798, "informal_statement": "Let $E$ be a normed space over a field $\\kappa$ (where $\\kappa$ is either $\\mathbb{R}$ or $\\mathbb{C}$). Show that $E$ and $\\kappa$ have separating duals.", "formal_statement": "import Mathlib\n\ninstance {E 𝕜 : Type*} [RCLike 𝕜] [NormedAddCommGroup E] [NormedSpace 𝕜 E] : SeparatingDual 𝕜 E := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to understand the components involved in both the informal and formal statements and how they correspond to each other.\n\n1. **Understanding the Informal Statement:**\n   - We are given a normed space \\( E \\) over a field \\( \\kappa \\).\n   - The field \\( \\kappa \\) is specified to be either the real numbers \\( \\mathbb{R} \\) or the complex numbers \\( \\mathbb{C} \\).\n   - The task is to show that both \\( E \\) and \\( \\kappa \\) have separating duals. A separating dual typically refers to a dual space such that the evaluation map is injective, meaning the dual can distinguish between different elements of the space.\n\n2. **Translating to Lean4:**\n   - **Types and Fields:**\n     - In Lean, types are used to represent mathematical objects. Here, `E` and `𝕜` are declared as types with `E` representing the normed space and `𝕜` representing the field.\n     - The field \\( \\kappa \\) is represented by `𝕜` in the Lean code.\n\n   - **Typeclass Constraints:**\n     - `[RCLike 𝕜]`: This constraint indicates that `𝕜` is a field that behaves like the reals or complexes. `RCLike` is a typeclass that abstracts over the properties of real and complex numbers.\n     - `[NormedAddCommGroup E]`: This constraint specifies that `E` is a normed additive commutative group, which is a requirement for a normed space.\n     - `[NormedSpace 𝕜 E]`: This indicates that `E` is a normed space over the field `𝕜`.\n\n   - **Separating Dual:**\n     - `SeparatingDual 𝕜 E`: This is a typeclass that represents the property of having a separating dual. The instance declaration is stating that for any normed space `E` over a field `𝕜` (where `𝕜` is like the reals or complexes), there exists a separating dual.\n\n3. **Instance Declaration:**\n   - The `instance` keyword in Lean is used to declare that a certain property or structure exists for given types under specified conditions.\n   - The declaration `instance"}
{"source_file": "herald_data/sample_500.jsonl", "line": 265, "id": 85968, "informal_statement": "For any finite types \\(n\\), \\(m\\), and \\(k\\) with decidable equality, and a semiring \\(\\alpha\\), let \\(b_1, b_2 \\in n\\) be distinct elements, \\(a \\in m\\), and \\(c \\in k\\). Show that the product of the matrices \\((\\text{single } a b_1)\\) and \\((\\text{single } b_2 c)\\), both converted to matrices over \\(\\alpha\\), equals the zero matrix in \\(\\alpha\\).", "formal_statement": "import Mathlib\nopen Matrix\nopen Matrix\ntheorem single_mul_single_of_ne_extracted [Fintype n] [DecidableEq n]\n [DecidableEq k] [DecidableEq m] [Semiring α] {b₁ b₂ : n} :\n b₁ ≠ b₂ → ∀ (a : m) (c : k), (PEquiv.single a b₁).toMatrix * (PEquiv.single b₂ c).toMatrix = 0 := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and semantics.\n\n1. **Finite Types with Decidable Equality**: \n   - The informal statement mentions finite types \\(n\\), \\(m\\), and \\(k\\) with decidable equality. In Lean, this is expressed using type classes. `Fintype n` indicates that \\(n\\) is a finite type, and `DecidableEq n` indicates that equality on \\(n\\) is decidable. Similarly, `DecidableEq m` and `DecidableEq k` are used for types \\(m\\) and \\(k\\).\n\n2. **Semiring \\(\\alpha\\)**:\n   - The semiring structure on \\(\\alpha\\) is captured by the type class `[Semiring α]`. This provides the necessary algebraic operations and properties for \\(\\alpha\\).\n\n3. **Distinct Elements \\(b_1, b_2 \\in n\\)**:\n   - The elements \\(b_1\\) and \\(b_2\\) are distinct elements of the type \\(n\\). In Lean, this is expressed by the hypothesis `b₁ ≠ b₂`, where `b₁` and `b₂` are variables of type \\(n\\).\n\n4. **Elements \\(a \\in m\\) and \\(c \\in k\\)**:\n   - The elements \\(a\\) and \\(c\\) are simply variables of types \\(m\\) and \\(k\\), respectively. In the theorem, they are universally quantified using `∀ (a : m) (c : k)`.\n\n5. **Matrix Construction Using `PEquiv.single`**:\n   - The informal statement uses the notation \\((\\text{single } a b_1)\\) and \\((\\text{single } b_2 c)\\). In Lean, `PEquiv.single a b₁` creates a partial equivalence (a kind of function) that maps \\(a\\) to \\(b₁\\) and is undefined elsewhere. The method `.toMatrix` converts this partial equivalence to a matrix over the semiring \\(\\alpha\\).\n\n6. **Matrix Multiplication and Zero Matrix**:\n   - The product of the matrices is expressed using the multiplication operator `*`. The result is compared to the zero matrix, which is"}
{"source_file": "herald_data/sample_500.jsonl", "line": 266, "id": 450607, "informal_statement": "Let $ a$ and $ b$ are positive numbers and $ 2-\\sqrt3\\leq k\\leq2+\\sqrt3.$ Prove that \\n $ \\left(\\sqrt a+\\sqrt b\\right)\\left(\\frac{1}{\\sqrt{a+kb}}+\\frac{1}{\\sqrt{b+ka}}\\right)\\leq\\frac{4}{\\sqrt{1+k}}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_450607 : ∀ a b k : ℝ, a > 0 ∧ b > 0 ∧ 2 - Real.sqrt 3 ≤ k ∧ k ≤ 2 + Real.sqrt 3 → (Real.sqrt a + Real.sqrt b) * (1 / Real.sqrt (a + k * b) + 1 / Real.sqrt (b + k * a)) ≤ 4 / Real.sqrt (1 + k)  :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the problem and its constraints. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves three variables: \\( a \\), \\( b \\), and \\( k \\).\n   - \\( a \\) and \\( b \\) are positive numbers, which in Lean are represented as real numbers (\\(\\mathbb{R}\\)) with the condition \\( a > 0 \\) and \\( b > 0 \\).\n   - \\( k \\) is a real number constrained by the inequality \\( 2 - \\sqrt{3} \\leq k \\leq 2 + \\sqrt{3} \\).\n\n2. **Translate the Constraints**:\n   - The constraints on \\( a \\), \\( b \\), and \\( k \\) are expressed using logical conjunctions (\\(\\land\\)) in Lean.\n   - The condition \\( a > 0 \\) and \\( b > 0 \\) is written as `a > 0 ∧ b > 0`.\n   - The condition \\( 2 - \\sqrt{3} \\leq k \\leq 2 + \\sqrt{3} \\) is split into two parts: \\( 2 - \\sqrt{3} \\leq k \\) and \\( k \\leq 2 + \\sqrt{3} \\), combined using \\(\\land\\).\n\n3. **Express the Main Inequality**:\n   - The expression \\((\\sqrt{a} + \\sqrt{b})(\\frac{1}{\\sqrt{a + kb}} + \\frac{1}{\\sqrt{b + ka}})\\) is translated directly using Lean's `Real.sqrt` for square roots and arithmetic operations.\n   - The right-hand side of the inequality \\(\\frac{4}{\\sqrt{1+k}}\\) is similarly expressed using `Real.sqrt`.\n\n4. **Structure the Theorem**:\n   - The theorem is defined using `theorem` in Lean, followed by a name (`extract_aug_450607`).\n   - The universal quantification over \\( a \\), \\( b \\), and \\( k \\) is expressed using `∀ a b k : ℝ`.\n   - The implication from the constraints to the inequality is expressed using `→`.\n\n5. **Use"}
{"source_file": "herald_data/sample_500.jsonl", "line": 264, "id": 41675, "informal_statement": "For any nonempty set $s$ of elements in a linearly ordered set, and given $a$ is a greatest lower bound of $s$ but $a \\notin s$, prove that the union of all lower closed intervals $[x, +\\infty)$ for $x \\in s$ is equal to the open interval $(a, +\\infty)$.", "formal_statement": "import Mathlib\nopen Set\nopen OrderDual (toDual)\ntheorem biUnion_Ici_eq_Ioi_extracted [LinearOrder α] {s : Set α} {a : α} : IsGLB s a → a ∉ s → ⋃ x ∈ s, Ici x = Ioi a := sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and semantics.\n\n1. **Context and Assumptions**:\n   - We are working within a linearly ordered set. In Lean, this is represented by `[LinearOrder α]`, where `α` is the type of elements in the set.\n   - We have a set `s` of type `Set α`. This is a nonempty set of elements in the linearly ordered set.\n   - We have an element `a` of type `α` which is a greatest lower bound (GLB) of the set `s`.\n\n2. **Greatest Lower Bound (GLB)**:\n   - The informal statement mentions that `a` is a greatest lower bound of `s`. In Lean, this is expressed using the predicate `IsGLB s a`. This predicate encapsulates the definition of `a` being a GLB of `s`.\n\n3. **Element Not in Set**:\n   - The condition `a \\notin s` is directly translated to `a ∉ s` in Lean. The symbol `∉` is the negation of the membership symbol `∈`.\n\n4. **Union of Lower Closed Intervals**:\n   - The informal statement describes the union of all lower closed intervals `[x, +\\infty)` for `x ∈ s`. In Lean, a lower closed interval `[x, +\\infty)` is represented as `Ici x`, where `Ici` stands for \"interval closed on the left\".\n   - The union of these intervals for all `x` in `s` is expressed as `⋃ x ∈ s, Ici x`. The symbol `⋃` denotes the union over a set.\n\n5. **Open Interval**:\n   - The open interval `(a, +\\infty)` is represented in Lean as `Ioi a`, where `Ioi` stands for \"interval open on the left\".\n\n6. **Equality of Sets**:\n   - The goal is to prove that the union of the intervals is equal to the open interval `(a, +\\infty)`. This is expressed as `⋃ x ∈ s, Ici x = Ioi a`.\n\n7. **Theorem Statement**:\n   - The theorem is named `biUnion_Ici_eq_Ioi_ex"}
{"source_file": "herald_data/sample_500.jsonl", "line": 263, "id": 258179, "informal_statement": "For any complex number $s$ and given that for all natural numbers $n$, $s \\neq -(2n + 1)$, and also given that $(s + 1)\\Gamma_{\\mathbb{R}} \\neq 0$, show that the quotient $\\frac{s\\Gamma_{\\mathbb{R}}}{(1 - s)\\Gamma_{\\mathbb{R}}}$ is equal to the product $s\\Gamma_{\\mathbb{R}} \\cdot \\frac{(s + 1)\\Gamma_{\\mathbb{R}}}{(1 - s)\\Gamma_{\\mathbb{R}} \\cdot (1 + s)\\Gamma_{\\mathbb{R}}}$.", "formal_statement": "import Mathlib\nopen Filter Topology Asymptotics Real Set MeasureTheory\nopen Complex hiding abs_of_nonneg\nlemma Gammaℝ_div_Gammaℝ_one_sub_tac_6744 (s : ℂ) (hs : ∀ (n : ℕ), s ≠ -(2 * ↑n + 1)) (this : (s + 1).Gammaℝ ≠ 0) : s.Gammaℝ / (1 - s).Gammaℝ = s.Gammaℝ * (s + 1).Gammaℝ / ((1 - s).Gammaℝ * (1 + s).Gammaℝ) := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully consider each component of the statement and how it corresponds to Lean's syntax and mathematical libraries. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context**:\n   - The statement involves complex numbers, natural numbers, and the Gamma function over the reals, denoted as `Γ_ℝ` in the informal statement. In Lean, this is represented as `Gammaℝ`.\n\n2. **Defining the Variables**:\n   - The informal statement starts with \"For any complex number $s$\". In Lean, this is represented by `(s : ℂ)`, where `ℂ` denotes the type of complex numbers.\n\n3. **Expressing the Conditions**:\n   - The condition \"for all natural numbers $n$, $s \\neq -(2n + 1)$\" is translated to `(hs : ∀ (n : ℕ), s ≠ -(2 * ↑n + 1))`. Here:\n     - `∀ (n : ℕ)` indicates that the condition applies to all natural numbers `n`.\n     - `s ≠ -(2 * ↑n + 1)` expresses the inequality, where `↑n` is used to cast the natural number `n` to a complex number, allowing arithmetic operations with `s`.\n\n4. **Additional Given Condition**:\n   - The condition \"$(s + 1)\\Gamma_{\\mathbb{R}} \\neq 0$\" is translated to `(this : (s + 1).Gammaℝ ≠ 0)`. This states that the Gamma function evaluated at `s + 1` is non-zero.\n\n5. **Stating the Conclusion**:\n   - The conclusion involves showing an equality of two expressions. The left-hand side of the equality, $\\frac{s\\Gamma_{\\mathbb{R}}}{(1 - s)\\Gamma_{\\mathbb{R}}}$, is translated to `s.Gammaℝ / (1 - s).Gammaℝ`.\n   - The right-hand side, $s\\Gamma_{\\mathbb{R}} \\cdot \\frac{(s + 1)\\Gamma_{\\mathbb{R}}}{(1 - s)\\Gamma_{\\mathbb{R}} \\cdot (1 + s)\\Gamma_{\\mathbb{R}}}$, is translated to `s.Gammaℝ * (s"}
{"source_file": "herald_data/sample_500.jsonl", "line": 260, "id": 246633, "informal_statement": "For any natural number \\(n\\), any transitive relation \\(r\\) on a type \\(\\alpha\\), a function \\(f\\) from \\(Fin(n + 1)\\) to \\(\\alpha\\), and given that for all \\(i : Fin(n)\\), \\(r(f(i.castSucc))(f(i.succ))\\) holds, show that if \\(i : Fin(n + 1)\\), \\(j : Fin(n)\\), and \\(i \\leq j.castSucc\\), then \\(r(f(i))(f(j.succ))\\) is true, provided \\(i < j.castSucc \\rightarrow r(f(i))(f(j.castSucc))\\) also holds.", "formal_statement": "import Mathlib\nopen Fin Nat Function\nlemma liftFun_iff_succ_tac_58102 (n : ℕ) (r : α → α → Prop) [IsTrans α r] (f : Fin (n + 1) → α) (H : ∀ (i : Fin n), r (f i.castSucc) (f i.succ)) (i : Fin (n + 1)) (j : Fin n) (ihj : (fun x x_1 => x < x_1) i j.castSucc → r (f i) (f j.castSucc)) (hij : i ≤ j.castSucc) : r (f i) (f j.succ) := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and semantics.\n\n1. **Quantifiers and Types**:\n   - The informal statement begins with \"For any natural number \\(n\\)\", which corresponds to the parameter `(n : ℕ)` in Lean. Here, `ℕ` is the type of natural numbers in Lean.\n   - \"Any transitive relation \\(r\\) on a type \\(\\alpha\\)\" translates to `(r : α → α → Prop) [IsTrans α r]`. This means `r` is a binary relation on type `α`, and `[IsTrans α r]` is a typeclass constraint ensuring that `r` is transitive.\n   - \"A function \\(f\\) from \\(Fin(n + 1)\\) to \\(\\alpha\\)\" is represented as `(f : Fin (n + 1) → α)`. `Fin (n + 1)` is the type of natural numbers less than `n + 1`, and `f` maps these to elements of type `α`.\n\n2. **Hypotheses**:\n   - \"Given that for all \\(i : Fin(n)\\), \\(r(f(i.castSucc))(f(i.succ))\\) holds\" is formalized as `(H : ∀ (i : Fin n), r (f i.castSucc) (f i.succ))`. This states that for each `i` in `Fin n`, the relation `r` holds between `f(i.castSucc)` and `f(i.succ)`.\n   - The condition \"provided \\(i < j.castSucc \\rightarrow r(f(i))(f(j.castSucc))\\) also holds\" is captured by `(ihj : (fun x x_1 => x < x_1) i j.castSucc → r (f i) (f j.castSucc))`. This is a hypothesis that if `i` is less than `j.castSucc`, then `r(f(i))(f(j.castSucc))` holds.\n\n3. **Variables and Conditions**:\n   - \"If \\(i : Fin(n + 1)\\), \\(j : Fin(n)\\)\" translates to `(i : Fin (n + 1)) (j : Fin n)`. These are the indices `i` and `j` with their respective types.\n   -"}
{"source_file": "herald_data/sample_500.jsonl", "line": 269, "id": 273436, "informal_statement": "For any normed abelian group $X$, ring $M$, $M$-module $X$, and assuming the scalar multiplication is faithful, let $P, Q, R \\in M$ be elements and $x \\in X$ be a vector. Suppose $P, Q, R$ are left-projection operators on $X$. Prove that the following equality holds:\n\\[\n\\|R \\cdot P \\cdot R \\cdot x\\| + \\|(1 - R) \\cdot P \\cdot R \\cdot x\\| + \\left(\\|R \\cdot x - R \\cdot P \\cdot R \\cdot x\\| + \\|(1 - R) \\cdot R \\cdot x - (1 - R) \\cdot P \\cdot R \\cdot x\\|\\right) =\n\\]\n\\[\n\\|R \\cdot P \\cdot R \\cdot x\\| + \\|(1 - R) \\cdot P \\cdot R \\cdot x\\| + \\left(\\|R \\cdot x - R \\cdot P \\cdot R \\cdot x\\| + \\|\\left((1 - R) \\cdot R\\right) \\cdot x - (1 - R) \\cdot P \\cdot R \\cdot x\\|\\right).\n\\]", "formal_statement": "import Mathlib\n\nlemma commute_tac_4764 [NormedAddCommGroup X] [Ring M] [Module M X] [FaithfulSMul M X] (P : M) (Q : M) (h₁ : IsLprojection X P) (h₂ : IsLprojection X Q) (R : M) (h₃ : IsLprojection X R) (x : X) : ‖R • P • R • x‖ + ‖(1 - R) • P • R • x‖ + (‖R • x - R • P • R • x‖ + ‖(1 - R) • R • x - (1 - R) • P • R • x‖) =\n  ‖R • P • R • x‖ + ‖(1 - R) • P • R • x‖ + (‖R • x - R • P • R • x‖ + ‖((1 - R) * R) • x - (1 - R) • P • R • x‖) := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach, ensuring that each component of the informal statement is accurately represented in the formal language of Lean. Here's a step-by-step explanation of the translation:\n\n1. **Importing Necessary Libraries**:\n   - The statement begins with `import Mathlib`, which is necessary to access the mathematical structures and operations required for the proof. This includes norms, groups, rings, modules, and other algebraic structures.\n\n2. **Defining the Context**:\n   - The lemma is defined using `lemma commute_tac_4764`, which is a placeholder name for the lemma. This is followed by the context in square brackets, which specifies the types and properties of the objects involved:\n     - `[NormedAddCommGroup X]`: This indicates that `X` is a normed abelian group, aligning with the informal statement's requirement for a normed abelian group.\n     - `[Ring M]`: This specifies that `M` is a ring, as mentioned in the informal statement.\n     - `[Module M X]`: This indicates that `X` is an `M`-module, consistent with the informal statement.\n     - `[FaithfulSMul M X]`: This assumes that the scalar multiplication is faithful, as required.\n\n3. **Declaring Variables and Assumptions**:\n   - `(P : M) (Q : M) (h₁ : IsLprojection X P) (h₂ : IsLprojection X Q) (R : M) (h₃ : IsLprojection X R) (x : X)`: These are the variables and assumptions for the lemma:\n     - `P`, `Q`, and `R` are elements of the ring `M`, corresponding to the left-projection operators in the informal statement.\n     - `h₁`, `h₂`, and `h₃` are hypotheses stating that `P`, `Q`, and `R` are left-projection operators on `X`. This is captured by the predicate `IsLprojection X`, which is assumed to be defined elsewhere in the library.\n     - `x : X` is a vector in the module `X`.\n\n4. **Formalizing the Equality**:\n   - The main body of the lemma states the equality to be proven. The expression is a direct translation of the informal statement:\n     - `‖R • P •"}
{"source_file": "herald_data/sample_500.jsonl", "line": 267, "id": 559327, "informal_statement": "$ \\sin 2x = \\sqrt{2} \\cos x \\iff 2 \\sin x \\cos x = \\sqrt{2} \\cos x. $", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_559327 (x : ℝ) : sin (2 * x) = Real.sqrt 2 * cos x ↔ 2 * sin x * cos x = Real.sqrt 2 * cos x   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Mathematical Components**: \n   - The informal statement involves trigonometric functions: sine (`\\sin`) and cosine (`\\cos`).\n   - It also involves the square root of 2 (`\\sqrt{2}`) and a logical equivalence (`\\iff`).\n\n2. **Translate Trigonometric Functions**:\n   - In Lean, trigonometric functions like sine and cosine are represented as `sin` and `cos`, respectively. These functions are part of the `Real` namespace, which deals with real numbers.\n\n3. **Translate the Square Root**:\n   - The square root function in Lean is represented as `Real.sqrt`. This is used to denote the square root of a real number.\n\n4. **Translate the Logical Equivalence**:\n   - The logical equivalence `\\iff` is directly translated to `↔` in Lean. This symbol is used to denote that two statements are logically equivalent.\n\n5. **Structure the Theorem**:\n   - The theorem is named `extract_aug_559327`, which is a placeholder name and can be replaced with a more descriptive name if needed.\n   - The theorem takes a single argument `x` of type `ℝ`, which represents a real number. This is indicated by `(x : ℝ)`.\n\n6. **Formalize the Statement**:\n   - The left side of the equivalence `\\sin 2x = \\sqrt{2} \\cos x` is translated to `sin (2 * x) = Real.sqrt 2 * cos x`.\n   - The right side of the equivalence `2 \\sin x \\cos x = \\sqrt{2} \\cos x` is translated to `2 * sin x * cos x = Real.sqrt 2 * cos x`.\n\n7. **Combine into a Theorem**:\n   - The entire statement is then combined into a theorem using the `theorem` keyword, followed by the name, parameters, and the statement itself.\n   - The `:= by sorry` part indicates that the proof is not provided and is left as a placeholder (`sorry` is used in Lean to indicate an incomplete proof).\n\n8. **Import Necessary Modules**:\n   - The `import Mathlib` statement is used to import the necessary mathematical libraries that include definitions and theorems for real numbers, trigonometric functions"}
{"source_file": "herald_data/sample_500.jsonl", "line": 268, "id": 331973, "informal_statement": "For any $n \\in \\mathbb{N}$ and $k \\in \\mathbb{N}$, prove that \\((n + 1 - k) \\cdot (n + 1)^{\\underline{k}} = (n + 1) \\cdot n^{\\underline{k}}\\), where \\(x^{\\underline{k}}\\) denotes the falling factorial.", "formal_statement": "import Mathlib\n\ntheorem succ_descFactorial (n : ℕ) :\n    ∀ k, (n + 1 - k) * (n + 1).descFactorial k = (n + 1) * n.descFactorial k := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Mathematical Statement**:\n   - We are given a statement involving natural numbers \\( n \\) and \\( k \\).\n   - The statement involves the falling factorial, denoted as \\( x^{\\underline{k}} \\), which is a product of \\( k \\) consecutive integers starting from \\( x \\) and decreasing by 1 each step.\n   - The goal is to prove the equality \\((n + 1 - k) \\cdot (n + 1)^{\\underline{k}} = (n + 1) \\cdot n^{\\underline{k}}\\).\n\n2. **Identifying Lean4 Constructs**:\n   - In Lean, natural numbers are represented by the type `ℕ`.\n   - The falling factorial is represented by the function `descFactorial` in Lean's math library.\n\n3. **Translating the Variables**:\n   - The informal statement involves two variables \\( n \\) and \\( k \\), both of which are natural numbers. In Lean, we declare \\( n \\) as a parameter of type `ℕ` and \\( k \\) as a universally quantified variable using `∀ k`.\n\n4. **Translating the Falling Factorial**:\n   - The falling factorial \\( (n + 1)^{\\underline{k}} \\) is translated to `(n + 1).descFactorial k` in Lean.\n   - Similarly, \\( n^{\\underline{k}} \\) is translated to `n.descFactorial k`.\n\n5. **Translating the Equation**:\n   - The equation \\((n + 1 - k) \\cdot (n + 1)^{\\underline{k}} = (n + 1) \\cdot n^{\\underline{k}}\\) is directly translated to:\n     ```lean\n     (n + 1 - k) * (n + 1).descFactorial k = (n + 1) * n.descFactorial k\n     ```\n\n6. **Structuring the Theorem**:\n   - The theorem is named `succ_descFactorial`, indicating it deals with the successor (or increment) of a number in the context of the falling factorial.\n   - The theorem is stated for a fixed \\( n \\) and universally quantified over \\( k \\), which is expressed as `∀ k`."}
{"source_file": "herald_data/sample_500.jsonl", "line": 274, "id": 424444, "informal_statement": "For any real number $t$, prove that $\\lim_{x \\to \\infty} x \\cdot \\log\\left(1 + \\frac{t}{x}\\right) = t$.", "formal_statement": "import Mathlib\nopen Filter Finset Set\nopen scoped Topology\nopen Real\n/-- The function `x * log (1 + t / x)` tends to `t` at `+∞`. -/\ntheorem tendsto_mul_log_one_plus_div_atTop (t : ℝ) :\n    Tendsto (fun x => x * log (1 + t / x)) atTop (𝓝 t) := sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to break down the components of the statement and understand how they map to Lean's formal language and libraries.\n\n1. **Understanding the Informal Statement**:\n   - We are given a real number \\( t \\).\n   - We need to prove that the limit of the function \\( x \\cdot \\log\\left(1 + \\frac{t}{x}\\right) \\) as \\( x \\) approaches infinity is \\( t \\).\n\n2. **Identifying the Components**:\n   - **Real Number \\( t \\)**: In Lean, real numbers are represented by the type `ℝ`.\n   - **Function**: The function in question is \\( x \\mapsto x \\cdot \\log\\left(1 + \\frac{t}{x}\\right) \\). In Lean, this is expressed as `fun x => x * log (1 + t / x)`.\n   - **Limit**: The concept of a limit as \\( x \\to \\infty \\) is represented in Lean using the `Tendsto` predicate.\n   - **At Infinity**: The notion of \\( x \\to \\infty \\) is captured by the filter `atTop`.\n   - **Convergence to \\( t \\)**: The target of the limit, \\( t \\), is expressed using the neighborhood filter `𝓝 t`.\n\n3. **Formalizing the Statement in Lean**:\n   - **Importing Necessary Libraries**: The statement uses real numbers and limits, so we import `Mathlib` which contains the necessary definitions and theorems for real analysis.\n   - **Opening Namespaces**: We open `Filter`, `Finset`, `Set`, and use `open scoped Topology` to access topological concepts like limits.\n   - **Theorem Declaration**: We declare a theorem named `tendsto_mul_log_one_plus_div_atTop` which takes a real number `t` as an argument.\n   - **Using `Tendsto`**: The core of the formal statement is `Tendsto (fun x => x * log (1 + t / x)) atTop (𝓝 t)`, which asserts that the function tends to `t` as \\( x \\to \\infty \\).\n\n4. **Putting It All Together**:\n   - The formal statement is structured as a theorem in Lean, with"}
{"source_file": "herald_data/sample_500.jsonl", "line": 271, "id": 329450, "informal_statement": "For any elements $a, b, c$ in a modular lattice $\\alpha$ with a bottom element, if $b$ and $c$ are disjoint and $a$ is disjoint from the supremum of $b$ and $c$, then $c$ is disjoint from the supremum of $b$ and $a$.", "formal_statement": "import Mathlib\nopen Set\nlemma disjoint_sup_left_of_disjoint_sup_right_tac_15330 (a : α) (b : α) (c : α) [Lattice α] [OrderBot α] [IsModularLattice α] (h : Disjoint b c) (hsup : Disjoint a (b ⊔ c)) : Disjoint c (b ⊔ a) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: \n   - The statement involves a modular lattice with a bottom element. In Lean, this is represented by the type class `Lattice α` for the lattice structure, `OrderBot α` for the existence of a bottom element, and `IsModularLattice α` for the modular property.\n\n2. **Define the Elements and Assumptions**:\n   - The elements $a$, $b$, and $c$ are elements of the modular lattice $\\alpha$. In Lean, these are represented as variables of type `α`.\n   - The condition that $b$ and $c$ are disjoint is expressed using the `Disjoint` predicate in Lean, which is a standard way to express that two elements have a meet (infimum) equal to the bottom element.\n   - Similarly, the condition that $a$ is disjoint from the supremum of $b$ and $c$ is also expressed using the `Disjoint` predicate.\n\n3. **Express the Conclusion**:\n   - The conclusion that $c$ is disjoint from the supremum of $b$ and $a$ is again expressed using the `Disjoint` predicate.\n\n4. **Formalize the Lemma**:\n   - The lemma is named `disjoint_sup_left_of_disjoint_sup_right_tac_15330`, which is a descriptive name indicating the nature of the lemma.\n   - The lemma takes as arguments the elements $a$, $b$, and $c$, and the type class instances `Lattice α`, `OrderBot α`, and `IsModularLattice α`.\n   - The assumptions are given as `h : Disjoint b c` and `hsup : Disjoint a (b ⊔ c)`.\n   - The conclusion is `Disjoint c (b ⊔ a)`.\n\n5. **Use of `sorry`**:\n   - The `:= sorry` at the end indicates that the proof of the lemma is not provided. In Lean, `sorry` is a placeholder that allows the code to compile without a complete proof.\n\nBy following these steps, the informal statement is accurately translated into a formal Lean4 lemma, capturing the essence of the mathematical properties and relationships described."}
{"source_file": "herald_data/sample_500.jsonl", "line": 270, "id": 214185, "informal_statement": "For any monoid \\(G\\) that is also a cancellative monoid, given any two elements \\(a, b \\in G\\) and assuming for all \\(g \\in G\\), \\(g^2 = 1\\), show that \\(a \\cdot (a \\cdot b) \\cdot b = a \\cdot a \\cdot (b \\cdot b)\\).", "formal_statement": "import Mathlib\nopen scoped Classical\nopen MulOpposite in\nopen Nat in\nopen Submonoid in\nopen Finset Monoid\nlemma of_orderOf_dvd_two_tac_24584 [Monoid G] [IsCancelMul G] (a : G) (b : G) (h : ∀ (g : G), g ^ 2 = 1) : a * (a * b) * b = a * a * (b * b) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: \n   - The statement involves a monoid \\(G\\) that is also a cancellative monoid. In Lean, this is represented by `[Monoid G]` and `[IsCancelMul G]`. The `Monoid` typeclass provides the basic monoid structure (associativity, identity element), and `IsCancelMul` indicates that the monoid is cancellative, meaning that if \\(a \\cdot b = a \\cdot c\\), then \\(b = c\\) for any \\(a, b, c \\in G\\).\n\n2. **Define the Elements and Assumptions**:\n   - The elements \\(a\\) and \\(b\\) are given as arbitrary elements of the monoid \\(G\\). In Lean, these are represented as `(a : G)` and `(b : G)`.\n   - The assumption that for all \\(g \\in G\\), \\(g^2 = 1\\) is expressed as `(h : ∀ (g : G), g ^ 2 = 1)`. This is a universal quantification over all elements \\(g\\) in the monoid, stating that each element is its own inverse.\n\n3. **State the Goal**:\n   - The goal is to show that \\(a \\cdot (a \\cdot b) \\cdot b = a \\cdot a \\cdot (b \\cdot b)\\). In Lean, this is directly translated to `a * (a * b) * b = a * a * (b * b)`. The multiplication operation in Lean is denoted by `*`, and the expression is written in a straightforward manner, reflecting the associative property of the monoid.\n\n4. **Structure the Lemma**:\n   - The lemma is named `of_orderOf_dvd_two_tac_24584`, which is a unique identifier for this particular result. The name is not directly derived from the informal statement but is likely generated or chosen to fit within a larger library or context.\n   - The lemma is introduced with the keyword `lemma`, followed by the name, and then the typeclass constraints and assumptions are listed in square brackets and parentheses, respectively.\n   - The conclusion of the lemma is the equality we aim to prove, and it is followed"}
{"source_file": "herald_data/sample_500.jsonl", "line": 272, "id": 250284, "informal_statement": "For a complex shape $c$ defined over an index set $\\iota$, and for any two indices $i, j \\in \\iota$ such that $c$'s relation holds between $i$ and $j$, show that $c$'s relation also holds between $i$ and a chosen index, which is $j$ if such a $j$ exists and $i$ otherwise, i.e., $c\\text{.Rel } i \\ (\\text{if } (\\exists j, c\\text{.Rel } i \\ j) \\text{ then } j \\text{ else } i)$.", "formal_statement": "import Mathlib\nopen Classical in\nopen Classical in\nlemma next_eq'_tac_5229 (c : ComplexShape ι) (i : ι) (j : ι) (h : c.Rel i j) : c.Rel i (if h : ∃ j, c.Rel i j then h.choose else i) := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Components**: \n   - We have a complex shape `c` defined over an index set `ι`.\n   - There is a relation `c.Rel` that holds between indices in `ι`.\n   - We need to show a property about this relation for indices `i` and `j`.\n\n2. **Understand the Informal Statement**:\n   - For any two indices `i, j ∈ ι` such that `c.Rel i j` holds, we need to show that `c.Rel` also holds between `i` and a chosen index.\n   - The chosen index is `j` if there exists such a `j` for which `c.Rel i j` holds; otherwise, it is `i`.\n\n3. **Formalize the Statement in Lean**:\n   - We start by importing necessary modules, such as `Mathlib`, which might contain definitions and theorems related to complex shapes and relations.\n   - We use `open Classical` to access classical logic, which allows us to use the law of excluded middle and the axiom of choice, both of which are useful for handling existential quantifiers and making choices.\n\n4. **Define the Lemma**:\n   - We define a lemma named `next_eq'_tac_5229`.\n   - The lemma takes as parameters:\n     - `c : ComplexShape ι`: the complex shape defined over the index set `ι`.\n     - `i : ι`: an index in the set `ι`.\n     - `j : ι`: another index in the set `ι`.\n     - `h : c.Rel i j`: a hypothesis that the relation `c.Rel` holds between `i` and `j`.\n\n5. **Express the Conclusion**:\n   - The conclusion of the lemma is that `c.Rel i` holds with a chosen index.\n   - We use an `if` expression to choose the index:\n     - `if h : ∃ j, c.Rel i j then h.choose else i`\n     - This expression uses the classical choice to select `j` if there exists a `j` such that `c.Rel i j` holds. Otherwise, it defaults to `i`.\n\n6. **Use of `sorry`**:\n   - The lemma ends with `:= sorry`, indicating that the proof is not provided"}
{"source_file": "herald_data/sample_500.jsonl", "line": 277, "id": 490493, "informal_statement": "For $ x,y,z > 0$ and $ xy + xz + yz = 3$ , the following inequality holds: \\n $ \\frac {x}{\\sqrt {5x + 4y}} + \\frac {y}{\\sqrt {5y + 4z}} + \\frac {z}{\\sqrt {5z + 4x}}\\geq1$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_490493 (x y z : ℝ) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z) (hab : x * y + x * z + y * z = 3) : x / Real.sqrt (5 * x + 4 * y) + y / Real.sqrt (5 * y + 4 * z) + z / Real.sqrt (5 * z + 4 * x) >= 1  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow a structured approach to ensure that all components of the statement are accurately represented in the formal language. Here's a step-by-step explanation of the translation process:\n\n1. **Import Necessary Libraries**:\n   - The Lean code begins with `import Mathlib`, which is a common practice to include necessary mathematical libraries. This provides access to various mathematical functions and theorems.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to bring specific namespaces into the current context, allowing us to use functions and operators without prefixing them with their module names.\n\n2. **Define the Theorem**:\n   - The theorem is named `extract_aug_490493`. Naming conventions in Lean often use descriptive names or identifiers that relate to the problem or its source.\n\n3. **Specify Variables and Assumptions**:\n   - `(x y z : ℝ)` declares that `x`, `y`, and `z` are real numbers. In Lean, `ℝ` denotes the set of real numbers.\n   - `(hx : 0 < x)`, `(hy : 0 < y)`, and `(hz : 0 < z)` are hypotheses stating that `x`, `y`, and `z` are all greater than zero. This corresponds to the condition $x, y, z > 0$ in the informal statement.\n   - `(hab : x * y + x * z + y * z = 3)` is another hypothesis that translates the condition $xy + xz + yz = 3$.\n\n4. **State the Inequality**:\n   - The goal of the theorem is to prove the inequality: `x / Real.sqrt (5 * x + 4 * y) + y / Real.sqrt (5 * y + 4 * z) + z / Real.sqrt (5 * z + 4 * x) >= 1`.\n   - This directly corresponds to the informal inequality $\\frac{x}{\\sqrt{5x + 4y}} + \\frac{y}{\\sqrt{5y + 4z}} + \\frac{z}{\\sqrt{5z + 4x}} \\geq 1$.\n   - `Real.sqrt` is used to denote the square root function, ensuring that the expression under the square root is correctly interpreted as a real number operation"}
{"source_file": "herald_data/sample_500.jsonl", "line": 275, "id": 137239, "informal_statement": "For any natural numbers $m$ and $n$, show that $m < n$ if and only if $m + 1 \\leq n$.", "formal_statement": "import Mathlib\nopen Function\nlemma lt_iff_add_one_le_tac_4535 (m : ℕ) (n : ℕ) : m < n ↔ m + 1 ≤ n := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we follow these steps:\n\n1. **Identify the Domain**: The informal statement involves natural numbers, which in Lean are represented by the type `ℕ`.\n\n2. **Quantifiers**: The phrase \"For any natural numbers $m$ and $n$\" indicates universal quantification over two variables, `m` and `n`. In Lean, this is expressed by introducing these variables as arguments to the lemma: `(m : ℕ) (n : ℕ)`.\n\n3. **Logical Structure**: The statement \"show that $m < n$ if and only if $m + 1 \\leq n$\" is a biconditional, which in Lean is represented by the logical connective `↔`.\n\n4. **Inequalities**: The informal statement uses the inequalities `$m < n$` and `$m + 1 \\leq n$`. In Lean, these are expressed using the operators `<` and `≤`, respectively.\n\n5. **Constructing the Lemma**: Combining all these elements, we construct a lemma in Lean. The lemma is named `lt_iff_add_one_le_tac_4535`, which is a placeholder name and can be replaced with a more descriptive one if desired. The lemma states that for natural numbers `m` and `n`, the proposition `m < n` is equivalent to `m + 1 ≤ n`.\n\n6. **Formal Statement**: The complete formal statement in Lean is:\n   ```lean\n   lemma lt_iff_add_one_le_tac_4535 (m : ℕ) (n : ℕ) : m < n ↔ m + 1 ≤ n := sorry\n   ```\n   Here, `sorry` is a placeholder indicating that the proof is not yet provided.\n\n7. **Imports and Namespace**: The line `import Mathlib` is included to ensure that all necessary mathematical definitions and theorems are available. `open Function` is included to make function-related definitions and theorems more accessible, although it is not directly used in this lemma.\n\nBy following these steps, we have translated the informal mathematical statement into a formal statement in Lean4."}
{"source_file": "herald_data/sample_500.jsonl", "line": 273, "id": 278521, "informal_statement": "For any element \\(a\\) in a group \\(α\\) equipped with a linear order and satisfying the covariant class axiom for multiplication and order, show that the multiplicative inverse of the absolute value of \\(a\\), denoted as \\((\\lvert a \\rvert)^{-1}\\), is less than or equal to \\(a\\), i.e., \\((\\lvert a \\rvert)^{-1} \\leq a\\).", "formal_statement": "import Mathlib\nopen Function\nlemma inv_mabs_le_tac_9135 [Group α] [LinearOrder α] [CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] (a : α) : (mabs a)⁻¹ ≤ a := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: \n   - The statement involves a group \\(α\\) with a linear order. In Lean, this is represented by `[Group α]` and `[LinearOrder α]`. These are typeclass instances that provide the necessary algebraic and order-theoretic structure to the type \\(α\\).\n\n2. **Covariant Class Axiom**:\n   - The statement mentions that the group satisfies the covariant class axiom for multiplication and order. In Lean, this is expressed using `[CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]`. This typeclass ensures that multiplication in the group is compatible with the order, meaning if \\(x \\leq y\\), then \\(a * x \\leq a * y\\) for all \\(a\\).\n\n3. **Element and Absolute Value**:\n   - The element \\(a\\) in the group is represented as `(a : α)`. The absolute value of \\(a\\), denoted \\(\\lvert a \\rvert\\), is represented by `mabs a` in Lean. This assumes that `mabs` is a function defined elsewhere in the context to compute the absolute value in the group.\n\n4. **Multiplicative Inverse and Inequality**:\n   - The multiplicative inverse of the absolute value, \\((\\lvert a \\rvert)^{-1}\\), is written as `(mabs a)⁻¹` in Lean. The inequality \\((\\lvert a \\rvert)^{-1} \\leq a\\) is directly translated to `(mabs a)⁻¹ ≤ a`.\n\n5. **Lemma Declaration**:\n   - The entire statement is encapsulated in a lemma named `inv_mabs_le_tac_9135`. The name is arbitrary and likely generated to be unique. The lemma is declared with the keyword `lemma`, followed by the name, the typeclass constraints, the element \\(a\\), and the statement of the inequality.\n\n6. **Proof Placeholder**:\n   - The `:= sorry` at the end indicates that the proof of the lemma is not provided. In Lean, `sorry` is a placeholder that allows the code to compile without a complete proof.\n\nBy following these"}
{"source_file": "herald_data/sample_500.jsonl", "line": 276, "id": 314573, "informal_statement": "For any function \\( f: \\alpha \\to \\beta \\) and any set \\( s \\subseteq \\beta \\), show that the complement of the range of \\( f \\) is a subset of \\( s \\) if and only if the complement of the range of \\( f \\) is a subset of \\( s \\).", "formal_statement": "import Mathlib\nopen Function Set\nlemma kernImage_preimage_eq_iff_tac_5032 (f : α → β) (s : Set β) : (range f)ᶜ ⊆ s ↔ (range f)ᶜ ⊆ s := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Components**: \n   - We have a function \\( f: \\alpha \\to \\beta \\).\n   - We have a set \\( s \\subseteq \\beta \\).\n   - We are dealing with the complement of the range of \\( f \\).\n\n2. **Understand the Informal Statement**:\n   - The statement is essentially a tautology: \"the complement of the range of \\( f \\) is a subset of \\( s \\) if and only if the complement of the range of \\( f \\) is a subset of \\( s \\)\". This is trivially true because it is stating the same thing on both sides of the \"if and only if\" (↔).\n\n3. **Formalize the Components in Lean**:\n   - The function \\( f: \\alpha \\to \\beta \\) is directly represented as `f : α → β` in Lean.\n   - The set \\( s \\subseteq \\beta \\) is represented as `s : Set β` in Lean.\n   - The range of \\( f \\) is represented as `range f` in Lean, using the `range` function from the `Function` module.\n   - The complement of the range of \\( f \\) is represented as `(range f)ᶜ` in Lean, where `ᶜ` denotes the complement operation from the `Set` module.\n\n4. **Construct the Logical Statement**:\n   - The statement \"the complement of the range of \\( f \\) is a subset of \\( s \\)\" is expressed as `(range f)ᶜ ⊆ s` in Lean.\n   - The tautological nature of the statement is captured by the equivalence `(range f)ᶜ ⊆ s ↔ (range f)ᶜ ⊆ s`.\n\n5. **Write the Lean Lemma**:\n   - The lemma is named `kernImage_preimage_eq_iff_tac_5032`, which is a placeholder name and not particularly descriptive.\n   - The lemma takes the function `f` and the set `s` as parameters.\n   - The statement of the lemma is the tautology `(range f)ᶜ ⊆ s ↔ (range f)ᶜ ⊆ s`.\n   - The proof is left as `sorry`,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 279, "id": 76069, "informal_statement": "For any type \\(\\alpha\\) and any natural number \\(n\\), the function that drops the \\(n+1\\)th element from the diagonal function on \\(\\alpha^{n+1}\\) is equal to the diagonal function on \\(\\alpha^n\\), i.e., \\(\\text{dropFun}(\\text{diag}_{\\alpha^{n+1}}) = \\text{diag}_{\\alpha^n}\\).", "formal_statement": "import Mathlib\nopen MvFunctor\nopen Nat\nopen Function (uncurry)\ntheorem dropFun_diag_extracted {n : ℕ} {α : TypeVec.{u_1} (n + 1)} : TypeVec.dropFun TypeVec.prod.diag = TypeVec.prod.diag := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand the components involved and how they relate to each other in both the informal and formal contexts.\n\n1. **Understanding the Informal Statement:**\n   - We are dealing with a type \\(\\alpha\\) and natural number \\(n\\).\n   - The statement involves a function that drops the \\(n+1\\)th element from a diagonal function on \\(\\alpha^{n+1}\\).\n   - The diagonal function on \\(\\alpha^{n+1}\\) maps a single element of type \\(\\alpha\\) to a tuple where each element is that same element of type \\(\\alpha\\).\n   - The goal is to show that dropping the last element from this tuple results in the diagonal function on \\(\\alpha^n\\).\n\n2. **Identifying Components in Lean:**\n   - `TypeVec` is a construct in Lean that represents a vector of types. `TypeVec.{u_1} (n + 1)` represents a vector of \\(n+1\\) types, each being \\(\\alpha\\).\n   - `TypeVec.prod.diag` is the diagonal function for a type vector, which takes an element and replicates it across all positions in the vector.\n   - `TypeVec.dropFun` is a function that removes the last element from a type vector.\n\n3. **Formalizing the Statement:**\n   - The theorem `dropFun_diag_extracted` is parameterized by a natural number `n` and a type vector `α` of length `n + 1`.\n   - The goal is to prove that applying `TypeVec.dropFun` to `TypeVec.prod.diag` results in `TypeVec.prod.diag` for a type vector of length `n`.\n\n4. **Translation Steps:**\n   - **Type and Function Definitions:** The type vector `α` is defined as `TypeVec.{u_1} (n + 1)`, which corresponds to \\(\\alpha^{n+1}\\) in the informal statement.\n   - **Diagonal Function:** `TypeVec.prod.diag` corresponds to the diagonal function on \\(\\alpha^{n+1}\\), which creates a tuple of length `n + 1` with identical elements.\n   - **Drop Function:** `TypeVec.dropFun` is the function that removes the last element from this tuple, effectively reducing the tuple to length `n"}
{"source_file": "herald_data/sample_500.jsonl", "line": 278, "id": 331750, "informal_statement": "For any scalar multiplications $M \\acts \\alpha$ and $N \\acts \\beta$, prove that a commutative scalar multiplication class $M \\acts N (\\alpha \\to \\beta)$ exists for functions from $\\alpha$ to $\\beta$.", "formal_statement": "import Mathlib\nopen Function\n@[to_additive]\ninstance [SMul M α] [SMul N β] : SMulCommClass Mᵈᵐᵃ N (α → β) := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand the components involved in both the informal and formal statements and how they correspond to each other.\n\n1. **Understanding the Informal Statement:**\n   - The statement involves scalar multiplications denoted by $M \\acts \\alpha$ and $N \\acts \\beta$. Here, $M$ and $N$ are types that act as scalars on the types $\\alpha$ and $\\beta$, respectively.\n   - The goal is to prove the existence of a commutative scalar multiplication class for functions from $\\alpha$ to $\\beta$, denoted as $M \\acts N (\\alpha \\to \\beta)$.\n\n2. **Lean4 Code Components:**\n   - `import Mathlib`: This imports the Mathlib library, which contains various mathematical structures and theorems that can be used in Lean.\n   - `open Function`: This opens the `Function` namespace, allowing us to use function-related definitions and theorems without prefixing them with `Function.`.\n   - `@[to_additive]`: This attribute is used to automatically generate the additive version of the multiplicative structure being defined. It is not directly related to the core translation but is useful for handling analogous additive structures.\n   - `instance [SMul M α] [SMul N β]`: This declares an instance of a type class. Here, `[SMul M α]` and `[SMul N β]` are type class constraints indicating that $M$ acts as a scalar on $\\alpha$ and $N$ acts as a scalar on $\\beta$.\n   - `: SMulCommClass Mᵈᵐᵃ N (α → β)`: This specifies the type class instance being defined. `SMulCommClass` is a type class that captures the commutativity of scalar multiplication. `Mᵈᵐᵃ` is a notation indicating that $M$ acts distributively on the function space, and `N` acts on the codomain $\\beta$ of the function space $\\alpha \\to β$.\n\n3. **Translation Process:**\n   - The informal statement mentions scalar multiplications $M \\acts \\alpha$ and $N \\acts \\beta$. In Lean, these are represented by the type class constraints `[SMul M α]` and `[SMul N β]`.\n   - The goal is to"}
{"source_file": "herald_data/sample_500.jsonl", "line": 285, "id": 223512, "informal_statement": "For any function $f$ from $\\alpha$ to $\\beta$, show that the preimage function induced by $f$ is injective if and only if $f$ is surjective.", "formal_statement": "import Mathlib\nopen Function Set\nopen scoped symmDiff in\nopen scoped symmDiff in\nopen scoped symmDiff in\nopen Set\nopen Set\nopen Function\nlemma preimage_injective_tac_50554 (f : α → β) : Injective (preimage f) ↔ Surjective f := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand the components involved and how they relate to each other in both the informal and formal contexts.\n\n1. **Understanding the Informal Statement**:\n   - We are given a function \\( f : \\alpha \\to \\beta \\).\n   - We need to show a relationship between the injectivity of the preimage function induced by \\( f \\) and the surjectivity of \\( f \\).\n   - The preimage function, for a function \\( f : \\alpha \\to \\beta \\), maps subsets of \\(\\beta\\) to subsets of \\(\\alpha\\) by taking the preimage of each subset under \\( f \\).\n\n2. **Formalizing the Components**:\n   - **Function \\( f \\)**: In Lean, this is represented as `f : α → β`, where `α` and `β` are types.\n   - **Preimage Function**: In Lean, the preimage of a set under a function \\( f \\) is represented by `preimage f`. This is a function from subsets of `β` to subsets of `α`.\n   - **Injective Preimage Function**: The statement \"the preimage function is injective\" means that if two subsets of `β` have the same preimage under \\( f \\), then the subsets themselves must be equal. This is expressed in Lean as `Injective (preimage f)`.\n   - **Surjective Function**: A function \\( f \\) is surjective if for every element in `β`, there is a corresponding element in `α` that maps to it. In Lean, this is expressed as `Surjective f`.\n\n3. **Constructing the Formal Statement**:\n   - The goal is to show an equivalence: the preimage function being injective is equivalent to \\( f \\) being surjective.\n   - In Lean, equivalence is expressed using the logical biconditional `↔`.\n   - Therefore, the formal statement is `Injective (preimage f) ↔ Surjective f`.\n\n4. **Lean Code Explanation**:\n   - `import Mathlib`: This imports the mathematical library in Lean, which contains definitions and theorems related to functions, sets, and other mathematical structures.\n   - `open Function Set`: This makes the definitions and theorems related to functions and sets available without needing to prefix them with `Function"}
{"source_file": "herald_data/sample_500.jsonl", "line": 284, "id": 574907, "informal_statement": "Let $ a_{1}$ , $ a_{2}$ , ..., $ a_{2007}$ be real numbers such that $ a_{1}+a_{2}+...+a_{2007}\\geq2007^{2}$ and $ a_{1}^{2}+a_{2}^{2}+...+a_{2007}^{2}\\leq2007^{3}-1$ . Prove that $ a_{k}\\in[2006;2008]$ for all $ k\\in{1,2,...,2007}$ .", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_574907 (a : ℕ → ℝ) (h₁ : ∑ i in Finset.range 2007, a i ≥ (2007 : ℝ)^2) (h₂ : ∑ i in Finset.range 2007, (a i)^2 ≤ (2007 : ℝ)^3 - 1) : ∀ i ∈ Finset.range 2007, (2006 : ℝ) ≤ a i ∧ a i ≤ (2008 : ℝ)   :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach to formalize each component of the problem. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context**:\n   - We are dealing with a sequence of real numbers \\( a_1, a_2, \\ldots, a_{2007} \\).\n   - We have two conditions on these numbers: a sum condition and a sum of squares condition.\n   - We need to prove a bound on each individual number in the sequence.\n\n2. **Setting Up the Environment**:\n   - We import necessary modules from Lean's math library. Specifically, `Mathlib` for general mathematical functions, `BigOperators` for handling summations, and `Real`, `Nat`, `Topology` for dealing with real numbers, natural numbers, and topological properties, respectively.\n\n3. **Defining the Variables**:\n   - We define `a` as a function from natural numbers to real numbers, `a : ℕ → ℝ`, representing the sequence \\( a_1, a_2, \\ldots, a_{2007} \\).\n\n4. **Formalizing the Conditions**:\n   - The first condition \\( a_1 + a_2 + \\ldots + a_{2007} \\geq 2007^2 \\) is expressed using Lean's summation notation: `∑ i in Finset.range 2007, a i ≥ (2007 : ℝ)^2`.\n     - `Finset.range 2007` generates the set \\(\\{0, 1, \\ldots, 2006\\}\\), which corresponds to indices \\(1\\) to \\(2007\\) in informal terms.\n     - `∑ i in Finset.range 2007, a i` computes the sum of the sequence from \\(a_0\\) to \\(a_{2006}\\), which corresponds to \\(a_1\\) to \\(a_{2007}\\) in informal terms.\n     - `(2007 : ℝ)^2` ensures that the number \\(2007\\) is treated as a real number before squaring.\n\n   - The second condition \\( a_1^2 + a_2^2 + \\ldots + a_{2007}^2 \\leq 2007^3 - 1 \\) is similarly expressed: `∑ i"}
{"source_file": "herald_data/sample_500.jsonl", "line": 280, "id": 9767, "informal_statement": "For any subset $s$ of a module over a ring $R$, and any submodule $p$ of the same module, if $s$ is contained in $p$ and $p$ is contained in the submodule spanned by $s$, show that the submodule spanned by $s$ is equal to $p$, i.e., $\\text{span}_R(s) = p$.", "formal_statement": "import Mathlib\nopen Function Set\nopen Pointwise\ntheorem span_eq_of_le_extracted [Semiring R] [AddCommMonoid M] [Module R M] (p : Submodule R M)\n {s : Set M} : s ⊆ ↑p → p ≤ Submodule.span R s → Submodule.span R s = p := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to carefully consider the components involved and how they map to Lean's formal language. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context**:\n   - We are dealing with modules over a ring \\( R \\). In Lean, this requires the use of type classes for rings and modules.\n   - We have a subset \\( s \\) of a module and a submodule \\( p \\) of the same module. Lean represents submodules using the `Submodule` type.\n\n2. **Setting Up the Environment**:\n   - We import necessary modules from Lean's math library, such as `Mathlib`, which contains definitions and theorems for algebraic structures.\n   - We open namespaces like `Function`, `Set`, and `Pointwise` to access relevant functions and operations without needing to prefix them.\n\n3. **Defining the Theorem**:\n   - We declare a theorem named `span_eq_of_le_extracted`. This name is descriptive of the result we want to prove: the equality of the span and the submodule under certain conditions.\n\n4. **Specifying Type Classes**:\n   - `[Semiring R]` indicates that \\( R \\) is a semiring, which is a necessary condition for defining a module over \\( R \\).\n   - `[AddCommMonoid M]` specifies that \\( M \\) is an additive commutative monoid, a requirement for it to be a module.\n   - `[Module R M]` asserts that \\( M \\) is a module over the ring \\( R \\).\n\n5. **Parameters of the Theorem**:\n   - `(p : Submodule R M)` declares \\( p \\) as a submodule of \\( M \\).\n   - `{s : Set M}` introduces \\( s \\) as a subset of \\( M \\). The curly braces `{}` indicate that \\( s \\) is an implicit argument, which Lean can infer from context.\n\n6. **Formalizing the Hypotheses**:\n   - `s ⊆ ↑p` translates the condition that the subset \\( s \\) is contained in the submodule \\( p \\). In Lean, `↑p` is the coercion of the submodule \\( p \\) to a set, allowing us to use set operations.\n   - `p ≤ Submodule.span R s` expresses that the submodule \\( p \\)"}
{"source_file": "herald_data/sample_500.jsonl", "line": 283, "id": 76822, "informal_statement": "For any multisets $m_1$ and $m_2$ over a type $\\alpha$, the following are equivalent: the enumeration of $m_1$ as a finite set is a subset of the enumeration of $m_2$ as a finite set if and only if $m_1$ is a submultiset of $m_2$.", "formal_statement": "import Mathlib\n\ntheorem toEnumFinset_subset_iff_extracted [DecidableEq α] {m₁ m₂ : Multiset α} : m₁.toEnumFinset ⊆ m₂.toEnumFinset ↔ m₁ ≤ m₂ := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to understand the components involved and how they relate to each other in both the informal and formal contexts.\n\n1. **Understanding Multisets and Finite Sets**:\n   - A multiset is a generalization of a set that allows for multiple occurrences of the same element. In Lean, `Multiset α` represents a multiset over a type `α`.\n   - A finite set, or `Finset` in Lean, is a set with a finite number of elements, where each element is unique.\n\n2. **Informal Statement Breakdown**:\n   - The statement involves two multisets, `m₁` and `m₂`, and discusses their relationship in terms of subsets and submultisets.\n   - The enumeration of a multiset as a finite set refers to converting the multiset into a set where each element appears only once, effectively removing duplicates.\n\n3. **Formalizing the Informal Statement**:\n   - The informal statement claims an equivalence: the enumeration of `m₁` as a finite set being a subset of the enumeration of `m₂` as a finite set is equivalent to `m₁` being a submultiset of `m₂`.\n\n4. **Lean4 Code Explanation**:\n   - `import Mathlib`: This imports the necessary mathematical library in Lean, which includes definitions and theorems related to multisets and finite sets.\n   - `theorem toEnumFinset_subset_iff_extracted`: This is the name of the theorem being defined. It suggests that the theorem is about the subset relationship of enumerated finite sets.\n   - `[DecidableEq α]`: This is a type class constraint indicating that equality on type `α` is decidable. This is necessary for operations like checking subset relations on finite sets.\n   - `{m₁ m₂ : Multiset α}`: These are the multisets involved in the theorem, specified as parameters.\n   - `m₁.toEnumFinset ⊆ m₂.toEnumFinset`: This part of the statement checks if the finite set enumeration of `m₁` is a subset of that of `m₂`. The function `toEnumFinset` converts a multiset to a finite set by removing duplicates.\n   - `↔ m₁ ≤ m₂`: This states the equivalence. The symbol `≤` in the context"}
{"source_file": "herald_data/sample_500.jsonl", "line": 282, "id": 104841, "informal_statement": "For any element \\( x \\) in a group \\( \\alpha \\), show that the function defined by \\( g \\mapsto x \\cdot g \\cdot x^{-1} \\) is injective.", "formal_statement": "import Mathlib\n\ntheorem conj_injective_extracted [Group α] {x : α} : Function.Injective fun g => x * g * x⁻¹ := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: The statement involves a group \\( \\alpha \\) and an element \\( x \\) in this group. In Lean, groups are typically represented using type classes, and elements of the group are of a certain type, here denoted as \\( \\alpha \\).\n\n2. **Use of Type Classes**: The Lean code uses `[Group α]` to indicate that \\( \\alpha \\) is a type with a group structure. This is a type class constraint that provides access to group operations like multiplication and inversion.\n\n3. **Element Declaration**: The element \\( x \\) is declared as `{x : α}`. The curly braces indicate that \\( x \\) is an implicit argument, meaning it can be inferred from context when the theorem is used.\n\n4. **Function Definition**: The function described in the informal statement is \\( g \\mapsto x \\cdot g \\cdot x^{-1} \\). In Lean, this is expressed as `fun g => x * g * x⁻¹`. The `fun` keyword is used to define an anonymous function, where `g` is the input and `x * g * x⁻¹` is the output.\n\n5. **Injectivity Statement**: The goal is to show that this function is injective. In Lean, injectivity of a function is expressed using `Function.Injective`. Therefore, `Function.Injective fun g => x * g * x⁻¹` states that the function is injective.\n\n6. **Theorem Declaration**: The entire statement is wrapped in a theorem declaration. `theorem conj_injective_extracted` is the name of the theorem. The `:= sorry` part is a placeholder indicating that the proof is not yet provided.\n\n7. **Importing Necessary Libraries**: The statement begins with `import Mathlib`, which is necessary to access the definitions and theorems related to groups and functions, such as `Group` and `Function.Injective`.\n\nBy following these steps, the informal mathematical statement is translated into a precise formal statement in Lean4, capturing the essence of the problem and setting up the framework for proving the injectivity of the given function."}
{"source_file": "herald_data/sample_500.jsonl", "line": 281, "id": 491610, "informal_statement": "Let $a,b,c$ be positive real numbers such that $\\frac{1}{1+b+c}+\\frac{1}{1+c+a}+\\frac{1}{1+a+b}= 1$ . Prove that $$abc\\leq 1$$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_491610 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : (1 / (1 + b + c) + 1 / (1 + c + a) + 1 / (1 + a + b) = 1 → a * b * c ≤ 1)  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves three variables \\(a\\), \\(b\\), and \\(c\\), which are specified as positive real numbers. In Lean, real numbers are represented by the type `ℝ`.\n\n2. **Express the Positivity Condition**:\n   - The condition that \\(a\\), \\(b\\), and \\(c\\) are positive is expressed in Lean using inequalities. Specifically, `0 < a`, `0 < b`, and `0 < c` are used to denote that each of these variables is greater than zero.\n\n3. **Translate the Given Equation**:\n   - The equation \\(\\frac{1}{1+b+c}+\\frac{1}{1+c+a}+\\frac{1}{1+a+b} = 1\\) is directly translated into Lean using the division operator `/` and the addition operator `+`. The expression becomes `1 / (1 + b + c) + 1 / (1 + c + a) + 1 / (1 + a + b) = 1`.\n\n4. **Formulate the Conclusion**:\n   - The conclusion \\(abc \\leq 1\\) is translated into Lean as `a * b * c ≤ 1`, using the multiplication operator `*` and the less than or equal to operator `≤`.\n\n5. **Structure the Theorem**:\n   - The theorem is structured to take the variables \\(a\\), \\(b\\), and \\(c\\) as inputs, along with their positivity conditions. The implication is then expressed using the `→` symbol, which denotes logical implication in Lean.\n\n6. **Combine Everything into a Theorem**:\n   - The entire statement is wrapped into a Lean theorem declaration. The theorem is named `extract_aug_491610`, and it takes the form:\n     ```lean\n     theorem extract_aug_491610 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : \n       (1 / (1 + b + c) + 1 / (1 + c + a) + 1 / (1 + a + b) = 1 → a * b * c ≤ 1) := by sorry\n     ```\n   - Here"}
{"source_file": "herald_data/sample_500.jsonl", "line": 286, "id": 541589, "informal_statement": "From Cauchy Schwarz we have the desired result \\n $({a^2} + ab + {b^2})({a^2} + ac + {c^2}) = \\left[ {{{\\left( {a + \\frac{b}{2}} \\right)}^2} + \\frac{{3{b^2}}}{4}} \\right]\\left[ {{{\\left( {a + \\frac{c}{2}} \\right)}^2} + \\frac{{3{c^2}}}{4}} \\right] \\ge {\\left[ {\\left( {a + \\frac{b}{2}} \\right)\\left( {a + \\frac{c}{2}} \\right) + \\frac{{3bc}}{4}} \\right]^2} = {\\left( {{a^2} + \\frac{{a(b + c)}}{2} + bc} \\right)^2}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_541589 (a b c : ℝ) :\n  (a^2 + a * b + b^2) * (a^2 + a * c + c^2) ≥ (a^2 + a * (b + c) / 2 + b * c)^2   :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4 code, we need to follow a structured approach to ensure that each component of the informal statement is accurately represented in the formal language of Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves three variables: \\(a\\), \\(b\\), and \\(c\\). These are real numbers, which in Lean are represented by the type `ℝ`.\n\n2. **Understand the Mathematical Expression**:\n   - The informal statement involves an inequality derived from the Cauchy-Schwarz inequality. The expression on the left-hand side is \\((a^2 + ab + b^2)(a^2 + ac + c^2)\\).\n   - The right-hand side of the inequality is \\((a^2 + \\frac{a(b+c)}{2} + bc)^2\\).\n\n3. **Translate the Mathematical Operations**:\n   - In Lean, addition is represented by `+`, multiplication by `*`, and exponentiation by `^`.\n   - The expression \\((a^2 + ab + b^2)\\) is translated to `a^2 + a * b + b^2`.\n   - Similarly, \\((a^2 + ac + c^2)\\) becomes `a^2 + a * c + c^2`.\n   - The right-hand side \\((a^2 + \\frac{a(b+c)}{2} + bc)^2\\) is translated to `(a^2 + a * (b + c) / 2 + b * c)^2`.\n\n4. **Formulate the Inequality**:\n   - The inequality \\((a^2 + ab + b^2)(a^2 + ac + c^2) \\ge (a^2 + \\frac{a(b+c)}{2} + bc)^2\\) is directly translated to `(a^2 + a * b + b^2) * (a^2 + a * c + c^2) ≥ (a^2 + a * (b + c) / 2 + b * c)^2`.\n\n5. **Structure the Theorem in Lean**:\n   - The theorem is named `extract_aug_541589`, which is a unique identifier for this specific result.\n   - The theorem statement begins with the keyword `theorem`, followed"}
{"source_file": "herald_data/sample_500.jsonl", "line": 287, "id": 278086, "informal_statement": "For any field \\( K \\) of characteristic \\( p \\) where \\( p \\) is a natural number, there exists a natural number \\( n \\) such that \\( p \\) is prime and \\( q = p^n \\), where \\( q \\) is the cardinality of \\( K \\).", "formal_statement": "import Mathlib\nopen Finset\nopen scoped Polynomial\nopen Polynomial\nlemma card_tac_9903 [Field K] (p : ℕ) [CharP K p] : ∃ n, Nat.Prime p ∧ q = p ^ ↑n := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal Lean code.\n\n1. **Field \\( K \\) of characteristic \\( p \\):**\n   - In Lean, a field is represented by a type `K` with the typeclass `[Field K]`. This indicates that `K` is a field.\n   - The characteristic of a field is specified using the typeclass `[CharP K p]`, where `p` is a natural number. This means that the field `K` has characteristic `p`.\n\n2. **\\( p \\) is a natural number:**\n   - In Lean, natural numbers are represented by the type `ℕ`. The variable `p` is explicitly declared as a natural number with `(p : ℕ)`.\n\n3. **There exists a natural number \\( n \\):**\n   - The existential quantifier \"there exists\" is represented in Lean by `∃`. The statement `∃ n` indicates that there exists a natural number `n`.\n\n4. **\\( p \\) is prime:**\n   - In Lean, the primality of a natural number is expressed using `Nat.Prime p`. This asserts that `p` is a prime number.\n\n5. **\\( q = p^n \\), where \\( q \\) is the cardinality of \\( K \\):**\n   - The cardinality of a field `K` is not directly expressed in the given Lean code snippet. However, the statement `q = p ^ ↑n` suggests that `q` is intended to be the cardinality of `K`, and it is expressed as `p` raised to the power of `n`.\n   - The expression `p ^ ↑n` uses the `^` operator for exponentiation, and `↑n` indicates that `n` is being coerced to a type compatible with exponentiation, likely an integer or a natural number.\n\n6. **Overall structure:**\n   - The lemma is named `card_tac_9903`, which is a placeholder name for the statement being proven.\n   - The `: sorry` at the end indicates that the proof of this lemma is not provided, and `sorry` is a placeholder for an incomplete proof in Lean.\n\nIn summary, the Lean code formalizes the informal statement by defining a field `K` with characteristic `p`, asserting the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 288, "id": 138894, "informal_statement": "For any function $f: \\alpha \\to \\beta$, any set $s \\subseteq \\beta$, and given that the image of the preimage of $s$ under $f$ is equal to $s$ itself, show that the image of the preimage of $s$ is a subset of the range of $f$. In symbols, if $f(f^{-1}(s)) = s$, then $f(f^{-1}(s)) \\subseteq \\text{range}(f)$.", "formal_statement": "import Mathlib\nopen Function Set\nopen scoped symmDiff in\nopen scoped symmDiff in\nopen scoped symmDiff in\nlemma image_preimage_eq_iff_tac_27008 (f : α → β) (s : Set β) (h : f '' (f ⁻¹' s) = s) : f '' (f ⁻¹' s) ⊆ range f := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to break down the components of the statement and understand how they map to Lean's syntax and semantics.\n\n1. **Understanding the Components:**\n   - We have a function \\( f: \\alpha \\to \\beta \\).\n   - We have a set \\( s \\subseteq \\beta \\).\n   - The image of the preimage of \\( s \\) under \\( f \\) is denoted as \\( f(f^{-1}(s)) \\).\n   - The range of \\( f \\) is denoted as \\(\\text{range}(f)\\).\n\n2. **Formalizing the Given Condition:**\n   - The condition given is \\( f(f^{-1}(s)) = s \\). In Lean, the image of the preimage is expressed using `f '' (f ⁻¹' s)`, where `''` denotes the image and `⁻¹'` denotes the preimage.\n   - This condition is represented in Lean as `h : f '' (f ⁻¹' s) = s`.\n\n3. **Formalizing the Conclusion:**\n   - We need to show that \\( f(f^{-1}(s)) \\subseteq \\text{range}(f) \\).\n   - In Lean, this is expressed as `f '' (f ⁻¹' s) ⊆ range f`, where `⊆` denotes the subset relation.\n\n4. **Structuring the Lean Lemma:**\n   - We start by importing necessary modules with `import Mathlib` to access mathematical functions and set operations.\n   - We open the `Function` and `Set` namespaces to use functions and set operations without prefixing them.\n   - We define a lemma named `image_preimage_eq_iff_tac_27008` which takes:\n     - A function `f : α → β`.\n     - A set `s : Set β`.\n     - A hypothesis `h : f '' (f ⁻¹' s) = s`.\n   - The goal of the lemma is to prove `f '' (f ⁻¹' s) ⊆ range f`.\n\n5. **Understanding the Proof Obligation:**\n   - The lemma states that under the hypothesis `h`, the image of the preimage of `s` is a subset of the range of `f`.\n   - The proof is left as `sorry`, indicating that the proof needs to"}
{"source_file": "herald_data/sample_500.jsonl", "line": 291, "id": 256154, "informal_statement": "For any uniform space $\\alpha$, a sequence $s: \\mathbb{N} \\to \\alpha$, assuming $s$ is a Cauchy sequence, an entourage $a$ in the uniform structure of $\\alpha$, and for any natural numbers $n$ and $m$, if for all natural numbers $k$ and $l$ greater than or equal to $n$, the pair $(s k, s l)$ is in $a$, show that there exists a natural number $i$ less than or equal to $n$ such that $s m$ is in the set of all $x$ for which $(x, s i)$ is in $a$.", "formal_statement": "import Mathlib\nopen Filter Function TopologicalSpace Topology Set UniformSpace Uniformity\nlemma totallyBounded_range_tac_33066 (uniformSpace : UniformSpace α) (s : ℕ → α) (hs : CauchySeq s) (a : Set (α × α)) (ha : a ∈ 𝓤 α) (n : ℕ) (hn : ∀ k ≥ n, ∀ l ≥ n, (s k, s l) ∈ a) (m : ℕ) : ∃ i, ∃ (_ : i ∈ {k | k ≤ n}), s m ∈ {x | (x, s i) ∈ a} := sorry", "explanation": "To translate the given informal mathematical statement into Lean4 code, we need to carefully map each component of the statement to its formal counterpart in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Uniform Space and Sequence**:\n   - The informal statement begins with \"For any uniform space $\\alpha$,\" which corresponds to declaring a type `α` with a `UniformSpace` structure in Lean. This is done by `(uniformSpace : UniformSpace α)`.\n   - The sequence $s: \\mathbb{N} \\to \\alpha$ is represented as a function `s : ℕ → α` in Lean.\n\n2. **Cauchy Sequence**:\n   - The assumption that $s$ is a Cauchy sequence is expressed by the hypothesis `(hs : CauchySeq s)`. `CauchySeq` is a predicate in Lean that checks if a sequence is Cauchy in the context of a uniform space.\n\n3. **Entourage in the Uniform Structure**:\n   - An entourage $a$ in the uniform structure of $\\alpha$ is represented by a set of pairs `(a : Set (α × α))`.\n   - The condition that $a$ is an entourage is expressed by `(ha : a ∈ 𝓤 α)`, where `𝓤 α` denotes the uniformity filter on `α`.\n\n4. **Natural Numbers and Pair Condition**:\n   - The natural numbers $n$ and $m$ are directly represented as `n : ℕ` and `m : ℕ`.\n   - The condition \"for all natural numbers $k$ and $l$ greater than or equal to $n$, the pair $(s k, s l)$ is in $a$\" is formalized as `(hn : ∀ k ≥ n, ∀ l ≥ n, (s k, s l) ∈ a)`. This uses universal quantification over `k` and `l` with the condition `k ≥ n` and `l ≥ n`.\n\n5. **Existence of a Natural Number $i$**:\n   - The goal is to show the existence of a natural number $i$ such that $i \\leq n$ and $s m$ is in the set of all $x$ for which $(x, s i) \\in a$.\n   - This is expressed in Lean as `∃ i, ∃"}
{"source_file": "herald_data/sample_500.jsonl", "line": 293, "id": 298834, "informal_statement": "For any polynomial \\( p \\in \\mathbb{Q}[X] \\) that is irreducible over \\(\\mathbb{Q}\\) and has a prime degree, demonstrate that the number of roots in the complex numbers \\(\\mathbb{C}\\), counted with multiplicity, is equal to the degree of the polynomial, i.e., \\(\\#(\\text{roots of } p \\text{ in } \\mathbb{C}) = \\deg(p)\\).", "formal_statement": "import Mathlib\nopen Polynomial Bornology Complex\nopen scoped ComplexConjugate\nlemma galActionHom_bijective_of_prime_degree_tac_5184 (p : ℚ[X]) (p_irr : Irreducible p) (p_deg : Nat.Prime p.natDegree) : (p.aroots ℂ).toFinset.card = p.natDegree := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and libraries.\n\n1. **Understanding the Context**:\n   - We are dealing with polynomials over the rational numbers \\(\\mathbb{Q}\\), which in Lean are represented as `ℚ[X]`.\n   - The statement involves concepts of irreducibility, prime degree, and roots in the complex numbers \\(\\mathbb{C}\\).\n\n2. **Identifying the Components**:\n   - **Polynomial \\( p \\)**: In Lean, a polynomial over the rationals is represented as `p : ℚ[X]`.\n   - **Irreducibility**: The property that \\( p \\) is irreducible over \\(\\mathbb{Q}\\) is captured by `Irreducible p`.\n   - **Prime Degree**: The degree of the polynomial \\( p \\) is a prime number, expressed as `Nat.Prime p.natDegree` in Lean. Here, `p.natDegree` gives the natural number degree of the polynomial \\( p \\).\n\n3. **Roots in the Complex Numbers**:\n   - The statement requires us to count the roots of \\( p \\) in \\(\\mathbb{C}\\), considering multiplicity. In Lean, this is done using `p.aroots ℂ`, which gives the multiset of roots of \\( p \\) in the complex numbers.\n   - To count these roots, we convert the multiset to a finset and then take its cardinality: `(p.aroots ℂ).toFinset.card`.\n\n4. **Equality to the Degree**:\n   - The goal is to show that the number of roots, counted with multiplicity, is equal to the degree of the polynomial. This is expressed as `(p.aroots ℂ).toFinset.card = p.natDegree`.\n\n5. **Putting It All Together**:\n   - The lemma is named `galActionHom_bijective_of_prime_degree_tac_5184`, which is a unique identifier for this particular result.\n   - The lemma takes three arguments: the polynomial `p`, the proof of its irreducibility `p_irr`, and the proof that its degree is prime `p_deg`.\n   - The statement of the lemma asserts the equality of the number of roots in \\(\\mathbb{C"}
{"source_file": "herald_data/sample_500.jsonl", "line": 289, "id": 369929, "informal_statement": "The set of Weierstrass curves over any inhabited ring \\( R \\) is inhabited.", "formal_statement": "import Mathlib\n\ninstance instInhabited {R : Type u} [Inhabited R] :\n    Inhabited <| WeierstrassCurve R := sorry", "explanation": "To translate the informal statement \"The set of Weierstrass curves over any inhabited ring \\( R \\) is inhabited\" into the given Lean4 code, we need to break down the components of both the informal and formal statements:\n\n1. **Understanding the Informal Statement:**\n   - **Weierstrass Curves:** These are specific types of algebraic curves defined by a particular equation. In the context of Lean, they are likely represented by a type or structure `WeierstrassCurve`.\n   - **Inhabited Ring \\( R \\):** A ring \\( R \\) is said to be inhabited if there exists at least one element in \\( R \\). In Lean, this is represented by the `Inhabited` typeclass, which provides a default element.\n   - **Set of Weierstrass Curves is Inhabited:** This means there exists at least one Weierstrass curve over the ring \\( R \\).\n\n2. **Translating to Lean4:**\n   - **Type Declaration:** The statement involves a type `R` which is a ring. In Lean, this is represented as `{R : Type u}`. The `Type u` indicates that \\( R \\) is a type in some universe `u`.\n   - **Inhabited Typeclass for \\( R \\):** The requirement that \\( R \\) is inhabited is expressed as `[Inhabited R]`. This is a typeclass constraint indicating that there is a default element in \\( R \\).\n   - **WeierstrassCurve Type:** The type `WeierstrassCurve R` represents the set of Weierstrass curves over the ring \\( R \\).\n   - **Inhabited Instance for WeierstrassCurve R:** The goal is to show that `WeierstrassCurve R` is inhabited. This is done by providing an instance of the `Inhabited` typeclass for `WeierstrassCurve R`.\n\n3. **Formal Statement in Lean4:**\n   - **Instance Declaration:** The line `instance instInhabited {R : Type u} [Inhabited R] : Inhabited <| WeierstrassCurve R` declares an instance named `instInhabited`. It states that for any type `R` that is inhabited, `WeierstrassCurve R` is also inhabited.\n   - **Use of `sorry`:** The `:= sorry"}
{"source_file": "herald_data/sample_500.jsonl", "line": 292, "id": 393869, "informal_statement": "For any filter $r$, and for any two functions $f, g$ such that $f \\leq g$, if $g$ is bounded by $r$, then $f$ is also bounded by $r$.", "formal_statement": "import Mathlib\nopen Filter Set Function\ntheorem IsBounded.mono (h : f ≤ g) : IsBounded r g → IsBounded r f := sorry", "explanation": "To translate the informal statement into Lean, we need to break down the components of the statement and understand how they map to Lean's formal language.\n\n1. **Understanding the Context**: \n   - We are dealing with filters and functions. In Lean, filters are often used to describe convergence and boundedness in a topological or order-theoretic sense.\n   - The statement involves two functions, `f` and `g`, and a filter `r`.\n\n2. **Identifying the Hypotheses**:\n   - The informal statement starts with \"For any filter $r$,\" which suggests that `r` is a parameter of the theorem. In Lean, this is typically handled by having `r` as an implicit argument or a parameter in the theorem.\n   - \"For any two functions $f, g$ such that $f \\leq g$,\" indicates a pointwise comparison between the functions `f` and `g`. In Lean, this is expressed as `f ≤ g`, where `≤` is the pointwise comparison operator for functions.\n\n3. **Understanding Boundedness**:\n   - The statement \"if $g$ is bounded by $r$\" refers to a property of the function `g` with respect to the filter `r`. In Lean, this is captured by a predicate `IsBounded r g`, which asserts that `g` is bounded with respect to the filter `r`.\n   - Similarly, \"then $f$ is also bounded by $r$\" translates to `IsBounded r f`.\n\n4. **Formulating the Theorem**:\n   - The theorem is named `IsBounded.mono`, indicating that it is about the monotonicity property of boundedness with respect to the pointwise order of functions.\n   - The hypothesis `h : f ≤ g` captures the condition that `f` is pointwise less than or equal to `g`.\n   - The conclusion `IsBounded r g → IsBounded r f` states that if `g` is bounded by `r`, then `f` is also bounded by `r`.\n\n5. **Putting it Together**:\n   - The theorem is structured as follows: given a hypothesis `h : f ≤ g`, if `g` is bounded by `r` (`IsBounded r g`), then `f` is bounded by `r` (`IsBounded r f`).\n   - The `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 290, "id": 72135, "informal_statement": "For any field extension $L/K$ with a subfield $A \\subseteq K$, consider the top submodule $\\top$ of $L$ over $B$, where $B$ is the algebraic closure of $A$ in $L$. Show that the trace dual of $\\top$ is $\\top$ itself if the restriction of scalars to $A$ of the range of the trace map from $L$ to $K$ is contained in the scalars, otherwise, it is the bottom submodule $\\bot$.", "formal_statement": "import Mathlib\nopen nonZeroDivisors IsLocalization Matrix Algebra\nopen scoped Classical in\ntheorem traceDual_top'_extracted [CommRing A] [Field K] [CommRing B]\n [Field L] [Algebra A K] [Algebra B L] [Algebra A B] [Algebra K L]\n [Algebra A L] [IsScalarTower A K L] [IsScalarTower A B L] :\n Submodule.traceDual A K ⊤ = if Submodule.restrictScalars A (LinearMap.range (Algebra.trace K L)) ≤ 1 then ⊤ else ⊥ := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's formal language. Here's a step-by-step explanation:\n\n1. **Understanding the Context**:\n   - We are dealing with field extensions and submodules, which are concepts in algebra.\n   - The informal statement involves a field extension \\( L/K \\) and a subfield \\( A \\subseteq K \\).\n   - We are considering the top submodule \\(\\top\\) of \\( L \\) over \\( B \\), where \\( B \\) is the algebraic closure of \\( A \\) in \\( L \\).\n\n2. **Setting Up the Environment**:\n   - We import necessary modules from Lean's math library (`Mathlib`) to work with algebraic structures.\n   - We open namespaces like `nonZeroDivisors`, `IsLocalization`, `Matrix`, and `Algebra` to access relevant functions and types.\n   - We use `open scoped Classical` to allow classical reasoning, which is often needed in algebra.\n\n3. **Defining the Theorem**:\n   - We declare a theorem named `traceDual_top'_extracted`.\n   - We specify the types and structures involved using type classes:\n     - `[CommRing A]` and `[CommRing B]` indicate that \\( A \\) and \\( B \\) are commutative rings.\n     - `[Field K]` and `[Field L]` indicate that \\( K \\) and \\( L \\) are fields.\n     - `[Algebra A K]`, `[Algebra B L]`, `[Algebra A B]`, `[Algebra K L]`, and `[Algebra A L]` set up the algebra structures, indicating how these fields and rings are related as algebras.\n     - `[IsScalarTower A K L]` and `[IsScalarTower A B L]` indicate that we have scalar tower structures, which are necessary for understanding how scalars from \\( A \\) act on \\( L \\) through \\( K \\) and \\( B \\).\n\n4. **Formalizing the Statement**:\n   - `Submodule.traceDual A K ⊤` refers to the trace dual of the top submodule \\(\\top\\) of \\( L \\) over \\( B \\).\n   - The `if` condition checks whether the restriction of scalars to \\( A \\)"}
{"source_file": "herald_data/sample_500.jsonl", "line": 296, "id": 317217, "informal_statement": "For any linearly ordered set \\((\\alpha, \\leq)\\) and elements \\(a, b, c, x \\in \\alpha\\) with \\(x \\leq b\\), if \\(a \\leq x \\land x \\leq c \\lor c \\leq x \\land x \\leq a\\), then prove that \\((a \\leq x \\land x \\leq b \\lor b \\leq x \\land x \\leq a) \\lor b \\leq x \\land x \\leq c \\lor c \\leq x \\land x \\leq b\\).", "formal_statement": "import Mathlib\nopen Function\nopen OrderDual (toDual ofDual)\nopen Interval\nopen Interval\nlemma uIcc_subset_uIcc_union_uIcc_tac_8323 [LinearOrder α] (a : α) (b : α) (c : α) (x : α) (h2 : x ≤ b) : a ≤ x ∧ x ≤ c ∨ c ≤ x ∧ x ≤ a → (a ≤ x ∧ x ≤ b ∨ b ≤ x ∧ x ≤ a) ∨ b ≤ x ∧ x ≤ c ∨ c ≤ x ∧ x ≤ b := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach to formalize each component of the statement. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Context and Assumptions**:\n   - The informal statement involves a linearly ordered set \\((\\alpha, \\leq)\\). In Lean, this is represented by the type class `LinearOrder α`, which provides the linear order structure on the type \\(\\alpha\\).\n   - The elements \\(a, b, c, x\\) are elements of the set \\(\\alpha\\). In Lean, these are simply variables of type \\(\\alpha\\).\n\n2. **Formalize the Hypotheses**:\n   - The hypothesis \\(x \\leq b\\) is a straightforward inequality between elements of \\(\\alpha\\). In Lean, this is expressed as `(h2 : x ≤ b)`, where `h2` is the name given to this hypothesis.\n   - The condition \\(a \\leq x \\land x \\leq c \\lor c \\leq x \\land x \\leq a\\) is a logical disjunction of conjunctions. In Lean, this is expressed using logical operators: `a ≤ x ∧ x ≤ c ∨ c ≤ x ∧ x ≤ a`.\n\n3. **Formalize the Conclusion**:\n   - The conclusion is a more complex logical expression: \\((a \\leq x \\land x \\leq b \\lor b \\leq x \\land x \\leq a) \\lor b \\leq x \\land x \\leq c \\lor c \\leq x \\land x \\leq b\\).\n   - This is expressed in Lean using the same logical operators: `(a ≤ x ∧ x ≤ b ∨ b ≤ x ∧ x ≤ a) ∨ b ≤ x ∧ x ≤ c ∨ c ≤ x ∧ x ≤ b`.\n\n4. **Structure the Lemma**:\n   - The lemma is named `uIcc_subset_uIcc_union_uIcc_tac_8323`, which is a unique identifier for this particular statement.\n   - The lemma is parameterized by the type \\(\\alpha\\) with a `LinearOrder` instance, and the elements \\(a, b, c, x\\) of type \\(\\alpha\\).\n   - The hypothesis `h2"}
{"source_file": "herald_data/sample_500.jsonl", "line": 294, "id": 165413, "informal_statement": "For any linearly ordered set \\(\\alpha\\) and elements \\(a, b, c, x \\in \\alpha\\) where \\(b \\leq x\\), if \\(x\\) lies within the interval \\([a, c]\\) or \\([c, a]\\), then prove that either \\(x\\) lies within the interval \\([a, b]\\) or \\([b, a]\\), or \\(x\\) lies within the interval \\([b, c]\\) or \\([c, b]\\). Formally, show that if \\(a \\leq x \\wedge x \\leq c \\vee c \\leq x \\wedge x \\leq a\\) and \\(b \\leq x\\), then \\((a \\leq x \\wedge x \\leq b \\vee b \\leq x \\wedge x \\leq a) \\vee b \\leq x \\wedge x \\leq c \\vee c \\leq x \\wedge x \\leq b\\).", "formal_statement": "import Mathlib\nopen Function\nopen OrderDual (toDual ofDual)\nopen Interval\nopen Interval\nlemma uIcc_subset_uIcc_union_uIcc_tac_8360 [LinearOrder α] (a : α) (b : α) (c : α) (x : α) (h2 : b ≤ x) : a ≤ x ∧ x ≤ c ∨ c ≤ x ∧ x ≤ a → (a ≤ x ∧ x ≤ b ∨ b ≤ x ∧ x ≤ a) ∨ b ≤ x ∧ x ≤ c ∨ c ≤ x ∧ x ≤ b := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach to formalize the concepts and logical structure. Here's a step-by-step explanation of how the informal statement is formalized in the Lean code:\n\n1. **Understanding the Context**: \n   - We are dealing with a linearly ordered set \\(\\alpha\\). In Lean, this is represented by `[LinearOrder α]`, which indicates that \\(\\alpha\\) is a type with a linear order.\n\n2. **Defining Variables**:\n   - The elements \\(a, b, c, x\\) are all elements of the set \\(\\alpha\\). In Lean, these are declared as `(a : α) (b : α) (c : α) (x : α)`.\n\n3. **Assumptions**:\n   - The condition \\(b \\leq x\\) is an assumption in the problem. In Lean, this is represented as `(h2 : b ≤ x)`.\n\n4. **Logical Structure**:\n   - The informal statement involves logical conditions and implications. The main logical structure is an implication: if a certain condition holds, then another condition must also hold.\n\n5. **Intervals and Conditions**:\n   - The condition that \\(x\\) lies within the interval \\([a, c]\\) or \\([c, a]\\) is expressed as `a ≤ x ∧ x ≤ c ∨ c ≤ x ∧ x ≤ a`.\n   - The conclusion involves \\(x\\) lying within either \\([a, b]\\) or \\([b, a]\\), or \\([b, c]\\) or \\([c, b]\\). This is expressed as `(a ≤ x ∧ x ≤ b ∨ b ≤ x ∧ x ≤ a) ∨ b ≤ x ∧ x ≤ c ∨ c ≤ x ∧ x ≤ b`.\n\n6. **Formalizing the Implication**:\n   - The implication is formalized in Lean as `a ≤ x ∧ x ≤ c ∨ c ≤ x ∧ x ≤ a → (a ≤ x ∧ x ≤ b ∨ b ≤ x ∧ x ≤ a) ∨ b ≤ x ∧ x ≤ c ∨ c ≤ x ∧ x ≤ b`.\n\n7. **Lemma Declaration**:\n   - The entire statement is encapsulated in a lemma named `uIcc_subset_uIcc_union_u"}
{"source_file": "herald_data/sample_500.jsonl", "line": 295, "id": 470505, "informal_statement": "Inequality: $ \\left( \\sum{\\frac{1}{(x+y)^3}} \\right) \\left( {x}^{2}{y}^{2}+{y}^{2}{z}^{2}+{z}^{2}{x}^{2} \\right) \\geq {\\frac {9}{8}}\\,\\sqrt [3]{xyz}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_470505 :  ∀ x y z : ℝ, (1 / (x + y) ^ 3 + 1 / (y + z) ^ 3 + 1 / (z + x) ^ 3) * (x ^ 2 * y ^ 2 + y ^ 2 * z ^ 2 + z ^ 2 * x ^ 2) ≥ (9 / 8) * (xyz) ^ (1 / 3)  :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach to ensure that each component of the inequality is correctly represented in the formal language. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Variables and Domain**:\n   - The informal statement involves three variables \\( x, y, z \\) which are implicitly real numbers. In Lean, we need to explicitly state the type of these variables. We use `∀ x y z : ℝ` to declare that \\( x, y, z \\) are real numbers.\n\n2. **Translating the Sum and Fractions**:\n   - The expression \\(\\sum \\frac{1}{(x+y)^3}\\) is a sum of three terms: \\(\\frac{1}{(x+y)^3}\\), \\(\\frac{1}{(y+z)^3}\\), and \\(\\frac{1}{(z+x)^3}\\). In Lean, this is expressed as `1 / (x + y) ^ 3 + 1 / (y + z) ^ 3 + 1 / (z + x) ^ 3`.\n\n3. **Translating the Product of Squares**:\n   - The term \\({x}^{2}{y}^{2}+{y}^{2}{z}^{2}+{z}^{2}{x}^{2}\\) is a straightforward sum of products of squares. In Lean, this is written as `x ^ 2 * y ^ 2 + y ^ 2 * z ^ 2 + z ^ 2 * x ^ 2`.\n\n4. **Combining the Expressions**:\n   - The left-hand side of the inequality is the product of the two expressions we translated above. In Lean, this is represented as `(1 / (x + y) ^ 3 + 1 / (y + z) ^ 3 + 1 / (z + x) ^ 3) * (x ^ 2 * y ^ 2 + y ^ 2 * z ^ 2 + z ^ 2 * x ^ 2)`.\n\n5. **Translating the Right-Hand Side**:\n   - The right-hand side of the inequality is \\(\\frac{9}{8} \\sqrt[3]{xyz}\\). In Lean, the cube root is expressed using the power `^ (1 / 3)`, so this becomes `(9"}
{"source_file": "herald_data/sample_500.jsonl", "line": 297, "id": 565786, "informal_statement": "prove that $\\frac{27a^2}{c}+\\frac{(b+c)^2}{a}\\ge 12b$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_565786 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : 27 * a ^ 2 / c + (b + c) ^ 2 / a ≥ 12 * b   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow a series of steps to ensure that the formal statement accurately represents the problem. Here's the breakdown:\n\n1. **Identify the Variables and Their Types**:\n   - The variables involved are \\(a\\), \\(b\\), and \\(c\\), which are real numbers. In Lean, real numbers are represented by `ℝ`.\n\n2. **Specify the Conditions**:\n   - The problem states that \\(a\\), \\(b\\), and \\(c\\) are positive. This is expressed in Lean by the conditions `ha : 0 < a`, `hb : 0 < b`, and `hc : 0 < c`.\n\n3. **Translate the Expression**:\n   - The expression \\(\\frac{27a^2}{c} + \\frac{(b+c)^2}{a}\\) is translated into Lean as `27 * a ^ 2 / c + (b + c) ^ 2 / a`.\n   - Here, `27 * a ^ 2` represents \\(27a^2\\), `/ c` represents division by \\(c\\), and `(b + c) ^ 2` represents \\((b+c)^2\\).\n\n4. **Translate the Inequality**:\n   - The inequality \\(\\ge 12b\\) is translated into Lean as `≥ 12 * b`.\n   - The `≥` symbol in Lean is used to denote \"greater than or equal to\", and `12 * b` represents \\(12b\\).\n\n5. **Structure the Theorem**:\n   - The theorem is structured with the keyword `theorem`, followed by a name `extract_aug_565786` (a placeholder name that can be replaced with a more descriptive one).\n   - The variables \\(a\\), \\(b\\), and \\(c\\) are declared with their type `ℝ`.\n   - The conditions `ha`, `hb`, and `hc` are included as hypotheses.\n   - The statement of the theorem is the inequality to be proved: `27 * a ^ 2 / c + (b + c) ^ 2 / a ≥ 12 * b`.\n\n6. **Import Necessary Libraries**:\n   - The `import Mathlib` statement is used to bring in necessary mathematical libraries.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are included"}
{"source_file": "herald_data/sample_500.jsonl", "line": 300, "id": 108622, "informal_statement": "For any submodule $p'$ of a submodule $p$ over a ring $R$, show that the map from $p'$ to $p$ induced by the subtype inclusion is a submodule map and it is less than or equal to $p$ in the lattice of submodules of $p$.", "formal_statement": "import Mathlib\nopen Function\nopen Submodule\nopen Submodule\nopen LinearMap\ntheorem map_subtype_le_extracted [Semiring R] [AddCommMonoid M] [Module R M] (p : Submodule R M)\n (p' : Submodule R ↥p) : Submodule.map p.subtype p' ≤ p := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understand the Context**: The problem involves submodules over a ring \\( R \\). We are given a submodule \\( p' \\) of a submodule \\( p \\) of a module \\( M \\) over \\( R \\). We need to show that the map induced by the inclusion of \\( p' \\) into \\( p \\) is a submodule map and that the image of this map is less than or equal to \\( p \\) in the lattice of submodules.\n\n2. **Identify the Structures**: \n   - **Submodule**: In Lean, a submodule is a structure that includes a set of elements closed under addition and scalar multiplication. \n   - **Subtype Inclusion**: The inclusion map from a submodule \\( p' \\) to \\( p \\) is a natural map that takes each element of \\( p' \\) to itself, viewed as an element of \\( p \\).\n\n3. **Formalize the Submodule Map**:\n   - The map from \\( p' \\) to \\( p \\) is induced by the inclusion, which in Lean is represented by `p.subtype`. This is a linear map from the submodule \\( p \\) to the module \\( M \\).\n\n4. **Use of `Submodule.map`**:\n   - `Submodule.map` is a function in Lean that takes a linear map and a submodule and returns the image of the submodule under the linear map. Here, `Submodule.map p.subtype p'` represents the image of \\( p' \\) under the inclusion map into \\( p \\).\n\n5. **Express the Inequality**:\n   - The statement `Submodule.map p.subtype p' ≤ p` expresses that the image of \\( p' \\) under the inclusion map is a submodule of \\( p \\). In the lattice of submodules, this means that every element of the image is also an element of \\( p \\).\n\n6. **Lean Theorem Statement**:\n   - The theorem `map_subtype_le_extracted` is defined with the necessary type class instances for a semiring \\( R \\), an additive commutative monoid \\( M \\), and a module structure over \\( R \\).\n   - The parameters `p` and `p'` are submodules, where `p'` is"}
{"source_file": "herald_data/sample_500.jsonl", "line": 301, "id": 140818, "informal_statement": "In a commutative ring \\(R\\) that is also an integral domain, for any natural number \\(n\\) and element \\(\\mu \\in R\\) that is a primitive root of \\(n + 1\\), demonstrate that the product over all \\(k\\) in the range from \\(0\\) to \\(n-1\\) of the terms \\((1 - \\mu^{k+1})\\) is equal to \\(n + 1\\), i.e., \\(\\prod_{k=0}^{n-1} (1 - \\mu^{k+1}) = n + 1\\).", "formal_statement": "import Mathlib\nopen Finset Polynomial BigOperators\nlemma prod_one_sub_pow_eq_order_tac_1149 [CommRing R] [IsDomain R] (n : ℕ) (μ : R) (hμ : IsPrimitiveRoot μ (n + 1)) : ∏ k ∈ range n, (1 - μ ^ (k + 1)) = ↑n + 1 := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully map each component of the statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context**:\n   - We are working within a commutative ring \\( R \\) that is also an integral domain. In Lean, this is represented by the type class constraints `[CommRing R]` and `[IsDomain R]`.\n\n2. **Parameters**:\n   - The statement involves a natural number \\( n \\) and an element \\(\\mu \\in R\\). In Lean, these are represented as `(n : ℕ)` and `(μ : R)` respectively.\n\n3. **Primitive Root Condition**:\n   - The element \\(\\mu\\) is a primitive root of \\( n + 1 \\). In Lean, this is expressed using the predicate `IsPrimitiveRoot μ (n + 1)`, which is included as a hypothesis `(hμ : IsPrimitiveRoot μ (n + 1))`.\n\n4. **Product Expression**:\n   - The informal statement involves a product over a range of terms \\((1 - \\mu^{k+1})\\) for \\( k \\) from \\( 0 \\) to \\( n-1 \\). In Lean, this is expressed using the `∏` (big product) notation over a finite set, specifically `∏ k ∈ range n, (1 - μ ^ (k + 1))`. Here, `range n` generates the set \\(\\{0, 1, \\ldots, n-1\\}\\).\n\n5. **Equality to \\( n + 1 \\)**:\n   - The result of the product is equal to \\( n + 1 \\). In Lean, since \\( n + 1 \\) is a natural number and we are working in a ring \\( R \\), we need to coerce \\( n + 1 \\) into the ring. This is done using `↑n + 1`, where `↑` is the coercion from natural numbers to the ring \\( R \\).\n\n6. **Lemma Declaration**:\n   - The entire statement is encapsulated in a lemma named `prod_one_sub_pow_eq_order_tac_1149`. The lemma takes the parameters and hypotheses as inputs and asserts the equality of the product to \\( n + 1 \\).\n\n7. **Use of `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 302, "id": 277316, "informal_statement": "For any commutative ring $k$, monoid $G$, and representation $A$ of $G$ over $k$, let $x$ be an element in the underlying type of $A$. Show that the application of the left regular homomorphism induced by $x$ to the finitely supported function that maps $1$ to $1$ and all other elements to $0$, is equal to $x$.", "formal_statement": "import Mathlib\nopen CategoryTheory\nopen CategoryTheory.Limits\nlemma leftRegularHom_apply_tac_11400 [CommRing k] [Monoid G] (A : Rep k G) (x : CoeSort.coe A) : (A.leftRegularHom x).hom (Finsupp.single 1 1) = x := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Commutative Ring \\( k \\):**\n   - In Lean, a commutative ring is represented by the type class `CommRing`. The statement `[CommRing k]` in the Lean code indicates that \\( k \\) is assumed to be a commutative ring.\n\n2. **Monoid \\( G \\):**\n   - Similarly, a monoid is represented by the type class `Monoid`. The statement `[Monoid G]` in the Lean code indicates that \\( G \\) is assumed to be a monoid.\n\n3. **Representation \\( A \\) of \\( G \\) over \\( k \\):**\n   - In the context of category theory, a representation of a monoid \\( G \\) over a ring \\( k \\) can be thought of as a functor from the monoid \\( G \\) (viewed as a category with one object) to the category of \\( k \\)-modules. In Lean, this is captured by the type `Rep k G`, which represents a representation of \\( G \\) over \\( k \\).\n\n4. **Element \\( x \\) in the underlying type of \\( A \\):**\n   - The informal statement refers to an element \\( x \\) in the underlying type of the representation \\( A \\). In Lean, this is expressed as `x : CoeSort.coe A`, where `CoeSort.coe A` is the underlying type of the representation \\( A \\).\n\n5. **Left Regular Homomorphism Induced by \\( x \\):**\n   - The left regular homomorphism is a map associated with the representation that acts on finitely supported functions. In Lean, this is represented by `A.leftRegularHom x`, which is a homomorphism induced by the element \\( x \\).\n\n6. **Finitely Supported Function Mapping \\( 1 \\) to \\( 1 \\) and Others to \\( 0 \\):**\n   - In Lean, finitely supported functions are represented using `Finsupp`, which stands for \"finitely supported functions\". The function that maps \\( 1 \\) to \\( 1 \\) and all other elements to \\( 0 \\) is represented by `Finsupp.single 1 1`.\n\n7"}
{"source_file": "herald_data/sample_500.jsonl", "line": 305, "id": 163002, "informal_statement": "For any semiring \\( R \\) and polynomials \\( p, q \\in R[X] \\) such that \\( p \\cdot q \\neq 0 \\) and \\( p = 0 \\), prove that \\( 0 = 0 \\).", "formal_statement": "import Mathlib\nopen Function Polynomial Finsupp Finset\nopen scoped Polynomial\nlemma le_natTrailingDegree_mul_tac_11590 [Semiring R] (p : R[X]) (q : R[X]) (h : p * q ≠ 0) (hp : p = 0) : 0 = 0 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: \n   - The statement involves a semiring \\( R \\) and polynomials \\( p, q \\in R[X] \\). In Lean, a semiring is represented by the typeclass `Semiring R`, and polynomials over a semiring are represented by `R[X]`.\n\n2. **Understand the Hypotheses**:\n   - The informal statement provides two conditions: \\( p \\cdot q \\neq 0 \\) and \\( p = 0 \\).\n   - In Lean, these are represented as hypotheses in the lemma. The hypothesis \\( p \\cdot q \\neq 0 \\) is written as `(h : p * q ≠ 0)`, and \\( p = 0 \\) is written as `(hp : p = 0)`.\n\n3. **Determine the Conclusion**:\n   - The conclusion of the informal statement is \\( 0 = 0 \\), which is trivially true. In Lean, this is directly stated as `0 = 0`.\n\n4. **Structure the Lean Lemma**:\n   - The lemma is defined with the keyword `lemma`, followed by a name `le_natTrailingDegree_mul_tac_11590`. The name is arbitrary and likely generated automatically.\n   - The lemma takes as parameters the semiring `R` (implicitly through the typeclass `[Semiring R]`), the polynomials `p` and `q` of type `R[X]`, and the hypotheses `h` and `hp`.\n   - The conclusion of the lemma is `0 = 0`, which is a tautology.\n\n5. **Use of Imports and Namespace**:\n   - The code begins with `import Mathlib`, which is necessary to access the mathematical library that includes definitions and theorems about semirings and polynomials.\n   - The `open` and `open scoped` statements are used to bring relevant definitions and notations into scope, such as those for polynomials.\n\n6. **Proof Placeholder**:\n   - The `:= sorry` at the end of the lemma indicates that the proof is not provided. In Lean, `sorry` is a placeholder that allows the code to compile without a complete proof.\n\nIn summary, the Lean code formalizes the informal statement by defining a lemma that takes a semiring and two"}
{"source_file": "herald_data/sample_500.jsonl", "line": 304, "id": 112239, "informal_statement": "For any topological space $\\alpha$ and any points $x, y \\in \\alpha$, show that $y$ belongs to the connected component of $x$ if and only if $y$ is in the connected component of $x$, i.e., $y \\in \\text{connectedComponent } x \\Leftrightarrow y \\in \\text{connectedComponent } x$.", "formal_statement": "import Mathlib\nopen Set Function Topology TopologicalSpace Relation\nopen Set.Notation in\nopen Set.Notation in\nlemma connectedComponents_preimage_singleton_tac_25743 [TopologicalSpace α] (x : α) (y : α) : y ∈ connectedComponent x ↔ y ∈ connectedComponent x := sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow these steps:\n\n1. **Understand the Informal Statement**: The statement is about topological spaces and connected components. It asserts a tautology: for any points \\( x \\) and \\( y \\) in a topological space \\(\\alpha\\), \\( y \\) belongs to the connected component of \\( x \\) if and only if \\( y \\) belongs to the connected component of \\( x \\).\n\n2. **Identify the Components of the Statement**:\n   - **Topological Space**: The type \\(\\alpha\\) is a topological space.\n   - **Points**: \\( x \\) and \\( y \\) are points in \\(\\alpha\\).\n   - **Connected Component**: The connected component of a point \\( x \\) is a subset of \\(\\alpha\\) containing all points that are connected to \\( x \\).\n\n3. **Formalize the Topological Space**: In Lean, a topological space is represented by a type with a `TopologicalSpace` instance. We declare \\(\\alpha\\) as a type with this instance using `[TopologicalSpace α]`.\n\n4. **Declare the Points**: The points \\( x \\) and \\( y \\) are elements of the type \\(\\alpha\\). We declare them as `(x : α)` and `(y : α)`.\n\n5. **Express the Connected Component**: The connected component of a point \\( x \\) is denoted by `connectedComponent x`. This is a standard notation in Lean for the set of points connected to \\( x \\).\n\n6. **Formulate the Lemma**: The lemma states that \\( y \\in \\text{connectedComponent } x \\Leftrightarrow y \\in \\text{connectedComponent } x \\). This is a tautology, so the proof is trivial (hence the `sorry` placeholder).\n\n7. **Write the Lean Code**:\n   - Import necessary modules: `Mathlib` for mathematical structures and `Topology` for topological concepts.\n   - Use `open` statements to bring relevant namespaces into scope, such as `Set`, `Function`, `Topology`, and `TopologicalSpace`.\n   - Define the lemma `connectedComponents_preimage_singleton_tac_25743` with the type `[TopologicalSpace α]` and parameters `(x : α) (y : α)"}
{"source_file": "herald_data/sample_500.jsonl", "line": 306, "id": 285581, "informal_statement": "For any commutative monoid $\\alpha$ equipped with a topology, given a proposition $P$ and a function $x : \\beta \\rightarrow (\\neg P \\rightarrow \\alpha)$, along with the proof $hP$ of $P$, show that the product over all $b \\in \\beta$ of the expression which is $1$ if $P$ holds and $x b h$ otherwise, is equal to $1$ if $P$ holds and the product over all $b \\in \\beta$ of $x b h$ otherwise.", "formal_statement": "import Mathlib\nopen Filter Finset Function\nopen scoped Topology\nopen scoped Classical in\nlemma tprod_dite_right_tac_23468 [CommMonoid α] [TopologicalSpace α] (P : Prop) [Decidable P] (x : β → ¬P → α) (hP : P) : (∏' (b : β), if h : P then 1 else x b h) = if h : P then 1 else ∏' (b : β), x b h := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Commutative Monoid and Topology**: \n   - The informal statement begins by specifying that we are working with a commutative monoid $\\alpha$ equipped with a topology. In Lean, this is represented by `[CommMonoid α] [TopologicalSpace α]`. These are typeclass constraints that ensure $\\alpha$ has the structure of a commutative monoid and a topology.\n\n2. **Proposition $P$ and Function $x$**:\n   - The proposition $P$ is a logical statement that can be true or false. In Lean, this is represented by `(P : Prop)`.\n   - The function $x : \\beta \\rightarrow (\\neg P \\rightarrow \\alpha)$ is a function that takes an element of type $\\beta$ and a proof that $P$ is false (i.e., $\\neg P$) and returns an element of $\\alpha$. In Lean, this is represented by `(x : β → ¬P → α)`.\n\n3. **Proof of $P$**:\n   - The proof $hP$ of $P$ is given in the informal statement. In Lean, this is represented by `(hP : P)`, which means we have a proof or evidence that $P$ is true.\n\n4. **Product Expression**:\n   - The informal statement describes a product over all $b \\in \\beta$ of an expression that depends on whether $P$ holds. In Lean, this is expressed using the `∏'` notation, which denotes an infinite product over a type. The expression inside the product is `(if h : P then 1 else x b h)`, which uses a `dite` (dependent if-then-else) construct to choose between `1` and `x b h` based on whether `P` is true.\n\n5. **Equality Statement**:\n   - The goal is to show that this product is equal to a certain value depending on whether $P$ holds. In Lean, this is expressed as an equality: `(∏' (b : β), if h : P then 1 else x b h) = if h : P then 1 else ∏' (b"}
{"source_file": "herald_data/sample_500.jsonl", "line": 298, "id": 8203, "informal_statement": "For any type family $\\pi : \\iota \\oplus \\iota' \\to \\mathbf{Type}^*$, where each $\\pi(i)$ is equipped with a measure space structure and the volume measure is $\\sigma$-finite for each $i$, show that the measurable equivalence between the sum and product types, $\\sum_{i \\in \\iota \\oplus \\iota'} \\pi(i)$ and $\\prod_{i \\in \\iota \\oplus \\iota'} \\pi(i)$, preserves the volume measure.", "formal_statement": "import Mathlib\nopen Function Set MeasureTheory.OuterMeasure Filter MeasurableSpace Encodable\nopen scoped Classical Topology ENNReal\nopen List\nopen List MeasurableEquiv\nopen Measure\ntheorem volume_measurePreserving_sumPiEquivProdPi_extracted [Fintype ι] [Fintype ι'] (π : ι ⊕ ι' → Type u_4)\n [(i : ι ⊕ ι') → MeasureTheory.MeasureSpace (π i)]\n [∀ (i : ι ⊕ ι') : MeasureTheory.SigmaFinite MeasureTheory.volume],\n MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.sumPiEquivProdPi π)) MeasureTheory.volume MeasureTheory.volume := sorry", "explanation": "To translate the given informal mathematical statement into the provided Lean4 code, we need to follow a structured approach that captures the essence of the problem and its formalization in Lean. Here's a step-by-step explanation:\n\n1. **Understanding the Context**:\n   - The informal statement involves a type family indexed by a sum type $\\iota \\oplus \\iota'$, where each type $\\pi(i)$ is equipped with a measure space structure. The volume measure for each type is $\\sigma$-finite.\n   - The goal is to show that a measurable equivalence between the sum and product types preserves the volume measure.\n\n2. **Identifying the Components**:\n   - **Type Family**: The type family is represented as `π : ι ⊕ ι' → Type u_4` in Lean, where `ι` and `ι'` are finite types (`Fintype ι` and `Fintype ι'`).\n   - **Measure Space Structure**: Each type `π(i)` is a measure space, which is expressed in Lean as `[(i : ι ⊕ ι') → MeasureTheory.MeasureSpace (π i)]`.\n   - **Sigma-Finite Volume Measure**: The volume measure is $\\sigma$-finite for each index, represented by `[∀ (i : ι ⊕ ι'), MeasureTheory.SigmaFinite MeasureTheory.volume]`.\n\n3. **Formalizing the Equivalence**:\n   - The measurable equivalence between the sum and product types is captured by `MeasurableEquiv.sumPiEquivProdPi π`. This is a specific measurable equivalence provided by Lean's library that relates the sum of types to the product of types.\n\n4. **Measure Preservation**:\n   - The goal is to show that this equivalence is measure-preserving. In Lean, this is expressed as `MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.sumPiEquivProdPi π)) MeasureTheory.volume MeasureTheory.volume`.\n   - `MeasureTheory.MeasurePreserving` is a predicate that asserts the function (here, the equivalence) preserves the measure from the source to the target.\n\n5. **Theorem Statement**:\n   - The theorem is named `volume_measurePreserving_sumPiEquivProdPi_extracted`, indicating it is about the preservation of the volume measure under the sum-to-product equivalence.\n   - The theorem takes as"}
{"source_file": "herald_data/sample_500.jsonl", "line": 299, "id": 313925, "informal_statement": "For any commutative monoid $\\alpha$, the following are equivalent: the structure of a decomposition monoid on the associates of $\\alpha$ and the structure of a decomposition monoid on $\\alpha$ itself.", "formal_statement": "import Mathlib\nopen Associated\nlemma decompositionMonoid_iff_tac_36384 [CommMonoid α] : DecompositionMonoid (Associates α) ↔ DecompositionMonoid α := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: The informal statement involves a commutative monoid $\\alpha$ and the concept of a decomposition monoid. In Lean, a commutative monoid is represented by the type class `CommMonoid α`.\n\n2. **Understand the Concept of Associates**: The term \"associates\" refers to the equivalence classes of elements in a commutative monoid under the relation of being associates (i.e., differing by a unit). In Lean, this is represented by the type `Associates α`.\n\n3. **Formalize the Equivalence Statement**: The informal statement claims an equivalence between two structures: a decomposition monoid on `Associates α` and a decomposition monoid on `α`. In Lean, this is expressed using the logical equivalence operator `↔`.\n\n4. **Use the Appropriate Lean Constructs**: \n   - `DecompositionMonoid` is a type class in Lean that represents the structure of a decomposition monoid. \n   - The statement `DecompositionMonoid (Associates α) ↔ DecompositionMonoid α` directly translates the informal equivalence into Lean's logical framework.\n\n5. **Structure the Lean Lemma**: \n   - The lemma is named `decompositionMonoid_iff_tac_36384`, which is a placeholder name and can be replaced with a more descriptive one.\n   - The lemma is stated with the assumption `[CommMonoid α]`, indicating that `α` is a commutative monoid.\n   - The body of the lemma is marked as `sorry`, indicating that the proof is not provided. This is a common practice in Lean when the focus is on stating the theorem rather than proving it.\n\n6. **Import Necessary Modules**: The line `import Mathlib` ensures that all necessary mathematical structures and definitions are available. The `open Associated` line allows direct access to the `Associates` type without needing to prefix it.\n\nBy following these steps, the informal mathematical statement is accurately translated into a formal statement in Lean4, capturing the equivalence of decomposition monoid structures on a commutative monoid and its associates."}
{"source_file": "herald_data/sample_500.jsonl", "line": 303, "id": 121039, "informal_statement": "For a measurable space \\((\\alpha, m0)\\), a non-negative extended real number \\(p\\), a measure \\(\\mu\\) on \\(\\alpha\\), and a normed additive commutative group \\(E\\), with a filter \\(fi\\) on an index set \\(\\iota\\), and given that \\(p \\geq 1\\), consider a sequence of functions \\(f : \\iota \\to L^p(E, p, \\mu)\\) in \\(L^p\\) space, a function \\(f_\\text{lim} : \\alpha \\to E\\), and assuming that \\(f_\\text{lim}\\) is an element of the \\(\\mathcal{L}^p\\) space with respect to \\(p\\) and \\(\\mu\\). Then, the sequence \\(f\\) converges in the \\(L^p\\) norm to \\(f_\\text{lim}\\) in the neighborhood of \\(\\mathcal{L}^p\\) space if and only if the sequence of \\(L^p\\) norms of the difference \\(f_n - f_\\text{lim}\\) converges to \\(0\\) in the neighborhood of \\(0\\) as \\(n\\) approaches the limit according to the filter \\(fi\\).", "formal_statement": "import Mathlib\nopen TopologicalSpace MeasureTheory Filter\nopen scoped NNReal ENNReal Topology MeasureTheory Uniformity symmDiff\nopen Set Function\nopen MeasureTheory\nlemma tendsto_Lp_iff_tendsto_ℒp_tac_63168 (m0 : MeasurableSpace α) (p : ℝ≥0∞) (μ : Measure α) [NormedAddCommGroup E] (fi : Filter ι) [Fact (1 ≤ p)] (f : ι → ↥(Lp E p μ)) (f_lim : α → E) (f_lim_ℒp : Memℒp f_lim p μ) : Tendsto f fi (𝓝 (Memℒp.toLp f_lim f_lim_ℒp)) ↔ Tendsto (fun n => eLpNorm (↑↑(f n) - f_lim) p μ) fi (𝓝 0) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to carefully map each component of the informal statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation:\n\n1. **Measurable Space and Measure**: \n   - The informal statement begins with a measurable space \\((\\alpha, m0)\\) and a measure \\(\\mu\\) on \\(\\alpha\\). In Lean, this is represented by `m0 : MeasurableSpace α` and `μ : Measure α`. These types indicate that `α` is a type equipped with a measurable space structure `m0` and a measure `μ`.\n\n2. **Non-negative Extended Real Number \\(p\\)**:\n   - The parameter \\(p\\) is a non-negative extended real number, which is represented in Lean by `p : ℝ≥0∞`. The type `ℝ≥0∞` is used for extended non-negative real numbers, which includes infinity.\n\n3. **Normed Additive Commutative Group \\(E\\)**:\n   - The space \\(E\\) is a normed additive commutative group, represented by `[NormedAddCommGroup E]` in Lean. This indicates that `E` is a type with a normed group structure.\n\n4. **Filter \\(fi\\) on an Index Set \\(\\iota\\)**:\n   - The filter \\(fi\\) on an index set \\(\\iota\\) is represented by `fi : Filter ι`. This indicates that `fi` is a filter on the type `ι`, which serves as the index set for the sequence of functions.\n\n5. **Condition \\(p \\geq 1\\)**:\n   - The condition \\(p \\geq 1\\) is captured by `[Fact (1 ≤ p)]`. The `Fact` typeclass is used in Lean to assert and carry assumptions like inequalities.\n\n6. **Sequence of Functions \\(f : \\iota \\to L^p(E, p, \\mu)\\)**:\n   - The sequence of functions \\(f\\) is represented by `f : ι → ↥(Lp E p μ)`. Here, `Lp E p μ` denotes the \\(L^p\\) space of functions from `α` to `E` with respect to the measure `μ`, and `↥(Lp E p μ)` indicates that each"}
{"source_file": "herald_data/sample_500.jsonl", "line": 307, "id": 295446, "informal_statement": "For a topological space $X$, a countable index set $\\iota$, a family of sets $s : \\iota \\to \\mathcal{P}(X)$, and a doubly indexed family of compact sets $K : \\iota \\times \\mathbb{N} \\to \\mathcal{P}(X)$, suppose for every $i \\in \\iota$ and $n \\in \\mathbb{N}$, $K(i, n)$ is compact. Moreover, assume that for each $i \\in \\iota$, the union of $K(i, n)$ over all $n \\in \\mathbb{N}$ equals $s(i)$. Given that the union over $i \\in \\iota$ of $s(i)$ is equal to the union over $x \\in \\iota \\times \\mathbb{N}$ of $K(x)$, prove that the union over $x \\in \\iota \\times \\mathbb{N}$ of $K(x)$ is $\\sigma$-compact.", "formal_statement": "import Mathlib\nopen Set Filter Topology TopologicalSpace\nlemma isSigmaCompact_iUnion_tac_2761 [TopologicalSpace X] [Countable ι] (s : ι → Set X) (K : ι → ℕ → Set X) (hcomp : ∀ (i : ι) (n : ℕ), IsCompact (K i n)) (hcov : ∀ (i : ι), ⋃ n, K i n = s i) (this : ⋃ i, s i = ⋃ x, Function.uncurry K x) : IsSigmaCompact (⋃ x, Function.uncurry K x) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the mathematical concepts and their relationships. Here's a step-by-step explanation of the translation:\n\n1. **Topological Space and Countable Index Set**:\n   - The informal statement begins by considering a topological space \\( X \\) and a countable index set \\( \\iota \\). In Lean, a topological space is represented by `[TopologicalSpace X]`, and countability of the index set is indicated by `[Countable ι]`.\n\n2. **Family of Sets and Doubly Indexed Family of Compact Sets**:\n   - We have a family of sets \\( s : \\iota \\to \\mathcal{P}(X) \\) and a doubly indexed family of compact sets \\( K : \\iota \\times \\mathbb{N} \\to \\mathcal{P}(X) \\). In Lean, these are represented as `s : ι → Set X` and `K : ι → ℕ → Set X`, respectively. The function `K` is curried, meaning it takes two arguments separately, which is typical in Lean.\n\n3. **Compactness Condition**:\n   - The condition that for every \\( i \\in \\iota \\) and \\( n \\in \\mathbb{N} \\), \\( K(i, n) \\) is compact is expressed in Lean as `hcomp : ∀ (i : ι) (n : ℕ), IsCompact (K i n)`. This uses the `IsCompact` predicate to assert compactness.\n\n4. **Union Condition for Each Index**:\n   - The statement that for each \\( i \\in \\iota \\), the union of \\( K(i, n) \\) over all \\( n \\in \\mathbb{N} \\) equals \\( s(i) \\) is formalized as `hcov : ∀ (i : ι), ⋃ n, K i n = s i`. The `⋃` symbol represents the union over all \\( n \\).\n\n5. **Overall Union Condition**:\n   - The condition that the union over \\( i \\in \\iota \\) of \\( s(i) \\) is equal to the union over \\( x \\in \\iota \\times \\mathbb{N} \\) of \\( K(x) \\"}
{"source_file": "herald_data/sample_500.jsonl", "line": 312, "id": 541090, "informal_statement": "$(x+y+z)^2-6(x+y+z)+9\\ge 0\\iff (x+y+z-3)^2\\ge0$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_541090 : (x + y + z - 3) ^ 2 ≥ 0 ↔ (x + y + z) ^ 2 - 6 * (x + y + z) + 9 ≥ 0   :=  by sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Understand the Mathematical Equivalence**: The informal statement is an equivalence between two expressions involving real numbers \\(x\\), \\(y\\), and \\(z\\). The left-hand side is \\((x+y+z-3)^2 \\ge 0\\), which is a standard non-negativity condition for a square of a real number. The right-hand side is \\((x+y+z)^2 - 6(x+y+z) + 9 \\ge 0\\), which is a quadratic expression in terms of \\(x+y+z\\).\n\n2. **Recognize the Structure**: The equivalence \\((x+y+z-3)^2 \\ge 0 \\iff (x+y+z)^2 - 6(x+y+z) + 9 \\ge 0\\) is based on the fact that both sides are equivalent transformations of each other. Specifically, expanding \\((x+y+z-3)^2\\) results in \\((x+y+z)^2 - 6(x+y+z) + 9\\).\n\n3. **Translate to Lean Syntax**:\n   - **Import Necessary Libraries**: The `import Mathlib` statement is used to bring in the necessary mathematical libraries that provide foundational definitions and theorems. `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to access specific namespaces that might be needed for operations on real numbers and other mathematical constructs.\n   \n   - **Define the Theorem**: The theorem is named `extract_aug_541090`. In Lean, theorem names are identifiers and can be arbitrary, but they often reflect the content or source of the theorem.\n   \n   - **State the Equivalence**: The equivalence is stated using the `↔` symbol, which represents logical equivalence in Lean. The left-hand side \\((x + y + z - 3) ^ 2 ≥ 0\\) is directly translated using Lean's syntax for arithmetic operations and inequalities. Similarly, the right-hand side \\((x + y + z) ^ 2 - 6 * (x + y + z) + 9 ≥ 0\\) is translated using Lean's syntax for arithmetic operations, where `*` denotes multiplication.\n\n4. **Proof Placeholder**: The `:="}
{"source_file": "herald_data/sample_500.jsonl", "line": 308, "id": 220865, "informal_statement": "For any polynomial \\( p \\) over a semiring \\( R \\) with coefficients in \\( R \\), if \\( p \\) is monic, \\( p \\) is a unit, there exists another polynomial \\( q \\) such that the product \\( pq = 1 \\), and both \\( p \\) and \\( q \\) have a natural degree of 0, then prove that \\( p = 1 \\).", "formal_statement": "import Mathlib\nopen Finset\nopen Polynomial\nlemma eq_one_of_isUnit_tac_8090 [Semiring R] (p : R[X]) (hm : p.Monic) (hpu : IsUnit p) (q : R[X]) (h : p * q = 1) (this : p.natDegree = 0 ∧ q.natDegree = 0) : p = 1 := sorry", "explanation": "To translate the given informal mathematical statement into the provided Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Context and Imports**:\n   - The statement involves polynomials over a semiring \\( R \\). In Lean, this requires importing the necessary libraries to work with polynomials and semirings. The line `import Mathlib` is a placeholder for importing the necessary modules, and `open Finset` and `open Polynomial` make the relevant definitions and theorems available without needing to prefix them.\n\n2. **Semiring \\( R \\)**:\n   - The informal statement specifies that \\( p \\) is a polynomial over a semiring \\( R \\). In Lean, this is expressed by `[Semiring R]`, which is a typeclass constraint indicating that \\( R \\) is a semiring.\n\n3. **Polynomial \\( p \\)**:\n   - The polynomial \\( p \\) is represented as `p : R[X]` in Lean. Here, `R[X]` denotes the type of polynomials with coefficients in \\( R \\).\n\n4. **Monic Polynomial**:\n   - The condition that \\( p \\) is monic is expressed by `hm : p.Monic`. In Lean, `p.Monic` is a predicate that checks if the leading coefficient of \\( p \\) is 1.\n\n5. **Unit Polynomial**:\n   - The statement that \\( p \\) is a unit is captured by `hpu : IsUnit p`. In Lean, `IsUnit p` means that there exists a polynomial \\( q \\) such that \\( p \\cdot q = 1 \\).\n\n6. **Existence of Polynomial \\( q \\)**:\n   - The existence of another polynomial \\( q \\) such that \\( p \\cdot q = 1 \\) is directly represented by the parameter `q : R[X]` and the hypothesis `h : p * q = 1`.\n\n7. **Natural Degree Condition**:\n   - The condition that both \\( p \\) and \\( q \\) have a natural degree of 0 is expressed by `this : p.natDegree = 0 ∧ q.natDegree = 0`. In Lean, `natDegree` gives the degree of the polynomial, and the condition checks that both degrees are zero.\n\n8. **Conclusion**"}
{"source_file": "herald_data/sample_500.jsonl", "line": 311, "id": 276811, "informal_statement": "For any seminormed abelian groups $E$ and $F$, nontrivially normed fields $\\mathbb{k}$ and $\\mathbb{k}_2$, and $f$ a continuous linear map from $E$ to $F$ over the ring homomorphism $\\sigma_{12} : \\mathbb{k} \\to \\mathbb{k}_2$ that is isometric, the positive norm of $f$ is equal to the greatest lower bound of the set of all positive real numbers $c$ such that for every $x \\in E$, the positive norm of $f(x)$ is less than or equal to $c$ times the positive norm of $x$.", "formal_statement": "import Mathlib\nopen Bornology\nopen Filter hiding map_smul\nopen scoped NNReal Topology Uniformity\nopen Metric ContinuousLinearMap\nopen Set Real\nlemma nnnorm_def_tac_1619 [SeminormedAddCommGroup E] [SeminormedAddCommGroup F] [NontriviallyNormedField 𝕜] [NontriviallyNormedField 𝕜₂] [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] (σ₁₂ : 𝕜 →+* 𝕜₂) [RingHomIsometric σ₁₂] (f : E →SL[σ₁₂] F) : ‖f‖₊ = sInf {c | ∀ (x : E), ‖f x‖₊ ≤ c * ‖x‖₊} := sorry", "explanation": "To translate the given informal mathematical statement into the provided Lean4 code, we need to follow a structured approach that maps each component of the informal statement to its formal counterpart in Lean. Here's a step-by-step explanation:\n\n1. **Context and Imports**:\n   - The Lean code begins with importing necessary modules from the Mathlib library. These imports provide the definitions and theorems related to seminormed groups, normed fields, and continuous linear maps, which are essential for formalizing the statement.\n\n2. **Type Classes and Variables**:\n   - `[SeminormedAddCommGroup E]` and `[SeminormedAddCommGroup F]`: These type class constraints specify that `E` and `F` are seminormed abelian groups. In Lean, a `SeminormedAddCommGroup` is a type with an additive commutative group structure equipped with a seminorm.\n   - `[NontriviallyNormedField 𝕜]` and `[NontriviallyNormedField 𝕜₂]`: These constraints indicate that `𝕜` and `𝕜₂` are nontrivially normed fields. A `NontriviallyNormedField` in Lean is a field with a norm that is not identically zero.\n   - `[NormedSpace 𝕜 E]` and `[NormedSpace 𝕜₂ F]`: These specify that `E` is a normed space over the field `𝕜`, and `F` is a normed space over the field `𝕜₂`.\n\n3. **Ring Homomorphism and Isometry**:\n   - `(σ₁₂ : 𝕜 →+* 𝕜₂)`: This denotes a ring homomorphism from `𝕜` to `𝕜₂`. In Lean, `→+*` is the type of ring homomorphisms.\n   - `[RingHomIsometric σ₁₂]`: This constraint ensures that the ring homomorphism `σ₁₂` is isometric, meaning it preserves the norm.\n\n4. **Continuous Linear Map**:\n   - `(f : E →SL[σ₁₂] F)`: This represents a continuous linear map `f` from `E` to `F` that respects the ring homomorphism `σ₁₂`. In Lean, `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 310, "id": 213491, "informal_statement": "For any fields $K$ and $L$, with $S$ being an intermediate field between $K$ and $L$, and for any element $x$ in $S$, show that $x$ is integral over $K$ if and only if its canonical image in $L$ is also integral over $K$.", "formal_statement": "import Mathlib\nopen FiniteDimensional\nlemma isIntegral_iff_tac_3449 [Field K] [Field L] [Algebra K L] (S : IntermediateField K L) (x : ↥S) : IsIntegral K x ↔ IsIntegral K ↑x := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Structures**: \n   - The informal statement involves fields $K$ and $L$, and an intermediate field $S$ between them. In Lean, fields are typically represented using the `Field` typeclass.\n   - An intermediate field $S$ is a subfield of $L$ that contains $K$. In Lean, this is represented by the `IntermediateField K L` type.\n\n2. **Set Up the Context**:\n   - The Lean code begins by importing necessary libraries with `import Mathlib`, which provides the required mathematical structures and theorems.\n   - The `open FiniteDimensional` statement is used to bring into scope definitions and theorems related to finite-dimensional vector spaces, which might be relevant for working with fields and algebraic structures.\n\n3. **Declare the Fields and Algebra**:\n   - `[Field K] [Field L]` declares that $K$ and $L$ are fields.\n   - `[Algebra K L]` indicates that $L$ is an algebra over $K$, meaning there is a ring homomorphism from $K$ to $L$ that respects the field operations.\n\n4. **Define the Intermediate Field**:\n   - `(S : IntermediateField K L)` declares $S$ as an intermediate field between $K$ and $L$. This means $S$ is a subfield of $L$ that contains the image of $K$ under the algebra homomorphism.\n\n5. **Specify the Element**:\n   - `(x : ↥S)` specifies that $x$ is an element of the intermediate field $S$. The notation `↥S` is Lean's way of denoting the type of elements in the set $S$.\n\n6. **State the Property of Interest**:\n   - `IsIntegral K x` is a predicate indicating that the element $x$ is integral over the field $K$. In algebra, an element is integral over a field if it is a root of a monic polynomial with coefficients in that field.\n\n7. **Formulate the Equivalence**:\n   - The statement `IsIntegral K x ↔ IsIntegral K ↑x` expresses the equivalence we want to prove. The `↔` symbol denotes logical equivalence.\n   - `↑x` is the canonical image of $"}
{"source_file": "herald_data/sample_500.jsonl", "line": 316, "id": 96785, "informal_statement": "For any objects $X, Y, Z$ in a category $\\mathcal{V}$, and given morphisms $f: X \\to Y$ and $g: Y \\to Z$ with the property that $f \\circ g = 0$, show that the image of the kernel of $g^\\mathrm{op}$ under $f^\\mathrm{op}$, where $^\\mathrm{op}$ denotes the opposite morphism, is isomorphic to the composition of the following morphisms in the opposite category:\n\n1. The homomorphism part of the isomorphism between the image of $g^\\mathrm{op}$ and its opposite under the image-subobject isomorphism,\n2. The cokernel descriptor of $f$ applied to the factorization through the image of $g$,\n3. The inverse of the isomorphism between the kernel of $g^\\mathrm{op}$ and its opposite under the kernel-subobject isomorphism.", "formal_statement": "import Mathlib\nopen Opposite CategoryTheory CategoryTheory.Limits\ntheorem imageToKernel_op_extracted [Category.{u_2 : u_1} V] [Abelian V] {X Y Z : V} (f : X ⟶ Y) (g : Y ⟶ Z)\n (w : f ≫ g = 0),\n imageToKernel g.op f.op ⋯ =\n (imageSubobjectIso g.op ≪≫ (imageOpOp g).symm).hom ≫\n (cokernel.desc f (factorThruImage g) ⋯).op ≫ (kernelSubobjectIso f.op ≪≫ kernelOpOp f).inv := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that involves understanding the concepts of category theory, the use of opposite categories, and the specific constructs available in Lean's math library. Here's a step-by-step explanation of the translation process:\n\n1. **Category and Morphisms**: \n   - The informal statement involves objects \\(X, Y, Z\\) in a category \\(\\mathcal{V}\\) and morphisms \\(f: X \\to Y\\) and \\(g: Y \\to Z\\). In Lean, this is represented by declaring a category `V` and objects `X`, `Y`, `Z` of type `V`. The morphisms `f` and `g` are represented as `f : X ⟶ Y` and `g : Y ⟶ Z`.\n\n2. **Condition \\(f \\circ g = 0\\)**:\n   - The condition that the composition of `f` and `g` is zero is expressed in Lean as `w : f ≫ g = 0`. This uses the composition operator `≫` and the equality `= 0` to denote the zero morphism in the category.\n\n3. **Opposite Category**:\n   - The opposite category is denoted by `op` in Lean. For morphisms, `f.op` and `g.op` represent the opposite morphisms of `f` and `g`, respectively.\n\n4. **Image and Kernel in Opposite Category**:\n   - The informal statement involves the image of the kernel of `g.op` under `f.op`. In Lean, this is expressed using `imageToKernel g.op f.op`, which represents the morphism from the image of the kernel of `g.op` to the kernel of `f.op`.\n\n5. **Isomorphisms and Compositions**:\n   - The statement involves several isomorphisms and compositions:\n     - `imageSubobjectIso g.op` gives the isomorphism between the image of `g.op` and its subobject.\n     - `(imageOpOp g).symm` is the inverse of the isomorphism between the image of `g` and its opposite.\n     - `cokernel.desc f (factorThruImage g)` represents the cokernel descriptor of `f` applied to the factorization through the image of `g`.\n     - `(kernelSubobject"}
{"source_file": "herald_data/sample_500.jsonl", "line": 309, "id": 362820, "informal_statement": "For any additive commutative monoid with identity $(\\alpha, +, 0)$, the lexicographic order structure $(\\text{Lex }\\alpha)$ also forms an additive commutative monoid with identity.", "formal_statement": "import Mathlib\nopen OrderDual\ninstance [h : AddCommMonoidWithOne α] : AddCommMonoidWithOne (Lex α) := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Understand the Informal Statement**: The statement asserts that if we have an additive commutative monoid with identity, denoted as $(\\alpha, +, 0)$, then the lexicographic order structure on $\\alpha$, denoted as $(\\text{Lex }\\alpha)$, also forms an additive commutative monoid with identity.\n\n2. **Identify the Lean Structures**: In Lean, an \"additive commutative monoid with identity\" is represented by the type class `AddCommMonoidWithOne`. This type class includes the operations and properties of an additive commutative monoid, along with an identity element (often denoted as `0`).\n\n3. **Lexicographic Order Structure**: The lexicographic order structure is a way to order pairs or tuples based on their components. In Lean, this is represented by the `Lex` type, which is a wrapper that provides a lexicographic ordering on the underlying type.\n\n4. **Formalize the Statement**: The goal is to show that if `α` is an `AddCommMonoidWithOne`, then `Lex α` is also an `AddCommMonoidWithOne`. This involves creating an instance of `AddCommMonoidWithOne` for `Lex α`.\n\n5. **Lean Code Explanation**:\n   - `import Mathlib`: This imports the necessary mathematical library that contains definitions and instances for algebraic structures.\n   - `open OrderDual`: This opens the `OrderDual` namespace, which might be related to dual order structures, but is not directly used in this instance declaration.\n   - `instance [h : AddCommMonoidWithOne α] : AddCommMonoidWithOne (Lex α) := sorry`: This line declares an instance of `AddCommMonoidWithOne` for `Lex α`. The `[h : AddCommMonoidWithOne α]` part is a type class assumption that `α` is already an `AddCommMonoidWithOne`. The `:= sorry` indicates that the proof or construction of this instance is omitted or left as a placeholder.\n\n6. **Conclusion**: The formal statement in Lean is a declaration that `Lex α` inherits the structure of an `AddCommMonoidWithOne` from `α`, assuming `α` itself is an `Add"}
{"source_file": "herald_data/sample_500.jsonl", "line": 315, "id": 53269, "informal_statement": "For any point $x$ in a topological space $X$, show that $x$ is an element of its irreducible component, i.e., $x \\in \\text{irreducibleComponent } x$.", "formal_statement": "import Mathlib\nopen Set\ntheorem mem_irreducibleComponent_extracted [TopologicalSpace X] {x : X} : x ∈ irreducibleComponent x := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Understand the Context**: The statement involves a topological space \\( X \\) and a point \\( x \\) within this space. We are dealing with the concept of an irreducible component in topology, which is a maximal irreducible subset containing a given point.\n\n2. **Identify the Components**:\n   - **Topological Space**: In Lean, a topological space is represented by a type `X` equipped with a topology, which is expressed using the type class `[TopologicalSpace X]`.\n   - **Point in the Space**: The point \\( x \\) is an element of the type `X`, denoted as `{x : X}` in Lean.\n\n3. **Formalize the Statement**:\n   - **Irreducible Component**: The function `irreducibleComponent` takes a point \\( x \\) and returns the irreducible component containing \\( x \\). This is a standard function in the topology library of Lean.\n   - **Membership**: The goal is to show that \\( x \\) is a member of its irreducible component, which is expressed as `x ∈ irreducibleComponent x`.\n\n4. **Structure the Theorem**:\n   - **Import Necessary Libraries**: The `Mathlib` library is imported to access topological concepts and functions.\n   - **Open Set Namespace**: The `Set` namespace is opened to use set-related functions and notations without qualification.\n   - **Theorem Declaration**: The theorem is declared with the name `mem_irreducibleComponent_extracted`. It specifies the context `[TopologicalSpace X]` and the point `{x : X}`.\n   - **Statement**: The statement `x ∈ irreducibleComponent x` is the conclusion we want to prove.\n\n5. **Proof Placeholder**:\n   - The proof is currently a placeholder (`sorry`), indicating that the proof needs to be completed. In Lean, `sorry` is used to temporarily bypass the proof requirement.\n\nBy following these steps, the informal mathematical statement is translated into a formal Lean theorem, ready for further proof development."}
{"source_file": "herald_data/sample_500.jsonl", "line": 314, "id": 263323, "informal_statement": "For any pseudo extended metric space $\\alpha$, real number $\\delta$, set $s$ of real numbers such that $s$ is a subset of the right open interval $(\\delta, +\\infty)$, and given that for all real numbers $\\varepsilon$, if $\\delta < \\varepsilon$, then the intersection of $s$ with the right half-open interval $[\\delta, \\varepsilon)$ is nonempty, and for any set $E$ in $\\alpha$, point $x$ in $\\alpha$, and a function $hx$ that maps each element $i$ in $s$ to the inequality $\\inf_{\\text{E}}\\text{dist}(x, E) \\leq i$ when $i$ is in $s$, show that for any non-negative real number $\\eta$, if $\\eta > 0$ and the extended non-negative real number representation of $\\delta$ is less than the top element of the extended non-negative real numbers, then $\\inf_{\\text{E}}\\text{dist}(x, E) \\leq \\delta + \\eta$ in the extended non-negative real numbers.", "formal_statement": "import Mathlib\nopen NNReal ENNReal Topology Set Filter Bornology\nopen EMetric\nopen EMetric\nopen ENNReal\nlemma cthickening_eq_iInter_cthickening'_tac_21608 [PseudoEMetricSpace α] (δ : ℝ) (s : Set ℝ) (hsδ : s ⊆ Ioi δ) (hs : ∀ (ε : ℝ), δ < ε → (s ∩ Ioc δ ε).Nonempty) (E : Set α) (x : α) (hx : ∀ i ∈ s, infEdist x E ≤ ENNReal.ofReal i) (η : ℝ≥0) : 0 < η → ENNReal.ofReal δ < ⊤ → infEdist x E ≤ ENNReal.ofReal δ + ↑η := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to carefully map each component of the informal statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation:\n\n1. **Pseudo Extended Metric Space**: \n   - The informal statement begins with \"For any pseudo extended metric space $\\alpha$\". In Lean, this is represented by `[PseudoEMetricSpace α]`. The `PseudoEMetricSpace` is a typeclass in Lean that represents a space with a pseudo extended metric, and `α` is the type of the space.\n\n2. **Real Number $\\delta$ and Set $s$**:\n   - The real number $\\delta$ is directly represented as `(δ : ℝ)` in Lean, where `ℝ` denotes the type of real numbers.\n   - The set $s$ of real numbers is represented as `(s : Set ℝ)`, where `Set ℝ` denotes a set of real numbers.\n\n3. **Subset Condition**:\n   - The condition \"$s$ is a subset of the right open interval $(\\delta, +\\infty)$\" is formalized as `(hsδ : s ⊆ Ioi δ)`. Here, `Ioi δ` represents the interval $(\\delta, +\\infty)$, and `⊆` denotes the subset relation.\n\n4. **Nonempty Intersection Condition**:\n   - The condition \"for all real numbers $\\varepsilon$, if $\\delta < \\varepsilon$, then the intersection of $s$ with the right half-open interval $[\\delta, \\varepsilon)$ is nonempty\" is formalized as `(hs : ∀ (ε : ℝ), δ < ε → (s ∩ Ioc δ ε).Nonempty)`. \n   - `∀ (ε : ℝ)` introduces a universal quantifier over real numbers.\n   - `δ < ε → (s ∩ Ioc δ ε).Nonempty` states that if `δ < ε`, then the intersection `s ∩ Ioc δ ε` is nonempty. `Ioc δ ε` represents the interval $[\\delta, \\varepsilon)$.\n\n5. **Set $E$ and Point $x$ in $\\alpha$**:\n   - The set $E$ in $\\alpha$ is represented as `(E : Set α)`.\n   - The point $x$ in $\\alpha$ is"}
{"source_file": "herald_data/sample_500.jsonl", "line": 313, "id": 523372, "informal_statement": "prove that $a^3b+b^3c+c^3a\\geq a^2bc+b^2ac+c^2ab$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_523372 (a b c : ℝ) : a ^ 3 * b + b ^ 3 * c + c ^ 3 * a >= a ^ 2 * b * c + b ^ 2 * a * c + c ^ 2 * a * b   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The variables involved in the inequality are \\(a\\), \\(b\\), and \\(c\\). In the context of the problem, these are real numbers. Therefore, in Lean, we declare them as variables of type `ℝ` (the type for real numbers in Lean).\n\n2. **Translate the Mathematical Expressions**:\n   - The left-hand side of the inequality is \\(a^3b + b^3c + c^3a\\). In Lean, exponentiation is represented using the `^` operator, and multiplication is represented using `*`. Thus, \\(a^3b\\) becomes `a ^ 3 * b`, \\(b^3c\\) becomes `b ^ 3 * c`, and \\(c^3a\\) becomes `c ^ 3 * a`.\n   - The right-hand side of the inequality is \\(a^2bc + b^2ac + c^2ab\\). Similarly, \\(a^2bc\\) is translated to `a ^ 2 * b * c`, \\(b^2ac\\) to `b ^ 2 * a * c`, and \\(c^2ab\\) to `c ^ 2 * a * b`.\n\n3. **Formulate the Inequality**:\n   - The inequality \\(a^3b + b^3c + c^3a \\geq a^2bc + b^2ac + c^2ab\\) is directly translated to `a ^ 3 * b + b ^ 3 * c + c ^ 3 * a >= a ^ 2 * b * c + b ^ 2 * a * c + c ^ 2 * a * b` in Lean.\n\n4. **Structure the Theorem in Lean**:\n   - We define a theorem named `extract_aug_523372` which takes three real numbers \\(a\\), \\(b\\), and \\(c\\) as inputs. The statement of the theorem is the inequality we have translated.\n   - The keyword `theorem` is used to declare a theorem in Lean, followed by the name of the theorem and the parameters it takes.\n   - The `:` symbol is used to separate the parameters from the statement of the theorem.\n\n5. **Use of Lean"}
{"source_file": "herald_data/sample_500.jsonl", "line": 320, "id": 3717, "informal_statement": "Let $\\mu$ and $\\nu$ be measures on a measurable space $\\alpha$, with $\\nu$ being a finite measure. Let $C$ denote the supremum of $\\nu(s)$ taken over all measurable sets $s$ for which the restriction of $\\mu$ to $s$, denoted $\\mu\\restriction_s$, is sigma-finite. Given any natural number $n$, there exists a measurable set $t$ such that $\\mu\\restriction_t$ is sigma-finite and $\\nu(t) \\geq C - \\frac{1}{n}$.", "formal_statement": "import Mathlib\nopen scoped ENNReal Topology\nopen Filter\nopen Classical in\ntheorem exists_isSigmaFiniteSet_measure_ge_extracted {mα : MeasurableSpace α} (μ ν : MeasureTheory.Measure α) [MeasureTheory.IsFiniteMeasure ν]\n (n : ℕ) :\n ∃ t,\n MeasurableSet t ∧\n MeasureTheory.SigmaFinite (μ.restrict t) ∧\n (⨆ s, ⨆ (_ : MeasurableSet s), ⨆ (_ : MeasureTheory.SigmaFinite (μ.restrict s)), ν s) - 1 / ↑n ≤ ν t := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully map each component of the informal statement to its formal counterpart in Lean. Here's a step-by-step explanation of how this is done:\n\n1. **Measurable Space and Measures**: \n   - The informal statement begins by considering a measurable space $\\alpha$ and two measures $\\mu$ and $\\nu$ on this space. In Lean, this is represented by declaring a measurable space `mα : MeasurableSpace α` and measures `μ` and `ν` of type `MeasureTheory.Measure α`.\n\n2. **Finite Measure**:\n   - The statement specifies that $\\nu$ is a finite measure. In Lean, this is expressed using the type class `MeasureTheory.IsFiniteMeasure ν`, which ensures that the measure `ν` is finite.\n\n3. **Supremum Definition**:\n   - The informal statement defines $C$ as the supremum of $\\nu(s)$ over all measurable sets $s$ for which $\\mu\\restriction_s$ is sigma-finite. In Lean, this is expressed using the `⨆` (supr) operator, which denotes the supremum. The expression `(⨆ s, ⨆ (_ : MeasurableSet s), ⨆ (_ : MeasureTheory.SigmaFinite (μ.restrict s)), ν s)` captures this supremum over all measurable sets `s` where `μ.restrict s` is sigma-finite.\n\n4. **Natural Number Parameter**:\n   - The informal statement introduces a natural number $n$. In Lean, this is simply a parameter `n : ℕ`.\n\n5. **Existence of a Measurable Set**:\n   - The goal is to find a measurable set $t$ such that $\\mu\\restriction_t$ is sigma-finite and $\\nu(t) \\geq C - \\frac{1}{n}$. In Lean, this is expressed using the existential quantifier `∃ t`, followed by conditions that `t` must satisfy:\n     - `MeasurableSet t` ensures that `t` is a measurable set.\n     - `MeasureTheory.SigmaFinite (μ.restrict t)` ensures that the restriction of `μ` to `t` is sigma-finite.\n     - The inequality `(⨆ s, ⨆ (_ : MeasurableSet s), ⨆ (_ : MeasureTheory.SigmaFinite ("}
{"source_file": "herald_data/sample_500.jsonl", "line": 318, "id": 290124, "informal_statement": "For any semiring $R$, a nonempty set $s$ of polynomials over $R[X]$, a polynomial $p \\in R[X]$, if $p$ is in the span of $s$ over $R$, and for all $p' \\in s$ we have $\\deg(p') < \\deg(p)$, and $p$ is not the zero polynomial, and $p$ is in the set of polynomials with natural degree less than $\\deg(p)$, then derive a contradiction.", "formal_statement": "import Mathlib\nopen Polynomial\nopen Finset\nlemma exists_degree_le_of_mem_span_tac_8130 [Semiring R] (s : Set R[X]) (p : R[X]) (hs : s.Nonempty) (hp : p ∈ Submodule.span R s) (h : ∀ p' ∈ s, p'.degree < p.degree) (hp_zero : ¬p = 0) (this : p ∈ degreeLT R p.natDegree) : False := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Semiring $R$**: \n   - In Lean, a semiring is a type with certain algebraic operations and properties. The statement `[Semiring R]` in the Lean code specifies that `R` is a semiring. This is a type class constraint that ensures `R` has the necessary structure for the operations we will perform.\n\n2. **Set $s$ of polynomials over $R[X]$**:\n   - The informal statement refers to a set `s` of polynomials. In Lean, this is represented as `s : Set R[X]`, where `R[X]` denotes the type of polynomials over the semiring `R`.\n\n3. **Nonempty set $s$**:\n   - The condition that the set `s` is nonempty is expressed in Lean as `hs : s.Nonempty`. This is a predicate that asserts there exists at least one element in the set `s`.\n\n4. **Polynomial $p \\in R[X]$**:\n   - The polynomial `p` is an element of `R[X]`, which is directly represented as `p : R[X]` in Lean.\n\n5. **$p$ is in the span of $s$ over $R$**:\n   - The span of a set of polynomials over a semiring is a submodule. The condition `p` is in the span of `s` is expressed as `hp : p ∈ Submodule.span R s`. This states that `p` can be written as a linear combination of elements from `s` with coefficients in `R`.\n\n6. **For all $p' \\in s$, $\\deg(p') < \\deg(p)$**:\n   - This condition is captured by `h : ∀ p' ∈ s, p'.degree < p.degree`. It uses a universal quantifier to state that for every polynomial `p'` in the set `s`, the degree of `p'` is less than the degree of `p`.\n\n7. **$p$ is not the zero polynomial**:\n   - The condition that `p` is not zero is expressed as `hp_zero : ¬p = 0`. This"}
{"source_file": "herald_data/sample_500.jsonl", "line": 317, "id": 455172, "informal_statement": "Let $a,b,c,d\\geq 0, ab+ac+ad+bc+bd+cd=6.$ Prove or disprove \\n $$\\dfrac{1}{a^2+2} + \\dfrac{1}{b^2+2} + \\dfrac{1}{c^2+2} + \\dfrac{1}{d^2+2}\\geq\\frac54.$$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_455172 (a b c d : ℝ) (hab : a ≥ 0 ∧ b ≥ 0 ∧ c ≥ 0 ∧ d ≥ 0) (h : a * b + a * c + a * d + b * c + b * d + c * d = 6) : 1 / (a ^ 2 + 2) + 1 / (b ^ 2 + 2) + 1 / (c ^ 2 + 2) + 1 / (d ^ 2 + 2) ≥ 5 / 4  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow a structured approach that captures the essence of the problem and its conditions. Here's a step-by-step explanation of the translation process:\n\n1. **Identify Variables and Their Types**:\n   - The informal statement involves four variables \\(a, b, c, d\\) which are non-negative real numbers. In Lean, these are represented as `ℝ`, the type for real numbers.\n   - We declare these variables in the theorem statement as `(a b c d : ℝ)`.\n\n2. **Express Non-negativity Condition**:\n   - The condition \\(a, b, c, d \\geq 0\\) is expressed using conjunctions in Lean. This is done with the logical `∧` operator.\n   - In Lean, this is written as `(hab : a ≥ 0 ∧ b ≥ 0 ∧ c ≥ 0 ∧ d ≥ 0)`, where `hab` is a hypothesis name for this condition.\n\n3. **Express the Given Equation**:\n   - The equation \\(ab + ac + ad + bc + bd + cd = 6\\) is a constraint on the variables.\n   - In Lean, multiplication is expressed with `*` and addition with `+`. The equation is written as `(h : a * b + a * c + a * d + b * c + b * d + c * d = 6)`, where `h` is a hypothesis name for this condition.\n\n4. **State the Inequality to Prove**:\n   - The goal is to prove the inequality \\(\\frac{1}{a^2+2} + \\frac{1}{b^2+2} + \\frac{1}{c^2+2} + \\frac{1}{d^2+2} \\geq \\frac{5}{4}\\).\n   - In Lean, division is expressed with `/`, and exponentiation is expressed with `^`. The inequality is written as `1 / (a ^ 2 + 2) + 1 / (b ^ 2 + 2) + 1 / (c ^ 2 + 2) + 1 / (d ^ 2 + 2) ≥ 5 / 4`.\n\n5. **Structure the Theorem**:\n   - The theorem is structured with the keyword `theorem`, followed by a"}
{"source_file": "herald_data/sample_500.jsonl", "line": 323, "id": 274684, "informal_statement": "For any topological group $G$ which is not compact, and given two compact sets $K, L \\subset G$ with the property that the product set $K \\cdot L^{-1}$ is not the entire space, along with an element $g \\in G$ not contained in $K \\cdot L^{-1}$, an element $b \\in L$, and the condition that $g \\cdot b$ is in $K$, prove that $b^{-1}$ is in $L^{-1}$.", "formal_statement": "import Mathlib\nopen Set Filter TopologicalSpace Function Topology Pointwise MulOpposite\nopen MulOpposite\nopen QuotientGroup\nopen MulOpposite\nlemma exists_disjoint_smul_of_isCompact_tac_64639 [TopologicalSpace G] [Group G] [TopologicalGroup G] [NoncompactSpace G] (K : Set G) (L : Set G) (hK : IsCompact K) (hL : IsCompact L) (A : ¬K * L⁻¹ = univ) (g : G) (hg : g ∉ K * L⁻¹) (b : G) (bL : b ∈ L) (ha : (fun x => g • x) b ∈ K) : b⁻¹ ∈ L⁻¹ := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully map each component of the informal statement to its formal counterpart in Lean. Here's a step-by-step explanation of the translation:\n\n1. **Topological Group and Non-compactness**:\n   - The informal statement begins by considering a topological group \\( G \\) that is not compact. In Lean, this is expressed by the type class constraints `[TopologicalSpace G]`, `[Group G]`, and `[TopologicalGroup G]` to indicate that \\( G \\) is a topological group. The non-compactness is captured by `[NoncompactSpace G]`.\n\n2. **Compact Sets \\( K \\) and \\( L \\)**:\n   - The sets \\( K \\) and \\( L \\) are subsets of \\( G \\) and are compact. In Lean, these are represented as `K : Set G` and `L : Set G`, with the compactness conditions `hK : IsCompact K` and `hL : IsCompact L`.\n\n3. **Product Set \\( K \\cdot L^{-1} \\)**:\n   - The product set \\( K \\cdot L^{-1} \\) is the set of all products \\( k \\cdot l^{-1} \\) where \\( k \\in K \\) and \\( l \\in L \\). In Lean, this is expressed as `K * L⁻¹`, using the pointwise multiplication and inverse operations.\n\n4. **Condition \\( K \\cdot L^{-1} \\neq G \\)**:\n   - The condition that \\( K \\cdot L^{-1} \\) is not the entire space \\( G \\) is expressed as `A : ¬K * L⁻¹ = univ`, where `univ` represents the entire space \\( G \\).\n\n5. **Element \\( g \\notin K \\cdot L^{-1} \\)**:\n   - The element \\( g \\) is not in the product set \\( K \\cdot L^{-1} \\). This is represented by `g : G` and `hg : g ∉ K * L⁻¹`.\n\n6. **Element \\( b \\in L \\) and Condition \\( g \\cdot b \\in K \\)**:\n   - The element \\( b \\) is in \\( L \\), expressed as `b : G` and `bL : b ∈"}
{"source_file": "herald_data/sample_500.jsonl", "line": 324, "id": 169434, "informal_statement": "For any $f$ in the class of functions $F$ between a group $\\alpha$ and a linearly ordered additive commutative group $\\beta$, and for any elements $x, y \\in \\alpha$, show that $f(x) \\leq f(y) + f(x / y)$ and $f(y) \\leq f(x) + f(x / y)$.", "formal_statement": "import Mathlib\nopen Function\nopen Lean Meta Qq Function\nlemma abs_sub_map_le_div_tac_10168 [FunLike F α β] [Group α] [LinearOrderedAddCommGroup β] [GroupSeminormClass F α β] (f : F) (x : α) (y : α) : f x ≤ f y + f (x / y) ∧ f y ≤ f x + f (x / y) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures:**\n   - The informal statement involves a group \\(\\alpha\\) and a linearly ordered additive commutative group \\(\\beta\\).\n   - The functions \\(f\\) belong to a class \\(F\\) of functions from \\(\\alpha\\) to \\(\\beta\\).\n\n2. **Translate the Structures into Lean:**\n   - In Lean, a group is represented by the type class `Group`.\n   - A linearly ordered additive commutative group is represented by the type class `LinearOrderedAddCommGroup`.\n\n3. **Function Class Representation:**\n   - The class of functions \\(F\\) is represented using `FunLike F α β`, which is a type class in Lean that abstracts over types that behave like functions from \\(\\alpha\\) to \\(\\beta\\).\n\n4. **Group Seminorm Class:**\n   - The informal statement implies some properties about the function \\(f\\), specifically related to norms or seminorms. In Lean, this is captured by the `GroupSeminormClass F α β`, which provides the necessary properties for \\(f\\).\n\n5. **Formalizing the Hypotheses:**\n   - The lemma is parameterized by `f : F`, `x : α`, and `y : α`, indicating that \\(f\\) is a function from the class \\(F\\), and \\(x\\) and \\(y\\) are elements of the group \\(\\alpha\\).\n\n6. **Formalizing the Conclusion:**\n   - The informal statement has two inequalities: \\(f(x) \\leq f(y) + f(x / y)\\) and \\(f(y) \\leq f(x) + f(x / y)\\).\n   - In Lean, these are combined using the conjunction `∧`, resulting in the statement `f x ≤ f y + f (x / y) ∧ f y ≤ f x + f (x / y)`.\n\n7. **Using Lean's Syntax:**\n   - The lemma is introduced with the keyword `lemma`, followed by the name `abs_sub_map_le_div_tac_10168`.\n   - The type classes and parameters are specified in square brackets and parentheses, respectively.\n   - The conclusion of the lemma is stated after the colon `:`, followed by `:= sorry`, indicating"}
{"source_file": "herald_data/sample_500.jsonl", "line": 325, "id": 474340, "informal_statement": "prove that : \\n $\\frac{(a-b)^{2}}{2(a+b)}\\leq\\sqrt{\\frac{a^{2}+b^{2}}{2}}-\\sqrt{ab}\\leq\\frac{(a-b)^{2}}{4\\sqrt{ab}}$ \\n where a, b are positive real numbers", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_474340 (a b : ℝ) (ha : 0 < a) (hb : 0 < b) : (a - b) ^ 2 / (2 * (a + b)) ≤ Real.sqrt ((a ^ 2 + b ^ 2) / 2) - Real.sqrt (a * b) ∧ Real.sqrt ((a ^ 2 + b ^ 2) / 2) - Real.sqrt (a * b) ≤ (a - b) ^ 2 / (4 * Real.sqrt (a * b))  :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a series of steps to ensure that the formal statement accurately represents the informal one. Here's a detailed breakdown of the translation process:\n\n1. **Understanding the Context**: \n   - The informal statement involves an inequality with two parts, where \\( a \\) and \\( b \\) are positive real numbers. The goal is to prove that a certain expression involving \\( a \\) and \\( b \\) is bounded by two other expressions.\n\n2. **Identifying the Variables and Assumptions**:\n   - The variables \\( a \\) and \\( b \\) are real numbers, and the conditions \\( a > 0 \\) and \\( b > 0 \\) are given. These are necessary to ensure that the expressions involving square roots and divisions are well-defined.\n\n3. **Translating the Inequality**:\n   - The inequality is split into two parts:\n     - The left part: \\(\\frac{(a-b)^{2}}{2(a+b)} \\leq \\sqrt{\\frac{a^{2}+b^{2}}{2}} - \\sqrt{ab}\\)\n     - The right part: \\(\\sqrt{\\frac{a^{2}+b^{2}}{2}} - \\sqrt{ab} \\leq \\frac{(a-b)^{2}}{4\\sqrt{ab}}\\)\n\n4. **Formalizing the Variables and Assumptions**:\n   - In Lean, we declare \\( a \\) and \\( b \\) as real numbers using `(a b : ℝ)`.\n   - The positivity conditions are expressed as `(ha : 0 < a)` and `(hb : 0 < b)`.\n\n5. **Formalizing the Inequality**:\n   - The inequality is expressed using Lean's logical operators. The conjunction of the two parts of the inequality is represented using `∧`.\n   - The left part of the inequality is written as `(a - b) ^ 2 / (2 * (a + b)) ≤ Real.sqrt ((a ^ 2 + b ^ 2) / 2) - Real.sqrt (a * b)`.\n   - The right part of the inequality is written as `Real.sqrt ((a ^ 2 + b ^ 2) / 2) - Real.sqrt (a * b) ≤ (a - b) ^ 2 / (4 * Real"}
{"source_file": "herald_data/sample_500.jsonl", "line": 322, "id": 137178, "informal_statement": "For any set \\( s \\) in a topological vector space \\( E \\) over \\( \\mathbb{R} \\), where \\( E \\) is a topological \\( \\mathbb{R} \\)-module, a Hausdorff topological vector space, and a locally convex space, if \\( s \\) is compact and nonempty, then the set of extreme points of \\( s \\) is nonempty.", "formal_statement": "import Mathlib\nopen Set\nopen scoped Classical\nlemma extremePoints_nonempty_tac_2836 [AddCommGroup E] [Module ℝ E] [TopologicalSpace E] [T2Space E] [TopologicalAddGroup E] [ContinuousSMul ℝ E] [LocallyConvexSpace ℝ E] (s : Set E) (hscomp : IsCompact s) (hsnemp : s.Nonempty) : (extremePoints ℝ s).Nonempty := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that involves understanding both the mathematical concepts and how they are represented in Lean4. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context**:\n   - We are dealing with a topological vector space \\( E \\) over the real numbers \\( \\mathbb{R} \\).\n   - The space \\( E \\) is specified to be a topological \\( \\mathbb{R} \\)-module, a Hausdorff space, and a locally convex space.\n   - The statement involves a set \\( s \\) within this space, which is compact and nonempty.\n\n2. **Identifying the Mathematical Structures**:\n   - **Topological Vector Space**: In Lean, this is represented by a combination of structures: `AddCommGroup E` (for the additive group structure), `Module ℝ E` (for the scalar multiplication by reals), `TopologicalSpace E` (for the topology), `T2Space E` (for the Hausdorff property), `TopologicalAddGroup E` (for continuity of addition), and `ContinuousSMul ℝ E` (for continuity of scalar multiplication).\n   - **Locally Convex Space**: This is represented by `LocallyConvexSpace ℝ E`.\n\n3. **Formalizing the Hypotheses**:\n   - The set \\( s \\) is compact: This is expressed as `IsCompact s` in Lean.\n   - The set \\( s \\) is nonempty: This is expressed as `s.Nonempty`.\n\n4. **Formalizing the Conclusion**:\n   - The conclusion states that the set of extreme points of \\( s \\) is nonempty. In Lean, this is expressed as `(extremePoints ℝ s).Nonempty`.\n\n5. **Constructing the Lean Lemma**:\n   - We start by importing necessary modules with `import Mathlib` to access mathematical definitions and theorems.\n   - We open the `Set` namespace to work with set-related functions and properties.\n   - We use `open scoped Classical` to allow classical reasoning, which is often necessary for non-constructive proofs involving compactness and nonemptiness.\n   - We define the lemma `extremePoints_nonempty_tac_2836` with the appropriate type class constraints and hypotheses.\n   - The lemma takes as"}
{"source_file": "herald_data/sample_500.jsonl", "line": 321, "id": 351953, "informal_statement": "For any non-negative real number $p$ and any family of types $\\alpha : \\iota \\to \\text{Type}^*$, there is a natural coercion from the space $\\Pi L^p(\\alpha)$ to the space of functions $i \\mapsto \\alpha(i)$.", "formal_statement": "import Mathlib\nopen Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal\ninstance (p : ℝ≥0∞) {ι : Type*} (α : ι → Type*) : CoeFun (PiLp p α) (fun _ ↦ (i : ι) → α i) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and understand how it maps to the formal language of Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Informal Statement:**\n   - We are dealing with a non-negative real number \\( p \\) and a family of types indexed by some type \\( \\iota \\).\n   - The space \\(\\Pi L^p(\\alpha)\\) refers to a product space of \\( L^p \\) spaces, where each component is a type \\(\\alpha(i)\\) for \\( i \\in \\iota \\).\n   - The statement asserts the existence of a natural coercion from this product space to the space of functions mapping each index \\( i \\) to the corresponding type \\(\\alpha(i)\\).\n\n2. **Translating the Non-negative Real Number \\( p \\):**\n   - In Lean, non-negative real numbers are often represented using `ℝ≥0∞`, which includes non-negative real numbers and infinity. This is suitable for \\( L^p \\) spaces where \\( p \\) can be infinity.\n   - The parameter \\( p \\) is declared as `(p : ℝ≥0∞)` in the Lean code.\n\n3. **Translating the Family of Types \\(\\alpha : \\iota \\to \\text{Type}^*\\):**\n   - The family of types is represented by a function \\(\\alpha\\) that maps each index \\( i \\) in some type \\(\\iota\\) to a type.\n   - In Lean, this is expressed as `(α : ι → Type*)`, where `ι` is the type of indices and `α` is a function from `ι` to `Type*`.\n\n4. **Understanding the Space \\(\\Pi L^p(\\alpha)\\):**\n   - \\(\\Pi L^p(\\alpha)\\) is a product space of \\( L^p \\) spaces for each type \\(\\alpha(i)\\).\n   - In Lean, this is represented by `PiLp p α`, which is a type that encapsulates this product space.\n\n5. **Coercion to the Space of Functions:**\n   - The goal is to define a coercion from `PiLp p α` to the space of functions from `ι` to `α i`.\n   - In Lean, coercions are defined using the `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 326, "id": 459489, "informal_statement": "Prove that if $a, b, c$ are positive real numbers, then $\\frac{27a^2}{c} + \\frac{(b+c)^2}{a} \\geq 12b$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_459489 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : 27 * a^2 / c + (b + c)^2 / a ≥ 12 * b  :=  by sorry", "explanation": "To translate the informal mathematical statement into a formal Lean4 statement, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves three variables: \\(a\\), \\(b\\), and \\(c\\), which are specified to be positive real numbers. In Lean, real numbers are represented by the type `ℝ`.\n\n2. **Express the Positivity Conditions**:\n   - The conditions \\(a, b, c > 0\\) are expressed in Lean using the inequalities `0 < a`, `0 < b`, and `0 < c`. These are included as hypotheses in the theorem.\n\n3. **Translate the Inequality**:\n   - The inequality \\(\\frac{27a^2}{c} + \\frac{(b+c)^2}{a} \\geq 12b\\) is translated directly into Lean syntax. \n   - The expression \\(\\frac{27a^2}{c}\\) is written as `27 * a^2 / c`.\n   - The expression \\(\\frac{(b+c)^2}{a}\\) is written as `(b + c)^2 / a`.\n   - The inequality \\(\\geq\\) is represented by `≥` in Lean.\n\n4. **Structure the Theorem**:\n   - The theorem is named `extract_aug_459489`, which is a placeholder name and can be replaced with a more descriptive name if desired.\n   - The theorem statement includes the variables \\(a\\), \\(b\\), and \\(c\\) as arguments, along with their positivity conditions as hypotheses.\n   - The conclusion of the theorem is the inequality itself.\n\n5. **Import Necessary Libraries**:\n   - The `Mathlib` library is imported to access mathematical functions and types.\n   - The `open` statements are used to bring relevant namespaces into scope, such as `BigOperators`, `Real`, `Nat`, and `Topology`, which might be needed for handling real numbers and operations.\n\n6. **Use of `by sorry`**:\n   - The `by sorry` at the end of the theorem indicates that the proof is not yet provided. In Lean, `sorry` is a placeholder that allows the theorem to be accepted by the system without a proof, useful during the development phase.\n\nBy following these steps, the informal statement is accurately translated into a formal Lean theorem, ready for further proof development."}
{"source_file": "herald_data/sample_500.jsonl", "line": 319, "id": 46231, "informal_statement": "Show that the function which computes the tail of a list, removing the first element and returning the remainder, is primitive recursive.", "formal_statement": "import Mathlib\nopen Mathlib (Vector)\nopen Denumerable Encodable Function\nopen Nat.Primrec\nopen Nat.Primrec\nopen Nat.Primrec\nopen Nat.Primrec\nopen Nat.Primrec\nopen Primrec\nopen Primrec\ntheorem list_tail_extracted [Primcodable α] : Primrec List.tail := sorry", "explanation": "To formalize the informal statement \"Show that the function which computes the tail of a list, removing the first element and returning the remainder, is primitive recursive\" into the Lean4 code provided, we need to follow these steps:\n\n1. **Understanding the Informal Statement**: The task is to show that the operation of taking the tail of a list (i.e., removing the first element and returning the rest) is a primitive recursive function. In computational terms, a function is primitive recursive if it can be constructed from basic functions using a finite number of applications of composition and primitive recursion.\n\n2. **Lean4 Imports and Setup**: \n   - `import Mathlib`: This imports the Mathlib library, which contains a wide range of mathematical definitions and theorems, including those related to primitive recursive functions.\n   - `open Mathlib (Vector)`: This opens the `Vector` namespace from Mathlib, which might be used for handling lists or vectors.\n   - `open Denumerable Encodable Function`: These namespaces are opened to provide access to functions and types related to encoding and denumerability, which are often used in defining computable functions.\n   - `open Nat.Primrec`: This opens the namespace for primitive recursive functions on natural numbers, which is crucial for defining and proving properties about primitive recursive functions.\n\n3. **Understanding the Typeclass `[Primcodable α]`**: \n   - The `[Primcodable α]` constraint indicates that the type `α` is primcodable, meaning it can be encoded in a way that is compatible with primitive recursive functions. This is necessary because the list elements must be of a type that can be handled by primitive recursive functions.\n\n4. **Formalizing the Theorem**:\n   - `theorem list_tail_extracted [Primcodable α] : Primrec List.tail := sorry`: This line states the theorem we want to prove. It asserts that `List.tail` is a primitive recursive function, given that the elements of the list are of a primcodable type `α`.\n   - `Primrec List.tail`: This part specifies that the function `List.tail` is primitive recursive. The `Primrec` predicate is used to denote that a function is primitive recursive.\n\n5. **Understanding `List.tail`**: \n   - `List.tail` is a function that takes a list and returns a new list with the first element removed. In Lean, this function is"}
{"source_file": "herald_data/sample_500.jsonl", "line": 327, "id": 10139, "informal_statement": "For any adapted process \\( f \\) with respect to a filtration \\( \\mathcal{F} \\), and for any real numbers \\( a, b \\) such that \\( a < b \\), prove that the function counting the number of upcrossings of \\( f \\) from level \\( a \\) to level \\( b \\) is measurable.", "formal_statement": "import Mathlib\nopen TopologicalSpace Filter\nopen scoped NNReal ENNReal MeasureTheory ProbabilityTheory Topology\ntheorem measurable_upcrossings_extracted {m0 : MeasurableSpace Ω} {a b : ℝ} {f : ℕ → Ω → ℝ} {ℱ : MeasureTheory.Filtration ℕ m0} :\n MeasureTheory.Adapted ℱ f → a < b → Measurable (MeasureTheory.upcrossings a b f) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down the components of the statement and understand how they map to Lean's formal language:\n\n1. **Context and Imports**:\n   - The code begins with `import Mathlib`, which is a common practice to bring in the necessary mathematical libraries in Lean. This includes definitions and theorems related to measure theory, probability, and topology, which are relevant for the problem at hand.\n   - The `open` and `open scoped` commands are used to bring specific namespaces and notations into the current context, making it easier to refer to concepts like `NNReal`, `ENNReal`, `MeasureTheory`, `ProbabilityTheory`, and `Topology`.\n\n2. **Theorem Declaration**:\n   - The theorem is named `measurable_upcrossings_extracted`, which suggests that it deals with the measurability of upcrossings, a concept in stochastic processes.\n   - The curly braces `{}` around the parameters indicate that these are implicit arguments, which Lean can infer from context when the theorem is applied.\n\n3. **Parameters**:\n   - `{m0 : MeasurableSpace Ω}`: This declares `m0` as a measurable space on a type `Ω`, which is the underlying sample space in probability theory.\n   - `{a b : ℝ}`: These are the real numbers `a` and `b` mentioned in the informal statement, with the condition `a < b` specified later in the theorem.\n   - `{f : ℕ → Ω → ℝ}`: This represents the adapted process `f`, which is a function from natural numbers `ℕ` (representing time indices) to functions from `Ω` to `ℝ`. This matches the description of `f` as a process.\n   - `{ℱ : MeasureTheory.Filtration ℕ m0}`: This is the filtration `ℱ` with respect to which the process `f` is adapted. A filtration is a sequence of σ-algebras that models the information available over time.\n\n4. **Hypotheses**:\n   - `MeasureTheory.Adapted ℱ f`: This hypothesis states that the process `f` is adapted to the filtration `ℱ`. This means that for each time index `n`, the function `f n` is measurable with respect to the σ-algebra `ℱ n`.\n   - `a < b"}
{"source_file": "herald_data/sample_500.jsonl", "line": 328, "id": 117312, "informal_statement": "For any division ring $K$, any additive commutative group $V$, and any submodule $W$ of $V$ over $K$, the submodule $W$ is atomic if and only if there exists a nonzero vector $v$ such that $W$ is the span of $\\{v\\}$ over $K$.", "formal_statement": "import Mathlib\nopen Function Set Submodule\nopen Submodule\nopen Fintype\nlemma atom_iff_nonzero_span_tac_5942 [DivisionRing K] [AddCommGroup V] [Module K V] (W : Submodule K V) (h : ∃ v, v ≠ 0 ∧ W = span K {v}) : IsAtom W := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean.\n\n1. **Division Ring \\( K \\):** \n   - In Lean, a division ring is represented by the type class `DivisionRing K`. This is a structure that provides the necessary operations and properties of a division ring. In the code, `[DivisionRing K]` indicates that \\( K \\) is assumed to be a division ring.\n\n2. **Additive Commutative Group \\( V \\):**\n   - An additive commutative group is represented by the type class `AddCommGroup V` in Lean. This ensures that \\( V \\) has the structure of an abelian group under addition. In the code, `[AddCommGroup V]` specifies this assumption.\n\n3. **Module \\( V \\) over \\( K \\):**\n   - The statement that \\( V \\) is a module over \\( K \\) is captured by the type class `Module K V`. This indicates that \\( V \\) is a vector space (or module) over the division ring \\( K \\). In the code, `[Module K V]` is used to denote this relationship.\n\n4. **Submodule \\( W \\) of \\( V \\):**\n   - In Lean, a submodule is represented by the type `Submodule K V`. The variable `W` is declared as a submodule of \\( V \\) over \\( K \\) with the type `(W : Submodule K V)`.\n\n5. **Atomic Submodule:**\n   - The concept of a submodule being atomic is expressed by the predicate `IsAtom W`. This predicate would be defined elsewhere in the library to capture the notion of atomicity, which typically means that the submodule cannot be decomposed into smaller nontrivial submodules.\n\n6. **Existence of a Nonzero Vector \\( v \\):**\n   - The existence of a nonzero vector \\( v \\) such that \\( W \\) is the span of \\( \\{v\\} \\) is expressed by the hypothesis `(h : ∃ v, v ≠ 0 ∧ W = span K {v})`. This uses Lean's existential quantifier `∃` to state that there exists some vector `v` which is nonzero (`v ≠ 0`) and for which the submodule `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 331, "id": 37781, "informal_statement": "Show that the open interval $(a, b)$ is a subset of the half-open interval $[a, b)$ for any real numbers $a$ and $b$.", "formal_statement": "import Mathlib\nopen Function OrderDual\nopen FinsetInterval\ntheorem Ioo_subset_Ioc_self_extracted {a b : α} [Preorder α] [LocallyFiniteOrder α] : Finset.Ioo a b ⊆ Finset.Ioc a b := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Objects**: The informal statement involves open and half-open intervals of real numbers. In Lean, these intervals are represented using `Finset.Ioo` for open intervals and `Finset.Ioc` for half-open intervals.\n\n2. **Understand the Context**: The statement is about subsets, so we need to show that every element of the open interval $(a, b)$ is also an element of the half-open interval $[a, b)$. This is a subset relation.\n\n3. **Choose the Appropriate Lean Structures**: \n   - `Finset.Ioo a b` represents the set of elements strictly between `a` and `b`.\n   - `Finset.Ioc a b` represents the set of elements greater than or equal to `a` and strictly less than `b`.\n\n4. **Specify the Type and Conditions**: \n   - The variables `a` and `b` are of type `α`, which is a generic type. This allows the theorem to be applicable to any type that has a preorder.\n   - `[Preorder α]` is a typeclass constraint that ensures `α` has a preorder structure, which is necessary to define intervals.\n   - `[LocallyFiniteOrder α]` is another typeclass constraint that ensures the intervals are finite, which is necessary for using `Finset`.\n\n5. **Formalize the Subset Relation**: The goal is to prove `Finset.Ioo a b ⊆ Finset.Ioc a b`. This means that for any element `x`, if `x` is in `Finset.Ioo a b`, then `x` must also be in `Finset.Ioc a b`.\n\n6. **Structure the Theorem**: \n   - The theorem is named `Ioo_subset_Ioc_self_extracted`, indicating it is about the subset relation between `Ioo` and `Ioc`.\n   - The theorem is stated with the `theorem` keyword, followed by the name and the type signature, which includes the variables `a` and `b` and the necessary typeclass constraints.\n\n7. **Use of `sorry`**: The `sorry` keyword is a placeholder indicating that the proof is not provided. In a complete formalization, this would be replaced with a proof showing that every element of `Fin"}
{"source_file": "herald_data/sample_500.jsonl", "line": 329, "id": 78901, "informal_statement": "For any ordered semiring \\( \\alpha \\) and any natural number \\( n \\), show that \\( 0 \\leq n \\) when \\( n \\) is cast to \\( \\alpha \\). That is, the natural number \\( n \\) is non-negative when considered as an element of \\( \\alpha \\).", "formal_statement": "import Mathlib\n\ntheorem cast_nonneg_extracted [OrderedSemiring α] (n : ℕ) : 0 ≤ ↑n := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: The informal statement involves an \"ordered semiring\" and \"natural numbers.\" In Lean, an ordered semiring is represented by the type class `OrderedSemiring α`, where `α` is a type that satisfies the properties of an ordered semiring. Natural numbers are represented by the type `ℕ`.\n\n2. **Understand the Goal**: The goal is to show that for any natural number `n`, when `n` is cast to the type `α`, it is non-negative. This means we need to prove `0 ≤ ↑n` where `↑n` denotes the casting of `n` from `ℕ` to `α`.\n\n3. **Set Up the Theorem**: We start by declaring a theorem in Lean. The theorem should be universally quantified over both the ordered semiring `α` and the natural number `n`. This is done by using the `theorem` keyword followed by the name of the theorem, `cast_nonneg_extracted`.\n\n4. **Specify the Type Class Constraint**: We need to specify that `α` is an ordered semiring. This is done by adding `[OrderedSemiring α]` as a type class constraint in the theorem's parameters.\n\n5. **Declare the Natural Number**: We introduce `n` as a natural number by specifying `(n : ℕ)` in the theorem's parameters.\n\n6. **State the Conclusion**: The conclusion of the theorem is that `0 ≤ ↑n` when `n` is cast to `α`. In Lean, `0` and `↑n` are elements of `α`, and `≤` is the order relation defined for the ordered semiring `α`.\n\n7. **Use the `sorry` Placeholder**: Since the proof is not provided, we use `:= sorry` to indicate that the proof is omitted. This allows the theorem to be syntactically correct without providing a proof.\n\n8. **Import Necessary Libraries**: The statement begins with `import Mathlib`, which is necessary to access the definitions and theorems related to ordered semirings and natural numbers.\n\nBy following these steps, we translate the informal statement into the formal Lean4 code:\n\n```lean\nimport Mathlib\n\ntheorem cast_nonneg_extracted [OrderedSemiring α] (n : ℕ)"}
{"source_file": "herald_data/sample_500.jsonl", "line": 330, "id": 156298, "informal_statement": "For any commutative semiring \\(R\\) equipped with a topological space structure and a topological semiring structure, let \\(s\\) be a subset of \\(R\\) and \\(p\\) a polynomial in \\(R[X]\\). Show that the continuous map representation of \\(p\\) on \\(s\\) is contained in the algebra adjoined by the continuous map representation of \\(X\\) on \\(s\\), i.e., \\((\\text{toContinuousMapOnAlgHom } s) p \\in \\text{Algebra.adjoin } R \\{(\\text{toContinuousMapOnAlgHom } s) X\\}\\).", "formal_statement": "import Mathlib\nopen Polynomial\nopen ContinuousMap in\nopen ContinuousMap in\nopen unitInterval\nopen ContinuousMap\nlemma eq_adjoin_X_tac_6520 [CommSemiring R] [TopologicalSpace R] [TopologicalSemiring R] (s : Set R) (p : R[X]) : (toContinuousMapOnAlgHom s) p ∈ Algebra.adjoin R {(toContinuousMapOnAlgHom s) X} := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to break down each component of the statement and understand how it corresponds to Lean's syntax and library functions. Here's a step-by-step explanation:\n\n1. **Understanding the Context**:\n   - We are dealing with a commutative semiring \\( R \\) that also has a topological space structure and a topological semiring structure. This means \\( R \\) is equipped with operations and a topology that are compatible with each other.\n   - We have a subset \\( s \\) of \\( R \\) and a polynomial \\( p \\) in the polynomial ring \\( R[X] \\).\n\n2. **Identifying the Goal**:\n   - The goal is to show that the continuous map representation of the polynomial \\( p \\) on the subset \\( s \\) is contained in the algebra generated by the continuous map representation of the variable \\( X \\) on \\( s \\).\n\n3. **Formalizing the Structures**:\n   - In Lean, we use type classes to represent algebraic structures. The commutative semiring is represented by `[CommSemiring R]`.\n   - The topological space and topological semiring structures are represented by `[TopologicalSpace R]` and `[TopologicalSemiring R]`, respectively.\n\n4. **Defining the Subset and Polynomial**:\n   - The subset \\( s \\) is represented as `s : Set R`.\n   - The polynomial \\( p \\) is represented as `p : R[X]`, where `R[X]` denotes the polynomial ring over \\( R \\).\n\n5. **Continuous Map Representation**:\n   - The function `toContinuousMapOnAlgHom` is used to convert a polynomial into its continuous map representation on the subset \\( s \\). This function is part of the `ContinuousMap` module, which deals with continuous maps in a topological setting.\n\n6. **Algebra Adjoin**:\n   - The expression `Algebra.adjoin R {(toContinuousMapOnAlgHom s) X}` represents the algebra generated by the continuous map representation of \\( X \\) on \\( s \\). This is the smallest subalgebra of the algebra of continuous maps that contains the image of \\( X \\).\n\n7. **Formalizing the Statement**:\n   - The lemma is named `eq_adjoin_X_tac_6520`, which is a unique identifier for this particular result.\n   - The statement of the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 334, "id": 461694, "informal_statement": "If $ a_{1},a_{2},....,a_{n} \\ge 0$ then prove that : \\n\\n $ ln(a_{1}) + ln(a_{2}) + .... + ln(a_{n}) + n.ln(n) \\leq n.ln(a_{1} + a_{2} + .... + a_{n})$ \\n\\n your inequality? just equivalent to AM-GM ......", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_461694 (n : ℕ) (a : ℕ → ℝ) (ha : ∀ i, 0 < a i) : ∑ i in Finset.range n, Real.log (a i) + n * Real.log n ≤ n * Real.log (∑ i in Finset.range n, a i)  :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to break down the components of the statement and understand how they map to Lean's syntax and libraries. Here's the step-by-step explanation:\n\n1. **Understanding the Informal Statement**:\n   - We are given a sequence of non-negative real numbers \\( a_1, a_2, \\ldots, a_n \\).\n   - The goal is to prove an inequality involving the natural logarithm of these numbers and their sum.\n   - The inequality is a form of the AM-GM inequality, which relates the arithmetic mean and the geometric mean.\n\n2. **Setting Up the Lean Environment**:\n   - We import necessary modules from Lean's math library:\n     - `Mathlib`: Provides access to a wide range of mathematical functions and theorems.\n     - `BigOperators`: Allows us to use summation notation (`∑`).\n     - `Real`: Provides real number operations, including logarithms.\n     - `Nat`: Deals with natural numbers.\n     - `Topology`: Although not directly used here, it might be part of the broader context in the library.\n\n3. **Defining the Theorem**:\n   - We declare a theorem named `extract_aug_461694`.\n   - The theorem takes three parameters:\n     - `n : ℕ`: A natural number representing the number of terms in the sequence.\n     - `a : ℕ → ℝ`: A function from natural numbers to real numbers, representing the sequence \\( a_1, a_2, \\ldots, a_n \\).\n     - `ha : ∀ i, 0 < a i`: A hypothesis stating that each term in the sequence is strictly positive. This is a stronger condition than non-negativity, ensuring the logarithm is well-defined.\n\n4. **Formalizing the Inequality**:\n   - The left-hand side of the inequality is expressed as a sum of logarithms: `∑ i in Finset.range n, Real.log (a i)`.\n     - `Finset.range n` generates the set of indices from 0 to \\( n-1 \\).\n     - `Real.log (a i)` computes the natural logarithm of each term \\( a_i \\).\n   - We add `n * Real.log n` to this sum, corresponding to the \\( n \\cdot \\ln(n) \\) term in the informal statement.\n   - The right"}
{"source_file": "herald_data/sample_500.jsonl", "line": 332, "id": 393497, "informal_statement": "Let $α$ and $β$ be preorders, and let $p : α × β → \\text{Prop}$ be a predicate. If $p$ holds for all but finitely many elements in $α × β$, then for all but finitely many $k \\in α$ and all but finitely many $l \\in β$, $p(k, l)$ holds.", "formal_statement": "import Mathlib\nopen Set\nopen Filter\nopen Filter\ntheorem eventually_atBot_curry [Preorder α] [Preorder β] {p : α × β → Prop}\n    (hp : ∀ᶠ x : α × β in Filter.atBot, p x) : ∀ᶠ k in atBot, ∀ᶠ l in atBot, p (k, l) := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand the components involved and how they map to Lean's formal language. Here's a step-by-step explanation:\n\n1. **Understanding Preorders**: \n   - The informal statement begins by specifying that $α$ and $β$ are preorders. In Lean, this is represented by `[Preorder α] [Preorder β]`. These are typeclass instances that provide the necessary structure (a reflexive and transitive relation) on the types $α$ and $β$.\n\n2. **Predicate on Product Type**:\n   - The predicate $p : α × β → \\text{Prop}$ is a function that takes a pair from the product type $α × β$ and returns a proposition. In Lean, this is directly represented as `{p : α × β → Prop}`.\n\n3. **Eventuality in Filters**:\n   - The informal statement uses the phrase \"for all but finitely many elements,\" which is a concept related to filters in topology. In Lean, this is expressed using the `Filter` module.\n   - The hypothesis `hp : ∀ᶠ x : α × β in Filter.atBot, p x` uses the `∀ᶠ` notation, which stands for \"eventually\" in the context of a filter. `Filter.atBot` is a filter that captures the notion of \"all but finitely many\" for preorders, specifically focusing on the behavior as elements go to negative infinity (or the bottom) in the preorder.\n\n4. **Curry the Predicate**:\n   - The goal is to show that for all but finitely many $k \\in α$, and for all but finitely many $l \\in β$, the predicate $p(k, l)$ holds. This is a curried form of the original predicate on the product type.\n   - The conclusion `∀ᶠ k in atBot, ∀ᶠ l in atBot, p (k, l)` expresses this in Lean. It states that for all but finitely many $k$ (using the filter `atBot` on $α`), and for each such $k$, for all but finitely many $l$ (using the filter `atBot` on $β`), the predicate `p (k, l)` holds.\n\n5. **Theorem Statement**:\n   - The entire statement"}
{"source_file": "herald_data/sample_500.jsonl", "line": 333, "id": 155291, "informal_statement": "For any real numbers $\\theta$ and $\\psi$, suppose $\\cos(\\theta) = \\cos(\\psi)$, $\\sin(\\theta) = \\sin(\\psi)$, $\\pi = 0$, $\\theta + \\psi = \\pi$, and for any integer $n$, $2n + 1 = 0$. Show that $\\theta = \\psi$. Note: The conditions $\\pi = 0$ and $2n + 1 = 0$ are contradictory and likely indicate a formal statement error or a specific context not represented in the informal statement.", "formal_statement": "import Mathlib\nopen Real\nlemma cos_sin_inj_tac_10926 (θ : ℝ) (ψ : ℝ) (Hcos : cos θ = cos ψ) (Hsin : sin θ = sin ψ) (hc : ↑π = 0) (hs : ↑θ + ↑ψ = ↑π) (n : ℤ) (hn : n * 2 + 1 = 0) : ↑θ = ↑ψ := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Types**:\n   - The informal statement involves real numbers $\\theta$ and $\\psi$. In Lean, these are represented as `θ : ℝ` and `ψ : ℝ`, where `ℝ` denotes the type of real numbers.\n\n2. **Translate the Hypotheses**:\n   - The conditions $\\cos(\\theta) = \\cos(\\psi)$ and $\\sin(\\theta) = \\sin(\\psi)$ are directly translated into Lean as `Hcos : cos θ = cos ψ` and `Hsin : sin θ = sin ψ`.\n   - The condition $\\pi = 0$ is translated as `hc : ↑π = 0`. Here, `↑π` is used to denote the real number representation of the mathematical constant $\\pi$. This is a peculiar condition since $\\pi$ is a constant and cannot be zero in standard mathematics, indicating a potential error or specific context.\n   - The condition $\\theta + \\psi = \\pi$ is translated as `hs : ↑θ + ↑ψ = ↑π`. Again, `↑θ` and `↑ψ` are used to denote the real number representations of $\\theta$ and $\\psi`.\n   - The condition for any integer $n$, $2n + 1 = 0$, is translated as `n : ℤ` and `hn : n * 2 + 1 = 0`. Here, `ℤ` denotes the type of integers in Lean, and the equation is directly translated.\n\n3. **State the Conclusion**:\n   - The goal is to show that $\\theta = \\psi$. In Lean, this is expressed as `↑θ = ↑ψ`, indicating that the real number representations of $\\theta$ and $\\psi$ are equal.\n\n4. **Structure of the Lemma**:\n   - The entire statement is encapsulated in a lemma named `cos_sin_inj_tac_10926`. The lemma takes the variables `θ` and `ψ` as inputs, along with the hypotheses `Hcos`, `Hsin`, `hc`, `hs`, and `hn`.\n   - The conclusion `↑θ = ↑ψ` is the goal of the lemma, indicated by `:= sorry`, which is a placeholder for the proof.\n\n5. **Contextual Note**:\n   - The conditions"}
{"source_file": "herald_data/sample_500.jsonl", "line": 335, "id": 133640, "informal_statement": "For a simple graph $G$ with vertex set $V$, a partition $P$ of the vertices, and any two vertices $v, w \\in V$ such that $v$ is adjacent to $w$ in $G$, if $P$ assigns the same part to both $v$ and $w$, and if $w$ is contained in the part of $P$ that includes $v$, then this leads to a contradiction, i.e., $False$.", "formal_statement": "import Mathlib\n\nlemma partOfVertex_ne_of_adj_tac_3548 (G : SimpleGraph V) (P : G.Partition) (v : V) (w : V) (h : G.Adj v w) (hn : P.partOfVertex v = P.partOfVertex w) (hw : w ∈ P.partOfVertex v) : False := sorry", "explanation": "To translate the given informal mathematical statement into the provided Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Context**:\n   - We are dealing with a simple graph \\( G \\) with a vertex set \\( V \\). In Lean, this is represented by `SimpleGraph V`, where `V` is the type of vertices.\n\n2. **Graph Partition**:\n   - The informal statement mentions a partition \\( P \\) of the vertices. In Lean, this is represented by `G.Partition`, which is a structure that partitions the vertices of the graph \\( G \\).\n\n3. **Vertices and Adjacency**:\n   - The statement involves two vertices \\( v \\) and \\( w \\) that are adjacent in \\( G \\). In Lean, adjacency is represented by `G.Adj v w`, which is a predicate indicating that there is an edge between \\( v \\) and \\( w \\).\n\n4. **Partition Assignment**:\n   - The condition that \\( P \\) assigns the same part to both \\( v \\) and \\( w \\) is expressed in Lean as `P.partOfVertex v = P.partOfVertex w`. This means that the partition assigns the same subset (or part) to both vertices.\n\n5. **Vertex Containment in Partition**:\n   - The condition that \\( w \\) is contained in the part of \\( P \\) that includes \\( v \\) is expressed as `w ∈ P.partOfVertex v`. This indicates that \\( w \\) is an element of the subset assigned to \\( v \\) by the partition.\n\n6. **Contradiction**:\n   - The informal statement concludes that these conditions lead to a contradiction, i.e., `False`. In Lean, this is represented by the conclusion of the lemma being `: False`.\n\n7. **Lemma Structure**:\n   - The lemma is named `partOfVertex_ne_of_adj_tac_3548`, which is a unique identifier for this specific result. The lemma takes as arguments the graph \\( G \\), the partition \\( P \\), the vertices \\( v \\) and \\( w \\), the adjacency condition `h : G.Adj v w`, the equality of parts `hn : P.partOfVertex v = P.partOfVertex w`, and the containment condition `hw : w ∈ P"}
{"source_file": "herald_data/sample_500.jsonl", "line": 336, "id": 43863, "informal_statement": "For any functor \\( F \\) from category \\( J \\) to category \\( C \\), show that the object part of the lax limit of \\( F \\) is equal to the object part of the limit of \\( F \\), i.e., \\(\\text{limLax.obj } F = \\text{lim.obj } F\\).", "formal_statement": "import Mathlib\nopen CategoryTheory\nopen CategoryTheory.MonoidalCategory\ntheorem limLax_obj'_extracted [SmallCategory J] [Category.{v : u} C] [Limits.HasLimitsOfShape J C]\n [MonoidalCategory C] (F : J ⥤ C), Limits.limLax.obj F = Limits.lim.obj F := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a series of steps that involve understanding both the mathematical concepts and the Lean4 syntax and libraries. Here's a detailed breakdown of the translation process:\n\n1. **Understanding the Mathematical Concepts**:\n   - We are dealing with functors, categories, and limits in category theory.\n   - A functor \\( F \\) from category \\( J \\) to category \\( C \\) is denoted as \\( F : J \\to C \\).\n   - The statement involves comparing the object part of the lax limit and the limit of a functor \\( F \\).\n\n2. **Lean4 Libraries and Imports**:\n   - The code begins with `import Mathlib`, which is a common practice to import the mathematical library in Lean4 that contains definitions and theorems related to category theory.\n   - `open CategoryTheory` and `open CategoryTheory.MonoidalCategory` are used to bring the relevant definitions and notations into scope, making it easier to work with categories and monoidal categories.\n\n3. **Setting Up the Theorem**:\n   - The theorem is named `limLax_obj'_extracted`, which is a descriptive name indicating that it deals with the object part of the lax limit.\n   - The statement is parameterized over a small category \\( J \\) and a category \\( C \\) with certain properties.\n\n4. **Specifying Category Properties**:\n   - `[SmallCategory J]` indicates that \\( J \\) is a small category, which is a technical condition often required in category theory to ensure certain constructions are well-defined.\n   - `[Category.{v : u} C]` specifies that \\( C \\) is a category with objects in universe level `u` and morphisms in universe level `v`. This is a common way to handle universes in Lean to avoid paradoxes.\n   - `[Limits.HasLimitsOfShape J C]` asserts that the category \\( C \\) has all limits of shape \\( J \\), meaning that for any diagram of shape \\( J \\) in \\( C \\), a limit exists.\n\n5. **Monoidal Category Requirement**:\n   - `[MonoidalCategory C]` indicates that \\( C \\) is a monoidal category, which is necessary for discussing lax limits, as they are defined in the context of monoidal categories.\n\n6. **Defining the Functor**:\n   - `(F :"}
{"source_file": "herald_data/sample_500.jsonl", "line": 341, "id": 220285, "informal_statement": "Show that the value of $\\pi$ divided by $2$ is not equal to $0$, i.e., $\\frac{\\pi}{2} \\neq 0$.", "formal_statement": "import Mathlib\nopen Real\nlemma pi_div_two_ne_zero_tac_20423  : π / 2 ≠ 0 := sorry", "explanation": "To translate the informal mathematical statement \"Show that the value of $\\pi$ divided by $2$ is not equal to $0$, i.e., $\\frac{\\pi}{2} \\neq 0$\" into Lean4, we follow these steps:\n\n1. **Identify the Mathematical Objects**: The statement involves the mathematical constant $\\pi$ and the operation of division by $2$. In Lean, $\\pi$ is represented as `π` within the `Real` namespace.\n\n2. **Understand the Operation**: The operation described is division, specifically $\\pi / 2$. In Lean, division is represented using the `/` operator.\n\n3. **Formulate the Inequality**: The statement asserts that the result of the division is not equal to $0$. In Lean, inequality is expressed using `≠`.\n\n4. **Structure the Lean Statement**: \n   - We start by importing the necessary library `Mathlib` to access mathematical constants and operations.\n   - We open the `Real` namespace to directly use real number operations and constants like `π`.\n   - We define a lemma named `pi_div_two_ne_zero_tac_20423`. The name is arbitrary but should be descriptive or follow a naming convention.\n   - The type of the lemma is the statement we want to prove: `π / 2 ≠ 0`.\n\n5. **Use `sorry` as a Placeholder**: Since the proof is not provided, we use `sorry` as a placeholder. This indicates that the proof is incomplete but allows the code to compile.\n\nThe formal statement in Lean4 is thus:\n\n```lean\nimport Mathlib\nopen Real\nlemma pi_div_two_ne_zero_tac_20423  : π / 2 ≠ 0 := sorry\n```\n\nThis code sets up the framework for proving the statement that $\\frac{\\pi}{2}$ is not equal to $0$ in Lean4."}
{"source_file": "herald_data/sample_500.jsonl", "line": 338, "id": 388153, "informal_statement": "Show that for any sets $A, B, C$, if $A \\subset B$ and $B \\subset C$, then $A \\subset C$.", "formal_statement": "import Mathlib\nopen Function\ninstance : IsTrans (Set α) (· ⊂ ·) := sorry", "explanation": "To formalize the given informal statement in Lean4, we need to translate the concepts of sets and subset relations into Lean's formal language. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Informal Statement**: \n   - We are given three sets \\( A, B, C \\).\n   - The statement involves subset relations: \\( A \\subset B \\) and \\( B \\subset C \\).\n   - We need to prove that \\( A \\subset C \\).\n\n2. **Identifying the Mathematical Concepts**:\n   - The concept of a \"set\" in mathematics is represented in Lean using the `Set` type.\n   - The subset relation \\( \\subset \\) is a binary relation on sets.\n\n3. **Translating Sets and Subset Relation**:\n   - In Lean, a set of elements of type `α` is represented as `Set α`.\n   - The subset relation \\( A \\subset B \\) is represented as `A ⊂ B` in Lean, where `⊂` is the notation for the subset relation.\n\n4. **Formalizing the Transitive Property**:\n   - The informal statement is essentially about the transitive property of the subset relation.\n   - In Lean, transitivity of a relation is expressed using the `IsTrans` typeclass.\n   - `IsTrans` is a typeclass that takes a type and a binary relation and asserts that the relation is transitive.\n\n5. **Writing the Lean Code**:\n   - We need to declare an instance of `IsTrans` for the subset relation on sets.\n   - The line `instance : IsTrans (Set α) (· ⊂ ·) := sorry` is a declaration that states we are defining an instance of `IsTrans` for the type `Set α` and the relation `⊂`.\n   - The `:= sorry` part indicates that the proof of this instance is omitted (or left as a placeholder) for now.\n\n6. **Using Lean's Libraries**:\n   - The line `import Mathlib` is used to import Lean's mathematical library, which provides definitions and theorems about sets and relations.\n   - `open Function` is used to open the `Function` namespace, which might be relevant if functions are involved, but in this case, it is not directly necessary for the subset relation.\n\nIn summary, the formal statement in Lean4 is about defining the trans"}
{"source_file": "herald_data/sample_500.jsonl", "line": 339, "id": 41835, "informal_statement": "For any isomorphisms $\\alpha: X \\to Y$ and $\\beta: Y \\to Z$ in a category, show that the symmetry of the composition $\\alpha \\circ \\beta$ equals the composition of the symmetries $\\beta^{-1} \\circ \\alpha^{-1}$, i.e., $(\\alpha \\circ \\beta)^{-1} = \\beta^{-1} \\circ \\alpha^{-1}$.", "formal_statement": "import Mathlib\nopen Category\ntheorem trans_symm_extracted [CategoryTheory.Category.{v : u} C] {X Y Z : C} (α : X ≅ Y) (β : Y ≅ Z),\n (α ≪≫ β).symm = β.symm ≪≫ α.symm := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to understand both the mathematical concepts involved and how they are represented in Lean's category theory library. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Informal Statement**:\n   - We are given two isomorphisms, $\\alpha: X \\to Y$ and $\\beta: Y \\to Z$, in a category.\n   - The task is to show that the inverse (or symmetry) of the composition of these isomorphisms, $\\alpha \\circ \\beta$, is equal to the composition of their inverses, $\\beta^{-1} \\circ \\alpha^{-1}$.\n\n2. **Identifying Lean's Category Theory Constructs**:\n   - In Lean, categories and isomorphisms are part of the `CategoryTheory` module.\n   - An isomorphism in Lean is represented by the type `X ≅ Y`, which is a structure containing both a morphism and its inverse.\n\n3. **Formalizing the Statement in Lean**:\n   - We start by importing the necessary module with `import Mathlib`, which includes the category theory library.\n   - We open the `Category` namespace to access category-related definitions and notations.\n\n4. **Setting Up the Theorem**:\n   - We declare a theorem named `trans_symm_extracted`.\n   - We specify that we are working within a category `C` by using `[CategoryTheory.Category.{v : u} C]`. This indicates that `C` is a category with objects and morphisms.\n\n5. **Declaring the Isomorphisms**:\n   - We declare the isomorphisms `α : X ≅ Y` and `β : Y ≅ Z`. These are the given isomorphisms in the category `C`.\n\n6. **Expressing the Composition and Inverses**:\n   - The composition of isomorphisms in Lean is denoted by `α ≪≫ β`, which represents the isomorphism from `X` to `Z` obtained by composing `α` and `β`.\n   - The inverse of an isomorphism is accessed using `.symm`. Therefore, `(α ≪≫ β).symm` represents the inverse of the composition.\n\n7. **Stating the Equality**:\n   - We need to show that `(α ≪≫ β).symm` is equal to `β.symm"}
{"source_file": "herald_data/sample_500.jsonl", "line": 340, "id": 380197, "informal_statement": "Let \\((\\alpha, \\leq_\\alpha)\\) and \\((\\beta, \\leq_\\beta)\\) be preordered sets, and let \\(f : \\alpha \\to \\beta\\) be a monotone function. If for every \\(b \\in \\beta\\) there exists \\(a \\in \\alpha\\) such that \\(f(a) \\leq_\\beta b\\), then show that \\(f\\) maps the bottom filter of \\(\\alpha\\) to the bottom filter of \\(\\beta\\).", "formal_statement": "import Mathlib\nopen Set\nopen Filter\nopen Filter\ntheorem tendsto_atBot_atBot_of_monotone [Preorder α] [Preorder β] {f : α → β} (hf : Monotone f)\n    (h : ∀ b, ∃ a, f a ≤ b) : Tendsto f atBot atBot := sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it corresponds to Lean's syntax and library functions.\n\n1. **Preordered Sets**: \n   - The informal statement mentions preordered sets \\((\\alpha, \\leq_\\alpha)\\) and \\((\\beta, \\leq_\\beta)\\). In Lean, a preordered set is represented by a type with a `Preorder` instance. This is indicated by `[Preorder α]` and `[Preorder β]` in the Lean code, which are typeclass constraints ensuring that `α` and `β` have preorder structures.\n\n2. **Monotone Function**:\n   - The function \\(f : \\alpha \\to \\beta\\) is described as monotone. In Lean, a function is monotone if it preserves the order, i.e., \\(a_1 \\leq_\\alpha a_2\\) implies \\(f(a_1) \\leq_\\beta f(a_2)\\). This is captured by the `Monotone f` hypothesis in the Lean code, where `Monotone` is a predicate provided by Lean's math library.\n\n3. **Existential Condition**:\n   - The condition \"for every \\(b \\in \\beta\\) there exists \\(a \\in \\alpha\\) such that \\(f(a) \\leq_\\beta b\\)\" is expressed in Lean as `∀ b, ∃ a, f a ≤ b`. This uses Lean's universal quantifier `∀` and existential quantifier `∃` to directly translate the informal condition into a formal logical statement.\n\n4. **Bottom Filter**:\n   - The informal statement refers to the \"bottom filter\" of a preordered set. In Lean, the bottom filter is represented by `atBot`. The goal is to show that the function \\(f\\) maps the bottom filter of \\(\\alpha\\) to the bottom filter of \\(\\beta\\), which is expressed as `Tendsto f atBot atBot`. Here, `Tendsto` is a predicate that describes the convergence of a function with respect to filters, and `atBot` is the filter representing the bottom of a preorder.\n\n5. **Theorem Statement**:\n   - The theorem is named `tendsto_atBot_atBot_of_monotone`, which succinctly describes its purpose"}
{"source_file": "herald_data/sample_500.jsonl", "line": 337, "id": 323237, "informal_statement": "For a measurable space $m0$ on $\\alpha$, a nonnegative extended real number $p$, a real number $q$, a measure $\\mu$ on $\\alpha$, and assuming $F$ is a normed additive commutative group, let $f: \\alpha \\to F$ be a function. Given that $q > 0$ and $p$ is neither $0$ nor $\\top$ in the extended nonnegative real numbers, show that the extended nonnegative real number representation of $q$ is not equal to $0$, i.e., $q \\neq 0$ in $\\mathbb{R}$.", "formal_statement": "import Mathlib\nopen TopologicalSpace MeasureTheory Filter\nopen scoped NNReal ENNReal Topology\nopen scoped symmDiff in\nlemma eLpNorm_norm_rpow_tac_28206 (m0 : MeasurableSpace α) (p : ℝ≥0∞) (q : ℝ) (μ : Measure α) [NormedAddCommGroup F] (f : α → F) (hq_pos : 0 < q) (h0 : ¬p = 0) (hp_top : ¬p = ⊤) : ENNReal.ofReal q ≠ 0 := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures all the components and assumptions of the problem. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context and Imports**:\n   - The problem involves concepts from measure theory, topology, and normed groups. Therefore, we import relevant modules from the Lean mathematical library (`Mathlib`), such as `TopologicalSpace`, `MeasureTheory`, and `Filter`.\n   - We also open specific namespaces and scopes like `NNReal`, `ENNReal`, and `Topology` to access definitions and operations related to nonnegative real numbers, extended nonnegative real numbers, and topological concepts.\n\n2. **Defining the Lemma**:\n   - We define a lemma named `eLpNorm_norm_rpow_tac_28206`. The name is arbitrary but should be descriptive enough to indicate its purpose or context.\n\n3. **Specifying the Parameters**:\n   - `(m0 : MeasurableSpace α)`: This parameter represents a measurable space on a type `α`. It corresponds to the informal statement's \"measurable space $m0$ on $\\alpha$\".\n   - `(p : ℝ≥0∞)`: This parameter is an extended nonnegative real number, representing the informal statement's \"nonnegative extended real number $p$\".\n   - `(q : ℝ)`: This parameter is a real number, corresponding to the informal statement's \"real number $q$\".\n   - `(μ : Measure α)`: This parameter is a measure on the type `α`, as mentioned in the informal statement.\n   - `[NormedAddCommGroup F]`: This is a type class assumption indicating that `F` is a normed additive commutative group, matching the informal statement's assumption about `F`.\n   - `(f : α → F)`: This parameter is a function from `α` to `F`, as described in the informal statement.\n\n4. **Assumptions**:\n   - `(hq_pos : 0 < q)`: This assumption states that `q` is positive, directly translating the informal statement's \"given that $q > 0$\".\n   - `(h0 : ¬p = 0)`: This assumption ensures that `p` is not zero, corresponding to the informal statement's \"and $p$ is neither $0$\"."}
{"source_file": "herald_data/sample_500.jsonl", "line": 342, "id": 261654, "informal_statement": "For any element \\(a\\) in a monoid \\(R\\), and for any natural number \\(n > 0\\), if \\(a^{n-1} \\cdot a\\) is left regular, then \\(a\\) is also left regular.", "formal_statement": "import Mathlib\n\nlemma pow_iff_tac_1455 (a : R) [Monoid R] (n : ℕ) (n0 : 0 < n) : IsLeftRegular (a ^ n.pred * a) → IsLeftRegular a := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean.\n\n1. **Understanding the Context:**\n   - The informal statement involves a monoid \\( R \\) and an element \\( a \\) within this monoid. In Lean, this is represented by declaring \\( a : R \\) and specifying that \\( R \\) is a monoid with `[Monoid R]`.\n\n2. **Quantification over Natural Numbers:**\n   - The statement involves a natural number \\( n \\) with the condition \\( n > 0 \\). In Lean, natural numbers are represented by `ℕ`, and the condition \\( n > 0 \\) is expressed as `n0 : 0 < n`.\n\n3. **Expression of Powers and Products:**\n   - The expression \\( a^{n-1} \\cdot a \\) in the informal statement is translated to `a ^ n.pred * a` in Lean. Here, `a ^ n.pred` represents \\( a^{n-1} \\) because `n.pred` gives the predecessor of \\( n \\), which is \\( n-1 \\).\n\n4. **Left Regularity:**\n   - The concept of an element being left regular is captured by the predicate `IsLeftRegular`. The informal statement asserts that if \\( a^{n-1} \\cdot a \\) is left regular, then \\( a \\) is left regular. This is directly translated to `IsLeftRegular (a ^ n.pred * a) → IsLeftRegular a`.\n\n5. **Structure of the Lemma:**\n   - The lemma is named `pow_iff_tac_1455`, which is a placeholder name and not directly derived from the informal statement. The lemma takes as arguments the element \\( a \\), the monoid \\( R \\), the natural number \\( n \\), and the proof of \\( n > 0 \\) (`n0 : 0 < n`).\n\n6. **Conclusion:**\n   - The conclusion of the lemma is a logical implication (`→`) from the left regularity of \\( a^{n-1} \\cdot a \\) to the left regularity of \\( a \\).\n\n7. **Use of `sorry`:**\n   - The `sorry` keyword is used as a placeholder for the proof, indicating that the proof is not provided"}
{"source_file": "herald_data/sample_500.jsonl", "line": 344, "id": 375388, "informal_statement": "Given a natural number $n$ and a random generator $g$, define a random computation $\\text{randFin}: \\mathbb{N} \\to \\text{Rand}(\\text{Fin}(n + 1))$ that outputs a random element from the finite set $\\text{Fin}(n + 1)$.", "formal_statement": "import Mathlib\nopen Rand\ndef randFin {n : Nat} [RandomGen g] : RandGT g m (Fin n.succ) := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand the components involved in both the informal and formal statements and how they correspond to each other.\n\n1. **Understanding the Informal Statement:**\n   - We are given a natural number \\( n \\).\n   - We have a random generator \\( g \\).\n   - We need to define a random computation that outputs a random element from the finite set \\(\\text{Fin}(n + 1)\\).\n\n2. **Components of the Formal Statement:**\n   - `import Mathlib`: This imports the Mathlib library, which contains various mathematical and utility functions, including those for random generation.\n   - `open Rand`: This opens the `Rand` namespace, making its definitions and functions directly accessible without needing to prefix them with `Rand.`.\n   - `def randFin {n : Nat} [RandomGen g]`: This begins the definition of a function `randFin`. The `{n : Nat}` indicates that `n` is an implicit argument of type `Nat` (natural number). The `[RandomGen g]` is a typeclass constraint indicating that `g` is a type that implements the `RandomGen` interface, which provides random generation capabilities.\n   - `: RandGT g m (Fin n.succ)`: This specifies the type of the function `randFin`. It is a random computation (`RandGT`) that, given a random generator `g`, produces a monadic action `m` resulting in an element of type `Fin n.succ`. Here, `Fin n.succ` corresponds to the finite set \\(\\text{Fin}(n + 1)\\), where `n.succ` is the successor of `n`, i.e., \\( n + 1 \\).\n\n3. **Mapping Informal to Formal:**\n   - The informal statement's \"natural number \\( n \\)\" is represented by `{n : Nat}` in the formal statement.\n   - The \"random generator \\( g \\)\" is represented by `[RandomGen g]`, indicating that `g` must satisfy the `RandomGen` interface.\n   - The \"random computation\" is represented by the function type `RandGT g m (Fin n.succ)`, which describes a computation that uses a random generator `g` to produce a random element of type `Fin n.succ`.\n   - The target set \\(\\text{Fin}(n + 1)\\"}
{"source_file": "herald_data/sample_500.jsonl", "line": 345, "id": 436853, "informal_statement": "For any integer \\( n \\), prove that \\( \\left\\lceil n \\right\\rceil + \\left\\lceil -n \\right\\rceil = \\left| n \\right| \\).", "formal_statement": "import Mathlib\n\n@[simp]\ntheorem toNat_add_toNat_neg_eq_norm (n : ℤ) : ↑n.toNat + ↑(-n).toNat = ‖n‖ := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand the mathematical concepts involved and how they are represented in Lean.\n\n1. **Understanding the Informal Statement**:\n   - The statement involves the ceiling function \\( \\left\\lceil \\cdot \\right\\rceil \\), which for integers is simply the identity function since integers are already whole numbers.\n   - The absolute value \\( \\left| n \\right| \\) is the non-negative value of \\( n \\), which can be expressed as \\( n \\) if \\( n \\geq 0 \\) and \\(-n\\) if \\( n < 0 \\).\n\n2. **Translation to Lean**:\n   - In Lean, the ceiling function for integers is not explicitly needed because integers are already whole numbers. Instead, we focus on the absolute value and the conversion to natural numbers.\n   - The function `toNat` in Lean converts an integer to a natural number, effectively taking the maximum of the integer and zero. For a positive integer \\( n \\), `n.toNat` is \\( n \\), and for a negative integer, it is \\( 0 \\).\n   - The expression `(-n).toNat` similarly converts the negation of \\( n \\) to a natural number.\n\n3. **Formalizing the Statement**:\n   - The theorem `toNat_add_toNat_neg_eq_norm` states that for any integer \\( n \\), the sum of the natural number conversions of \\( n \\) and \\(-n\\) equals the norm (absolute value) of \\( n \\).\n   - `↑n.toNat` and `↑(-n).toNat` are the natural number conversions of \\( n \\) and \\(-n\\), respectively, lifted to integers for addition.\n   - `‖n‖` represents the absolute value of \\( n \\) in Lean.\n\n4. **Conclusion**:\n   - The Lean theorem asserts that the sum of the non-negative parts of \\( n \\) and \\(-n\\) (i.e., the natural number parts) equals the absolute value of \\( n \\). This aligns with the informal statement because the sum of the positive part of \\( n \\) and the positive part of \\(-n\\) (which is zero if \\( n \\) is positive and \\( n \\) if \\( n \\) is negative) results in the absolute value of \\( n \\).\n\nThus,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 346, "id": 162064, "informal_statement": "For any natural number $n > 0$, show that the minimal polynomial over $\\mathbb{Z}$ of the complex number $\\exp\\left(\\frac{2\\pi i}{n}\\right)$ is irreducible.", "formal_statement": "import Mathlib\nopen IsPrimitiveRoot Complex\nlemma irreducible_tac_9122 (n : ℕ) (hpos : 0 < n) : Irreducible (minpoly ℤ (cexp (2 * ↑Real.pi * I / ↑n))) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Objects**: \n   - The informal statement involves natural numbers, complex numbers, and polynomials. Specifically, it mentions the minimal polynomial over the integers of a complex number of the form \\(\\exp\\left(\\frac{2\\pi i}{n}\\right)\\).\n\n2. **Translate Natural Numbers and Conditions**:\n   - The statement \"for any natural number \\(n > 0\\)\" is translated to Lean as `(n : ℕ) (hpos : 0 < n)`. Here, `n : ℕ` declares \\(n\\) as a natural number, and `hpos : 0 < n` is a hypothesis ensuring \\(n\\) is positive.\n\n3. **Complex Exponential Function**:\n   - The complex number \\(\\exp\\left(\\frac{2\\pi i}{n}\\right)\\) is expressed in Lean using `cexp (2 * ↑Real.pi * I / ↑n)`. \n   - `cexp` is the complex exponential function.\n   - `2 * ↑Real.pi * I / ↑n` represents the exponent \\(\\frac{2\\pi i}{n}\\), where:\n     - `↑Real.pi` lifts the real number \\(\\pi\\) to the complex numbers.\n     - `I` is the imaginary unit in Lean.\n     - `↑n` lifts the natural number \\(n\\) to the complex numbers.\n\n4. **Minimal Polynomial**:\n   - The minimal polynomial over \\(\\mathbb{Z}\\) of the complex number is expressed as `minpoly ℤ (cexp (2 * ↑Real.pi * I / ↑n))`.\n   - `minpoly ℤ` denotes the minimal polynomial over the integers.\n\n5. **Irreducibility**:\n   - The statement \"is irreducible\" is translated to `Irreducible (...)`.\n   - `Irreducible` is a predicate in Lean that checks if a given polynomial is irreducible over its coefficient ring.\n\n6. **Structure of the Lemma**:\n   - The lemma is named `irreducible_tac_9122`, which is a placeholder name.\n   - The lemma takes two arguments: `n` (a natural number) and `hpos` (a proof that \\(n > 0"}
{"source_file": "herald_data/sample_500.jsonl", "line": 349, "id": 185656, "informal_statement": "For any elements $a, b, c$ in a linearly ordered semifield $\\alpha$, given that $0 \\leq a$, $0 < c$, and $c \\leq b$, show that $\\frac{a}{b} \\leq \\frac{a}{c}$.", "formal_statement": "import Mathlib\nopen Function OrderDual\nlemma div_le_div_of_nonneg_left_tac_8312 [LinearOrderedSemifield α] (a : α) (b : α) (c : α) (ha : 0 ≤ a) (hc : 0 < c) (h : c ≤ b) : a / b ≤ a / c := sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structure**: \n   The problem involves a linearly ordered semifield. In Lean, this is represented by the type class `LinearOrderedSemifield α`. This type class includes the properties of a semifield (a field with non-negative elements) and a linear order.\n\n2. **Declare Variables**:\n   The elements $a$, $b$, and $c$ are elements of the semifield $\\alpha$. In Lean, we declare these as variables of type `α`.\n\n3. **State the Hypotheses**:\n   The informal statement provides three conditions:\n   - $0 \\leq a$: This is expressed in Lean as `ha : 0 ≤ a`.\n   - $0 < c$: This is expressed as `hc : 0 < c`.\n   - $c \\leq b$: This is expressed as `h : c ≤ b`.\n\n4. **State the Conclusion**:\n   The goal is to show $\\frac{a}{b} \\leq \\frac{a}{c}$. In Lean, division is represented by the `/` operator, so this is expressed as `a / b ≤ a / c`.\n\n5. **Combine into a Lemma**:\n   The lemma is then constructed with the type class constraint, the variables, the hypotheses, and the conclusion. The lemma is named `div_le_div_of_nonneg_left_tac_8312`, which is a unique identifier for this specific result.\n\n6. **Use the `sorry` Placeholder**:\n   Since the proof is not provided, we use `sorry` as a placeholder. This indicates that the proof is incomplete but allows the statement to be checked for correctness in terms of syntax and logical structure.\n\nPutting it all together, the formal statement in Lean4 is:\n\n```lean\nimport Mathlib\nopen Function OrderDual\n\nlemma div_le_div_of_nonneg_left_tac_8312 [LinearOrderedSemifield α] \n  (a : α) (b : α) (c : α) \n  (ha : 0 ≤ a) (hc : 0 < c) (h : c ≤ b) : \n  a / b ≤ a / c := sorry\n```\n\nThis code imports necessary libraries, opens relevant namespaces, and defines a lemma with the specified conditions and conclusion."}
{"source_file": "herald_data/sample_500.jsonl", "line": 343, "id": 107790, "informal_statement": "For any type \\(\\iota\\) and a family of submonoids \\(p : \\iota \\to \\text{Submonoid } M\\) of a monoid \\(M\\), show that the supremum of this family \\(\\bigvee_{i} p(i)\\) is equal to the closure of the union of these submonoids, i.e., \\(\\bigvee_{i} p(i) = \\text{Submonoid.closure}\\left(\\bigcup_{i} (p(i) : \\text{Set } M)\\right)\\).", "formal_statement": "import Mathlib\nopen Set\ntheorem iSup_eq_closure_extracted [MulOneClass M] {ι : Sort u_4} (p : ι → Submonoid M) : ⨆ i, p i = Submonoid.closure (⋃ i, ↑(p i)) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a series of steps that align the informal concepts with their formal counterparts in Lean. Here's how the translation is achieved:\n\n1. **Understanding the Context**:\n   - We are dealing with a monoid \\( M \\) and a family of submonoids indexed by a type \\(\\iota\\).\n   - The goal is to show that the supremum (join) of these submonoids is equal to the closure of their union.\n\n2. **Formalizing the Monoid**:\n   - In Lean, a monoid is typically represented by a type class. Here, `MulOneClass M` is used, which is a type class that provides the multiplication and identity element for the type \\( M \\). This is a basic structure that supports multiplication and has an identity element, which is sufficient for defining submonoids.\n\n3. **Defining the Index Type**:\n   - The index type \\(\\iota\\) is represented as `ι : Sort u_4`. In Lean, `Sort u_4` is a universe level that allows \\(\\iota\\) to be any type, including types of higher universes.\n\n4. **Defining the Family of Submonoids**:\n   - The family of submonoids is given by a function `p : ι → Submonoid M`. This means for each index \\( i \\) of type \\(\\iota\\), `p(i)` is a submonoid of \\( M \\).\n\n5. **Expressing the Supremum**:\n   - The supremum of the family of submonoids is expressed using the notation `⨆ i, p i`. In Lean, `⨆` is the notation for the supremum (or join) over a family of substructures, such as submonoids.\n\n6. **Expressing the Union and Closure**:\n   - The union of the submonoids is expressed as `⋃ i, ↑(p i)`. Here, `↑(p i)` is the coercion of the submonoid `p(i)` to a set of elements of \\( M \\). The `⋃` symbol denotes the union over all indices \\( i \\).\n   - The closure of this union is expressed as `Submonoid.closure (⋃ i, ↑(p i))`. The `Submonoid"}
{"source_file": "herald_data/sample_500.jsonl", "line": 351, "id": 25991, "informal_statement": "For any non-negative real number $x$, integer $n$, and real number $z$, demonstrate that the real power function satisfies the identity $x^{n \\cdot z} = (x^n)^z$.", "formal_statement": "import Mathlib\nopen scoped Classical\nopen Real ComplexConjugate\nopen Finset Set\nopen Real\nopen Lean Meta Qq\ntheorem rpow_intCast_mul_extracted {x : ℝ} : 0 ≤ x → ∀ (n : ℤ) (z : ℝ), x ^ (↑n * z) = (x ^ n) ^ z := sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to break down the components of the statement and understand how they map to Lean's syntax and semantics.\n\n1. **Understanding the Informal Statement:**\n   - The statement involves three variables: a non-negative real number \\( x \\), an integer \\( n \\), and a real number \\( z \\).\n   - It asserts an identity involving the real power function: \\( x^{n \\cdot z} = (x^n)^z \\).\n\n2. **Translating Variables and Types:**\n   - In Lean, we need to specify the types of the variables explicitly.\n   - \\( x \\) is a non-negative real number, so it is of type `ℝ` (real numbers) with the condition \\( 0 \\leq x \\).\n   - \\( n \\) is an integer, so it is of type `ℤ`.\n   - \\( z \\) is a real number, so it is also of type `ℝ`.\n\n3. **Translating the Power Function:**\n   - The power function in Lean for real numbers is denoted by `^`.\n   - The expression \\( x^{n \\cdot z} \\) involves multiplying \\( n \\) and \\( z \\), which requires casting \\( n \\) from an integer to a real number. This is done using `↑n`, which is the notation for casting an integer to a real number in Lean.\n\n4. **Formalizing the Statement in Lean:**\n   - We start by defining a theorem named `rpow_intCast_mul_extracted`.\n   - The theorem takes a real number \\( x \\) with the condition \\( 0 \\leq x \\), an integer \\( n \\), and a real number \\( z \\).\n   - The goal is to prove the identity \\( x^{(↑n * z)} = (x^n)^z \\).\n\n5. **Lean Syntax and Structure:**\n   - The `theorem` keyword is used to define a new theorem.\n   - The variables and their types are specified in curly braces `{}` for implicit arguments or parentheses `()` for explicit arguments.\n   - The condition \\( 0 \\leq x \\) is specified as a hypothesis in the theorem.\n   - The `∀` symbol is used to denote \"for all\" in Lean, which is written as `∀` in the code.\n   -"}
{"source_file": "herald_data/sample_500.jsonl", "line": 348, "id": 170399, "informal_statement": "For any rack \\(R\\) and elements \\(x, y, z \\in R\\), show that the equation \\((x \\rhd y) \\rhd x \\rhd z = (x \\rhd y) \\rhd z\\) holds if and only if \\(x \\rhd z = z\\). Here, \\(\\rhd\\) denotes the rack operation.", "formal_statement": "import Mathlib\nopen MulOpposite\nopen Quandles\nopen Shelf\nlemma assoc_iff_id_tac_10760 [Rack R] (x : R) (y : R) (z : R) : (x ◃ y) ◃ x ◃ z = (x ◃ y) ◃ z ↔ x ◃ z = z := sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow a structured approach that involves understanding the mathematical concepts, identifying the appropriate Lean constructs, and then writing the formal statement. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Mathematical Context**:\n   - We are dealing with a structure called a \"rack,\" which is a set equipped with a binary operation denoted by \\(\\rhd\\).\n   - The operation \\(\\rhd\\) is associative and satisfies certain axioms typical of racks, such as self-distributivity.\n   - The goal is to prove an equivalence involving this operation for elements \\(x, y, z\\) in a rack \\(R\\).\n\n2. **Identifying Lean Constructs**:\n   - In Lean, racks are often represented using type classes that encapsulate the properties of the operation \\(\\rhd\\).\n   - The operation \\(\\rhd\\) is typically represented by a symbol like `◃` in Lean, which is defined as part of the rack structure.\n\n3. **Translating the Informal Statement**:\n   - The informal statement involves an equivalence: \\((x \\rhd y) \\rhd x \\rhd z = (x \\rhd y) \\rhd z\\) if and only if \\(x \\rhd z = z\\).\n   - In Lean, this is expressed using the logical equivalence operator `↔`.\n\n4. **Writing the Lean Code**:\n   - We start by importing necessary modules from Lean's math library, such as `Mathlib`, which contains definitions and theorems related to racks and quandles.\n   - We open relevant namespaces like `MulOpposite`, `Quandles`, and `Shelf` to access the definitions and operations related to racks.\n   - We define a lemma named `assoc_iff_id_tac_10760` to encapsulate the statement we want to prove.\n   - We specify that \\(R\\) is a rack by using the type class `[Rack R]`.\n   - We declare \\(x, y, z\\) as elements of \\(R\\) with `(x : R) (y : R) (z : R)`.\n   - We then state the equivalence using the `↔` operator: `(x ◃ y) ◃ x ◃ z = (x ◃ y) ◃ z ↔ x"}
{"source_file": "herald_data/sample_500.jsonl", "line": 350, "id": 443333, "informal_statement": "Prove that: $ \\frac {a_1^2}{a_1 + b_1} + \\frac {a_2^2}{a_2 + b_2} + ... + \\frac {a_n^2}{a_n + b_n}\\geq \\frac {a_1 + a_2 + ... + a_n}{2}$ given $ a_1,a_2,...,a_n$ and $ b_1,b_2,...,b_n$ are positive real numbers such that $ a_1 + a_2 + ... + a_n = b_1 + b_2 + ... + b_n$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_443333 {n : ℕ}\n {a b : ℕ → ℝ}\n (h : ∑ i in Finset.range n, a i = ∑ i in Finset.range n, b i)\n : ∑ i in Finset.range n, (a i ^ 2 / (a i + b i)) ≥ ∑ i in Finset.range n, (a i / 2)  :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully map each component of the statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context**:\n   - The problem involves sequences of positive real numbers \\(a_1, a_2, \\ldots, a_n\\) and \\(b_1, b_2, \\ldots, b_n\\).\n   - We are given the condition that the sum of the \\(a_i\\)'s equals the sum of the \\(b_i\\)'s.\n   - The goal is to prove an inequality involving these sequences.\n\n2. **Setting Up the Environment**:\n   - We import necessary modules from Lean's math library (`Mathlib`) to handle real numbers, natural numbers, and summations over finite sets.\n   - `open BigOperators` allows us to use the summation notation `∑` conveniently.\n   - `open Real Nat Topology` provides access to real number operations and properties.\n\n3. **Defining the Variables**:\n   - We declare `n : ℕ` to represent the number of terms in the sequences. This is a natural number.\n   - We define `a b : ℕ → ℝ` as functions from natural numbers to real numbers, representing the sequences \\(a_1, a_2, \\ldots, a_n\\) and \\(b_1, b_2, \\ldots, b_n\\).\n\n4. **Expressing the Given Condition**:\n   - The condition \\(a_1 + a_2 + \\ldots + a_n = b_1 + b_2 + \\ldots + b_n\\) is expressed using the summation notation in Lean:\n     ```lean\n     h : ∑ i in Finset.range n, a i = ∑ i in Finset.range n, b i\n     ```\n   - `Finset.range n` generates the finite set of indices from 0 to \\(n-1\\), and `∑ i in Finset.range n, a i` computes the sum of the sequence \\(a\\).\n\n5. **Formulating the Inequality**:\n   - The inequality to be proven is:\n     \\[\n     \\frac {a_1^2}{a_1 + b_1} + \\frac {a_2^2}{a_2"}
{"source_file": "herald_data/sample_500.jsonl", "line": 352, "id": 188077, "informal_statement": "For any natural number \\( n \\) satisfying \\( 512 \\leq n \\), and assuming there is no prime \\( p \\) such that \\( n < p \\leq 2n \\), along with the inequalities \\( n \\cdot (2n)^{\\sqrt{2n}} \\cdot 4^{\\frac{2n}{3}} \\leq 4^n \\), \\( 4^n < n \\cdot \\binom{n}{\\frac{n}{2}} \\), and \\( n \\cdot \\binom{n}{\\frac{n}{2}} \\leq (2n)^{\\sqrt{2n}} \\cdot 4^{\\frac{2n}{3}} \\), demonstrate that these conditions lead to a contradiction, i.e., \\( \\bot \\).", "formal_statement": "import Mathlib\nopen Real\nopen Nat\nlemma exists_prime_lt_and_le_two_mul_eventually_tac_9826 (n : ℕ) (n_large : 512 ≤ n) (no_prime : ¬∃ p, Prime p ∧ n < p ∧ p ≤ 2 * n) (H1 : n * (2 * n) ^ (2 * n).sqrt * 4 ^ (2 * n / 3) ≤ 4 ^ n) (H2 : 4 ^ n < n * n.centralBinom) (H3 : n.centralBinom ≤ (2 * n) ^ (2 * n).sqrt * 4 ^ (2 * n / 3)) : False := sorry", "explanation": "To translate the given informal mathematical statement into Lean4 code, we need to follow a structured approach to formalize each component of the statement. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context and Imports**:\n   - The problem involves natural numbers, primes, and inequalities, so we need to import relevant libraries from Lean's math library (`Mathlib`) to handle these concepts. The `open Real` and `open Nat` commands are used to access real number operations and natural number operations, respectively.\n\n2. **Defining the Lemma**:\n   - We define a lemma named `exists_prime_lt_and_le_two_mul_eventually_tac_9826`. The name is arbitrary but should be descriptive of the lemma's purpose. In this case, it suggests a contradiction involving primes and inequalities.\n\n3. **Specifying the Parameters**:\n   - The lemma takes several parameters:\n     - `n : ℕ`: A natural number \\( n \\).\n     - `n_large : 512 ≤ n`: An assumption that \\( n \\) is at least 512.\n     - `no_prime : ¬∃ p, Prime p ∧ n < p ∧ p ≤ 2 * n`: An assumption that there is no prime \\( p \\) such that \\( n < p \\leq 2n \\).\n     - `H1 : n * (2 * n) ^ (2 * n).sqrt * 4 ^ (2 * n / 3) ≤ 4 ^ n`: The first inequality condition.\n     - `H2 : 4 ^ n < n * n.centralBinom`: The second inequality condition, where `n.centralBinom` represents the central binomial coefficient \\(\\binom{n}{\\frac{n}{2}}\\).\n     - `H3 : n.centralBinom ≤ (2 * n) ^ (2 * n).sqrt * 4 ^ (2 * n / 3)`: The third inequality condition.\n\n4. **Formalizing the Conclusion**:\n   - The conclusion of the lemma is `False`, represented by `⊥` (bottom) in Lean, indicating a contradiction. The goal is to show that the given assumptions lead to a logical inconsistency.\n\n5. **Using `sorry`**:\n   - The `:= sorry` at the end of the lemma indicates that the proof is not provided. In Lean, `sorry`"}
{"source_file": "herald_data/sample_500.jsonl", "line": 347, "id": 248241, "informal_statement": "For any elements \\(x\\) and \\(y\\) in a commutative ring \\(R\\), show that \\(x\\) divides \\(y\\) if and only if \\(x\\) divides \\(y\\), i.e., \\(x \\mid y \\leftrightarrow x \\mid y\\).", "formal_statement": "import Mathlib\nopen Set\nlemma eq_zero_iff_dvd_tac_4010 [CommRing R] (x : R) (y : R) : x ∣ y ↔ x ∣ y := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Informal Statement**: The statement is a tautology in the context of divisibility in a commutative ring. It asserts that for any elements \\(x\\) and \\(y\\) in a commutative ring \\(R\\), the statement \\(x \\mid y\\) (meaning \\(x\\) divides \\(y\\)) is equivalent to itself, i.e., \\(x \\mid y \\leftrightarrow x \\mid y\\).\n\n2. **Identifying the Mathematical Structures**: The statement involves a commutative ring \\(R\\). In Lean, a commutative ring is typically represented by the type class `CommRing`. The elements \\(x\\) and \\(y\\) are elements of this ring, so they are of type \\(R\\).\n\n3. **Formalizing the Divisibility Relation**: In Lean, the divisibility relation \\(x \\mid y\\) is expressed using the infix operator `∣`. This operator is defined for elements of a ring and is part of Lean's mathematical library.\n\n4. **Setting Up the Lean Environment**: The code begins with `import Mathlib`, which is necessary to access the mathematical library that includes definitions and theorems about rings and divisibility. The `open Set` line is not directly relevant to this lemma but is often included to simplify working with sets.\n\n5. **Defining the Lemma**: The lemma is defined using the `lemma` keyword. The name `eq_zero_iff_dvd_tac_4010` is arbitrary and serves as an identifier for the lemma. The lemma takes two arguments, `x` and `y`, both of type `R`, where `R` is a commutative ring.\n\n6. **Stating the Lemma**: The statement of the lemma is `x ∣ y ↔ x ∣ y`. This is a direct translation of the informal statement into Lean's syntax, asserting the equivalence of \\(x \\mid y\\) with itself.\n\n7. **Using `sorry`**: The `:= sorry` at the end of the lemma indicates that the proof is omitted. In Lean, `sorry` is a placeholder that allows the code to compile without providing a proof. Since the statement is a tautology, the proof would be trivial, but `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 357, "id": 166935, "informal_statement": "The provided formal statement does not contain a mathematical proposition that can be translated into an informal mathematical statement. Instead, it appears to be related to the internal workings of a tactic in Lean's mathlib, specifically a part of the `gcongr` tactic. As such, it does not adhere to the principles of informal statement provided, and there is no mathematical content to translate. Therefore, no informal mathematical statement can be given for this input.", "formal_statement": "import Mathlib\nopen Lean Meta\nopen Elab Tactic\nlemma tacticGcongr__With___tac_23424 (withArg : TSyntax Name.anonymous) (g : MVarId) (_rel : Expr) (lhs : Expr) (_rhs : Expr) (template : Option Expr) : True := sorry", "explanation": "The provided formal statement is a Lean4 code snippet that defines a lemma related to the internal workings of a tactic, specifically within the context of Lean's mathlib. Here's a step-by-step explanation of how this formal statement is structured and what each part represents:\n\n1. **Import Statements**:\n   - `import Mathlib`: This imports the mathlib library, which is a comprehensive library for mathematics in Lean. It provides a wide range of mathematical definitions, theorems, and tactics.\n   - `open Lean Meta`: This opens the `Lean.Meta` namespace, which contains meta-programming utilities in Lean. These are used for manipulating Lean's internal representations of expressions and goals.\n   - `open Elab Tactic`: This opens the `Elab.Tactic` namespace, which includes tools and definitions for elaborating and defining tactics in Lean.\n\n2. **Lemma Declaration**:\n   - `lemma tacticGcongr__With___tac_23424`: This declares a lemma named `tacticGcongr__With___tac_23424`. The name suggests it is related to the `gcongr` tactic, possibly a generated or internal name for a specific part of the tactic's implementation.\n\n3. **Parameters**:\n   - `(withArg : TSyntax Name.anonymous)`: This parameter `withArg` is of type `TSyntax Name.anonymous`, indicating it is a syntax tree node with an anonymous name. This is likely used to represent a part of the syntax tree in the tactic's implementation.\n   - `(g : MVarId)`: This parameter `g` is of type `MVarId`, which represents a metavariable identifier. Metavariables are placeholders for expressions that are yet to be determined, commonly used in tactic scripts.\n   - `(_rel : Expr)`: This parameter `_rel` is of type `Expr`, representing a Lean expression. The underscore prefix suggests it might be an unused or auxiliary parameter.\n   - `(lhs : Expr)`: This parameter `lhs` is also of type `Expr`, representing the left-hand side of a relation or expression.\n   - `(_rhs : Expr)`: This parameter `_rhs` is of type `Expr`, representing the right-hand side of a relation or expression. Like `_rel`, the underscore prefix suggests it might be auxiliary.\n   - `(template : Option Expr)`: This parameter `template` is of type `Option Expr`, meaning it can"}
{"source_file": "herald_data/sample_500.jsonl", "line": 356, "id": 279770, "informal_statement": "For any monoid \\(N\\) and any semimodule \\(M\\) over \\(N\\), given that for all \\(x \\in M\\) and \\(y \\in N\\), the equation \\(y \\cdot (x \\bullet 1) = x \\bullet y\\) holds, show that for any \\(x \\in M\\) and any \\(y, z \\in N\\), the equation \\(y \\cdot (z \\cdot (x \\bullet 1)) = y \\cdot (z \\cdot (x \\bullet 1))\\) is true.", "formal_statement": "import Mathlib\nopen Function (Injective Surjective)\nlemma of_mul_smul_one_tac_27573 [Monoid N] [SMul M N] (H : ∀ (x : M) (y : N), y * x • 1 = x • y) (x : M) (y : N) (z : N) : y * (z * x • 1) = y * (z * x • 1) := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach to formalize each component of the statement. Here's a step-by-step explanation of the translation:\n\n1. **Identify the Structures Involved**:\n   - The informal statement involves a monoid \\(N\\) and a semimodule \\(M\\) over \\(N\\). In Lean, a monoid is represented by the typeclass `Monoid`, and a semimodule is represented by the typeclass `SMul`.\n\n2. **Import Necessary Libraries**:\n   - The formal statement begins with `import Mathlib`, which is necessary to access the mathematical structures and operations defined in Lean's math library.\n\n3. **Open Necessary Namespaces**:\n   - The line `open Function (Injective Surjective)` is included to potentially use properties of functions, although they are not directly used in this lemma.\n\n4. **Define the Lemma**:\n   - The lemma is named `of_mul_smul_one_tac_27573`. Naming conventions in Lean can vary, but this name is likely auto-generated or chosen to be unique.\n\n5. **Specify Typeclass Instances**:\n   - `[Monoid N]` indicates that \\(N\\) is a monoid. This provides the multiplication operation and the identity element.\n   - `[SMul M N]` indicates that \\(M\\) is a semimodule over \\(N\\), which provides the scalar multiplication operation `•`.\n\n6. **State the Hypothesis**:\n   - The hypothesis `H : ∀ (x : M) (y : N), y * x • 1 = x • y` is a direct translation of the given condition in the informal statement. It states that for all \\(x \\in M\\) and \\(y \\in N\\), the equation \\(y \\cdot (x \\bullet 1) = x \\bullet y\\) holds.\n\n7. **State the Variables and Goal**:\n   - The variables `x : M`, `y : N`, and `z : N` are introduced to represent arbitrary elements of the semimodule and the monoid, respectively.\n   - The goal is to prove the equation `y * (z * x • 1) = y * (z * x • 1)`. This is trivially true as it is an identity, meaning the left-hand side is exactly the same as the right"}
{"source_file": "herald_data/sample_500.jsonl", "line": 354, "id": 442723, "informal_statement": "For $a, b, c>0,$ prove that \\n $a^2+b^2+c^2=3\\ \\ \\ \\Longrightarrow\\ \\ \\ a^2\\cdot\\frac{a-b^4}{a+b^4}+b^2\\cdot\\frac{b-c^4}{b+c^4}+c^2\\cdot\\frac{c-a^4}{c+a^4}\\geq0$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_442723 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hab : a + b + c = 3) : a^2 * (a - b^4) / (a + b^4) + b^2 * (b - c^4) / (b + c^4) + c^2 * (c - a^4) / (c + a^4) ≥ 0  :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach to ensure that all components of the statement are accurately represented in the formal language. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Variables and Their Types**:\n   - The variables \\(a\\), \\(b\\), and \\(c\\) are real numbers, as indicated by the context of the problem (involving powers and inequalities).\n   - In Lean, we declare these variables with the type `ℝ` (the type for real numbers in Lean).\n\n2. **State the Conditions**:\n   - The condition \\(a, b, c > 0\\) is translated into three separate hypotheses: `ha : 0 < a`, `hb : 0 < b`, and `hc : 0 < c`. These are assumptions that \\(a\\), \\(b\\), and \\(c\\) are positive real numbers.\n   - The condition \\(a^2 + b^2 + c^2 = 3\\) is translated into a hypothesis `hab : a + b + c = 3`. However, it seems there is a discrepancy here, as the informal statement mentions \\(a^2 + b^2 + c^2 = 3\\), but the formal statement uses \\(a + b + c = 3\\). This might be an error in the formal statement.\n\n3. **Translate the Expression**:\n   - The expression \\(a^2 \\cdot \\frac{a-b^4}{a+b^4} + b^2 \\cdot \\frac{b-c^4}{b+c^4} + c^2 \\cdot \\frac{c-a^4}{c+a^4}\\) is translated directly into Lean using arithmetic operations and division. In Lean, multiplication is denoted by `*`, and division by `/`.\n   - Each term in the sum is expressed as `a^2 * (a - b^4) / (a + b^4)`, `b^2 * (b - c^4) / (b + c^4)`, and `c^2 * (c - a^4) / (c + a^4)`.\n\n4. **State the Inequality**:\n   - The inequality \\(\\geq 0\\) is expressed in Lean as `≥ 0`. Lean uses `≥`"}
{"source_file": "herald_data/sample_500.jsonl", "line": 353, "id": 350336, "informal_statement": "For any element $x$ in a type $\\alpha$, and for any sets $s, t \\subseteq \\alpha$, if $x \\in s \\setminus t$, then $x \\in s$.", "formal_statement": "import Mathlib\nopen Function\ntheorem mem_of_mem_diff {s t : Set α} {x : α} (h : x ∈ s \\ t) : x ∈ s := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Types and Variables**: \n   - The informal statement involves a type $\\alpha$ and elements $x$ of this type. In Lean, we represent this with a type variable `α` and an element `x : α`.\n   - The sets $s$ and $t$ are subsets of $\\alpha$. In Lean, subsets are represented using the `Set` type, so `s` and `t` are of type `Set α`.\n\n2. **Understand the Set Operations**:\n   - The operation $s \\setminus t$ represents the set difference, which in Lean is written as `s \\ t`.\n\n3. **Formalize the Hypothesis**:\n   - The hypothesis $x \\in s \\setminus t$ is expressed in Lean as `x ∈ s \\ t`. This is the input assumption for the theorem.\n\n4. **State the Conclusion**:\n   - The conclusion $x \\in s$ is directly translated to `x ∈ s` in Lean.\n\n5. **Structure the Theorem**:\n   - We need to define a theorem that takes the hypothesis and proves the conclusion. The theorem is named `mem_of_mem_diff`, which is descriptive of its purpose.\n   - The theorem signature includes the sets `s` and `t`, the element `x`, and the hypothesis `h : x ∈ s \\ t`.\n\n6. **Use Lean Syntax**:\n   - The `import Mathlib` statement is used to include the necessary libraries for set operations.\n   - The `open Function` statement is not directly relevant to this theorem but is often included for general utility functions.\n   - The theorem is stated using the `theorem` keyword, followed by the name, parameters, and the type of the theorem, which is the implication from the hypothesis to the conclusion.\n\n7. **Placeholder for Proof**:\n   - The `:= sorry` part is a placeholder indicating that the proof is not yet provided. In a complete development, this would be replaced with the actual proof.\n\nBy following these steps, we translate the informal mathematical statement into the precise formal language of Lean4, capturing the logical structure and relationships between the elements and sets involved."}
{"source_file": "herald_data/sample_500.jsonl", "line": 355, "id": 260226, "informal_statement": "For any Dyck word \\( p \\), the tail of the result of concatenating an up-step, the Dyck word \\( p \\) itself, and a down-step, then dropping the last element, is equal to the Dyck word \\( p \\), i.e., \\([U] ++ p ++ [D]\\).dropLast.tail = p\\).", "formal_statement": "import Mathlib\nopen List\nopen DyckStep\nlemma denest_nest_tac_9214 (p : DyckWord) : ([U] ++ ↑p ++ [D]).dropLast.tail = ↑p := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to understand both the mathematical concepts involved and how they are represented in Lean. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Informal Statement**:\n   - We are dealing with a Dyck word \\( p \\), which is a sequence of up-steps \\( U \\) and down-steps \\( D \\) that is balanced (i.e., at no point in the sequence does the number of down-steps exceed the number of up-steps, and the total number of up-steps equals the total number of down-steps).\n   - The operation described involves concatenating an up-step \\( U \\), the Dyck word \\( p \\), and a down-step \\( D \\).\n   - We then drop the last element of this concatenated list and take the tail of the resulting list.\n   - The claim is that this operation results in the original Dyck word \\( p \\).\n\n2. **Translating to Lean4**:\n   - **Imports and Setup**: The code begins with `import Mathlib`, which is a standard import for mathematical libraries in Lean. It also opens the `List` and `DyckStep` namespaces, which are likely to contain definitions and operations related to lists and Dyck words, respectively.\n   \n   - **Defining the Lemma**: The lemma is named `denest_nest_tac_9214`, which is a unique identifier for this particular result. It takes a single argument `p` of type `DyckWord`.\n   \n   - **DyckWord Representation**: In Lean, `DyckWord` is a type that represents a Dyck word. The notation `↑p` is used to coerce or convert `p` from a `DyckWord` to a list of steps (likely a list of some type representing up-steps and down-steps).\n   \n   - **Concatenation and Operations**:\n     - `[U] ++ ↑p ++ [D]`: This represents the concatenation of a list containing a single up-step `[U]`, the list representation of the Dyck word `p` (`↑p`), and a list containing a single down-step `[D]`.\n     - `.dropLast`: This operation removes the last element from the list. In this context, it removes the down-step `D` that was appended at the end."}
{"source_file": "herald_data/sample_500.jsonl", "line": 358, "id": 113350, "informal_statement": "For any element $b$ in a densely ordered linear topological space $\\alpha$, and for any set $s \\subseteq \\alpha$ satisfying $s \\subseteq ( -\\infty, b)$, if for every $a' < b$ there exists $a < b$ such that the open interval $(a, b)$ is contained in $s$, then for any $a \\in ( -\\infty, b)$, show that $s$ belongs to the left neighborhood filter of $b$, i.e., $s \\in \\mathcal{N}_{<}(b)$.", "formal_statement": "import Mathlib\nopen Set Filter TopologicalSpace Topology Function\nopen OrderDual (toDual ofDual)\nlemma map_coe_atTop_of_Ioo_subset_tac_10415 [TopologicalSpace α] [LinearOrder α] [OrderTopology α] [DenselyOrdered α] (b : α) (s : Set α) (hb : s ⊆ Iio b) (hs : ∀ a' < b, ∃ a < b, Ioo a b ⊆ s) (a : α) (ha : a ∈ Iio b) : s ∈ 𝓝[<] b := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully consider each component of the statement and how it corresponds to Lean's syntax and library functions. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context and Imports**:\n   - The problem involves a densely ordered linear topological space, which requires importing relevant modules from Lean's math library. The imports include `Mathlib`, `Set`, `Filter`, `TopologicalSpace`, `Topology`, and `Function`, which provide the necessary definitions and theorems for working with topological spaces, filters, and order structures.\n\n2. **Defining the Space and Order Properties**:\n   - The space `α` is a topological space with a linear order and an order topology. This is specified by the type class constraints `[TopologicalSpace α]`, `[LinearOrder α]`, `[OrderTopology α]`, and `[DenselyOrdered α]`. These constraints ensure that `α` has the required properties for the problem.\n\n3. **Specifying the Element and Set**:\n   - The element `b` is an element of the space `α`, and `s` is a subset of `α`. In Lean, this is expressed as `(b : α)` and `(s : Set α)`, where `Set α` denotes a subset of `α`.\n\n4. **Subset Condition**:\n   - The condition `s \\subseteq ( -\\infty, b)` is expressed in Lean as `s ⊆ Iio b`, where `Iio b` represents the set of elements less than `b` (the interval `(-∞, b)`).\n\n5. **Existential Condition**:\n   - The condition \"for every `a' < b` there exists `a < b` such that the open interval `(a, b)` is contained in `s`\" is expressed using a universal quantifier followed by an existential quantifier: `∀ a' < b, ∃ a < b, Ioo a b ⊆ s`. Here, `Ioo a b` represents the open interval `(a, b)`.\n\n6. **Conclusion: Membership in the Left Neighborhood Filter**:\n   - The goal is to show that `s` belongs to the left neighborhood filter of `b`, denoted as `s ∈ 𝓝[<] b`. In Lean, `𝓝[<] b"}
{"source_file": "herald_data/sample_500.jsonl", "line": 359, "id": 409010, "informal_statement": "For any order isomorphism \\(e\\) between \\(Fin\\ n\\) and \\(Fin\\ m\\), and for every \\(i \\in Fin\\ n\\), we have \\(e(i) = i\\).", "formal_statement": "import Mathlib\nopen Function Nat Set\n/-- If `e` is an `orderIso` between `Fin n` and `Fin m`, then `n = m` and `e` is the identity\nmap. In this lemma we state that for each `i : Fin n` we have `(e i : ℕ) = (i : ℕ)`. -/\n@[simp] lemma coe_orderIso_apply (e : Fin n ≃o Fin m) (i : Fin n) : (e i : ℕ) = i := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand the components involved and how they relate to each other in both the informal and formal contexts.\n\n1. **Understanding the Informal Statement:**\n   - We are given an \"order isomorphism\" \\( e \\) between two finite sets \\( Fin\\ n \\) and \\( Fin\\ m \\).\n   - The statement claims that for every element \\( i \\) in \\( Fin\\ n \\), the image of \\( i \\) under \\( e \\) is equal to \\( i \\) itself.\n\n2. **Lean4 Components:**\n   - `Fin n`: This represents the finite set of natural numbers less than \\( n \\). It is a type in Lean that corresponds to the set \\(\\{0, 1, \\ldots, n-1\\}\\).\n   - `≃o`: This denotes an order isomorphism between two ordered sets. In this context, it is used to indicate that \\( e \\) is a bijective function that preserves the order between `Fin n` and `Fin m`.\n   - `e : Fin n ≃o Fin m`: This declares that \\( e \\) is an order isomorphism between `Fin n` and `Fin m`.\n\n3. **Formalizing the Statement:**\n   - The lemma `coe_orderIso_apply` is defined to express the property that for each element \\( i \\) in `Fin n`, the image of \\( i \\) under the order isomorphism \\( e \\) is equal to \\( i \\) when both are considered as natural numbers.\n   - The type signature `(e : Fin n ≃o Fin m) (i : Fin n) : (e i : ℕ) = i` specifies that for any order isomorphism \\( e \\) and any element \\( i \\) in `Fin n`, the natural number representation of \\( e(i) \\) is equal to the natural number representation of \\( i \\).\n\n4. **Key Points in the Translation:**\n   - The use of `@[simp]` indicates that this lemma is marked as a simplification rule, suggesting that it is a fundamental property that can be used to simplify expressions involving order isomorphisms between finite sets.\n   - The lemma asserts that the order isomorphism \\( e \\) acts as the identity function on `Fin n`, which implies that \\( n ="}
{"source_file": "herald_data/sample_500.jsonl", "line": 361, "id": 504636, "informal_statement": "Prove that, if a, b, c are positive real numbers, \\n $$ \\frac{a}{bc}+\\frac{b}{ac}+\\frac{c}{ab} \\geq \\frac{2}{a}+\\frac{2}{b}-\\frac{2}{c}$$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_504636 (a b c : ℝ) (ha : a > 0) (hb : b > 0) (hc : c > 0) : a / b / c + b / a / c + c / a / b ≥ 2 / a + 2 / b - 2 / c   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow a series of steps to ensure that the formal statement accurately represents the given problem. Here's the step-by-step explanation:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves three variables \\(a\\), \\(b\\), and \\(c\\), which are specified as positive real numbers. In Lean, real numbers are represented by the type `ℝ`.\n\n2. **Declare the Variables**:\n   - In the formal statement, we declare \\(a\\), \\(b\\), and \\(c\\) as variables of type `ℝ`. This is done in the theorem signature: `(a b c : ℝ)`.\n\n3. **Specify the Conditions**:\n   - The condition that \\(a\\), \\(b\\), and \\(c\\) are positive is crucial. In Lean, this is expressed using inequalities: `ha : a > 0`, `hb : b > 0`, and `hc : c > 0`. These are included as hypotheses in the theorem.\n\n4. **Translate the Expression**:\n   - The left-hand side of the inequality in the informal statement is \\(\\frac{a}{bc} + \\frac{b}{ac} + \\frac{c}{ab}\\). In Lean, division is expressed using the `/` operator. The expression is translated as `a / b / c + b / a / c + c / a / b`.\n   - The right-hand side of the inequality is \\(\\frac{2}{a} + \\frac{2}{b} - \\frac{2}{c}\\). This is translated directly as `2 / a + 2 / b - 2 / c`.\n\n5. **Formulate the Inequality**:\n   - The informal statement requires proving an inequality. In Lean, inequalities are expressed using `≥` for \"greater than or equal to\". The complete inequality is thus `a / b / c + b / a / c + c / a / b ≥ 2 / a + 2 / b - 2 / c`.\n\n6. **Structure the Theorem**:\n   - The theorem is structured with the keyword `theorem`, followed by a name (`extract_aug_504636`), the variables and conditions, and the statement of the inequality. The `:=` symbol indicates the start of the proof, which is currently a placeholder (`by"}
{"source_file": "herald_data/sample_500.jsonl", "line": 360, "id": 40608, "informal_statement": "For any type \\(\\alpha\\), and given points \\(c, x \\in P\\), \\(R \\in \\mathbb{R}\\), and a filter \\(l\\) on \\(\\alpha\\), consider functions \\(fc, fx : \\alpha \\to P\\), \\(fR : \\alpha \\to \\mathbb{R}\\), such that \\(fc\\) tends to \\(c\\), \\(fR\\) tends to \\(R\\), and \\(fx\\) tends to \\(x\\) as filtered by \\(l\\). If \\(x \\neq c\\), demonstrate that the function mapping \\(a\\) to the inversion of \\(fc(a)\\), \\(fR(a)\\), and \\(fx(a)\\) also tends to the inversion of \\(c\\), \\(R\\), and \\(x\\) as filtered by \\(l\\).", "formal_statement": "import Mathlib\nopen Metric Function AffineMap Set AffineSubspace\nopen scoped Topology\nopen EuclideanGeometry\ntheorem inversion_extracted [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P]\n [NormedAddTorsor V P] {x c : P} {R : ℝ} {l : Filter α} {fc fx : α → P} {fR : α → ℝ} :\n Filter.Tendsto fc l (𝓝 c) →\n Filter.Tendsto fR l (𝓝 R) →\n Filter.Tendsto fx l (𝓝 x) →\n x ≠ c → Filter.Tendsto (fun a => inversion (fc a) (fR a) (fx a)) l (𝓝 (inversion c R x)) := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and semantics.\n\n1. **Types and Variables**:\n   - The informal statement begins with \"For any type \\(\\alpha\\)\", which in Lean is implicit in the use of a filter \\(l\\) on \\(\\alpha\\). The type \\(\\alpha\\) is not explicitly declared in the theorem statement but is implied by the filter \\(l : Filter α\\).\n   - Points \\(c, x \\in P\\) and \\(R \\in \\mathbb{R}\\) are declared as variables `{x c : P}` and `{R : ℝ}` in the theorem. Here, \\(P\\) is a type that represents a metric space, which is specified by the context `[MetricSpace P]`.\n\n2. **Filters and Functions**:\n   - The filter \\(l\\) on \\(\\alpha\\) is represented as `{l : Filter α}`.\n   - Functions \\(fc, fx : \\alpha \\to P\\) and \\(fR : \\alpha \\to \\mathbb{R}\\) are declared as `{fc fx : α → P}` and `{fR : α → ℝ}`. These are functions from the type \\(\\alpha\\) to the respective spaces.\n\n3. **Tendencies**:\n   - The statement \"such that \\(fc\\) tends to \\(c\\), \\(fR\\) tends to \\(R\\), and \\(fx\\) tends to \\(x\\) as filtered by \\(l\\)\" is formalized using `Filter.Tendsto`. This is a Lean predicate that describes the convergence of a function with respect to a filter.\n   - `Filter.Tendsto fc l (𝓝 c)` means that the function \\(fc\\) tends to the point \\(c\\) as filtered by \\(l\\), where `𝓝 c` denotes the neighborhood filter of \\(c\\).\n   - Similarly, `Filter.Tendsto fR l (𝓝 R)` and `Filter.Tendsto fx l (𝓝 x)` express the convergence of \\(fR\\) to \\(R\\) and \\(fx\\) to \\(x\\), respectively.\n\n4. **Condition \\(x \\neq c\\)**:\n   - The condition \\(x \\neq c\\) is directly translated to `x"}
{"source_file": "herald_data/sample_500.jsonl", "line": 366, "id": 320020, "informal_statement": "For any function $f : \\beta \\to \\gamma$, and any filters $F$ on $\\alpha$ and $G$ on $\\beta$, show that the product filter of $F$ and the image filter of $G$ under $f$ is equal to the image filter of the product filter $(F \\times G)$ under the product map where the first component is the identity and the second component is $f$, i.e., $(F \\times \\map f G) = \\map (\\Prod.map \\id f) (F \\times G)$.", "formal_statement": "import Mathlib\nopen Set\nopen Filter\nlemma prod_map_right_tac_15320 (f : β → γ) (F : Filter α) (G : Filter β) : F ×ˢ map f G = map (Prod.map id f) (F ×ˢ G) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to understand the components involved and how they correspond to Lean's syntax and library functions. Here's a step-by-step explanation:\n\n1. **Understanding the Components**:\n   - We have a function \\( f : \\beta \\to \\gamma \\).\n   - We have two filters: \\( F \\) on \\( \\alpha \\) and \\( G \\) on \\( \\beta \\).\n   - The goal is to show an equality between two filters: the product filter of \\( F \\) and the image filter of \\( G \\) under \\( f \\), and the image filter of the product filter \\( (F \\times G) \\) under a specific product map.\n\n2. **Lean's Filter Operations**:\n   - `Filter α` represents a filter on the type \\( \\alpha \\).\n   - `map f G` represents the image filter of \\( G \\) under the function \\( f \\).\n   - `F ×ˢ G` represents the product filter of \\( F \\) and \\( G \\).\n\n3. **Product Map**:\n   - The product map mentioned is a function that takes a pair and applies the identity function to the first component and \\( f \\) to the second component. In Lean, this is expressed using `Prod.map id f`.\n\n4. **Formalizing the Statement**:\n   - The goal is to show that the product filter of \\( F \\) and the image filter of \\( G \\) under \\( f \\) is equal to the image filter of the product filter \\( (F \\times G) \\) under the map `Prod.map id f`.\n\n5. **Lean Code Explanation**:\n   - `import Mathlib`: This imports the necessary mathematical library in Lean, which includes definitions and theorems about filters and sets.\n   - `open Set`: This opens the `Set` namespace, allowing us to use set-related functions and notations without prefixing them with `Set.`.\n   - `open Filter`: This opens the `Filter` namespace, allowing us to use filter-related functions and notations without prefixing them with `Filter.`.\n   - `lemma prod_map_right_tac_15320`: This declares a new lemma named `prod_map_right_tac_15320`.\n   - `(f : β → γ) (F : Filter α) (G : Filter β)`: These are the parameters of"}
{"source_file": "herald_data/sample_500.jsonl", "line": 363, "id": 209271, "informal_statement": "For any non-empty finite linearly ordered sets $X$ and $Y$, and given a function $f : X \\to Y$, along with another non-empty finite linearly ordered set $I$, and functions $e : X \\to I$ and $m : I \\to Y$, where $e$ is an epimorphism, show that there exists a strong epimorphism and monomorphism factorisation of $f$.", "formal_statement": "import Mathlib\nopen CategoryTheory CategoryTheory.Limits\nlemma instHasStrongEpiMonoFactorisations_tac_7363 (X : NonemptyFinLinOrd) (Y : NonemptyFinLinOrd) (f : X ⟶ Y) (I : NonemptyFinLinOrd) (e : X ⟶ I) (m : I ⟶ Y) (this : Epi e) : Nonempty (StrongEpiMonoFactorisation f) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a series of steps that involve understanding both the mathematical concepts and how they are represented in Lean's type theory and category theory library. Here's the step-by-step explanation:\n\n1. **Identify the Mathematical Structures**:\n   - The informal statement involves non-empty finite linearly ordered sets, which are mathematical structures that can be represented in Lean using a specific type. In Lean, these are represented by `NonemptyFinLinOrd`, a type that encapsulates the properties of being non-empty, finite, and linearly ordered.\n\n2. **Define the Objects and Morphisms**:\n   - The sets \\( X \\) and \\( Y \\) are represented as objects of type `NonemptyFinLinOrd`.\n   - The function \\( f : X \\to Y \\) is represented as a morphism `f : X ⟶ Y` in the category of non-empty finite linearly ordered sets.\n   - Similarly, \\( I \\) is another object of type `NonemptyFinLinOrd`, and the functions \\( e : X \\to I \\) and \\( m : I \\to Y \\) are morphisms `e : X ⟶ I` and `m : I ⟶ Y`.\n\n3. **Express the Epimorphism Condition**:\n   - The condition that \\( e \\) is an epimorphism is expressed using the `Epi` typeclass in Lean, which is applied to the morphism `e`. This is written as `(this : Epi e)`.\n\n4. **State the Goal**:\n   - The goal is to show the existence of a strong epimorphism and monomorphism factorization of \\( f \\). In Lean, this is expressed using the type `StrongEpiMonoFactorisation f`, which represents such a factorization.\n   - The existence of such a factorization is expressed using `Nonempty (StrongEpiMonoFactorisation f)`, indicating that there is at least one such factorization.\n\n5. **Structure the Lemma**:\n   - The lemma is structured to take the objects \\( X \\), \\( Y \\), and \\( I \\), along with the morphisms \\( f \\), \\( e \\), and \\( m \\), and the epimorphism condition as inputs.\n   - The lemma's conclusion is the existence of a strong epimorphism and monomorphism factorization, expressed"}
{"source_file": "herald_data/sample_500.jsonl", "line": 364, "id": 493727, "informal_statement": "Prove that for any triangle of sides $a,b,c$ and circumradius $R$, $(a+b+c)R \\ge \\sqrt{a^2b^2+b^2c^2+c^2a^2}$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_493727 (a b c R : ℝ) (hx: a > 0 ∧ b > 0 ∧ c > 0) (hab : a + b > c) (hbc : b + c > a) (hca : a + c > b) : (a+b+c)*R ≥ Real.sqrt (a^2 * b^2 + b^2 * c^2 + c^2 * a^2)  :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a structured approach to formalize each component of the problem. Here's a step-by-step explanation:\n\n1. **Understanding the Problem Context**:\n   - We are dealing with a geometric problem involving a triangle with sides \\(a\\), \\(b\\), and \\(c\\), and a circumradius \\(R\\).\n   - The goal is to prove an inequality involving these quantities.\n\n2. **Identifying the Variables**:\n   - The variables \\(a\\), \\(b\\), \\(c\\), and \\(R\\) are real numbers. In Lean, these are represented as `ℝ`, the type for real numbers.\n\n3. **Triangle Inequality Conditions**:\n   - The conditions \\(a + b > c\\), \\(b + c > a\\), and \\(a + c > b\\) ensure that the sides \\(a\\), \\(b\\), and \\(c\\) can form a valid triangle. These are included as hypotheses in the theorem.\n\n4. **Positive Side Lengths**:\n   - The condition \\(a > 0 \\land b > 0 \\land c > 0\\) ensures that the side lengths are positive, which is necessary for a valid triangle. This is also included as a hypothesis.\n\n5. **Formalizing the Inequality**:\n   - The inequality \\((a+b+c)R \\ge \\sqrt{a^2b^2 + b^2c^2 + c^2a^2}\\) is directly translated into Lean using the `≥` operator for greater than or equal to, and `Real.sqrt` for the square root function.\n\n6. **Theorem Declaration**:\n   - The theorem is named `extract_aug_493727`, which is a placeholder name and can be replaced with a more descriptive name.\n   - The theorem takes four real numbers \\(a\\), \\(b\\), \\(c\\), and \\(R\\) as inputs, along with the necessary conditions for a valid triangle and positive side lengths.\n\n7. **Using Lean's Libraries**:\n   - The `import Mathlib` statement brings in necessary mathematical libraries, which include definitions and theorems about real numbers, inequalities, and other mathematical constructs.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to access specific functions and operators without needing to prefix"}
{"source_file": "herald_data/sample_500.jsonl", "line": 367, "id": 238655, "informal_statement": "For any list \\( l \\) of elements in a type \\( \\alpha \\) with decidable equality, assuming \\( l \\) has no duplicates, and for any element \\( x \\) not in \\( l \\), if \\( x \\) is in the set of elements where applying the permutation induced by \\( l \\) to itself \\( l.length \\) times does not fix \\( x \\), then prove that \\( x \\) is actually in \\( l \\).", "formal_statement": "import Mathlib\nopen Equiv Equiv.Perm\nlemma formPerm_pow_length_eq_one_of_nodup_tac_16297 [DecidableEq α] (l : List α) (hl : l.Nodup) (x : α) (hx : x ∉ l) (H : x ∈ {x | (l.formPerm ^ l.length) x ≠ x}) : x ∈ l := sorry", "explanation": "To translate the given informal statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and semantics.\n\n1. **Type and Decidable Equality**: \n   - The informal statement begins by specifying a list \\( l \\) of elements in a type \\( \\alpha \\) with decidable equality. In Lean, this is expressed by `[DecidableEq α]`, which is a typeclass constraint indicating that equality between elements of type \\( \\alpha \\) can be decided (i.e., it is computable whether two elements are equal or not).\n\n2. **List and No Duplicates**:\n   - The list \\( l \\) is specified to have no duplicates. In Lean, this property is captured by `l.Nodup`, which is a predicate that holds true if the list \\( l \\) contains no duplicate elements.\n\n3. **Element Not in List**:\n   - The statement specifies an element \\( x \\) that is not in the list \\( l \\). This is represented in Lean by the condition `x ∉ l`, where `∉` is the infix notation for \"not in\".\n\n4. **Permutation Induced by List**:\n   - The permutation induced by the list \\( l \\) is referred to as `l.formPerm` in Lean. This is a permutation of the elements of the list based on their order.\n\n5. **Applying Permutation Multiple Times**:\n   - The statement involves applying the permutation induced by \\( l \\) to itself \\( l.length \\) times. In Lean, this is expressed as `(l.formPerm ^ l.length)`, where `^` denotes the power operation on permutations, meaning the permutation is applied repeatedly.\n\n6. **Set of Elements Not Fixed by Permutation**:\n   - The informal statement refers to the set of elements where applying the permutation \\( l.length \\) times does not fix the element. In Lean, this is expressed as `{x | (l.formPerm ^ l.length) x ≠ x}`, which is a set comprehension that includes all elements \\( x \\) for which the permutation does not map \\( x \\) to itself.\n\n7. **Conclusion**:\n   - The goal is to prove that if \\( x \\) is in the set of elements not fixed by the permutation, then \\( x \\) must be in \\( l \\). This is the conclusion of the lemma"}
{"source_file": "herald_data/sample_500.jsonl", "line": 371, "id": 427601, "informal_statement": "For any set $S$ of type $\\alpha$, a non-unital, non-associative semiring structure is induced by the set semiring structure on $S$.", "formal_statement": "import Mathlib\nopen Function Set\nopen Pointwise\nopen SetSemiring (down)\nopen Set (up)\ninstance : NonUnitalNonAssocSemiring (SetSemiring α) := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand both the mathematical concepts involved and how they are represented in Lean4.\n\n1. **Understanding the Informal Statement**:\n   - We are dealing with a set \\( S \\) of type \\( \\alpha \\).\n   - The goal is to show that a non-unital, non-associative semiring structure can be induced on this set by using the set semiring structure.\n\n2. **Lean4 Concepts**:\n   - **Type \\(\\alpha\\)**: In Lean, types are used to categorize collections of objects. Here, \\(\\alpha\\) is a type variable representing any type.\n   - **Set \\( S \\)**: In Lean, `Set α` represents the type of all sets whose elements are of type \\(\\alpha\\).\n   - **NonUnitalNonAssocSemiring**: This is a typeclass in Lean representing a semiring that does not necessarily have a multiplicative identity (non-unital) and does not require multiplication to be associative (non-associative).\n\n3. **Translation Steps**:\n   - **Importing Necessary Modules**: \n     - `import Mathlib`: This imports the Mathlib library, which contains a wide range of mathematical definitions and theorems.\n     - `open Function Set`: This makes the definitions and theorems related to functions and sets available without needing to prefix them with `Function` or `Set`.\n     - `open Pointwise`: This allows pointwise operations on sets, which are often used in defining algebraic structures on sets.\n     - `open SetSemiring (down)`: This imports the `SetSemiring` structure, which is a specific way to define semiring operations on sets. The `down` function is likely used to map elements into this structure.\n     - `open Set (up)`: This allows the use of the `up` function, which might be used to lift elements into the set semiring structure.\n\n   - **Defining the Instance**:\n     - `instance : NonUnitalNonAssocSemiring (SetSemiring α) := sorry`: \n       - `instance`: This keyword is used to define a new instance of a typeclass.\n       - `NonUnitalNonAssocSemiring (SetSemiring α)`: We are declaring that `SetSemiring α` can be given the structure of a `NonUnitalNonAssocSem"}
{"source_file": "herald_data/sample_500.jsonl", "line": 362, "id": 233242, "informal_statement": "For any elements \\(a, b \\in \\alpha\\) in a cancel commutative monoid with zero and a GCD monoid \\(\\alpha\\), prove that the greatest common divisor of \\(a\\) and \\(b\\) being zero implies \\(a = 0\\) and \\(b = 0\\), i.e., \\(\\gcd(a, b) = 0 \\implies a = 0 \\wedge b = 0\\).", "formal_statement": "import Mathlib\n\nlemma gcd_eq_zero_iff_tac_15474 [CancelCommMonoidWithZero α] [GCDMonoid α] (a : α) (b : α) (h : gcd a b = 0) (ca : α) (ha : a = 0) (cb : α) (hb : b = 0) : a = 0 ∧ b = 0 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understand the Mathematical Context**: \n   - We are dealing with a structure called a \"cancel commutative monoid with zero\" and a \"GCD monoid\". This implies that the set \\(\\alpha\\) has a binary operation (addition or multiplication) that is commutative, associative, has an identity element (zero), and satisfies the cancellation property. Additionally, it supports a greatest common divisor (GCD) operation.\n\n2. **Identify the Goal**:\n   - The goal is to prove that if the GCD of two elements \\(a\\) and \\(b\\) is zero, then both \\(a\\) and \\(b\\) must be zero.\n\n3. **Translate the Informal Statement**:\n   - The informal statement \"For any elements \\(a, b \\in \\alpha\\)\" translates to having \\(a\\) and \\(b\\) as variables of type \\(\\alpha\\) in Lean.\n   - The condition \"\\(\\gcd(a, b) = 0\\)\" is represented by the hypothesis \\(h : \\text{gcd } a b = 0\\).\n   - The conclusion \"\\(\\implies a = 0 \\wedge b = 0\\)\" is expressed as the goal of the lemma, which is \\(a = 0 \\wedge b = 0\\).\n\n4. **Formalize the Structure and Context**:\n   - The Lean code begins by importing the necessary library `Mathlib` to access the definitions and properties of the structures involved.\n   - The lemma is defined with the necessary type class constraints `[CancelCommMonoidWithZero α]` and `[GCDMonoid α]`, which ensure that the operations and properties required for the proof are available.\n\n5. **Define the Variables and Hypotheses**:\n   - The variables \\(a\\) and \\(b\\) are declared as elements of \\(\\alpha\\).\n   - The hypothesis \\(h : \\text{gcd } a b = 0\\) is included to represent the condition given in the informal statement.\n\n6. **State the Conclusion**:\n   - The conclusion \\(a = 0 \\wedge b = 0\\) is the goal of the lemma, which is what needs to be proven.\n\n7. **Additional Parameters**:\n   - The parameters"}
{"source_file": "herald_data/sample_500.jsonl", "line": 365, "id": 370693, "informal_statement": "For any real number $x$ and rational number $r \\neq 0$, the product $x \\cdot r$ is a Liouville number with exponent $p$ if and only if $x$ is a Liouville number with exponent $p$.", "formal_statement": "import Mathlib\nopen Filter Metric Real Set\nopen scoped Filter Topology\n/-- The product `x * r`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem mul_rat_iff (hr : r ≠ 0) : LiouvilleWith p (x * r) ↔ LiouvilleWith p x := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to understand both the informal and formal components and how they correspond to each other. Here's a step-by-step explanation:\n\n1. **Understanding the Informal Statement:**\n   - We are given a real number \\( x \\) and a non-zero rational number \\( r \\).\n   - The statement involves the concept of a \"Liouville number with exponent \\( p \\).\" A Liouville number is a real number that can be approximated \"very closely\" by rational numbers, with the closeness determined by the exponent \\( p \\).\n   - The statement asserts an equivalence: \\( x \\cdot r \\) is a Liouville number with exponent \\( p \\) if and only if \\( x \\) is a Liouville number with exponent \\( p \\).\n\n2. **Understanding the Formal Statement:**\n   - The Lean code begins by importing necessary libraries (`Mathlib`) and opening relevant namespaces (`Filter`, `Metric`, `Real`, `Set`) to access mathematical definitions and theorems.\n   - The theorem is named `mul_rat_iff`, indicating it deals with multiplication by a rational number and an \"if and only if\" condition.\n   - The hypothesis `hr : r ≠ 0` ensures that \\( r \\) is non-zero, matching the informal statement's condition.\n   - The statement `LiouvilleWith p (x * r) ↔ LiouvilleWith p x` is the core of the theorem. It uses the `LiouvilleWith` predicate to express that both \\( x \\cdot r \\) and \\( x \\) are Liouville numbers with the same exponent \\( p \\).\n\n3. **Translation of Concepts:**\n   - **Real and Rational Numbers:** In Lean, real numbers are typically represented by `ℝ` and rational numbers by `ℚ`. The theorem implicitly assumes \\( x \\) is a real number and \\( r \\) is a rational number.\n   - **Non-zero Condition:** The condition `r ≠ 0` is explicitly stated in the hypothesis `hr : r ≠ 0`.\n   - **Liouville Number with Exponent \\( p \\):** The predicate `LiouvilleWith p` is used to denote that a number is a Liouville number with a specific exponent \\( p \\). This predicate is applied to both \\( x \\cdot r"}
{"source_file": "herald_data/sample_500.jsonl", "line": 368, "id": 233756, "informal_statement": "Show that for any boolean value $a$, the $0$-fold zsmulRec operation of $a$ using nsmulRec is equal to $0$.", "formal_statement": "import Mathlib\nopen scoped symmDiff\nopen BooleanAlgebraOfBooleanRing\nopen BooleanRing\nopen Bool\nlemma instBooleanRingBool_tac_16095  : ∀ (a : Bool), zsmulRec nsmulRec 0 a = 0 := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand both the mathematical concepts involved and how they are represented in Lean.\n\n1. **Understanding the Informal Statement**:\n   - We are dealing with a boolean value `a`. In Lean, this is represented by the type `Bool`.\n   - The operation `zsmulRec` is a zero-scalar multiplication operation, which is a part of the algebraic structure in Lean. It is used to define scalar multiplication in the context of a ring or similar algebraic structure.\n   - The `0`-fold application of `zsmulRec` means applying the operation zero times, which should result in the identity element for addition in the context of the operation, which is `0` in this case.\n   - The `nsmulRec` is another operation that is likely used to define how scalar multiplication is recursively applied, but since we are applying it zero times, its specific behavior is not directly relevant here.\n\n2. **Formalizing in Lean**:\n   - The statement is universally quantified over all boolean values `a`, which is expressed in Lean as `∀ (a : Bool)`.\n   - The expression `zsmulRec nsmulRec 0 a` represents the application of the zero-scalar multiplication operation to the boolean `a`. The `0` indicates that we are applying the operation zero times.\n   - The expected result of this operation is `0`, which is the identity element for addition in the context of boolean algebra (where `0` typically represents `false`).\n\n3. **Lean Code Explanation**:\n   - `import Mathlib`: This imports the necessary mathematical library that contains definitions and operations for boolean algebra and related structures.\n   - `open scoped symmDiff`, `open BooleanAlgebraOfBooleanRing`, `open BooleanRing`, `open Bool`: These lines open various namespaces and scopes that provide access to operations and definitions related to boolean rings and algebra, ensuring that the operations like `zsmulRec` and `nsmulRec` are available.\n   - `lemma instBooleanRingBool_tac_16095`: This defines a lemma, which is a statement that we aim to prove. The name is automatically generated and not particularly descriptive.\n   - `∀ (a : Bool), zsmulRec nsmulRec 0 a = 0`: This is the formal statement of the lemma. It asserts that"}
{"source_file": "herald_data/sample_500.jsonl", "line": 369, "id": 24814, "informal_statement": "For any continuous linear map $A: E \\to F$ over the field $\\mathbb{k}$, show that the adjoint of the adjoint of $A$ is equal to $A$, i.e., $\\text{adjoint}(\\text{adjoint}(A)) = A$.", "formal_statement": "import Mathlib\nopen RCLike\nopen scoped ComplexConjugate\nopen InnerProductSpace\ntheorem adjointAux_adjointAux_extracted [RCLike 𝕜] [NormedAddCommGroup E]\n [NormedAddCommGroup F] [InnerProductSpace 𝕜 E] [InnerProductSpace 𝕜 F]\n [CompleteSpace E] [CompleteSpace F] (A : E →L[𝕜] F) :\n ContinuousLinearMap.adjointAux (ContinuousLinearMap.adjointAux A) = A := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to formalize several components: the spaces involved, the properties of the map, and the concept of the adjoint. Here's a step-by-step explanation of how this is done:\n\n1. **Import Necessary Libraries**: \n   - `import Mathlib`: This imports the Mathlib library, which contains a wide range of mathematical definitions and theorems, including those related to linear algebra and functional analysis.\n\n2. **Open Relevant Namespaces**:\n   - `open RCLike`: This opens the `RCLike` namespace, which is likely related to real or complex linear structures.\n   - `open scoped ComplexConjugate`: This allows the use of complex conjugation in a scoped manner, which is relevant for inner product spaces over complex fields.\n   - `open InnerProductSpace`: This opens the namespace for inner product spaces, which are necessary for defining adjoints.\n\n3. **Define the Theorem**:\n   - `theorem adjointAux_adjointAux_extracted`: This begins the definition of a theorem named `adjointAux_adjointAux_extracted`.\n\n4. **Specify Typeclass Constraints**:\n   - `[RCLike 𝕜]`: This constraint indicates that `𝕜` is a field that supports real or complex linear operations, which is necessary for defining linear maps and adjoints.\n   - `[NormedAddCommGroup E]` and `[NormedAddCommGroup F]`: These constraints specify that `E` and `F` are normed additive commutative groups, which are the underlying structures for normed spaces.\n   - `[InnerProductSpace 𝕜 E]` and `[InnerProductSpace 𝕜 F]`: These constraints specify that `E` and `F` are inner product spaces over the field `𝕜`. This is crucial because the concept of an adjoint is defined in the context of inner product spaces.\n   - `[CompleteSpace E]` and `[CompleteSpace F]`: These constraints ensure that `E` and `F` are complete spaces, which is often a requirement for the existence of adjoints in infinite-dimensional spaces.\n\n5. **Define the Linear Map**:\n   - `(A : E →L[𝕜] F)`: This specifies that `A` is a continuous linear map from `E` to `F` over the field `𝕜"}
{"source_file": "herald_data/sample_500.jsonl", "line": 372, "id": 345764, "informal_statement": "For non-negative real numbers \\( x \\) and \\( y \\), and a positive real number \\( z \\), prove that \\( x^{1/z} < y \\) if and only if \\( x < y^z \\).", "formal_statement": "import Mathlib\nopen scoped Classical\nopen Real NNReal ENNReal ComplexConjugate\nopen Finset Function Set\ntheorem rpow_inv_lt_iff {x y : ℝ≥0} {z : ℝ} (hz : 0 < z) : x ^ z⁻¹ < y ↔ x < y ^ z := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types:**\n   - The informal statement involves non-negative real numbers \\( x \\) and \\( y \\), and a positive real number \\( z \\).\n   - In Lean, non-negative real numbers are represented by the type `ℝ≥0`, which is used for `x` and `y`.\n   - The positive real number \\( z \\) is represented by the type `ℝ` with an additional condition `0 < z`.\n\n2. **Understand the Mathematical Operations:**\n   - The operation \\( x^{1/z} \\) is a power operation where the exponent is the reciprocal of \\( z \\). In Lean, this is expressed using the `^` operator and the reciprocal is denoted by `z⁻¹`.\n   - The operation \\( y^z \\) is a straightforward power operation, also using the `^` operator.\n\n3. **Formulate the Theorem Statement:**\n   - The goal is to prove the equivalence \\( x^{1/z} < y \\) if and only if \\( x < y^z \\).\n   - In Lean, this is expressed using the logical equivalence operator `↔`.\n\n4. **Specify the Conditions:**\n   - The condition that \\( z \\) is positive is crucial for the equivalence to hold. This is specified in Lean as `(hz : 0 < z)`, which is a hypothesis in the theorem.\n\n5. **Structure the Theorem:**\n   - The theorem is named `rpow_inv_lt_iff`, which suggests it deals with the reciprocal power (`rpow_inv`) and the less-than relation (`lt_iff`).\n   - The theorem is stated with the variables `x`, `y`, and `z` and the condition `hz` as inputs.\n   - The statement `x ^ z⁻¹ < y ↔ x < y ^ z` captures the equivalence to be proven.\n\n6. **Import Necessary Libraries:**\n   - The imports at the beginning (`Mathlib`, `Classical`, `Real`, `NNReal`, etc.) ensure that all necessary mathematical operations and types are available for use in the theorem.\n\n7. **Open Relevant Scopes:**\n   - The `open` statements make certain namespaces available, which simplifies the use of functions and types without needing to prefix"}
{"source_file": "herald_data/sample_500.jsonl", "line": 374, "id": 72795, "informal_statement": "For any two elements $q, r \\in \\mathbb{Q}_p$, if the $p$-adic norm of $q$ is not equal to the $p$-adic norm of $r$, then show that the $p$-adic norm of their sum $q + r$ is equal to the maximum of the $p$-adic norms of $q$ and $r$, i.e., $\\|q + r\\|_p = \\max(\\|q\\|_p, \\|r\\|_p)$.", "formal_statement": "import Mathlib\nopen Nat multiplicity padicNorm CauSeq CauSeq.Completion Metric\nopen Classical in\nopen CauSeq\nopen CauSeq\nopen Classical in\nopen PadicSeq\nopen CauSeq\nopen PadicSeq\ntheorem add_eq_max_of_ne'_extracted {p : ℕ} [Fact (Nat.Prime p)] {q r : ℚ_[p]} :\n padicNormE q ≠ padicNormE r → padicNormE (q + r) = max (padicNormE q) (padicNormE r) := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach that involves understanding the mathematical concepts, identifying the appropriate Lean constructs, and then formalizing the statement. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Mathematical Context**:\n   - We are dealing with elements from the $p$-adic numbers, denoted as $\\mathbb{Q}_p$.\n   - The $p$-adic norm, denoted as $\\|\\cdot\\|_p$, is a function that assigns a non-negative real number to each $p$-adic number, reflecting its \"size\" in the $p$-adic sense.\n   - The statement involves comparing the $p$-adic norms of two elements and their sum.\n\n2. **Identifying Lean Constructs**:\n   - In Lean, the $p$-adic numbers are represented as `ℚ_[p]`.\n   - The $p$-adic norm is represented by the function `padicNormE`.\n   - The theorem involves a conditional statement: if the norms of two elements are not equal, then a certain property about their sum holds.\n\n3. **Formalizing the Statement in Lean**:\n   - We start by importing necessary modules from the Lean mathematical library (`Mathlib`) that provide definitions and theorems related to $p$-adic numbers and norms.\n   - We use `open` statements to bring relevant namespaces into scope, such as `Nat`, `multiplicity`, `padicNorm`, `CauSeq`, and `Metric`. This allows us to use functions and theorems from these modules without prefixing them with their module names.\n   - The theorem is defined using the `theorem` keyword, followed by a name that describes its purpose: `add_eq_max_of_ne'_extracted`.\n   - We specify the parameters of the theorem:\n     - `{p : ℕ}` indicates that `p` is a natural number.\n     - `[Fact (Nat.Prime p)]` is a typeclass constraint ensuring that `p` is a prime number.\n     - `{q r : ℚ_[p]}` specifies that `q` and `r` are elements of the $p$-adic numbers.\n   - The hypothesis `padicNormE q ≠ padicNormE r` is the condition under which the conclusion holds.\n   - The conclusion `padicNormE"}
{"source_file": "herald_data/sample_500.jsonl", "line": 379, "id": 573418, "informal_statement": "If $a,b,c\\geq 1,$ prove that $\\sqrt{a^2-1}+\\sqrt{b^2-1}+\\sqrt{c^2-1}\\leq \\frac{ab+bc+ca}{2}.$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_573418 (a b c : ℝ) (ha : 1 ≤ a) (hb : 1 ≤ b) (hc : 1 ≤ c) : √(a^2 - 1) + √(b^2 - 1) + √(c^2 - 1) ≤ (a * b + b * c + c * a) / 2   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The variables \\(a\\), \\(b\\), and \\(c\\) are real numbers. In Lean, real numbers are represented by `ℝ`.\n\n2. **State the Assumptions**:\n   - The conditions \\(a, b, c \\geq 1\\) are translated into Lean as `1 ≤ a`, `1 ≤ b`, and `1 ≤ c`. These are assumptions that need to be included in the theorem statement.\n\n3. **Express the Mathematical Operations**:\n   - The expression \\(\\sqrt{a^2 - 1}\\) is translated to `√(a^2 - 1)` in Lean. The square root function is represented by `√`, and exponentiation is represented by `^`.\n   - Similarly, \\(\\sqrt{b^2 - 1}\\) and \\(\\sqrt{c^2 - 1}\\) are translated to `√(b^2 - 1)` and `√(c^2 - 1)` respectively.\n\n4. **Formulate the Inequality**:\n   - The inequality \\(\\sqrt{a^2-1}+\\sqrt{b^2-1}+\\sqrt{c^2-1}\\leq \\frac{ab+bc+ca}{2}\\) is directly translated to `√(a^2 - 1) + √(b^2 - 1) + √(c^2 - 1) ≤ (a * b + b * c + c * a) / 2`.\n   - The division by 2 is represented by `/ 2`, and multiplication is represented by `*`.\n\n5. **Structure the Theorem in Lean**:\n   - The theorem is named `extract_aug_573418`. In Lean, theorem names are identifiers and can be arbitrary, but they should be descriptive or follow a naming convention.\n   - The theorem statement begins with `theorem` followed by the name and the list of variables and assumptions in parentheses.\n   - The assumptions are listed as `(ha : 1 ≤ a)`, `(hb : 1 ≤ b)`, and `(hc : 1 ≤ c)`, indicating that these are hypotheses for the theorem.\n   - The conclusion of the theorem, the inequality, follows the colon `:`"}
{"source_file": "herald_data/sample_500.jsonl", "line": 370, "id": 202515, "informal_statement": "For any natural numbers $m$ and $n$ with $2 \\leq n$, and given $m \\leq \\frac{m}{n}$, prove that $m \\cdot n \\leq m$.", "formal_statement": "import Mathlib\nopen Function\nlemma eq_zero_of_le_div_tac_19280 (m : ℕ) (n : ℕ) (hn : 2 ≤ n) (h : m ≤ m / n) : m * n ≤ m := sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves two natural numbers, \\( m \\) and \\( n \\). In Lean, natural numbers are represented by the type `ℕ`.\n\n2. **State the Conditions**:\n   - The condition \\( 2 \\leq n \\) is directly translated to `(hn : 2 ≤ n)`. This is a hypothesis that \\( n \\) is at least 2.\n   - The condition \\( m \\leq \\frac{m}{n} \\) is translated to `(h : m ≤ m / n)`. This is another hypothesis that \\( m \\) is less than or equal to the integer division of \\( m \\) by \\( n \\).\n\n3. **Formulate the Conclusion**:\n   - The conclusion \\( m \\cdot n \\leq m \\) is directly translated to `m * n ≤ m`. This is the statement we aim to prove under the given hypotheses.\n\n4. **Structure the Lemma**:\n   - In Lean, a lemma is declared using the `lemma` keyword followed by a name, in this case, `eq_zero_of_le_div_tac_19280`.\n   - The lemma takes the variables \\( m \\) and \\( n \\) as arguments, along with the hypotheses `hn` and `h`.\n   - The conclusion of the lemma is `m * n ≤ m`.\n\n5. **Import Necessary Libraries**:\n   - The statement begins with `import Mathlib`, which is a placeholder for importing necessary mathematical libraries. This ensures that all required definitions and theorems are available.\n   - `open Function` is included to make function-related definitions and theorems available without prefixing them with `Function.`.\n\n6. **Use of `sorry`**:\n   - The keyword `sorry` is used as a placeholder for the proof. It indicates that the proof is not yet provided but the statement is syntactically correct.\n\nBy following these steps, the informal statement is accurately translated into a formal Lean4 lemma, ready for further proof development."}
{"source_file": "herald_data/sample_500.jsonl", "line": 373, "id": 292140, "informal_statement": "For any elements $c_1, c_2, r, x, y, z$ in a commutative ring $R$, and any quaternions $a, b, c$ in the quaternion algebra $\\mathbb{H}[R, c_1, c_2]$, show that the quaternion $(2 \\cdot \\text{Re}(a)) - a$ commutes with $a$, where $\\text{Re}(a)$ denotes the real part of $a$.", "formal_statement": "import Mathlib\nopen Quaternion\nlemma instIsStarNormal_tac_20254 (c₁ : R) (c₂ : R) (r : R) (x : R) (y : R) (z : R) (a : ℍ[R,c₁,c₂]) (b : ℍ[R,c₁,c₂]) (c : ℍ[R,c₁,c₂]) [CommRing R] : Commute (↑(2 * a.re) - a) a := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**: \n   - The problem involves a commutative ring \\( R \\) and a quaternion algebra \\(\\mathbb{H}[R, c_1, c_2]\\). In Lean, this is represented by the type `ℍ[R, c₁, c₂]`, where `ℍ` denotes the quaternion algebra over the ring \\( R \\) with parameters \\( c_1 \\) and \\( c_2 \\).\n\n2. **Define the Variables**:\n   - The elements \\( c_1, c_2, r, x, y, z \\) are elements of the commutative ring \\( R \\). In Lean, these are declared as `(c₁ : R) (c₂ : R) (r : R) (x : R) (y : R) (z : R)`.\n   - The quaternions \\( a, b, c \\) are elements of the quaternion algebra \\(\\mathbb{H}[R, c_1, c_2]\\). In Lean, these are declared as `(a : ℍ[R,c₁,c₂]) (b : ℍ[R,c₁,c₂]) (c : ℍ[R,c₁,c₂])`.\n\n3. **Specify the Algebraic Structure**:\n   - The statement requires \\( R \\) to be a commutative ring. In Lean, this is specified by the typeclass `[CommRing R]`.\n\n4. **Translate the Mathematical Expression**:\n   - The expression \\((2 \\cdot \\text{Re}(a)) - a\\) involves the real part of the quaternion \\( a \\), denoted as `a.re` in Lean. The multiplication by 2 is represented as `2 * a.re`.\n   - The subtraction from \\( a \\) is represented as `↑(2 * a.re) - a`. The `↑` symbol is used to coerce the real part, which is an element of \\( R \\), into the quaternion algebra.\n\n5. **State the Commutativity**:\n   - The goal is to show that the quaternion \\((2 \\cdot \\text{Re}(a)) - a\\) commutes with \\( a \\). In Lean, this is expressed using the `Commute` predicate"}
{"source_file": "herald_data/sample_500.jsonl", "line": 375, "id": 292687, "informal_statement": "For any commutative monoid $G$, and given scalar multiplications from monoids $A$ and $B$ to $G$, along with the scalar tower properties for both $A$ and $B$ over $G$, show that for any $r \\in A$, $s \\in B$, and $x \\in G$, the expressions $s \\cdot (r \\cdot x)$ and $s \\cdot r \\cdot x$ are equal, i.e., $s \\cdot (r \\cdot x) = s \\cdot r \\cdot x$.", "formal_statement": "import Mathlib\nopen Function (Injective Surjective)\nlemma of_commMonoid_tac_23467 [CommMonoid G] [SMul A G] [SMul B G] [IsScalarTower A G G] [IsScalarTower B G G] (r : A) (s : B) (x : G) : s • r • x = s • r • x := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Structures Involved**: \n   - The informal statement involves a commutative monoid \\( G \\) and scalar multiplications from monoids \\( A \\) and \\( B \\) to \\( G \\). \n   - It also involves scalar tower properties for both \\( A \\) and \\( B \\) over \\( G \\).\n\n2. **Translate the Structures into Lean**:\n   - In Lean, a commutative monoid is represented by the typeclass `CommMonoid G`.\n   - Scalar multiplication from a monoid \\( A \\) to \\( G \\) is represented by the typeclass `SMul A G`.\n   - Similarly, scalar multiplication from a monoid \\( B \\) to \\( G \\) is represented by `SMul B G`.\n   - The scalar tower property, which ensures compatibility of scalar multiplications, is represented by `IsScalarTower A G G` and `IsScalarTower B G G`.\n\n3. **Formalize the Variables**:\n   - The variables \\( r \\), \\( s \\), and \\( x \\) are elements of \\( A \\), \\( B \\), and \\( G \\) respectively. In Lean, these are represented as `(r : A)`, `(s : B)`, and `(x : G)`.\n\n4. **State the Goal**:\n   - The goal is to show that the expressions \\( s \\cdot (r \\cdot x) \\) and \\( s \\cdot r \\cdot x \\) are equal. In Lean, this is expressed as `s • r • x = s • r • x`.\n\n5. **Construct the Lemma**:\n   - The lemma is constructed with the necessary typeclass instances and variables. The lemma statement is:\n     ```lean\n     lemma of_commMonoid_tac_23467 [CommMonoid G] [SMul A G] [SMul B G] [IsScalarTower A G G] [IsScalarTower B G G] (r : A) (s : B) (x : G) : s • r • x = s • r • x := sorry\n     ```\n   - The `sorry` keyword is a placeholder indicating that the proof is not yet provided.\n\n6. **Import Necessary Libraries**:\n   - The `Mathlib` library is"}
{"source_file": "herald_data/sample_500.jsonl", "line": 376, "id": 372437, "informal_statement": "For any $a, b, c, d \\in S$, if $(a, b) = (c, d)$, then $a = c$ and $b = d$, proving the injectivity of the pairing function.", "formal_statement": "import Mathlib\nopen Function (OfArity)\nopen PSet\nopen PSet\ntheorem pair_injective : Function.Injective2 pair := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand both the mathematical concept and how it is expressed in Lean.\n\n1. **Understanding the Informal Statement**: \n   - The statement is about the injectivity of the pairing function. In mathematics, a pairing function takes two inputs and returns a single output, typically a pair. The statement asserts that if two pairs are equal, then their corresponding components must also be equal. This is a property of injectivity for functions that take two arguments.\n\n2. **Lean4 Concepts**:\n   - **Function.Injective2**: This is a Lean4 construct that represents the injectivity of a function that takes two arguments. Specifically, it means that if the function applied to two pairs of arguments yields the same result, then the pairs of arguments must be identical.\n   - **pair**: This is the function in question, which takes two arguments and returns a pair. In Lean, this is often the standard pairing function that constructs ordered pairs.\n\n3. **Translation Steps**:\n   - **Importing Necessary Modules**: The code begins with `import Mathlib`, which is a common practice to bring in necessary mathematical libraries and definitions. This ensures that all required functions and theorems are available.\n   - **Opening Namespaces**: The `open Function (OfArity)` and `open PSet` lines are used to bring specific functions and definitions into the current namespace, making them easier to reference. `Function.Injective2` is likely defined or used within these modules.\n   - **Theorem Declaration**: The line `theorem pair_injective : Function.Injective2 pair := sorry` declares a theorem named `pair_injective`. This theorem asserts that the function `pair` is injective when considered as a function of two arguments. The `:= sorry` part indicates that the proof is not provided here, but the statement of the theorem is clear.\n\n4. **Formalizing the Statement**:\n   - The informal statement is about the injectivity of the pairing function, which is directly captured by `Function.Injective2 pair`. This Lean construct succinctly expresses the idea that if `pair(a, b) = pair(c, d)`, then `a = c` and `b = d`.\n   - The use of `Function.Injective2` is crucial because it directly corresponds to the concept of injectivity for functions of two arguments, aligning perfectly with the informal"}
{"source_file": "herald_data/sample_500.jsonl", "line": 378, "id": 429009, "informal_statement": "For $p > 1$ and $n > 0$, show that $\\nu_p(p^{exp} \\cdot n) = \\nu_p(n) + exp$, where $\\nu_p(m)$ denotes the highest power of $p$ dividing $m$.", "formal_statement": "import Mathlib\nopen Nat\ntheorem base_pow_mul {p n exp : ℕ} (hp : 1 < p) (hn : 0 < n) :\n    p.maxPowDiv (p ^ exp * n) = p.maxPowDiv n + exp := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understand the Mathematical Concepts**:\n   - The informal statement involves the concept of the p-adic valuation, denoted as \\(\\nu_p(m)\\), which is the highest power of \\(p\\) dividing \\(m\\).\n   - The goal is to show that for a prime \\(p > 1\\) and a positive integer \\(n > 0\\), the p-adic valuation of the product \\(p^{\\text{exp}} \\cdot n\\) is equal to the sum of the p-adic valuation of \\(n\\) and \\(\\text{exp}\\).\n\n2. **Identify the Lean4 Constructs**:\n   - In Lean4, the function `p.maxPowDiv` is used to represent the p-adic valuation \\(\\nu_p(m)\\).\n   - The theorem is named `base_pow_mul`, which is a descriptive name indicating the operation of multiplying a base power with another number.\n\n3. **Translate the Variables and Conditions**:\n   - The variables \\(p\\), \\(n\\), and \\(\\text{exp}\\) are declared as natural numbers (`ℕ`) in Lean4.\n   - The conditions \\(p > 1\\) and \\(n > 0\\) are translated into Lean4 as `hp : 1 < p` and `hn : 0 < n`, respectively. These are hypotheses that are passed as arguments to the theorem.\n\n4. **Formalize the Statement**:\n   - The goal is to prove that `p.maxPowDiv (p ^ exp * n) = p.maxPowDiv n + exp`.\n   - This directly corresponds to the informal statement \\(\\nu_p(p^{\\text{exp}} \\cdot n) = \\nu_p(n) + \\text{exp}\\).\n\n5. **Structure of the Theorem**:\n   - The theorem is structured with the keyword `theorem`, followed by the name `base_pow_mul`.\n   - The variables and hypotheses are introduced in curly braces `{p n exp : ℕ}` and parentheses `(hp : 1 < p) (hn : 0 < n)`.\n   - The statement to be proven is written after the colon `:`, which is `p.maxPowDiv (p ^ exp * n) = p.maxPowDiv n + exp`.\n   - The `:="}
{"source_file": "herald_data/sample_500.jsonl", "line": 377, "id": 545283, "informal_statement": "Show that $a^3+b^3+3abc \\geq c(a+b)^2$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_545283 (a b c : ℝ) : a^3 + b^3 + 3 * a * b * c ≥ c * (a + b)^2   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The variables involved in the inequality are \\(a\\), \\(b\\), and \\(c\\). Since the inequality involves powers and multiplication, these variables should be real numbers. In Lean, real numbers are represented by `ℝ`.\n\n2. **Translate the Mathematical Operations**:\n   - The expression \\(a^3 + b^3 + 3abc\\) involves exponentiation and multiplication. In Lean, exponentiation is represented by `^`, and multiplication is represented by `*`.\n   - The expression \\(c(a+b)^2\\) involves multiplication and exponentiation. The addition inside the parentheses is represented by `+`, and the square is represented by `^ 2`.\n\n3. **Formulate the Inequality**:\n   - The inequality \\(a^3 + b^3 + 3abc \\geq c(a+b)^2\\) is translated to `a^3 + b^3 + 3 * a * b * c ≥ c * (a + b)^2` in Lean. The symbol `≥` is used for the \"greater than or equal to\" relation.\n\n4. **Structure the Theorem in Lean**:\n   - Begin with the `theorem` keyword, followed by a name for the theorem, `extract_aug_545283`, which is a placeholder name.\n   - Specify the variables and their types in parentheses: `(a b c : ℝ)`.\n   - Use a colon `:` to separate the variable declarations from the statement of the theorem.\n   - Write the formal statement of the inequality after the colon.\n\n5. **Use Lean's Libraries**:\n   - The `import Mathlib` statement is used to import the necessary mathematical libraries that provide definitions and theorems for real numbers and inequalities.\n   - The `open BigOperators`, `open Real`, `open Nat`, and `open Topology` statements are used to bring relevant definitions and notations into scope, although not all may be necessary for this specific theorem.\n\n6. **Conclude with a Proof Placeholder**:\n   - The `:= by sorry` part indicates that the proof is not yet provided. The `sorry` keyword is a placeholder that allows the theorem to be checked for syntactic correctness without a proof.\n\nBy following these steps, the informal statement is accurately translated"}
{"source_file": "herald_data/sample_500.jsonl", "line": 382, "id": 120948, "informal_statement": "For any natural number $a$, show that the square root of $a$, denoted as $\\sqrt{a}$, is less than the natural number square root of $a$ plus one, i.e., $\\sqrt{a} < \\sqrt{a} + 1$. Here, $\\sqrt{a}$ denotes the real square root of $a$ and $\\sqrt{a}$ in the context of natural numbers refers to the largest natural number whose square is less than or equal to $a$.", "formal_statement": "import Mathlib\nopen Set Filter\nopen scoped Filter NNReal Topology\nopen Lean Meta Qq Function\nlemma real_sqrt_lt_nat_sqrt_succ_tac_13632 (a : ℕ) : √↑a < ↑a.sqrt + 1 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to understand both the mathematical concepts involved and how they are represented in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Informal Statement**:\n   - We are given a natural number \\( a \\).\n   - We need to show that the real square root of \\( a \\), denoted as \\( \\sqrt{a} \\), is less than the natural number square root of \\( a \\) plus one.\n   - The natural number square root of \\( a \\) is defined as the largest natural number whose square is less than or equal to \\( a \\).\n\n2. **Identifying Key Components**:\n   - **Real Square Root**: In Lean, the real square root of a number is typically represented using the `sqrt` function, but since we are dealing with natural numbers, we need to convert \\( a \\) to a real number first.\n   - **Natural Number Square Root**: Lean provides a method to compute the integer square root of a natural number, which is represented as `a.sqrt`.\n\n3. **Formalizing the Statement in Lean**:\n   - **Importing Necessary Libraries**: The code begins with importing `Mathlib`, which is a library that includes various mathematical definitions and theorems. It also opens several namespaces (`Set`, `Filter`, `NNReal`, `Topology`) that might be useful for handling real numbers and natural numbers.\n   - **Defining the Lemma**: The lemma is named `real_sqrt_lt_nat_sqrt_succ_tac_13632`, which is a unique identifier for this particular statement.\n   - **Specifying the Type of \\( a \\)**: The lemma takes a parameter `a : ℕ`, indicating that \\( a \\) is a natural number.\n   - **Expressing the Inequality**:\n     - `√↑a`: This represents the real square root of \\( a \\). The `↑` operator is used to cast the natural number \\( a \\) to a real number before applying the square root.\n     - `↑a.sqrt`: This represents the natural number square root of \\( a \\), which is then cast to a real number using `↑` to allow for comparison with the real square root.\n     - `+ 1`: This adds 1 to the natural number square root (after casting it to a real number) to form"}
{"source_file": "herald_data/sample_500.jsonl", "line": 380, "id": 349143, "informal_statement": "For any cardinal number $c > 2$, prove that the filter generated by subsets of a set $g$ with cardinality at least $c$ has the property that the intersection of fewer than $c$ sets from this filter has cardinality at least $c$.", "formal_statement": "import Mathlib\nopen Set Filter Cardinal\nlemma cardinalInter_ofCardinalGenerate (hc : 2 < c) :\n    CardinalInterFilter (cardinalGenerate g hc) c := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down the components of the statement and understand how they map to Lean constructs:\n\n1. **Understanding the Informal Statement:**\n   - We are dealing with cardinal numbers, specifically a cardinal number \\( c \\) that is greater than 2.\n   - We need to consider a filter generated by subsets of a set \\( g \\) where each subset has a cardinality of at least \\( c \\).\n   - The goal is to show that the intersection of fewer than \\( c \\) sets from this filter has a cardinality of at least \\( c \\).\n\n2. **Lean4 Constructs:**\n   - **Cardinal Numbers:** In Lean, cardinal numbers are handled by the `Cardinal` module.\n   - **Filters:** Filters are a concept in topology and analysis, and in Lean, they are managed by the `Filter` module.\n   - **Sets and Subsets:** The `Set` module provides the necessary tools to work with sets and their properties.\n\n3. **Translation Steps:**\n   - **Importing Necessary Modules:** The statement begins with `import Mathlib` to access the mathematical library, which includes modules for sets, filters, and cardinals.\n   - **Opening Modules:** `open Set Filter Cardinal` makes the functions and types from these modules directly accessible without needing to prefix them with the module name.\n   - **Lemma Declaration:** The lemma is named `cardinalInter_ofCardinalGenerate`, which suggests it is about the intersection property of a filter generated by cardinality conditions.\n   - **Assumption on Cardinality:** The assumption `hc : 2 < c` is a direct translation of the condition that \\( c \\) is greater than 2.\n   - **Filter Generation:** `cardinalGenerate g hc` represents the filter generated by subsets of a set \\( g \\) with cardinality at least \\( c \\). This is a hypothetical function or construct that would need to be defined to generate such a filter.\n   - **Intersection Property:** `CardinalInterFilter` is a predicate or property that checks if the intersection of fewer than \\( c \\) sets from the filter has cardinality at least \\( c \\). This is the core property we want to prove.\n\n4. **Conclusion:**\n   - The formal statement sets up the context and assumptions needed to prove the desired property about the filter and its intersections.\n   - The `sorry"}
{"source_file": "herald_data/sample_500.jsonl", "line": 383, "id": 273907, "informal_statement": "For any star ring $R$ with trivial star operation, any additive commutative group $A$, any star-additive monoid $A$, any monoid $R$, any distributive multiplication action of $R$ on $A$, and any star module $A$ over $R$, if $x$ is an element of $A$ belonging to the skew-adjoint of $A$ and $r$ is an element of $R$, then show that the scalar multiplication of $r$ with $x$, negated, is equal to itself, i.e., $-(r \\cdot x) = -(r \\cdot x)$.", "formal_statement": "import Mathlib\nopen Function\nopen scoped ComplexConjugate\nlemma smul_mem_tac_15362 [Star R] [TrivialStar R] [AddCommGroup A] [StarAddMonoid A] [Monoid R] [DistribMulAction R A] [StarModule R A] (r : R) (x : A) (h : x ∈ skewAdjoint A) : -(r • x) = -(r • x) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it corresponds to the Lean4 constructs:\n\n1. **Star Ring with Trivial Star Operation**: \n   - In Lean, a \"star ring\" is represented by the typeclass `Star R`. The \"trivial star operation\" is represented by the typeclass `TrivialStar R`. These are included as typeclass constraints in the lemma.\n\n2. **Additive Commutative Group**:\n   - This is represented by the typeclass `AddCommGroup A` in Lean. It indicates that `A` is a group under addition and that the addition operation is commutative.\n\n3. **Star-Additive Monoid**:\n   - This is represented by the typeclass `StarAddMonoid A`. It indicates that `A` is a monoid with an additional star operation that respects the monoid structure.\n\n4. **Monoid**:\n   - The typeclass `Monoid R` indicates that `R` is a monoid, which is a set equipped with an associative binary operation and an identity element.\n\n5. **Distributive Multiplication Action**:\n   - The typeclass `DistribMulAction R A` indicates that `R` acts on `A` in a way that distributes over the addition in `A`.\n\n6. **Star Module**:\n   - The typeclass `StarModule R A` indicates that `A` is a module over `R` with a compatible star operation.\n\n7. **Element of Skew-Adjoint**:\n   - The condition `x ∈ skewAdjoint A` is a predicate indicating that `x` is in the skew-adjoint part of `A`. This is passed as a hypothesis `h` in the lemma.\n\n8. **Scalar Multiplication and Negation**:\n   - The expression `-(r • x)` represents the negation of the scalar multiplication of `r` and `x`. The goal is to show that this expression is equal to itself, which is trivially true.\n\n9. **Formalizing the Lemma**:\n   - The lemma is named `smul_mem_tac_15362`, and it takes as arguments the elements `r : R` and `x : A`, along with the hypothesis `h : x ∈ skewAdjoint A`.\n   - The conclusion `-(r •"}
{"source_file": "herald_data/sample_500.jsonl", "line": 385, "id": 278365, "informal_statement": "For any field $K$, and given a valuation subring $A$ of $K$, an element $a$ in the underlying type of $A$, and hypotheses that the valuation of $a$ (considered as an element of $K$) is $1$ and $a$ is nonzero, prove that $a$ is a unit in $A$.", "formal_statement": "import Mathlib\nopen scoped Classical\nlemma valuation_eq_one_iff_tac_5775 [Field K] (A : ValuationSubring K) (a : ↥A) (h : A.valuation ↑a = 1) (ha : ↑a ≠ 0) : IsUnit a := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures**:\n   - The statement involves a field \\( K \\) and a valuation subring \\( A \\) of \\( K \\). In Lean, a field is represented by the type class `Field K`.\n   - A valuation subring is a specific type of subring associated with a valuation, which is a function that assigns values to elements of a field. In Lean, this is represented by `ValuationSubring K`.\n\n2. **Define the Element and Hypotheses**:\n   - We have an element \\( a \\) in the underlying type of \\( A \\). In Lean, this is represented by `a : ↥A`, where `↥A` denotes the type of elements in the valuation subring \\( A \\).\n   - The hypotheses are that the valuation of \\( a \\) (considered as an element of \\( K \\)) is 1, and \\( a \\) is nonzero. These are represented by `h : A.valuation ↑a = 1` and `ha : ↑a ≠ 0`, respectively. Here, `↑a` is the coercion of \\( a \\) from the subring \\( A \\) to the field \\( K \\).\n\n3. **State the Conclusion**:\n   - The conclusion is that \\( a \\) is a unit in \\( A \\). In Lean, this is expressed as `IsUnit a`, which means that \\( a \\) has a multiplicative inverse in the subring \\( A \\).\n\n4. **Structure the Lemma**:\n   - The lemma is named `valuation_eq_one_iff_tac_5775`, which is a unique identifier for this specific result.\n   - The lemma is stated with the necessary imports and scope settings: `import Mathlib` to access mathematical libraries, and `open scoped Classical` to allow classical reasoning, which is often used in fields and valuation contexts.\n\n5. **Formalize the Proof Obligation**:\n   - The statement ends with `: IsUnit a := sorry`, indicating that the proof is yet to be completed. The `sorry` keyword is a placeholder in Lean, used when the proof is not provided.\n\nBy following these steps, the informal statement is accurately translated into a formal Lean4 lemma, capturing the essence of the mathematical claim and setting up the framework for"}
{"source_file": "herald_data/sample_500.jsonl", "line": 387, "id": 113672, "informal_statement": "For any commutative ring \\(R\\), a finite set \\(s\\) of indices \\(\\iota\\), a function \\(v : \\iota \\to R\\), and an index \\(i \\in \\iota\\) such that \\(i \\in s\\), demonstrate that the product \\(\\prod_{i_1 \\in s} (v i - v i_1) = 0\\).", "formal_statement": "import Mathlib\nopen Polynomial\nopen Function Fintype\nopen Finset\nopen Polynomial\nopen Finset\nopen Finset\nopen Finset Polynomial\nlemma eval_nodal_at_node_tac_20769 [CommRing R] (s : Finset ι) (v : ι → R) (i : ι) (hi : i ∈ s) : ∏ i_1 ∈ s, (v i - v i_1) = 0 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a structured approach that captures the essence of the problem and its formalization in Lean. Here's a step-by-step explanation:\n\n1. **Understanding the Context**:\n   - The problem involves a commutative ring \\( R \\), a finite set of indices \\( s \\), a function \\( v \\) mapping indices to elements of \\( R \\), and a specific index \\( i \\) within \\( s \\).\n   - The goal is to show that the product of differences \\( \\prod_{i_1 \\in s} (v i - v i_1) \\) equals zero.\n\n2. **Identifying the Components**:\n   - **Commutative Ring \\( R \\)**: In Lean, this is represented by `[CommRing R]`, indicating that \\( R \\) is a commutative ring.\n   - **Finite Set \\( s \\)**: Represented by `Finset ι`, where `ι` is the type of indices. `Finset` is a Lean construct for finite sets.\n   - **Function \\( v : \\iota \\to R \\)**: This is directly translated to `v : ι → R`, a function from indices to ring elements.\n   - **Index \\( i \\in \\iota \\)**: The index `i` is specified as an element of the type `ι`.\n   - **Condition \\( i \\in s \\)**: This is captured by the hypothesis `hi : i ∈ s`, asserting that `i` is indeed an element of the set `s`.\n\n3. **Formalizing the Product**:\n   - The product \\(\\prod_{i_1 \\in s} (v i - v i_1)\\) is expressed in Lean using the `∏` notation, which is a common way to denote products over finite sets in Lean. The expression `∏ i_1 ∈ s, (v i - v i_1)` directly translates the informal product notation.\n\n4. **Conclusion of the Statement**:\n   - The goal is to prove that this product equals zero. In Lean, this is expressed as `= 0` at the end of the lemma statement.\n\n5. **Putting It All Together**:\n   - The lemma is named `eval_nodal_at_node_tac_20769`, which is a placeholder name and can be replaced with"}
{"source_file": "herald_data/sample_500.jsonl", "line": 384, "id": 187245, "informal_statement": "For any commutative monoid with zero $R$, let $f$ and $g$ be multiplicative arithmetic functions from $\\mathbb{N}$ to $R$. Given that $f = g$, show that for any prime number $p$ and any natural number $i$, the equality $g(p^i) = g(p^i)$ holds.", "formal_statement": "import Mathlib\nopen Finset\nopen Nat\nopen ArithmeticFunction\nopen Batteries.ExtendedBinder\nlemma eq_iff_eq_on_prime_powers_tac_26299 [CommMonoidWithZero R] (f : ArithmeticFunction R) (hf : f.IsMultiplicative) (g : ArithmeticFunction R) (hg : g.IsMultiplicative) (h : f = g) (p : ℕ) (i : ℕ) : g (p ^ i) = g (p ^ i) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a series of logical steps that align the informal concepts with their formal counterparts in Lean. Here's how the translation is achieved:\n\n1. **Understanding the Context**:\n   - The informal statement involves a commutative monoid with zero, denoted as \\( R \\), and multiplicative arithmetic functions from \\(\\mathbb{N}\\) to \\( R \\).\n   - The goal is to show that if two such functions \\( f \\) and \\( g \\) are equal, then for any prime \\( p \\) and any natural number \\( i \\), the equality \\( g(p^i) = g(p^i) \\) holds trivially.\n\n2. **Formalizing the Context**:\n   - In Lean, we start by importing necessary libraries with `import Mathlib`, which provides access to mathematical structures and functions.\n   - We open namespaces like `Finset`, `Nat`, and `ArithmeticFunction` to use their definitions and functions without prefixing them.\n\n3. **Defining the Commutative Monoid with Zero**:\n   - `[CommMonoidWithZero R]` specifies that \\( R \\) is a commutative monoid with zero. This is a type class constraint in Lean, ensuring that \\( R \\) has the required algebraic structure.\n\n4. **Defining Arithmetic Functions**:\n   - `f : ArithmeticFunction R` and `g : ArithmeticFunction R` declare that \\( f \\) and \\( g \\) are arithmetic functions mapping natural numbers to \\( R \\).\n   - `hf : f.IsMultiplicative` and `hg : g.IsMultiplicative` assert that both functions are multiplicative, a property that is crucial for arithmetic functions.\n\n5. **Equality of Functions**:\n   - `h : f = g` is the hypothesis that the two functions \\( f \\) and \\( g \\) are equal. This is a direct translation of the informal statement \"Given that \\( f = g \\)\".\n\n6. **Prime and Exponent**:\n   - `p : ℕ` and `i : ℕ` declare that \\( p \\) and \\( i \\) are natural numbers, corresponding to the prime number and the exponent in the informal statement.\n\n7. **Stating the Goal**:\n   - The goal is to prove `g (p ^ i) = g (p ^ i"}
{"source_file": "herald_data/sample_500.jsonl", "line": 386, "id": 40118, "informal_statement": "For any real numbers $a$, $b$, and $c$ such that $a < c$, show that the minimum of $a$ and $b$ is less than $c$, i.e., $\\min(a, b) < c$.", "formal_statement": "import Mathlib\n\ntheorem min_lt_of_left_lt_extracted [LinearOrder α] {a b c : α} : a < c → min a b < c := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we follow these steps:\n\n1. **Identify the Mathematical Context**: The statement involves real numbers and comparisons, which suggests the use of an ordered structure. In Lean, this is typically represented by a type with a `LinearOrder` instance.\n\n2. **Choose the Appropriate Type Class**: The statement is about real numbers, but to keep it general, we use a type variable `α` with a `LinearOrder` instance. This allows the theorem to apply to any linearly ordered type, not just real numbers.\n\n3. **Declare the Variables**: The informal statement involves three real numbers, $a$, $b$, and $c$. In Lean, we declare these as variables of type `α` using `{a b c : α}`. The curly braces indicate that these are implicit arguments, which Lean can infer from context.\n\n4. **Express the Hypothesis**: The condition given is $a < c$. In Lean, this is directly translated to `a < c`, which is the hypothesis of the theorem.\n\n5. **State the Conclusion**: The conclusion is that the minimum of $a$ and $b$ is less than $c$. In Lean, the minimum of two elements `a` and `b` is expressed as `min a b`. Therefore, the conclusion is `min a b < c`.\n\n6. **Combine into a Theorem**: The theorem is then stated as `theorem min_lt_of_left_lt_extracted [LinearOrder α] {a b c : α} : a < c → min a b < c`. This reads as: for any linearly ordered type `α` and elements `a`, `b`, `c` of that type, if `a < c`, then `min a b < c`.\n\n7. **Use of `sorry`**: The `:= sorry` at the end indicates that the proof of the theorem is not provided. In Lean, `sorry` is a placeholder that allows the code to compile without a complete proof.\n\nBy following these steps, we have translated the informal mathematical statement into a formal Lean theorem that captures the same logical content."}
{"source_file": "herald_data/sample_500.jsonl", "line": 389, "id": 366058, "informal_statement": "For any field $K$, the ring of formal power series over $K$, denoted by $K[[x]]$, is a subring of the ring of formal Laurent series over $K$, denoted by $K((x))$.", "formal_statement": "import Mathlib\nopen scoped Classical\nopen HahnSeries Polynomial\ninstance {K : Type*} [Field K] : IsFractionRing (PowerSeries K) (LaurentSeries K) := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand the mathematical concepts involved and how they are represented in Lean.\n\n1. **Understanding the Mathematical Concepts**:\n   - **Field $K$**: A field is a set equipped with two operations, addition and multiplication, satisfying certain axioms. In Lean, a field is represented by the type class `Field`.\n   - **Formal Power Series $K[[x]]$**: This is the ring of infinite series in $x$ with coefficients from $K$. In Lean, this is represented by `PowerSeries K`.\n   - **Formal Laurent Series $K((x))$**: This is the ring of series that can have finitely many negative powers of $x$, with coefficients from $K$. In Lean, this is represented by `LaurentSeries K`.\n   - **Subring**: The statement that $K[[x]]$ is a subring of $K((x))$ can be interpreted in terms of the concept of a fraction ring, where one ring is a localization of another.\n\n2. **Lean4 Code Explanation**:\n   - `import Mathlib`: This imports the Mathlib library, which contains definitions and theorems about mathematical structures, including fields, power series, and Laurent series.\n   - `open scoped Classical`: This line allows the use of classical logic, which is often necessary in formalizing mathematical statements in Lean.\n   - `open HahnSeries Polynomial`: This opens the namespaces for Hahn series and polynomials, which are related to power and Laurent series.\n   - `instance {K : Type*} [Field K]`: This declares an instance for any type `K` that is a field. The `Type*` indicates that `K` is a type with some structure, and `[Field K]` specifies that `K` is a field.\n   - `IsFractionRing (PowerSeries K) (LaurentSeries K)`: This is the key part of the formalization. `IsFractionRing` is a type class in Lean that indicates one ring is a fraction ring (or localization) of another. Here, it states that the ring of power series `PowerSeries K` is a fraction ring of the ring of Laurent series `LaurentSeries K`.\n   - `:= sorry`: The `:= sorry` indicates that the proof or construction of this instance is omitted. In a complete formalization, this would"}
{"source_file": "herald_data/sample_500.jsonl", "line": 381, "id": 28942, "informal_statement": "For any two points $z, w$ in the upper half-plane $\\mathbb{H}$ and a real number $r$, the distance in the complex plane $\\mathbb{C}$ between $z$ and $w$'s center at radius $r$ in the upper half-plane model is given by $\\sqrt{2z_{\\text{im}}w_{\\text{im}}(\\cosh(d(z, w)) - \\cosh(r)) + (w_{\\text{im}}\\sinh(r))^2}$, where $z_{\\text{im}}$ and $w_{\\text{im}}$ denote the imaginary parts of $z$ and $w$ respectively, and $d(z, w)$ is the hyperbolic distance between $z$ and $w$.", "formal_statement": "import Mathlib\nopen scoped UpperHalfPlane ComplexConjugate NNReal Topology MatrixGroups\nopen Set Metric Filter Real\nopen Complex\ntheorem dist_coe_center_extracted (z w : ℍ) (r : ℝ) : dist ↑z ↑(w.center r) = √(2 * z.im * w.im * (cosh (dist z w) - cosh r) + (w.im * sinh r) ^ 2) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a series of steps that involve understanding both the mathematical concepts and how they are represented in Lean4. Here's the step-by-step explanation:\n\n1. **Understanding the Context**:\n   - The informal statement involves points in the upper half-plane $\\mathbb{H}$, which is a subset of the complex plane $\\mathbb{C}$ where the imaginary part is positive.\n   - The statement involves computing a distance related to hyperbolic geometry, specifically using the hyperbolic distance $d(z, w)$ between two points $z$ and $w$.\n\n2. **Identifying the Components**:\n   - **Points $z$ and $w$**: These are elements of the upper half-plane $\\mathbb{H}$, which in Lean is represented by the type `ℍ`.\n   - **Real number $r$**: This is a real number, represented by the type `ℝ` in Lean.\n   - **Imaginary parts**: The imaginary parts of $z$ and $w$ are denoted as `z.im` and `w.im` respectively in Lean.\n\n3. **Formalizing the Distance**:\n   - The distance in the complex plane between $z$ and the center of $w$ at radius $r$ is expressed using the `dist` function in Lean, which computes the Euclidean distance between two points.\n   - The center of $w$ at radius $r$ is represented as `w.center r` in Lean.\n\n4. **Hyperbolic Distance and Trigonometric Functions**:\n   - The hyperbolic distance $d(z, w)$ is represented as `dist z w` in Lean, assuming `dist` is appropriately defined for hyperbolic distance in the context of `ℍ`.\n   - The hyperbolic trigonometric functions $\\cosh$ and $\\sinh$ are represented as `cosh` and `sinh` in Lean, which are part of the `Real` namespace.\n\n5. **Constructing the Expression**:\n   - The expression under the square root in the informal statement is translated directly into Lean syntax:\n     - `2 * z.im * w.im * (cosh (dist z w) - cosh r) + (w.im * sinh r) ^ 2`\n   - This expression is then wrapped with the square root function"}
{"source_file": "herald_data/sample_500.jsonl", "line": 390, "id": 328919, "informal_statement": "For any elements \\(x, y\\) in a type \\(\\alpha\\), a list \\(l\\) of elements in \\(\\alpha\\), and given a proof \\(hp\\) that \\(l\\) being equal to its reverse implies \\(l\\) is a palindrome, along with a proof \\(hr\\) that the reverse of \\(y\\) appended to the reverse of \\(l\\), and then \\(x\\) appended to this, is equal to \\(x\\) followed by \\(l\\) and then \\(y\\), show that the list \\(x\\) followed by \\(l\\) and then \\(y\\) is a palindrome.", "formal_statement": "import Mathlib\n\nlemma of_reverse_eq_tac_1484 (x : α) (l : List α) (y : α) (hp : l.reverse = l → l.Palindrome) (hr : [y].reverse ++ l.reverse ++ [x] = x :: (l ++ [y])) : (x :: (l ++ [y])).Palindrome := sorry", "explanation": "To translate the given informal statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and logic.\n\n1. **Understanding the Context and Types**:\n   - We are dealing with elements \\(x, y\\) of a type \\(\\alpha\\), and a list \\(l\\) of elements in \\(\\alpha\\). In Lean, this is expressed by declaring \\(x, y\\) as variables of type \\(\\alpha\\) and \\(l\\) as a variable of type `List α`.\n\n2. **Given Proofs**:\n   - We have a proof \\(hp\\) that if a list \\(l\\) is equal to its reverse, then \\(l\\) is a palindrome. In Lean, this is expressed as a function `hp : l.reverse = l → l.Palindrome`. This means `hp` takes a proof of `l.reverse = l` and returns a proof of `l.Palindrome`.\n   - We also have a proof \\(hr\\) that the reverse of \\(y\\) appended to the reverse of \\(l\\), and then \\(x\\) appended to this, is equal to \\(x\\) followed by \\(l\\) and then \\(y\\). In Lean, this is expressed as `hr : [y].reverse ++ l.reverse ++ [x] = x :: (l ++ [y])`.\n\n3. **Goal**:\n   - We need to show that the list \\(x\\) followed by \\(l\\) and then \\(y\\) is a palindrome. In Lean, this is expressed as `(x :: (l ++ [y])).Palindrome`.\n\n4. **Formalizing the Lemma**:\n   - We start by defining a lemma in Lean using the `lemma` keyword. The lemma is named `of_reverse_eq_tac_1484`.\n   - We specify the parameters of the lemma: `x`, `l`, `y`, `hp`, and `hr`, each with their respective types.\n   - The conclusion of the lemma is that `(x :: (l ++ [y])).Palindrome`.\n\n5. **Using `import Mathlib`**:\n   - The `import Mathlib` statement is used to bring in necessary mathematical libraries that include definitions and theorems about lists, reverses, and palindromes.\n\n6. **The `sorry` Placeholder**:\n   - The"}
{"source_file": "herald_data/sample_500.jsonl", "line": 388, "id": 466705, "informal_statement": "Let $a,b,c>0$ . Prove that : \\n $3\\sum a^{2}b^{4}+abc\\sum a^{3}+\\sum a^{3}b^{3}\\geq 9a^{2}b^{2}c^{2}+abc\\sum ab(a+b)$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_466705 (a b c : ℝ) : 3 * (a^2 * b^4 + b^2 * c^4 + c^2 * a^4) + a * b * c * (a^3 + b^3 + c^3) + (a^3 * b^3 + b^3 * c^3 + c^3 * a^3) ≥ 9 * a^2 * b^2 * c^2 + a * b * c * (a * b * (a + b) + b * c * (b + c) + c * a * (c + a))  :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Domain**: \n   - The informal statement specifies that \\(a, b, c > 0\\). In Lean, we represent these as real numbers, since the operations involved (powers, products) are naturally defined over the reals. Thus, we declare \\(a, b, c\\) as real numbers: `(a b c : ℝ)`.\n\n2. **Translate the Mathematical Expressions**:\n   - The expression \\(3\\sum a^{2}b^{4}\\) translates to `3 * (a^2 * b^4 + b^2 * c^4 + c^2 * a^4)`. Here, the summation \\(\\sum a^{2}b^{4}\\) is expanded to \\(a^2b^4 + b^2c^4 + c^2a^4\\), reflecting the cyclic nature of the terms.\n   - The term \\(abc\\sum a^{3}\\) becomes `a * b * c * (a^3 + b^3 + c^3)`, where \\(\\sum a^{3}\\) is expanded to \\(a^3 + b^3 + c^3\\).\n   - The term \\(\\sum a^{3}b^{3}\\) is translated to `(a^3 * b^3 + b^3 * c^3 + c^3 * a^3)`, again reflecting the cyclic summation.\n   - The right-hand side \\(9a^{2}b^{2}c^{2}\\) is straightforwardly `9 * a^2 * b^2 * c^2`.\n   - The term \\(abc\\sum ab(a+b)\\) is translated to `a * b * c * (a * b * (a + b) + b * c * (b + c) + c * a * (c + a))`, where \\(\\sum ab(a+b)\\) is expanded to \\(ab(a+b) + bc(b+c) + ca(c+a)\\).\n\n3. **Construct the Inequality**:\n   - The inequality is constructed by placing the translated left-hand side and right-hand side expressions with the `≥` operator in between. In Lean, this is written as `≥`.\n\n4. **Formalize the Theorem**:"}
{"source_file": "herald_data/sample_500.jsonl", "line": 396, "id": 267099, "informal_statement": "Let $(\\alpha, \\mathcal{U})$ be a uniform space, $(\\beta, \\sqcup)$ a semilattice with supremum, and suppose $\\beta$ is nonempty. Given a family of subsets $U : \\beta \\to \\mathcal{P}(\\alpha \\times \\alpha)$ of the product space $\\alpha \\times \\alpha$, a condition $hU$ stating that for every $s \\in \\mathcal{U}$, there exists $n \\in \\beta$ such that $U n \\subseteq s$, a function $f : \\beta \\to \\alpha$, and a condition $hf$ asserting that for all $N, m, n \\in \\beta$ with $N \\leq m$ and $N \\leq n$, the pair $(f m, f n)$ is in $U N$. Then, for any subset $s \\subseteq \\alpha \\times \\alpha$, prove that if $s \\in \\mathcal{U}$, it follows that $s$ is in the image of the map induced by $f \\times f$ on the filter at infinity, i.e., $s \\in (\\mathsf{Prod.map}\\ f\\ f)^\\leftarrow(\\mathcal{F}_{\\infty})$.", "formal_statement": "import Mathlib\nopen Filter Function TopologicalSpace Topology Set UniformSpace Uniformity\nlemma cauchySeq_of_controlled_tac_15859 (uniformSpace : UniformSpace α) [SemilatticeSup β] [Nonempty β] (U : β → Set (α × α)) (hU : ∀ s ∈ 𝓤 α, ∃ n, U n ⊆ s) (f : β → α) (hf : ∀ ⦃N m n : β⦄, N ≤ m → N ≤ n → (f m, f n) ∈ U N) (s : Set (α × α)) : s ∈ 𝓤 α → s ∈ map (Prod.map f f) atTop := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to carefully map each component of the informal description to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Uniform Space and Semilattice with Supremum**:\n   - The informal statement begins by introducing a uniform space $(\\alpha, \\mathcal{U})$. In Lean, this is represented by `UniformSpace α`, where `α` is the type over which the uniform space is defined.\n   - The semilattice with supremum $(\\beta, \\sqcup)$ is represented by `[SemilatticeSup β]`. This indicates that `β` is a type equipped with a semilattice structure that includes a supremum operation.\n\n2. **Nonempty Type**:\n   - The condition that $\\beta$ is nonempty is captured by `[Nonempty β]` in Lean. This ensures that there is at least one element in the type `β`.\n\n3. **Family of Subsets**:\n   - The family of subsets $U : \\beta \\to \\mathcal{P}(\\alpha \\times \\alpha)$ is represented by `U : β → Set (α × α)`. Here, `Set (α × α)` denotes the power set of the product space $\\alpha \\times \\alpha$.\n\n4. **Condition on Family of Subsets**:\n   - The condition $hU$ is that for every $s \\in \\mathcal{U}$, there exists $n \\in \\beta$ such that $U n \\subseteq s$. This is formalized as `hU : ∀ s ∈ 𝓤 α, ∃ n, U n ⊆ s`. The notation `𝓤 α` represents the uniformity filter on `α`.\n\n5. **Function and Condition on Function**:\n   - The function $f : \\beta \\to \\alpha$ is directly translated as `f : β → α`.\n   - The condition $hf$ is that for all $N, m, n \\in \\beta$ with $N \\leq m$ and $N \\leq n$, the pair $(f m, f n)$ is in $U N$. This is expressed as `hf : ∀ ⦃N m n : β⦄, N ≤ m → N ≤ n → (f"}
{"source_file": "herald_data/sample_500.jsonl", "line": 391, "id": 468626, "informal_statement": "$a,c$ have the same imaginary parts, $b$ is purely imaginary", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_468626 (a b c : ℂ) (h₁ : a.im = c.im) (h₂ : b.im = 0) : a * b * c = a * c * b  :=  by sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to understand the mathematical concepts involved and how they are represented in Lean.\n\n1. **Understanding the Informal Statement:**\n   - We have three complex numbers: \\(a\\), \\(b\\), and \\(c\\).\n   - The statement \"have the same imaginary parts\" means that the imaginary part of \\(a\\) is equal to the imaginary part of \\(c\\).\n   - The statement \"is purely imaginary\" for \\(b\\) means that the real part of \\(b\\) is zero.\n\n2. **Translating to Lean4:**\n   - **Complex Numbers in Lean:** In Lean, complex numbers are represented by the type `ℂ`. Each complex number has a real part and an imaginary part, accessible via `.re` and `.im` respectively.\n   - **Equality of Imaginary Parts:** The condition \\(a.im = c.im\\) is directly translated to `a.im = c.im` in Lean. This is represented by the hypothesis `h₁`.\n   - **Purely Imaginary Condition:** For a number to be purely imaginary, its real part must be zero. However, the informal statement specifies that \\(b\\) is purely imaginary, which typically means its real part is zero, but the given formal statement uses `b.im = 0`. This seems to be a discrepancy, as purely imaginary numbers have non-zero imaginary parts and zero real parts. However, we will proceed with the given formal statement, which uses `b.im = 0`. This is represented by the hypothesis `h₂`.\n\n3. **Theorem Statement:**\n   - The theorem aims to prove that the product of these complex numbers is commutative under the given conditions: `a * b * c = a * c * b`.\n   - This is a typical property of multiplication in the complex numbers, but the conditions provided might be used to simplify or justify the commutativity in this specific context.\n\n4. **Lean4 Code Structure:**\n   - The `import` statements bring in necessary libraries for working with complex numbers and other mathematical structures.\n   - The `theorem` keyword introduces a new theorem named `extract_aug_468626`.\n   - The parameters `(a b c : ℂ)` declare that \\(a\\), \\(b\\), and \\(c\\) are complex numbers.\n   - The hypotheses `(h₁ : a.im"}
{"source_file": "herald_data/sample_500.jsonl", "line": 393, "id": 121267, "informal_statement": "For any measurable space $m$ on $\\alpha$, any measure $\\mu$ on $\\alpha$, any normed additive commutative group $\\beta$, a sequence of functions $F : \\mathbb{N} \\to \\alpha \\to \\beta$, a function $f : \\alpha \\to \\beta$, and a bound function $bound : \\alpha \\to \\mathbb{R}$, assume the following:\n\n1. The norm of $F(n, a)$ is less than or equal to $bound(a)$ for $\\mu$-almost every $a$ in $\\alpha$, for all natural numbers $n$.\n2. The sequence of functions $(F(n, a))_{n \\in \\mathbb{N}}$ converges to $f(a)$ in the neighborhood of $f(a)$ for $\\mu$-almost every $a$ in $\\alpha$.\n3. For $\\mu$-almost every $a$ in $\\alpha$, and for all natural numbers $i$, the norm of $F(i, a)$ seen as an extended non-negative real number is less than or equal to the bound $bound(a)$ seen as an extended non-negative real number.\n\nShow that for $\\mu$-almost every $a$ in $\\alpha$, the norm of $f(a)$ seen as an extended non-negative real number is less than or equal to $bound(a)$ seen as an extended non-negative real number.", "formal_statement": "import Mathlib\nopen scoped Classical\nopen Topology ENNReal MeasureTheory NNReal\nopen Set Filter TopologicalSpace ENNReal EMetric MeasureTheory\nlemma all_ae_ofReal_f_le_bound_tac_11560 (m : MeasurableSpace α) (μ : Measure α) [NormedAddCommGroup β] (F : ℕ → α → β) (f : α → β) (bound : α → ℝ) (h_bound : ∀ (n : ℕ), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound a) (h_lim : ∀ᵐ (a : α) ∂μ, Tendsto (fun n => F n a) atTop (𝓝 (f a))) (F_le_bound : ∀ᵐ (a : α) ∂μ, ∀ (i : ℕ), ENNReal.ofReal ‖F i a‖ ≤ ENNReal.ofReal (bound a)) : ∀ᵐ (a : α) ∂μ, ENNReal.ofReal ‖f a‖ ≤ ENNReal.ofReal (bound a) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to carefully map each component of the informal statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of this process:\n\n1. **Measurable Space and Measure**:\n   - The informal statement mentions a measurable space $m$ on $\\alpha$ and a measure $\\mu$ on $\\alpha$. In Lean, these are represented by `m : MeasurableSpace α` and `μ : Measure α`, respectively. This sets up the context for measure-theoretic reasoning on the type $\\alpha$.\n\n2. **Normed Additive Commutative Group**:\n   - The informal statement specifies that $\\beta$ is a normed additive commutative group. In Lean, this is captured by the typeclass `[NormedAddCommGroup β]`, which ensures that $\\beta$ has the necessary algebraic and topological structure.\n\n3. **Sequence of Functions and Limit Function**:\n   - The sequence of functions $F : \\mathbb{N} \\to \\alpha \\to \\beta$ is directly translated to `F : ℕ → α → β` in Lean. The function $f : \\alpha \\to \\beta$ is similarly translated to `f : α → β`.\n\n4. **Bound Function**:\n   - The bound function $bound : \\alpha \\to \\mathbb{R}$ is represented as `bound : α → ℝ` in Lean. This function provides an upper bound for the norms of the functions involved.\n\n5. **Assumptions**:\n   - **Assumption 1**: The norm of $F(n, a)$ is less than or equal to $bound(a)$ for $\\mu$-almost every $a$ in $\\alpha$, for all $n$. This is formalized as `h_bound : ∀ (n : ℕ), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound a`. Here, `∀ᵐ (a : α) ∂μ` denotes \"for $\\mu$-almost every $a$ in $\\alpha$\".\n   \n   - **Assumption 2**: The sequence $(F(n, a))_{n \\in \\mathbb{N}}$ converges to $f(a)$ for $\\mu$-almost every $a$. This is expressed as `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 392, "id": 547401, "informal_statement": "Find the maximum value of $ab+bc+cd+da$ given that $a+b+c+d = 4$ and $a, b, c, d$ are positive real numbers.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_547401 (a b c d : ℝ) : a + b + c + d = 4 → a * b + b * c + c * d + d * a ≤ 4   :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Domain**: \n   - The informal statement involves four variables \\(a\\), \\(b\\), \\(c\\), and \\(d\\), which are specified to be positive real numbers. In Lean, we represent these variables as elements of the real numbers, denoted by `ℝ`.\n\n2. **Express the Given Condition**:\n   - The condition given is \\(a + b + c + d = 4\\). This is directly translated into Lean as `a + b + c + d = 4`.\n\n3. **Formulate the Expression to Maximize**:\n   - The expression to maximize is \\(ab + bc + cd + da\\). In Lean, multiplication is represented by `*`, so this expression becomes `a * b + b * c + c * d + d * a`.\n\n4. **State the Objective**:\n   - The objective is to find the maximum value of the expression under the given condition. The informal statement implies that we need to show that this maximum value is 4. In Lean, this is expressed as an inequality: `a * b + b * c + c * d + d * a ≤ 4`.\n\n5. **Structure the Theorem**:\n   - The theorem is structured to take four real numbers \\(a\\), \\(b\\), \\(c\\), and \\(d\\) as inputs. The hypothesis is the condition \\(a + b + c + d = 4\\), and the conclusion is the inequality \\(a * b + b * c + c * d + d * a ≤ 4\\).\n\n6. **Use of Lean Syntax**:\n   - The theorem is defined using the `theorem` keyword, followed by a name `extract_aug_547401`. The variables \\(a\\), \\(b\\), \\(c\\), and \\(d\\) are declared as real numbers using `(a b c d : ℝ)`.\n   - The implication is introduced with `→`, connecting the hypothesis to the conclusion.\n   - The `:=` symbol is used to define the body of the theorem, which is currently a placeholder `by sorry`, indicating that the proof is not yet provided.\n\n7. **Importing Necessary Libraries**:\n   - The code begins with importing necessary libraries from Mathlib, such as `BigOperators`,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 394, "id": 412093, "informal_statement": "Let \\( \\text{toExprMData} \\) be a function that maps \\( \\text{MData} \\) instances to expressions in Lean, ensuring that the internal structure of \\( \\text{KVMap} \\) is not directly accessed by employing the \\( \\text{KVMap.set*} \\) functions.", "formal_statement": "import Mathlib\nopen Lean\nopen DataValue in\n/-- Core of a hand-written `ToExpr` handler for `MData`.\nUses the `KVMap.set*` functions rather than going into the internals\nof the `KVMap` data structure. -/\nprivate def toExprMData (md : MData) : Expr := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Function Purpose**: The informal statement describes a function, `toExprMData`, which converts instances of `MData` into expressions (`Expr`) in Lean. The function should not directly manipulate the internal structure of `KVMap`, but instead use provided functions like `KVMap.set*`.\n\n2. **Import Necessary Modules**: The formal statement begins with `import Mathlib`, which is necessary to access Lean's mathematical library and its functionalities. This is a common practice to ensure that all required definitions and functions are available.\n\n3. **Open Relevant Namespaces**: The code uses `open Lean` and `open DataValue in`. Opening the `Lean` namespace allows direct access to Lean's core functionalities, including the `Expr` type. The `DataValue` namespace is opened to access specific data handling utilities, which might be relevant for working with `MData`.\n\n4. **Document the Function**: The formal statement includes a docstring (enclosed in `/-- ... -/`) that explains the purpose of the function. It states that this is the core of a hand-written `ToExpr` handler for `MData`, emphasizing the use of `KVMap.set*` functions instead of directly accessing `KVMap` internals. This aligns with the informal requirement to avoid direct manipulation of `KVMap`.\n\n5. **Define the Function**: The function `toExprMData` is defined as `private`, indicating that it is intended for use only within the current module or file. This encapsulation is a design choice to prevent external access, which might be due to the function's specific role or to maintain module integrity.\n\n6. **Specify Function Parameters and Return Type**: The function takes a single parameter `md` of type `MData` and returns a value of type `Expr`. This matches the informal description of mapping `MData` instances to expressions.\n\n7. **Placeholder for Implementation**: The body of the function is marked with `sorry`, a placeholder in Lean that indicates the implementation is incomplete or omitted. This is often used during development to allow the code to compile while the function's logic is being worked out.\n\nBy following these steps, the informal statement is accurately translated into the formal Lean4 code, ensuring that the function's purpose and constraints are clearly defined and documented."}
{"source_file": "herald_data/sample_500.jsonl", "line": 398, "id": 468273, "informal_statement": "Apply the AM-GM we have:\\n $ \\dfrac{1}{{\\sum a }} + \\dfrac{1}{{\\sum {{a^2}} }} + \\dfrac{1}{{\\sum {{a^3}} }} + \\dfrac{{{a^6} + {{(b + c)}^6}}}{4} \\ge 4\\sqrt[4]{{\\dfrac{{{a^6} + {{(b + c)}^6}}}{{4(a + b + c)({a^2} + {b^2} + {c^2})({a^3} + {b^3} + {c^3})}}}}, $", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_468273  (a b c : ℝ) :\n  1 / (a + b + c) + 1 / (a^2 + b^2 + c^2) + 1 / (a^3 + b^3 + c^3) + (a^6 + (b + c)^6) / 4 ≥\n  4 * (a^6 + (b + c)^6 / (4 * (a + b + c) * (a^2 + b^2 + c^2) * (a^3 + b^3 + c^3)))^(1 / 4)  :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a series of steps to ensure that the formal statement accurately represents the informal one. Here's the breakdown:\n\n1. **Understanding the Context**: The informal statement involves applying the AM-GM inequality to a specific expression. The goal is to show that a certain sum of fractions and a term involving powers of variables is greater than or equal to a specific expression involving a fourth root.\n\n2. **Identifying Variables**: The variables involved are \\(a\\), \\(b\\), and \\(c\\), which are real numbers. In Lean, we declare these variables with the type `ℝ` (real numbers).\n\n3. **Translating the Expression**:\n   - The left-hand side of the inequality consists of several terms:\n     - \\(\\frac{1}{\\sum a}\\) translates to `1 / (a + b + c)`.\n     - \\(\\frac{1}{\\sum a^2}\\) translates to `1 / (a^2 + b^2 + c^2)`.\n     - \\(\\frac{1}{\\sum a^3}\\) translates to `1 / (a^3 + b^3 + c^3)`.\n     - \\(\\frac{a^6 + (b + c)^6}{4}\\) translates to `(a^6 + (b + c)^6) / 4`.\n\n4. **Constructing the Right-Hand Side**:\n   - The right-hand side involves a fourth root, which in Lean is expressed using the power operator `^` with a fractional exponent:\n     - The expression under the fourth root is \\(\\frac{a^6 + (b + c)^6}{4(a + b + c)(a^2 + b^2 + c^2)(a^3 + b^3 + c^3)}\\).\n     - In Lean, this is written as `(a^6 + (b + c)^6) / (4 * (a + b + c) * (a^2 + b^2 + c^2) * (a^3 + b^3 + c^3))`.\n   - The fourth root is expressed as raising to the power of \\(1/4\\), which is written as `^(1 / 4)`.\n\n5. **Combining the Expressions**:\n   - The inequality is then constructed by combining"}
{"source_file": "herald_data/sample_500.jsonl", "line": 400, "id": 556320, "informal_statement": "Prove that $ \\frac {23}{8b^2 + 7bc + 8c^2} + \\frac {23}{8c^2 + 7ca + 8a^2} + \\frac {23}{8a^2 + 7ab + 8b^2} - \\frac {27}{(a + b + c)^2} \\geq0$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_556320 (a b c : ℝ) : (23 / (8 * b ^ 2 + 7 * b * c + 8 * c ^ 2) + 23 / (8 * c ^ 2 + 7 * c * a + 8 * a ^ 2) + 23 / (8 * a ^ 2 + 7 * a * b + 8 * b ^ 2) - 27 / (a + b + c) ^ 2) ≥ 0   :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves three variables \\(a\\), \\(b\\), and \\(c\\). In Lean, these are specified as real numbers, which is denoted by `ℝ`. This is done by declaring `(a b c : ℝ)` in the theorem statement.\n\n2. **Understand the Mathematical Expression**:\n   - The expression consists of three fractions and a subtraction of another fraction. Each fraction has a numerator and a denominator. The numerators are constants (23 and 27), and the denominators are quadratic expressions in terms of \\(a\\), \\(b\\), and \\(c\\).\n\n3. **Translate the Fractions**:\n   - The first fraction is \\(\\frac{23}{8b^2 + 7bc + 8c^2}\\). In Lean, this is written as `23 / (8 * b ^ 2 + 7 * b * c + 8 * c ^ 2)`.\n   - The second fraction is \\(\\frac{23}{8c^2 + 7ca + 8a^2}\\), translated to `23 / (8 * c ^ 2 + 7 * c * a + 8 * a ^ 2)`.\n   - The third fraction is \\(\\frac{23}{8a^2 + 7ab + 8b^2}\\), translated to `23 / (8 * a ^ 2 + 7 * a * b + 8 * b ^ 2)`.\n   - The fourth term is \\(\\frac{27}{(a + b + c)^2}\\), translated to `27 / (a + b + c) ^ 2`.\n\n4. **Combine the Expressions**:\n   - The expression is a sum of the first three fractions minus the fourth fraction. In Lean, this is expressed as:\n     ```lean\n     23 / (8 * b ^ 2 + 7 * b * c + 8 * c ^ 2) + \n     23 / (8 * c ^ 2 + 7 * c * a + 8 * a ^ 2) + \n     23 / (8 * a ^ 2 + 7 * a * b + 8 * b ^"}
{"source_file": "herald_data/sample_500.jsonl", "line": 395, "id": 199316, "informal_statement": "For any natural numbers $N$, $k$, and $n$, suppose $n$ is in the set of smooth numbers up to $k$ within $N$, $n$ is less than or equal to $N$, and $n$ is in the set of smooth numbers for $k$. Let $s$ be a finite set of natural numbers contained in the powerset of primes less than $k$. Given a natural number $m$ such that $n$ equals $m$ squared times the product of elements in $s$, prove that $m$ is not equal to zero.", "formal_statement": "import Mathlib\nopen List Perm in\nopen List Perm Equiv in\nlemma smoothNumbersUpTo_subset_image_tac_24722 (N : ℕ) (k : ℕ) (n : ℕ) (hn : n ∈ N.smoothNumbersUpTo k) (hn₁ : n ≤ N) (hn₂ : n ∈ k.smoothNumbers) (s : Finset ℕ) (hs : s ∈ k.primesBelow.powerset) (m : ℕ) (hm : n = m ^ 2 * s.prod id) : m ≠ 0 := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it corresponds to the Lean4 constructs:\n\n1. **Universal Quantification**: The informal statement begins with \"For any natural numbers $N$, $k$, and $n$,\" which corresponds to the parameters `(N : ℕ) (k : ℕ) (n : ℕ)` in the Lean lemma. This indicates that $N$, $k$, and $n$ are natural numbers, which are represented by `ℕ` in Lean.\n\n2. **Smooth Numbers Condition**: The statement \"suppose $n$ is in the set of smooth numbers up to $k$ within $N$\" is formalized as `(hn : n ∈ N.smoothNumbersUpTo k)`. Here, `N.smoothNumbersUpTo k` represents the set of smooth numbers up to $k$ within $N$, and `n ∈ N.smoothNumbersUpTo k` asserts that $n$ is an element of this set.\n\n3. **Inequality Condition**: The condition \"$n$ is less than or equal to $N$\" is directly translated to `(hn₁ : n ≤ N)`, which is a straightforward inequality in Lean.\n\n4. **Smooth Numbers for $k$**: The condition \"$n$ is in the set of smooth numbers for $k$\" is represented as `(hn₂ : n ∈ k.smoothNumbers)`. This indicates that $n$ is an element of the set of $k$-smooth numbers.\n\n5. **Finite Set of Natural Numbers**: The statement \"Let $s$ be a finite set of natural numbers contained in the powerset of primes less than $k$\" is formalized as `(s : Finset ℕ) (hs : s ∈ k.primesBelow.powerset)`. Here, `s : Finset ℕ` declares $s$ as a finite set of natural numbers, and `s ∈ k.primesBelow.powerset` ensures that $s$ is a subset of the powerset of primes less than $k$.\n\n6. **Natural Number $m$ and Equation**: The condition \"Given a natural number $m$ such that $n$ equals $m$ squared times the product of elements in $s$\" is translated to `(m :"}
{"source_file": "herald_data/sample_500.jsonl", "line": 401, "id": 575766, "informal_statement": "Prove that if $p$ is a prime number that $p\\equiv5\\pmod6$ and $p|a^2+ab+b^2$ when $a,b$ is integers, then $p|a$ and $p|b$ .", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_575766 (p a b : ℤ) (hp : Prime p) (h : p ≡ 5 [ZMOD 6]) (hab : p ∣ a^2 + a*b + b^2) : p ∣ a ∧ p ∣ b   :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and logical structure.\n\n1. **Understanding the Informal Statement:**\n   - We are given a prime number \\( p \\) such that \\( p \\equiv 5 \\pmod{6} \\).\n   - We are also given that \\( p \\) divides the expression \\( a^2 + ab + b^2 \\) for integers \\( a \\) and \\( b \\).\n   - We need to prove that \\( p \\) divides both \\( a \\) and \\( b \\).\n\n2. **Translating to Lean:**\n   - **Variables and Types:**\n     - The variables \\( p \\), \\( a \\), and \\( b \\) are integers, which in Lean are represented by `ℤ`.\n     - We declare these variables in the theorem statement: `(p a b : ℤ)`.\n\n   - **Prime Condition:**\n     - The condition that \\( p \\) is a prime number is expressed using `Prime p`. This uses Lean's built-in `Prime` predicate for integers.\n\n   - **Congruence Condition:**\n     - The condition \\( p \\equiv 5 \\pmod{6} \\) is expressed using `p ≡ 5 [ZMOD 6]`. This uses Lean's notation for modular arithmetic congruences.\n\n   - **Divisibility Condition:**\n     - The condition \\( p \\mid a^2 + ab + b^2 \\) is expressed using `p ∣ a^2 + a*b + b^2`. The symbol `∣` is used in Lean to denote divisibility.\n\n   - **Conclusion:**\n     - We need to prove that \\( p \\mid a \\) and \\( p \\mid b \\). This is expressed as `p ∣ a ∧ p ∣ b` in Lean, where `∧` denotes logical conjunction (and).\n\n3. **Theorem Structure:**\n   - The theorem is named `extract_aug_575766`, which is a placeholder name and can be replaced with a more descriptive name if desired.\n   - The theorem statement includes all the hypotheses (`hp`, `h`, `hab`) and the conclusion (`p ∣ a ∧ p ∣ b`).\n   - The `:= by sorry` part indicates that"}
{"source_file": "herald_data/sample_500.jsonl", "line": 397, "id": 46545, "informal_statement": "For any three points $p_1, p_2, p_3$ in the plane, show that the oriented angle from $p_1$ to $p_2$ to $p_3$ added to the oriented angle from $p_3$ to $p_2$ to $p_1$ results in $0$, i.e., $\\measuredangle p_1 p_2 p_3 + \\measuredangle p_3 p_2 p_1 = 0$.", "formal_statement": "import Mathlib\nopen FiniteDimensional Complex\nopen scoped Affine EuclideanGeometry Real RealInnerProductSpace ComplexConjugate\ntheorem oangle_add_oangle_rev_extracted [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P]\n [NormedAddTorsor V P] [hd2 : Fact (finrank ℝ V = 2)] [Module.Oriented ℝ V (Fin 2)] (p₁ p₂ p₃ : P) :\n ∡ p₁ p₂ p₃ + ∡ p₃ p₂ p₁ = 0 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a series of steps that map the concepts and operations from the informal language to the formal language of Lean4. Here's how this translation is achieved:\n\n1. **Understanding the Informal Statement**: \n   - We are given three points \\( p_1, p_2, p_3 \\) in the plane.\n   - We need to show that the sum of the oriented angle from \\( p_1 \\) to \\( p_2 \\) to \\( p_3 \\) and the oriented angle from \\( p_3 \\) to \\( p_2 \\) to \\( p_1 \\) is zero.\n\n2. **Identifying the Mathematical Concepts**:\n   - **Oriented Angles**: These are angles measured in a specific direction (counterclockwise or clockwise) between two vectors.\n   - **Plane Geometry**: The problem is set in a two-dimensional space, which is crucial for defining angles.\n\n3. **Setting Up the Lean Environment**:\n   - The code begins by importing necessary modules from Mathlib, which is a library for Lean that includes various mathematical theories.\n   - `open FiniteDimensional Complex` and other similar lines are used to bring relevant definitions and theorems into scope, particularly those related to Euclidean geometry and complex numbers.\n\n4. **Defining the Context**:\n   - `[NormedAddCommGroup V]` and `[InnerProductSpace ℝ V]` specify that \\( V \\) is a vector space over the real numbers \\( \\mathbb{R} \\) with a norm and an inner product, respectively.\n   - `[MetricSpace P]` and `[NormedAddTorsor V P]` indicate that \\( P \\) is a metric space and a torsor for the vector space \\( V \\), meaning \\( P \\) can be thought of as an affine space modeled on \\( V \\).\n   - `[hd2 : Fact (finrank ℝ V = 2)]` asserts that the dimension of the vector space \\( V \\) is 2, confirming that we are indeed working in a plane.\n   - `[Module.Oriented ℝ V (Fin 2)]` ensures that the vector space \\( V \\) has an orientation, which is necessary for defining oriented angles.\n\n5. **Formalizing the Theorem**:\n   - `theorem oangle"}
{"source_file": "herald_data/sample_500.jsonl", "line": 404, "id": 463279, "informal_statement": "If $a,b,c\\ge 0$ and $ab+bc+ac = 1$ then\\n\\n$ -8(abc)^2 - 8abc(a+b+c)^2 + 16abc(a+b+c) + 8abc + 2(a+b+c) -4 \\ge 0 $\\n\\n", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_463279 (a b c : ℝ) (ha : a ≥ 0) (hb : b ≥ 0) (hc : c ≥ 0) (hab : a * b + b * c + c * a = 1) : -8 * a * b * c ^ 2 - 8 * a * b * c * (a + b + c) ^ 2 + 16 * a * b * c * (a + b + c) + 8 * a * b * c + 2 * (a + b + c) - 4 ≥ 0  :=  by sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that involves understanding the mathematical conditions and expressions, and then expressing them using Lean's syntax and libraries. Here's a step-by-step explanation of the translation process:\n\n1. **Understand the Variables and Conditions**:\n   - The informal statement involves three real numbers \\(a\\), \\(b\\), and \\(c\\) with the conditions \\(a, b, c \\geq 0\\) and \\(ab + bc + ac = 1\\).\n   - These conditions are prerequisites for the inequality that follows.\n\n2. **Translate the Variables and Conditions**:\n   - In Lean, we declare the variables \\(a\\), \\(b\\), and \\(c\\) as real numbers using `(a b c : ℝ)`.\n   - The conditions \\(a \\geq 0\\), \\(b \\geq 0\\), and \\(c \\geq 0\\) are translated to `(ha : a ≥ 0)`, `(hb : b ≥ 0)`, and `(hc : c ≥ 0)`, respectively.\n   - The condition \\(ab + bc + ac = 1\\) is translated to `(hab : a * b + b * c + c * a = 1)`.\n\n3. **Translate the Inequality**:\n   - The inequality to prove is \\(-8(abc)^2 - 8abc(a+b+c)^2 + 16abc(a+b+c) + 8abc + 2(a+b+c) - 4 \\ge 0\\).\n   - In Lean, this is expressed using the syntax for arithmetic operations and inequalities:\n     - `-8 * a * b * c ^ 2` represents \\(-8(abc)^2\\).\n     - `- 8 * a * b * c * (a + b + c) ^ 2` represents \\(-8abc(a+b+c)^2\\).\n     - `+ 16 * a * b * c * (a + b + c)` represents \\(+16abc(a+b+c)\\).\n     - `+ 8 * a * b * c` represents \\(+8abc\\).\n     - `+ 2 * (a + b + c)` represents \\(+2(a+b+c)\\).\n     - `- 4` represents \\(-4\\).\n   - The entire expression"}
{"source_file": "herald_data/sample_500.jsonl", "line": 403, "id": 387656, "informal_statement": "For any $n \\in \\mathbb{N}$, $\\nu_p(n) = \\nu_p(n)$, where $\\nu_p$ denotes the $p$-adic valuation.", "formal_statement": "import Mathlib\nopen Nat\nopen Rat\nopen multiplicity\nopen multiplicity\nopen Nat.maxPowDiv\nopen multiplicity\n/-- The `p`-adic value of a natural is its `p`-adic value as an integer. -/\n@[simp]\ntheorem of_nat {n : ℕ} : padicValInt p n = padicValNat p n := sorry", "explanation": "To translate the informal statement \"For any \\( n \\in \\mathbb{N} \\), \\( \\nu_p(n) = \\nu_p(n) \\), where \\( \\nu_p \\) denotes the \\( p \\)-adic valuation\" into the formal Lean statement, we need to follow these steps:\n\n1. **Understand the Informal Statement**: The statement asserts that for any natural number \\( n \\), the \\( p \\)-adic valuation of \\( n \\) considered as an integer is the same as the \\( p \\)-adic valuation of \\( n \\) considered as a natural number. This is essentially a statement about the consistency of the \\( p \\)-adic valuation function across different types (integers and natural numbers).\n\n2. **Identify the Lean Constructs**:\n   - **Natural Numbers**: In Lean, natural numbers are represented by the type `ℕ`.\n   - **\\( p \\)-adic Valuation**: The \\( p \\)-adic valuation for integers and natural numbers is represented by `padicValInt` and `padicValNat` respectively in Lean.\n\n3. **Formalize the Statement**:\n   - We need to express that for any natural number `n`, the \\( p \\)-adic valuation as an integer (`padicValInt p n`) is equal to the \\( p \\)-adic valuation as a natural number (`padicValNat p n`).\n\n4. **Structure the Theorem**:\n   - Use a theorem to state this equality. The theorem is named `of_nat` to indicate that it is about the natural number version of the \\( p \\)-adic valuation.\n   - The theorem is marked with `@[simp]` to suggest that this is a simplification rule, which Lean can use automatically to simplify expressions involving \\( p \\)-adic valuations.\n\n5. **Write the Theorem in Lean**:\n   - The theorem is written as `theorem of_nat {n : ℕ} : padicValInt p n = padicValNat p n`.\n   - The `sorry` keyword is used as a placeholder for the proof, indicating that the proof is not provided here.\n\n6. **Import Necessary Modules**:\n   - The statement begins with `import Mathlib` to include the necessary mathematical libraries.\n   - The `open` statements are used to bring relevant namespaces into scope, such as `Nat`, `Rat`, and `multiplicity`, which are likely needed"}
{"source_file": "herald_data/sample_500.jsonl", "line": 399, "id": 1773, "informal_statement": "For any abelian group \\( G \\), the torsion submonoid of \\( G \\) is equal to the torsion subgroup of \\( G \\) when viewed as a submonoid.", "formal_statement": "import Mathlib\nopen Monoid\nopen CommMonoid (torsion)\ntheorem torsion_eq_torsion_submonoid_extracted (G : Type u_1) [CommGroup G] : CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand the mathematical concepts involved and how they are represented in Lean. Here's a step-by-step explanation:\n\n1. **Understanding the Mathematical Concepts**:\n   - **Abelian Group**: A group \\( G \\) where the group operation is commutative. In Lean, this is represented by `CommGroup G`.\n   - **Torsion Submonoid**: The set of elements in a monoid (or group) that have finite order. In Lean, for a commutative monoid, this is represented by `CommMonoid.torsion G`.\n   - **Torsion Subgroup**: The set of elements in a group that have finite order, which forms a subgroup. In Lean, for a commutative group, this is represented by `CommGroup.torsion G`.\n\n2. **Lean Imports and Namespace**:\n   - `import Mathlib`: This imports the Mathlib library, which contains definitions and theorems for algebraic structures like groups and monoids.\n   - `open Monoid` and `open CommMonoid (torsion)`: These lines open the namespaces for monoids and commutative monoids, allowing us to use their definitions and functions directly, such as `torsion`.\n\n3. **Formalizing the Statement**:\n   - **Type Declaration**: `G : Type u_1` declares \\( G \\) as a type in some universe `u_1`. This is a common way to handle types in Lean, allowing for generality.\n   - **Commutative Group Assumption**: `[CommGroup G]` specifies that \\( G \\) is a commutative group, which is necessary for discussing torsion elements in the context of both groups and monoids.\n\n4. **Theorem Statement**:\n   - `theorem torsion_eq_torsion_submonoid_extracted`: This declares a theorem named `torsion_eq_torsion_submonoid_extracted`.\n   - `CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid`: This is the core statement of the theorem. It asserts that the torsion submonoid of \\( G \\) (as a commutative monoid) is equal to the torsion subgroup of \\( G \\) (as a commutative group) when the latter is viewed as a sub"}
{"source_file": "herald_data/sample_500.jsonl", "line": 402, "id": 206610, "informal_statement": "For any semiring \\(R\\), given two polynomials \\(p, q \\in R[X]\\) such that the product of their leading coefficients is nonzero and \\(p\\) is not the zero polynomial, show that if \\(q\\) is the zero polynomial, then the product of the leading coefficients of \\(p\\) and \\(q\\) is zero, i.e., if \\(q = 0\\), then \\(p.leadingCoeff \\cdot q.leadingCoeff = 0\\).", "formal_statement": "import Mathlib\nopen Finsupp Finset\nopen Polynomial\nlemma degree_mul'_tac_33717 [Semiring R] (p : R[X]) (q : R[X]) (h : p.leadingCoeff * q.leadingCoeff ≠ 0) (hp : p ≠ 0) : q = 0 → p.leadingCoeff * q.leadingCoeff = 0 := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understand the Context**: The problem is set in the context of a semiring \\( R \\) and involves polynomials over this semiring. In Lean, this is represented by the type `R[X]`, which denotes polynomials with coefficients in \\( R \\).\n\n2. **Identify the Variables**: The informal statement involves two polynomials \\( p \\) and \\( q \\). In Lean, these are represented as `p : R[X]` and `q : R[X]`.\n\n3. **Leading Coefficients**: The leading coefficient of a polynomial is a key concept here. In Lean, `p.leadingCoeff` and `q.leadingCoeff` are used to denote the leading coefficients of the polynomials \\( p \\) and \\( q \\), respectively.\n\n4. **Nonzero Product Condition**: The informal statement specifies that the product of the leading coefficients is nonzero. This is expressed in Lean as the hypothesis `(h : p.leadingCoeff * q.leadingCoeff ≠ 0)`.\n\n5. **Nonzero Polynomial Condition**: The statement also specifies that \\( p \\) is not the zero polynomial. This is captured in Lean by the hypothesis `(hp : p ≠ 0)`.\n\n6. **Conclusion**: The goal is to show that if \\( q \\) is the zero polynomial, then the product of the leading coefficients is zero. In Lean, this is expressed as `q = 0 → p.leadingCoeff * q.leadingCoeff = 0`.\n\n7. **Structure of the Lemma**: The lemma is named `degree_mul'_tac_33717`, and it is defined with the necessary hypotheses and conclusion. The lemma is stated as:\n   ```lean\n   lemma degree_mul'_tac_33717 [Semiring R] (p : R[X]) (q : R[X]) \n     (h : p.leadingCoeff * q.leadingCoeff ≠ 0) (hp : p ≠ 0) : \n     q = 0 → p.leadingCoeff * q.leadingCoeff = 0 := sorry\n   ```\n   Here, `[Semiring R]` indicates that \\( R \\) is a semiring, and the `sorry` keyword is a placeholder indicating that the proof is not yet provided.\n\n8. **Logical Flow**: The lemma is structured to take the assumptions as"}
{"source_file": "herald_data/sample_500.jsonl", "line": 407, "id": 329169, "informal_statement": "For any ring $\\alpha$ with a linear order, and given $a, b \\in \\alpha$, where multiplication by positive elements is strictly monotone increasing, and the sum of elements preserves the order in both covariant and contravariant manners, show that the conjunction of \"$0 < -a$ implies $0 \\leq -b$\" and \"$0 < -b$ implies $0 \\leq -a$\" holds if and only if the conjunction of \"$a < 0$ implies $b \\leq 0$\" and \"$b < 0$ implies $a \\leq 0$\" holds.", "formal_statement": "import Mathlib\nopen Function\nlemma mul_nonneg_iff_neg_imp_nonpos_tac_39532 [Ring α] [LinearOrder α] (a : α) (b : α) [PosMulStrictMono α] [MulPosStrictMono α] [CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] : (0 < -a → 0 ≤ -b) ∧ (0 < -b → 0 ≤ -a) ↔ (a < 0 → b ≤ 0) ∧ (b < 0 → a ≤ 0) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the mathematical concepts and their logical relationships. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Mathematical Structures**: \n   - The statement involves a ring with a linear order. In Lean, this is represented by `[Ring α]` and `[LinearOrder α]`, where `α` is the type of the elements in the ring.\n\n2. **Define the Elements and Properties**:\n   - The elements `a` and `b` are elements of the ring `α`. This is expressed as `(a : α) (b : α)` in the Lean code.\n   - The properties of the ring include:\n     - Multiplication by positive elements is strictly monotone increasing, represented by `[PosMulStrictMono α]` and `[MulPosStrictMono α]`.\n     - The sum of elements preserves the order in both covariant and contravariant manners. This is captured by `[CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]` and `[ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]`.\n\n3. **Formalize the Logical Statement**:\n   - The informal statement involves logical implications and conjunctions. In Lean, implications are represented by `→` and conjunctions by `∧`.\n   - The statement \"0 < -a implies 0 ≤ -b\" is formalized as `(0 < -a → 0 ≤ -b)`.\n   - Similarly, \"0 < -b implies 0 ≤ -a\" is formalized as `(0 < -b → 0 ≤ -a)`.\n   - The conjunction of these two implications is expressed as `(0 < -a → 0 ≤ -b) ∧ (0 < -b → 0 ≤ -a)`.\n\n4. **Express the Equivalence**:\n   - The equivalence between the two conjunctions is represented by `↔`.\n   - The second conjunction \"a < 0 implies b ≤ 0\" and \"b < 0 implies a ≤ 0\" is formalized as `(a < 0 → b ≤ 0) ∧ (b < 0 → a"}
{"source_file": "herald_data/sample_500.jsonl", "line": 405, "id": 73375, "informal_statement": "For any elements \\(m, p\\) in an associates type \\(\\alpha\\) with decidable equality, where \\(m \\neq 0\\) and \\(p\\) is irreducible, and for any natural number \\(k\\), prove that \\(p^k \\leq m\\) if and only if \\(k \\leq\\) the number of times \\(p\\) appears in the factorization of \\(m\\).", "formal_statement": "import Mathlib\nopen Associates Nat\nopen Classical in\nopen Classical in\nopen Multiset in\nopen scoped Classical\nopen Multiset Associates\nopen multiplicity Multiset\nopen UniqueFactorizationMonoid Associated Multiset\nopen Classical in\nopen Classical in\nopen Classical in\nopen Classical in\nopen Classical in\ntheorem prime_pow_le_iff_le_bcount_extracted [CancelCommMonoidWithZero α] [UniqueFactorizationMonoid α]\n [DecidableEq (Associates α)] {m p : Associates α} :\n m ≠ 0 → ∀ (h₂ : Irreducible p) {k : ℕ}, p ^ k ≤ m ↔ k ≤ Associates.bcount ⟨p, h₂⟩ m.factors := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and libraries. Here's the step-by-step explanation:\n\n1. **Context and Imports**:\n   - The problem involves elements in an \"associates type\" with \"decidable equality.\" In Lean, this is handled by importing relevant libraries and opening necessary namespaces. The `Mathlib` import provides access to a wide range of mathematical constructs, including those for handling associates and unique factorization.\n   - The `open` statements bring various modules and namespaces into scope, such as `Associates`, `Nat`, `Multiset`, and `UniqueFactorizationMonoid`. These are necessary for working with associates, natural numbers, multisets, and unique factorization properties.\n\n2. **Type and Properties**:\n   - `[CancelCommMonoidWithZero α]` and `[UniqueFactorizationMonoid α]` are typeclass constraints. They specify that the type `α` is a commutative monoid with zero where cancellation is possible, and it also has unique factorization properties. These are essential for defining the behavior of elements in the associates type.\n   - `[DecidableEq (Associates α)]` indicates that equality between elements of type `Associates α` is decidable, which is necessary for certain logical operations and comparisons.\n\n3. **Variables and Assumptions**:\n   - `{m p : Associates α}` declares `m` and `p` as elements of the associates type `α`.\n   - `m ≠ 0` is a condition that `m` is non-zero, which is crucial for meaningful factorization.\n   - `∀ (h₂ : Irreducible p)` introduces a universal quantifier over `h₂`, which is a proof that `p` is irreducible. This matches the informal statement's condition that `p` is irreducible.\n\n4. **Natural Number and Exponentiation**:\n   - `{k : ℕ}` introduces `k` as a natural number, representing the exponent in the expression `p^k`.\n   - `p ^ k ≤ m` is the formalization of the statement \"prove that \\(p^k \\leq m\\).\" In Lean, `^` denotes exponentiation, and `≤` is the less-than-or-equal relation.\n\n5. **Factorization and Counting**"}
{"source_file": "herald_data/sample_500.jsonl", "line": 408, "id": 130683, "informal_statement": "For any Lie ring $L$, additive commutative group $M$, and Lie ring module $M$ over $L$, and for any elements $x \\in L$ and $m \\in M$, show that the Lie bracket of $-x + x$ and $m$ is the zero element of $M$, i.e., $[ -x + x, m ] = 0$.", "formal_statement": "import Mathlib\nopen Function\nlemma neg_lie_tac_6060 [LieRing L] [AddCommGroup M] [LieRingModule L M] (x : L) (m : M) : ⁅-x + x, m⁆ = 0 := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Structures Involved**: \n   - The informal statement involves a Lie ring \\( L \\), an additive commutative group \\( M \\), and a Lie ring module \\( M \\) over \\( L \\). In Lean, these are represented by the type classes `LieRing`, `AddCommGroup`, and `LieRingModule`, respectively.\n\n2. **Declare the Context**:\n   - In Lean, we use type classes to declare that certain types have specific algebraic structures. Here, we declare that \\( L \\) is a `LieRing`, \\( M \\) is an `AddCommGroup`, and \\( M \\) is a `LieRingModule` over \\( L \\). This is done using the square bracket notation `[LieRing L] [AddCommGroup M] [LieRingModule L M]`.\n\n3. **Specify the Elements**:\n   - The informal statement involves elements \\( x \\in L \\) and \\( m \\in M \\). In Lean, these are introduced as variables with their respective types: `(x : L)` and `(m : M)`.\n\n4. **Express the Lie Bracket**:\n   - The operation \\( [ -x + x, m ] \\) is the Lie bracket of the elements \\(-x + x\\) and \\( m \\). In Lean, the Lie bracket is denoted by `⁅ , ⁆`. Therefore, `⁅-x + x, m⁆` represents the Lie bracket of \\(-x + x\\) and \\( m \\).\n\n5. **State the Conclusion**:\n   - The informal statement concludes that the Lie bracket \\( [ -x + x, m ] \\) is the zero element of \\( M \\). In Lean, this is expressed as `⁅-x + x, m⁆ = 0`.\n\n6. **Formulate the Lemma**:\n   - The entire statement is encapsulated in a lemma. The lemma is named `neg_lie_tac_6060`, and it asserts that for any \\( x \\) and \\( m \\), the Lie bracket \\( ⁅-x + x, m⁆ \\) equals zero. The lemma is written as:\n     ```lean\n     lemma neg_lie_tac_6060 [LieRing L] [AddCommGroup"}
{"source_file": "herald_data/sample_500.jsonl", "line": 412, "id": 439192, "informal_statement": "For any element \\(a\\) in a nontrivial ordered semiring \\(\\alpha\\), prove that \\(0 < a^0\\).", "formal_statement": "import Mathlib\nopen Lean Meta Qq Function\nprivate theorem pow_zero_pos [OrderedSemiring α] [Nontrivial α] (a : α) : 0 < a ^ 0 := sorry", "explanation": "To translate the informal statement \"For any element \\(a\\) in a nontrivial ordered semiring \\(\\alpha\\), prove that \\(0 < a^0\\)\" into the formal Lean statement, we follow these steps:\n\n1. **Identify the Mathematical Structures**: \n   - The statement involves an \"ordered semiring\" and \"nontrivial\" properties. In Lean, these are represented by typeclasses. An `OrderedSemiring` is a semiring with an order that is compatible with the semiring operations, and `Nontrivial` indicates that the semiring has more than one element (i.e., it is not the trivial semiring where all elements are equal).\n\n2. **Specify the Type and Assumptions**:\n   - We need to specify that \\(\\alpha\\) is a type that has the structure of an ordered semiring and is nontrivial. This is done using the typeclass mechanism in Lean: `[OrderedSemiring α] [Nontrivial α]`.\n\n3. **Define the Element and the Goal**:\n   - The element \\(a\\) is an arbitrary element of the semiring \\(\\alpha\\). In Lean, this is expressed by `(a : α)`.\n   - The goal is to prove that \\(0 < a^0\\). In Lean, exponentiation is denoted by `^`, and the inequality is expressed using `<`.\n\n4. **Formalize the Theorem Statement**:\n   - The theorem is named `pow_zero_pos`, which is descriptive of the property being proven: the positivity of \\(a^0\\).\n   - The full theorem statement in Lean is: `theorem pow_zero_pos [OrderedSemiring α] [Nontrivial α] (a : α) : 0 < a ^ 0`.\n\n5. **Use of `sorry`**:\n   - The keyword `sorry` is used as a placeholder for the proof. It indicates that the proof is not provided, but the statement is expected to be provable.\n\n6. **Import Necessary Libraries**:\n   - The line `import Mathlib` is used to import the necessary mathematical libraries that provide definitions and theorems related to ordered semirings and other algebraic structures.\n\n7. **Open Necessary Namespaces**:\n   - The line `open Lean Meta Qq Function` is included to bring certain namespaces into scope, which might be useful for more advanced manipulations or extensions"}
{"source_file": "herald_data/sample_500.jsonl", "line": 406, "id": 348042, "informal_statement": "In $\\mathbb{R}^2$, the 2-dimensional Hausdorff measure $\\mu_H^2$ coincides with the Lebesgue measure.", "formal_statement": "import Mathlib\nopen scoped NNReal ENNReal Topology\nopen EMetric Set Function Filter Encodable FiniteDimensional TopologicalSpace\nopen scoped MeasureTheory\nopen MeasureTheory MeasureTheory.Measure\nopen scoped Pointwise\n/-- In the space `ℝ × ℝ`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\n@[simp]\ntheorem hausdorffMeasure_prod_real : (μH[2] : Measure (ℝ × ℝ)) = volume := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Context**: The informal statement is about the relationship between two measures in the context of $\\mathbb{R}^2$: the 2-dimensional Hausdorff measure and the Lebesgue measure. In Lean, these measures are represented in the context of measure theory.\n\n2. **Identifying the Space**: The informal statement refers to $\\mathbb{R}^2$, which is the Cartesian product of the real line with itself. In Lean, this is represented as `ℝ × ℝ`.\n\n3. **Hausdorff Measure in Lean**: The 2-dimensional Hausdorff measure is denoted by `μH[2]` in Lean. This notation indicates the Hausdorff measure of dimension 2.\n\n4. **Lebesgue Measure in Lean**: The Lebesgue measure on `ℝ × ℝ` is represented by `volume` in Lean. This is a standard notation in Lean's measure theory library for the Lebesgue measure on Euclidean spaces.\n\n5. **Formalizing the Statement**: The goal is to express that these two measures are equal on `ℝ × ℝ`. In Lean, this is done by stating that the Hausdorff measure `μH[2]` is equal to the `volume` measure. This is expressed as `(μH[2] : Measure (ℝ × ℝ)) = volume`.\n\n6. **Theorem Declaration**: The statement is formalized as a theorem in Lean. The theorem is named `hausdorffMeasure_prod_real`, indicating that it pertains to the product space of real numbers. The `@[simp]` attribute is used to mark this theorem as a simplification rule, which can be used by Lean's simplifier to automatically replace instances of `μH[2]` with `volume` in proofs.\n\n7. **Imports and Open Statements**: The code begins with several `import` and `open` statements. These are necessary to bring in the relevant libraries and namespaces for measure theory, topology, and other mathematical structures used in the theorem. Specifically, `Mathlib` is imported, and various namespaces like `MeasureTheory` and `Topology` are opened to access the necessary definitions and theorems.\n\n8. **Conclusion**: The theorem is stated but not proved (`:= sorry`). In"}
{"source_file": "herald_data/sample_500.jsonl", "line": 411, "id": 324313, "informal_statement": "In a semiring $\\alpha$ equipped with a preorder, for any elements $a, b, c, d \\in \\alpha$, if there exists an element such that for any two elements the addition is defined when one is less than or equal to the other, and if multiplication is monotone with respect to positivity, and if addition respects the preorder in both covariant and contravariant ways, given $b \\leq a$ and $c \\leq 0$, and given $0 = c + d$, show that $a \\cdot c \\leq b \\cdot c$.", "formal_statement": "import Mathlib\nopen Function\nlemma mul_le_mul_of_nonpos_right_tac_7366 [Semiring α] [Preorder α] (a : α) (b : α) (c : α) [ExistsAddOfLE α] [MulPosMono α] [CovariantClass α α (swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [ContravariantClass α α (swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (h : b ≤ a) (hc : c ≤ 0) (d : α) (hcd : 0 = c + d) : a * c ≤ b * c := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it corresponds to the Lean constructs:\n\n1. **Semiring and Preorder**: \n   - The informal statement begins by specifying that we are working within a semiring $\\alpha$ equipped with a preorder. In Lean, this is expressed by `[Semiring α] [Preorder α]`. These are typeclass constraints that ensure the type $\\alpha$ has the structure of a semiring and a preorder.\n\n2. **Elements and Conditions**:\n   - The elements $a, b, c, d \\in \\alpha$ are introduced as variables in the lemma: `(a : α) (b : α) (c : α)`.\n   - The condition \"if there exists an element such that for any two elements the addition is defined when one is less than or equal to the other\" is captured by `[ExistsAddOfLE α]`. This typeclass indicates that for any two elements $x, y \\in \\alpha$, if $x \\leq y$, then there exists an element $z$ such that $x + z = y$.\n\n3. **Monotonicity of Multiplication**:\n   - The statement \"multiplication is monotone with respect to positivity\" is formalized by `[MulPosMono α]`. This typeclass ensures that multiplication by a positive element is monotone.\n\n4. **Covariant and Contravariant Addition**:\n   - The conditions \"addition respects the preorder in both covariant and contravariant ways\" are expressed using `[CovariantClass α α (swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]` and `[ContravariantClass α α (swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]`. These typeclasses ensure that addition is monotone in both arguments, with the `swap` indicating the contravariant nature.\n\n5. **Hypotheses**:\n   - The hypothesis $b \\leq a$ is directly translated as `(h : b ≤ a)`.\n   - The hypothesis $c \\leq 0$ is translated as `(hc : c ≤ 0)`.\n   - The condition $0 = c + d$ is expressed as `(d : α) (h"}
{"source_file": "herald_data/sample_500.jsonl", "line": 409, "id": 314914, "informal_statement": "For a normed additive commutative group $E$, a normed space over the complex numbers $\\mathbb{C}$, a function $f: \\mathbb{C} \\to E$, a point $c \\in \\mathbb{C}$, a radius $R \\in \\mathbb{R}$, and a point $w \\in \\mathbb{C}$, assuming that $f$ is circle integrable on the circle centered at $c$ with radius $R$, the absolute value of $w$ is less than $R$, $R > 0$, and $\\frac{|w|}{R}$ is in the open interval $(0, 1)$, show that the function $(x \\mapsto (circleMap(c, R, x) - c)^{-1})$ is measurable, where $n \\in \\mathbb{N}$ is given.", "formal_statement": "import Mathlib\nopen scoped Real NNReal Interval Pointwise Topology\nopen Complex MeasureTheory TopologicalSpace Metric Function Set Filter Asymptotics\nlemma hasSum_two_pi_I_cauchyPowerSeries_integral_tac_27305 [NormedAddCommGroup E] [NormedSpace ℂ E] (f : ℂ → E) (c : ℂ) (R : ℝ) (w : ℂ) (hf : CircleIntegrable f c R) (hw : Complex.abs w < R) (hR : 0 < R) (hwR : Complex.abs w / R ∈ Ico 0 1) (n : ℕ) : Measurable fun x => (circleMap c R x - c)⁻¹ := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures all the mathematical concepts and assumptions involved. Here's a step-by-step explanation of the translation:\n\n1. **Context and Imports**:\n   - The problem involves complex analysis and measure theory, so we import relevant libraries from Mathlib, such as `Complex`, `MeasureTheory`, and others. These imports provide the necessary definitions and theorems for handling complex numbers, integrals, and measurability.\n\n2. **Type Classes and Assumptions**:\n   - We declare `E` as a `NormedAddCommGroup` and a `NormedSpace` over the complex numbers `ℂ`. This sets up the context that `E` is a normed space where addition is commutative, and it is equipped with a norm compatible with the complex field.\n\n3. **Function and Variables**:\n   - The function `f : ℂ → E` is defined, mapping complex numbers to the normed space `E`.\n   - The variables `c : ℂ`, `R : ℝ`, and `w : ℂ` are introduced, representing the center of the circle, the radius, and a point in the complex plane, respectively.\n\n4. **Assumptions**:\n   - `hf : CircleIntegrable f c R` asserts that the function `f` is integrable over the circle centered at `c` with radius `R`. This is a key assumption for applying results related to circle integrals.\n   - `hw : Complex.abs w < R` ensures that the point `w` lies inside the circle of radius `R`.\n   - `hR : 0 < R` confirms that the radius is positive, which is necessary for defining a valid circle.\n   - `hwR : Complex.abs w / R ∈ Ico 0 1` states that the ratio of the absolute value of `w` to `R` is within the open interval `(0, 1)`, ensuring `w` is strictly inside the circle.\n\n5. **Goal**:\n   - The goal is to show that the function `fun x => (circleMap c R x - c)⁻¹` is measurable. This function maps a point on the circle to the inverse of its displacement from the center `c`.\n\n6. **Function Definition**:\n   - `circleMap c R x"}
{"source_file": "herald_data/sample_500.jsonl", "line": 410, "id": 542887, "informal_statement": "Prove that if $a,b,c >0$ then \\n $\\frac{ab}{3a+4b+5c}+\\frac{bc}{3b+4c+5a}+\\frac{ac}{3c+4a+5b} \\le \\frac{a+b+c}{12}.$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_542887 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : (a * b / (3 * a + 4 * b + 5 * c) + b * c / (3 * b + 4 * c + 5 * a) + a * c / (3 * c + 4 * a + 5 * b)) ≤ (a + b + c) / 12   :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves three positive real numbers \\(a\\), \\(b\\), and \\(c\\). In Lean, these are represented as variables of type `ℝ` (real numbers). The conditions \\(a, b, c > 0\\) are expressed as `0 < a`, `0 < b`, and `0 < c`.\n\n2. **Structure the Theorem**:\n   - The goal is to prove an inequality involving these variables. In Lean, this is structured as a theorem. The theorem is named `extract_aug_542887`, which is a placeholder name and can be replaced with a more descriptive one if desired.\n\n3. **Express the Inequality**:\n   - The left-hand side of the inequality is a sum of three fractions: \\(\\frac{ab}{3a+4b+5c} + \\frac{bc}{3b+4c+5a} + \\frac{ac}{3c+4a+5b}\\). In Lean, multiplication is denoted by `*`, and division by `/`. Thus, each term is expressed as `a * b / (3 * a + 4 * b + 5 * c)`, `b * c / (3 * b + 4 * c + 5 * a)`, and `a * c / (3 * c + 4 * a + 5 * b)`.\n   - The right-hand side of the inequality is \\(\\frac{a+b+c}{12}\\), which is expressed in Lean as `(a + b + c) / 12`.\n\n4. **Combine the Elements**:\n   - The theorem statement combines these elements, asserting that the sum of the three fractions is less than or equal to the right-hand side. This is expressed using the `≤` operator in Lean.\n\n5. **Specify the Proof Strategy**:\n   - The `:= by sorry` part indicates that the proof is not yet provided. In Lean, `sorry` is a placeholder that allows the theorem to be syntactically correct without a complete proof. In practice, this would be replaced with a valid proof strategy.\n\n6. **Import Necessary Libraries**:\n   - The `import Mathlib` statement ensures that necessary mathematical libraries are available, providing definitions"}
{"source_file": "herald_data/sample_500.jsonl", "line": 413, "id": 343363, "informal_statement": "Let \\(R\\) be a ring, \\(k\\) a linearly ordered field, and \\(\\abv : R \\to k\\) an absolute value. For a polynomial \\(p \\in R[X]\\) with \\(\\deg p > 0\\), and a filter \\(l\\) on a type \\(\\alpha\\), if \\(z : \\alpha \\to R\\) satisfies \\(\\abv \\circ z \\to \\infty\\) as \\(l\\)-filtered, prove that \\(\\abv(p(z(x))) \\to \\infty\\) as \\(l\\)-filtered.", "formal_statement": "import Mathlib\nopen IsAbsoluteValue Filter\nopen Polynomial\ntheorem tendsto_abv_atTop {R k α : Type*} [Ring R] [LinearOrderedField k] (abv : R → k)\n    [IsAbsoluteValue abv] (p : R[X]) (h : 0 < degree p) {l : Filter α} {z : α → R}\n    (hz : Tendsto (abv ∘ z) l atTop) : Tendsto (fun x => abv (p.eval (z x))) l atTop := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to carefully map each component of the statement to its corresponding Lean constructs. Here's a step-by-step explanation of the translation:\n\n1. **Types and Structures**:\n   - The informal statement involves a ring \\( R \\), a linearly ordered field \\( k \\), and an absolute value \\(\\abv : R \\to k\\). In Lean, we declare these using type variables and type classes:\n     - `R` and `k` are declared as type variables with `R : Type*` and `k : Type*`.\n     - `R` is specified to be a ring with `[Ring R]`.\n     - `k` is specified to be a linearly ordered field with `[LinearOrderedField k]`.\n\n2. **Absolute Value**:\n   - The absolute value \\(\\abv : R \\to k\\) is represented as a function `abv : R → k`.\n   - We also need to ensure that `abv` satisfies the properties of an absolute value, which is done by including `[IsAbsoluteValue abv]`.\n\n3. **Polynomial and Degree**:\n   - The polynomial \\( p \\in R[X] \\) is represented as `p : R[X]`, where `R[X]` denotes the type of polynomials with coefficients in \\( R \\).\n   - The condition \\(\\deg p > 0\\) is expressed using `h : 0 < degree p`, where `degree p` computes the degree of the polynomial `p`.\n\n4. **Filter and Convergence**:\n   - The filter \\( l \\) on a type \\(\\alpha\\) is represented as `l : Filter α`, where `α : Type*` is the type over which the filter is defined.\n   - The function \\( z : \\alpha \\to R \\) is represented as `z : α → R`.\n\n5. **Convergence Condition**:\n   - The condition \\(\\abv \\circ z \\to \\infty\\) as \\( l \\)-filtered is expressed using `hz : Tendsto (abv ∘ z) l atTop`.\n   - `Tendsto` is a Lean predicate that describes the convergence of a function with respect to a filter. `atTop` is the filter representing convergence to infinity.\n\n6. **Conclusion**:\n   - The goal is to prove that \\(\\abv(p(z"}
{"source_file": "herald_data/sample_500.jsonl", "line": 415, "id": 310020, "informal_statement": "For any linearly ordered and locally finite type $\\alpha$, and for any elements $a, b, c \\in \\alpha$, show that the finite set of elements in the closed interval from $\\max(a, c)$ to $b$ is equal to itself, i.e., the set $\\{x \\in \\alpha \\mid \\max(a, c) \\leq x \\leq b\\}$ is equal to $\\{x \\in \\alpha \\mid \\max(a, c) \\leq x \\leq b\\}$.", "formal_statement": "import Mathlib\n\nlemma Ico_filter_le_tac_9920 [LinearOrder α] [LocallyFiniteOrder α] (a : α) (b : α) (c : α) : (Finset.Ico (max a c) b).val = (Finset.Ico (max a c) b).val := sorry", "explanation": "To translate the given informal mathematical statement into the provided Lean4 code, we need to follow these steps:\n\n1. **Understanding the Context**: \n   - The informal statement involves a linearly ordered and locally finite type $\\alpha$. This means that $\\alpha$ is a type with a total order (every pair of elements is comparable) and for any two elements, the set of elements between them is finite.\n   - We are considering elements $a, b, c \\in \\alpha$ and the closed interval from $\\max(a, c)$ to $b$.\n\n2. **Formalizing the Type and Order**:\n   - In Lean, we represent the type $\\alpha$ with the type variable `α`.\n   - The constraints that $\\alpha$ is linearly ordered and locally finite are expressed using type classes. `LinearOrder α` ensures that `α` is a linearly ordered type, and `LocallyFiniteOrder α` ensures that for any two elements, the interval between them is finite.\n\n3. **Defining the Interval**:\n   - The interval from $\\max(a, c)$ to $b$ is represented using `Finset.Ico (max a c) b`. In Lean, `Finset.Ico` represents a finite set of elements in the interval `[a, b)`, which is the half-open interval including `a` and excluding `b`.\n   - The use of `max a c` ensures that the interval starts at the larger of `a` and `c`.\n\n4. **Stating the Equality**:\n   - The goal is to show that this interval is equal to itself, which is trivially true. In Lean, this is expressed as `(Finset.Ico (max a c) b).val = (Finset.Ico (max a c) b).val`.\n   - The `.val` is used to extract the underlying set from the `Finset`, but in this context, it is essentially stating that the set is equal to itself.\n\n5. **Writing the Lemma**:\n   - The lemma is named `Ico_filter_le_tac_9920`, which is a placeholder name and can be replaced with something more descriptive.\n   - The lemma takes three arguments `a`, `b`, and `c`, all of type `α`.\n   - The statement of the lemma is the equality of the interval with itself, which is trivially true and hence marked with `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 420, "id": 182484, "informal_statement": "For any preordered sets \\((\\alpha, \\leq_{\\alpha}), (\\beta, \\leq_{\\beta}), (\\gamma, \\leq_{\\gamma})\\), equipped with multiplication, zero, and one \\((\\alpha, *, 0, 1), (\\beta, *, 0, 1), (\\gamma, *, 0, 1)\\), and given order-preserving monoid with zero homomorphisms \\(g_1, g_2 : \\beta \\to \\gamma\\) and \\(f : \\alpha \\to \\beta\\), if \\(f\\) is surjective, then show that \\(g_1 \\circ f = g_2 \\circ f\\) implies \\(g_1 = g_2\\).", "formal_statement": "import Mathlib\nopen Function\nlemma cancel_right_tac_28510 [Preorder α] [Preorder β] [Preorder γ] [MulZeroOneClass α] [MulZeroOneClass β] [MulZeroOneClass γ] (g₁ : β →*₀o γ) (g₂ : β →*₀o γ) (f : α →*₀o β) (hf : Surjective ⇑f) : g₁.comp f = g₂.comp f := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully map each component of the informal description to its formal counterpart in Lean. Here's a step-by-step explanation of the translation:\n\n1. **Preordered Sets with Multiplication, Zero, and One:**\n   - The informal statement mentions preordered sets \\((\\alpha, \\leq_{\\alpha}), (\\beta, \\leq_{\\beta}), (\\gamma, \\leq_{\\gamma})\\) equipped with multiplication, zero, and one. In Lean, this is represented using type classes. \n   - `[Preorder α]`, `[Preorder β]`, and `[Preorder γ]` are type class constraints that ensure \\(\\alpha\\), \\(\\beta\\), and \\(\\gamma\\) are preordered sets.\n   - `[MulZeroOneClass α]`, `[MulZeroOneClass β]`, and `[MulZeroOneClass γ]` are type class constraints that ensure these types have a multiplication operation, a zero, and a one.\n\n2. **Order-Preserving Monoid with Zero Homomorphisms:**\n   - The informal statement refers to homomorphisms \\(g_1, g_2 : \\beta \\to \\gamma\\) and \\(f : \\alpha \\to \\beta\\) that preserve the order and the monoid structure with zero.\n   - In Lean, `β →*₀o γ` denotes an order-preserving monoid with zero homomorphism from \\(\\beta\\) to \\(\\gamma\\). Similarly, `α →*₀o β` denotes such a homomorphism from \\(\\alpha\\) to \\(\\beta\\).\n   - `g₁ : β →*₀o γ` and `g₂ : β →*₀o γ` are the homomorphisms \\(g_1\\) and \\(g_2\\).\n   - `f : α →*₀o β` is the homomorphism \\(f\\).\n\n3. **Surjective Function:**\n   - The informal statement specifies that \\(f\\) is surjective.\n   - In Lean, `hf : Surjective ⇑f` asserts that the function \\(f\\) is surjective. The notation `⇑f` is used to denote the underlying function of the homomorphism \\(f\\).\n\n4. **Equality of Compositions Implies Equality of Functions:"}
{"source_file": "herald_data/sample_500.jsonl", "line": 414, "id": 432176, "informal_statement": "Let \\( P \\) be an inductive proposition, \\( R \\) a relation, and \\( \\text{syntax} \\) the syntax for \\( R \\). The function \\( \\text{mkIffOfInductivePropImpl} \\) takes \\( P \\), \\( R \\), and \\( \\text{syntax} \\) as inputs and returns a computation of type \\( \\text{Unit} \\) in the meta monad, facilitating the generation of if-and-only-if statements from \\( P \\).", "formal_statement": "import Mathlib\nopen Lean Meta Elab\n/-- Implementation for both `mk_iff` and `mk_iff_of_inductive_prop`.\n-/\ndef mkIffOfInductivePropImpl (ind : Name) (rel : Name) (relStx : Syntax) : MetaM Unit := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to break down each component of the informal description and see how it corresponds to the elements in the Lean code.\n\n1. **Understanding the Context**:\n   - The informal statement involves an inductive proposition \\( P \\), a relation \\( R \\), and a syntax representation for \\( R \\). These are typical components in formal logic and type theory, where propositions and relations are often represented as types or terms.\n\n2. **Lean Imports and Namespace**:\n   - The code begins with `import Mathlib`, which suggests that the function relies on the Mathlib library, a comprehensive library for Lean that includes many mathematical definitions and theorems.\n   - `open Lean Meta Elab` is used to bring the `Meta` and `Elab` namespaces into scope, which are part of Lean's metaprogramming framework. This indicates that the function operates within the metaprogramming environment, allowing manipulation of Lean's internal structures.\n\n3. **Function Definition**:\n   - The function is defined using `def`, which is the keyword for defining a new function in Lean.\n   - The function name `mkIffOfInductivePropImpl` is a direct translation of the informal description \"The function \\( \\text{mkIffOfInductivePropImpl} \\)\". The name suggests that the function is an implementation detail for creating if-and-only-if statements from inductive propositions.\n\n4. **Parameters**:\n   - The parameters `(ind : Name) (rel : Name) (relStx : Syntax)` correspond to the inputs \\( P \\), \\( R \\), and \\( \\text{syntax} \\) in the informal statement.\n     - `ind : Name` represents the inductive proposition \\( P \\). In Lean, `Name` is a type used to refer to identifiers, such as the name of an inductive type.\n     - `rel : Name` represents the relation \\( R \\). Similarly, it is identified by a `Name`.\n     - `relStx : Syntax` represents the syntax for \\( R \\). `Syntax` is a type in Lean that represents parsed expressions, which is suitable for handling the syntactic representation of relations.\n\n5. **Return Type**:\n   - The return type `: MetaM Unit` indicates that the function returns a computation in the `MetaM` monad, which is used for metaprogramming tasks in"}
{"source_file": "herald_data/sample_500.jsonl", "line": 417, "id": 201162, "informal_statement": "For any normed abelian group \\(V\\), inner product space over \\(\\mathbb{R}\\) with dimension 2, and given an orientation \\(o\\) on \\(\\mathbb{R}\\) vector space \\(V\\) over \\(Fin\\ 2\\), along with vectors \\(x, y \\in V\\) and a scalar \\(r \\in \\mathbb{R}\\), show that the sign of the oriented angle \\((o.oangle (-x) y)\\) is equal to itself. Note: This statement is trivial as it asserts the sign is equal to itself, hence it may be an artifact or placeholder within the formal development.", "formal_statement": "import Mathlib\nopen FiniteDimensional Complex\nopen scoped Real RealInnerProductSpace ComplexConjugate\nlemma oangle_sign_smul_sub_left_tac_44036 [NormedAddCommGroup V] [InnerProductSpace ℝ V] [Fact (finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) (y : V) (r : ℝ) : (o.oangle (-x) y).sign = (o.oangle (-x) y).sign := sorry", "explanation": "To translate the given informal mathematical statement into the provided Lean4 code, we need to follow a structured approach that captures the essence of the statement and its components in Lean's formal language. Here's a step-by-step explanation:\n\n1. **Understanding the Context**:\n   - The informal statement involves a normed abelian group \\(V\\), which in Lean is represented by `NormedAddCommGroup V`.\n   - It also involves an inner product space over \\(\\mathbb{R}\\) with dimension 2. In Lean, this is captured by `InnerProductSpace ℝ V` and `Fact (finrank ℝ V = 2)`. The `Fact` typeclass is used to assert that the finite dimension of \\(V\\) over \\(\\mathbb{R}\\) is 2.\n\n2. **Orientation**:\n   - The orientation \\(o\\) on the vector space \\(V\\) is represented by `Orientation ℝ V (Fin 2)`. This indicates that \\(V\\) is oriented over the finite type `Fin 2`, which corresponds to the dimension 2 requirement.\n\n3. **Vectors and Scalars**:\n   - The vectors \\(x\\) and \\(y\\) in \\(V\\) are directly translated to `x : V` and `y : V` in Lean.\n   - The scalar \\(r\\) in \\(\\mathbb{R}\\) is represented as `r : ℝ`.\n\n4. **Oriented Angle and Sign**:\n   - The oriented angle between vectors, denoted as \\((o.oangle (-x) y)\\), is a function of the orientation and the vectors. In Lean, this is expressed as `o.oangle (-x) y`.\n   - The sign of this oriented angle is captured by `.sign`, leading to `(o.oangle (-x) y).sign`.\n\n5. **Equality Assertion**:\n   - The informal statement asserts that the sign of the oriented angle is equal to itself, which is trivially true. In Lean, this is expressed as `(o.oangle (-x) y).sign = (o.oangle (-x) y).sign`.\n\n6. **Lemma Declaration**:\n   - The entire statement is encapsulated in a lemma named `oangle_sign_smul_sub_left_tac_44036`. The name is likely auto-generated or follows a specific naming convention.\n   - The lemma is declared with the necessary type"}
{"source_file": "herald_data/sample_500.jsonl", "line": 419, "id": 405026, "informal_statement": "Let \\((\\alpha, \\preceq)\\) be a preordered set without a maximum element. For any \\(a \\in \\alpha\\), prove that in the cofinal filter at top, there is a set \\(S\\) such that \\(a \\notin S\\).", "formal_statement": "import Mathlib\nopen Set\ntheorem eventually_ne_atTop [Preorder α] [NoMaxOrder α] (a : α) : ∀ᶠ x in atTop, x ≠ a := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean.\n\n1. **Preordered Set \\((\\alpha, \\preceq)\\):**\n   - In Lean, a preordered set is represented by a type `α` with a `Preorder` instance. This is indicated by `[Preorder α]` in the Lean code, which means that `α` is a type equipped with a preorder relation.\n\n2. **Without a Maximum Element:**\n   - The condition that the preordered set has no maximum element is captured by the `NoMaxOrder α` typeclass. This is a Lean typeclass that asserts there is no maximum element in the preorder on `α`.\n\n3. **For any \\(a \\in \\alpha\\):**\n   - The statement \"for any \\(a \\in \\alpha\\)\" is represented by the parameter `(a : α)` in the theorem. This indicates that `a` is an arbitrary element of the type `α`.\n\n4. **Cofinal Filter at Top:**\n   - The \"cofinal filter at top\" is represented by `atTop` in Lean. The `atTop` filter is a standard filter on a preorder that captures the notion of being \"eventually above\" any given element.\n\n5. **There is a set \\(S\\) such that \\(a \\notin S\\):**\n   - The statement that there exists a set \\(S\\) such that \\(a \\notin S\\) is formalized using the filter notation `∀ᶠ x in atTop, x ≠ a`. The symbol `∀ᶠ` denotes \"for all eventually\" in the context of a filter. This means that for all elements `x` in the filter `atTop`, `x` is not equal to `a`.\n\n6. **Theorem Statement:**\n   - The theorem is named `eventually_ne_atTop`, which suggests that it is about elements being eventually not equal (`ne`) to a given element `a` at the top filter (`atTop`).\n\n7. **Proof Placeholder:**\n   - The `:= sorry` at the end of the theorem indicates that the proof is not provided. In Lean, `sorry` is used as a placeholder for a proof that is yet to be completed.\n\nIn summary, the Lean"}
{"source_file": "herald_data/sample_500.jsonl", "line": 418, "id": 451888, "informal_statement": "Find $N$ such that $0<(n+1)^{1/3}-n^{1/3}< e$ for all $n>N$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_451888 (e : ℝ) (he_pos : 0 < e) :\n    ∃ N : ℕ, ∀ n : ℕ, n > N → (0 < ((n:ℝ) + 1) ^ (1 / 3) - (n:ℝ) ^ (1 / 3)) ∧\n      ((n:ℝ) + 1) ^ (1 / 3) - (n:ℝ) ^ (1 / 3) < e  :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formalized version in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Informal Statement**:\n   - We are asked to find an integer \\( N \\) such that for all integers \\( n \\) greater than \\( N \\), the inequality \\( 0 < (n+1)^{1/3} - n^{1/3} < e \\) holds.\n   - The statement involves real numbers and cube roots, and it requires finding a threshold \\( N \\) beyond which the inequality is satisfied.\n\n2. **Translation to Lean4**:\n   - **Import Statements**: \n     - `import Mathlib` is used to bring in the necessary mathematical libraries.\n     - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to access specific operations and types without prefixing them with their module names.\n\n   - **Theorem Declaration**:\n     - `theorem extract_aug_451888` names the theorem. The name is arbitrary and can be anything descriptive.\n     - `(e : ℝ) (he_pos : 0 < e)` declares the parameter \\( e \\) as a real number and asserts that \\( e \\) is positive. This corresponds to the condition \\( e > 0 \\) in the informal statement.\n\n   - **Existential Quantifier**:\n     - `∃ N : ℕ` states that there exists a natural number \\( N \\). This matches the requirement to find such an \\( N \\).\n\n   - **Universal Quantifier and Implication**:\n     - `∀ n : ℕ, n > N → ...` states that for all natural numbers \\( n \\) greater than \\( N \\), the following conditions hold. This captures the \"for all \\( n > N \\)\" part of the informal statement.\n\n   - **Inequality Conditions**:\n     - `0 < ((n:ℝ) + 1) ^ (1 / 3) - (n:ℝ) ^ (1 / 3)` ensures the difference between the cube roots is positive. The expression `((n:ℝ) + 1) ^ (1 / 3)` converts \\( n+1 \\) to a real number and takes its cube root, and similarly for"}
{"source_file": "herald_data/sample_500.jsonl", "line": 421, "id": 315572, "informal_statement": "In a commutative ring \\(L\\), for a field \\(K\\), and given \\(L\\) is an algebra over \\(K\\), and assuming \\(\\zeta\\) is a primitive root of order 2 in \\(L\\), and \\(L\\) is an integral domain, show that \\((-1)^{\\text{finrank}_K L} = (-1)^{\\text{finrank}_K L}\\). Here, \\(\\text{finrank}_K L\\) denotes the finite dimensional rank of \\(L\\) as a vector space over \\(K\\).", "formal_statement": "import Mathlib\nopen Polynomial Algebra Finset FiniteDimensional IsCyclotomicExtension Nat PNat Set\nopen scoped IntermediateField\nlemma norm_eq_neg_one_pow_tac_12899 [CommRing L] (ζ : L) [Field K] [Algebra K L] (hζ : IsPrimitiveRoot ζ 2) [IsDomain L] : (-1) ^ FiniteDimensional.finrank K L = (-1) ^ FiniteDimensional.finrank K L := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully consider each component of the statement and how it corresponds to Lean's formal language and libraries. Here's a step-by-step explanation of the translation:\n\n1. **Commutative Ring \\(L\\):** \n   - In Lean, a commutative ring is represented by the type class `CommRing`. The statement `[CommRing L]` in the Lean code indicates that \\(L\\) is assumed to be a commutative ring.\n\n2. **Field \\(K\\):**\n   - A field in Lean is represented by the type class `Field`. The statement `[Field K]` indicates that \\(K\\) is assumed to be a field.\n\n3. **Algebra \\(L\\) over \\(K\\):**\n   - The statement `[Algebra K L]` indicates that \\(L\\) is an algebra over the field \\(K\\). This means that \\(L\\) is a vector space over \\(K\\) with a compatible ring structure.\n\n4. **Primitive Root \\(\\zeta\\) of Order 2:**\n   - The informal statement mentions \\(\\zeta\\) as a primitive root of order 2 in \\(L\\). In Lean, this is expressed using the `IsPrimitiveRoot` predicate. The statement `(hζ : IsPrimitiveRoot ζ 2)` asserts that \\(\\zeta\\) is a primitive root of unity of order 2 in \\(L\\).\n\n5. **Integral Domain \\(L\\):**\n   - An integral domain in Lean is represented by the type class `IsDomain`. The statement `[IsDomain L]` indicates that \\(L\\) is assumed to be an integral domain, which is a commutative ring with no zero divisors and not the zero ring.\n\n6. **Finite Dimensional Rank \\(\\text{finrank}_K L\\):**\n   - The function `FiniteDimensional.finrank K L` in Lean computes the finite dimensional rank of \\(L\\) as a vector space over \\(K\\). This corresponds to the informal \\(\\text{finrank}_K L\\).\n\n7. **Equality of Powers of \\(-1\\):**\n   - The goal is to show that \\((-1)^{\\text{finrank}_K L} = (-1)^{\\text{finrank}_K L}\\). In Lean, this is directly expressed as `"}
{"source_file": "herald_data/sample_500.jsonl", "line": 416, "id": 133474, "informal_statement": "For any element \\( a \\) in a group with zero \\( G_0 \\) such that \\( a \\neq 0 \\), show that \\( a \\cdot a \\cdot a^{-1} = a \\).", "formal_statement": "import Mathlib\nopen Function\nlemma mul_self_mul_inv_tac_10377 [GroupWithZero G₀] (a : G₀) (h : ¬a = 0) : a * a * a⁻¹ = a := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Structure**: The informal statement refers to a \"group with zero,\" which in Lean is represented by the type class `GroupWithZero`. This structure includes a group operation (multiplication), an identity element (1), and an inverse operation, along with a zero element that is distinct from the identity.\n\n2. **Define the Variables**: The element \\( a \\) is an arbitrary element of the group with zero \\( G_0 \\). In Lean, this is represented by declaring a variable `a` of type `G₀`, where `G₀` is a type that has the `GroupWithZero` structure.\n\n3. **State the Condition**: The condition \\( a \\neq 0 \\) is crucial because it ensures that the inverse \\( a^{-1} \\) is well-defined. In Lean, this condition is expressed as `h : ¬a = 0`, where `¬` denotes logical negation.\n\n4. **Express the Conclusion**: The goal is to show that \\( a \\cdot a \\cdot a^{-1} = a \\). In Lean, multiplication is denoted by `*`, and the inverse is denoted by `⁻¹`. Therefore, the expression `a * a * a⁻¹ = a` directly translates the mathematical expression into Lean syntax.\n\n5. **Formulate the Lemma**: The entire statement is encapsulated in a lemma named `mul_self_mul_inv_tac_10377`. The lemma takes as input an element `a` of type `G₀` and a hypothesis `h` that `a` is not zero. The conclusion of the lemma is the equality `a * a * a⁻¹ = a`.\n\n6. **Use of `sorry`**: The keyword `sorry` is a placeholder in Lean, indicating that the proof of the lemma is not yet provided. It allows the lemma to be syntactically correct and type-check without an actual proof.\n\nBy following these steps, the informal statement is accurately translated into a formal Lean4 lemma, capturing the essence of the mathematical assertion within the framework of Lean's type system and logical foundations."}
{"source_file": "herald_data/sample_500.jsonl", "line": 422, "id": 436510, "informal_statement": "For the matrix space $\\text{Matrix } m \\, n \\, 𝕜$, define a norm structure that makes it a normed additive commutative group, arising from the operator norm induced by the identification with continuous linear maps of the Euclidean space.", "formal_statement": "import Mathlib\nopen scoped Matrix\nopen LinearMap\nopen Bornology Filter\nopen scoped Topology Uniformity\nopen scoped Matrix.L2OpNorm\n/-- The norm structure on `Matrix m n 𝕜` arising from the operator norm given by the identification\nwith (continuous) linear maps of `EuclideanSpace`. -/\ndef instL2OpNormedAddCommGroup : NormedAddCommGroup (Matrix m n 𝕜) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Context**: The informal statement is about defining a norm structure on the space of matrices, `Matrix m n 𝕜`, where `m` and `n` are dimensions and `𝕜` is a field (often the real or complex numbers). The norm is derived from the operator norm, which is a concept from functional analysis, typically used for linear maps between normed spaces.\n\n2. **Identifying the Target Structure**: The goal is to define a `NormedAddCommGroup` instance for `Matrix m n 𝕜`. In Lean, a `NormedAddCommGroup` is a type that is both an additive commutative group and a normed space. This means it has operations for addition, negation, and a norm function satisfying certain properties.\n\n3. **Operator Norm and Euclidean Space**: The operator norm is used here, which is a norm on the space of linear maps between normed spaces. The identification with continuous linear maps of `EuclideanSpace` suggests that matrices are being viewed as linear maps from one Euclidean space to another, and the norm is the operator norm of these maps.\n\n4. **Lean Imports and Scopes**: The code begins with several `import` statements and `open` directives:\n   - `import Mathlib`: This imports the Mathlib library, which contains a wide range of mathematical definitions and theorems.\n   - `open scoped Matrix`, `open LinearMap`, etc.: These open specific namespaces or scopes, making definitions and theorems within them available without needing to prefix them with the namespace.\n\n5. **Defining the Instance**: The core of the translation is the definition of the instance:\n   - `def instL2OpNormedAddCommGroup : NormedAddCommGroup (Matrix m n 𝕜) := sorry`: This line defines a new instance named `instL2OpNormedAddCommGroup`. The type of this instance is `NormedAddCommGroup (Matrix m n 𝕜)`, indicating that it provides a normed additive commutative group structure for matrices of size `m` by `n` over the field `𝕜`.\n   - The `:= sorry` part is a placeholder indicating that the actual implementation is not provided here. In a complete"}
{"source_file": "herald_data/sample_500.jsonl", "line": 423, "id": 425, "informal_statement": "For any group \\( G \\), show that the cardinality of the set of pairs \\((g_1, g_2) \\in G \\times G\\) such that \\(g_1\\) and \\(g_2\\) commute is equal to the cardinality of the set of conjugacy classes of \\( G \\) multiplied by the cardinality of \\( G \\), i.e., \\(\\left| \\{ (g_1, g_2) \\in G \\times G \\mid g_1 g_2 = g_2 g_1 \\} \\right| = | \\text{ConjClasses}(G) | \\cdot |G|\\).", "formal_statement": "import Mathlib\nopen Fintype\ntheorem card_comm_eq_card_conjClasses_mul_card_extracted (G : Type u_1) [Group G] : Nat.card { p // Commute p.1 p.2 } = Nat.card (ConjClasses G) * Nat.card G := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to break down the components of the statement and map them to their corresponding formal representations in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Context**: \n   - We are dealing with a group \\( G \\). In Lean, a group is typically represented by a type with a `Group` instance. This is captured by `(G : Type u_1) [Group G]`.\n\n2. **Set of Commuting Pairs**:\n   - The informal statement refers to the set of pairs \\((g_1, g_2) \\in G \\times G\\) such that \\(g_1 g_2 = g_2 g_1\\). In Lean, this is represented using a subtype `{ p // Commute p.1 p.2 }`, where `p` is a pair `(g_1, g_2)` and `Commute p.1 p.2` is a predicate that asserts \\(g_1\\) and \\(g_2\\) commute.\n\n3. **Cardinality of the Set**:\n   - The cardinality of the set of commuting pairs is expressed using `Nat.card { p // Commute p.1 p.2 }`. `Nat.card` is a function that computes the cardinality of a finite type.\n\n4. **Conjugacy Classes**:\n   - The informal statement involves the set of conjugacy classes of \\( G \\). In Lean, this is represented by `ConjClasses G`, which is a type representing the set of conjugacy classes.\n\n5. **Cardinality of Conjugacy Classes and Group**:\n   - The cardinality of the set of conjugacy classes is `Nat.card (ConjClasses G)`, and the cardinality of the group \\( G \\) itself is `Nat.card G`.\n\n6. **Equality of Cardinalities**:\n   - The statement asserts an equality between the cardinality of the set of commuting pairs and the product of the cardinalities of the conjugacy classes and the group. This is expressed as `Nat.card { p // Commute p.1 p.2 } = Nat.card (ConjClasses G) * Nat.card G`.\n\n7. **Theorem Declaration**:\n   - The entire statement is wrapped in a theorem declaration `theorem card_comm_eq_card_conjClasses_mul_card_extracted`, which names the theorem and states"}
{"source_file": "herald_data/sample_500.jsonl", "line": 427, "id": 461800, "informal_statement": " $\\left( {x + y + z} \\right)^4 + \\left( {y + z - x} \\right)^4 + \\left( {z + x - y} \\right)^4 + \\left( {x + y - z} \\right)^4 = 4\\left( {x^4 + y^4 + z^4 } \\right) + 24\\left( {x^2 y^2 + z^2 y^2 + x^2 z^2 } \\right)$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_461800 ∀ x y z : ℝ, (x + y + z) ^ 4 + (y + z - x) ^ 4 + (z + x - y) ^ 4 + (x + y - z) ^ 4 = 4 * (x ^ 4 + y ^ 4 + z ^ 4) + 24 * (x ^ 2 * y ^ 2 + z ^ 2 * y ^ 2 + x ^ 2 * z ^ 2)  :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Understand the Mathematical Expression**: The informal statement is an equation involving powers and sums of real numbers \\(x\\), \\(y\\), and \\(z\\). The left-hand side consists of four terms, each raised to the fourth power, and the right-hand side is a combination of fourth powers and products of squares.\n\n2. **Identify the Variables and Their Types**: The variables \\(x\\), \\(y\\), and \\(z\\) are real numbers. In Lean, real numbers are represented by the type `ℝ`.\n\n3. **Structure the Lean Theorem**: In Lean, a theorem is stated using the `theorem` keyword, followed by a name for the theorem, a list of quantified variables, and the statement of the theorem.\n\n4. **Quantify the Variables**: Use `∀` (forall) to quantify the variables \\(x\\), \\(y\\), and \\(z\\) over the real numbers. This is done by writing `∀ x y z : ℝ`.\n\n5. **Translate the Expression**: \n   - The expression \\((x + y + z)^4\\) is translated to `(x + y + z) ^ 4`.\n   - Similarly, \\((y + z - x)^4\\), \\((z + x - y)^4\\), and \\((x + y - z)^4\\) are translated to `(y + z - x) ^ 4`, `(z + x - y) ^ 4`, and `(x + y - z) ^ 4`, respectively.\n   - The right-hand side involves terms like \\(4(x^4 + y^4 + z^4)\\), which is translated to `4 * (x ^ 4 + y ^ 4 + z ^ 4)`.\n   - The term \\(24(x^2 y^2 + z^2 y^2 + x^2 z^2)\\) is translated to `24 * (x ^ 2 * y ^ 2 + z ^ 2 * y ^ 2 + x ^ 2 * z ^ 2)`.\n\n6. **Combine the Translated Parts**: The entire equation is then written in Lean as:\n   ```lean\n   (x + y + z) ^ 4 + (y + z - x) ^"}
{"source_file": "herald_data/sample_500.jsonl", "line": 424, "id": 318640, "informal_statement": "For any cardinal number $c$, show that $\\aleph_0 \\leq c$ if and only if $\\aleph_0 \\leq c$.", "formal_statement": "import Mathlib\nopen Mathlib (Vector)\nopen Function Set Order\nopen Sum\nlemma aleph0_le_lift_tac_43493 (c : Cardinal.{u}) : ℵ₀ ≤ c ↔ ℵ₀ ≤ c := sorry", "explanation": "To translate the informal statement \"For any cardinal number $c$, show that $\\aleph_0 \\leq c$ if and only if $\\aleph_0 \\leq c$\" into Lean, we follow these steps:\n\n1. **Identify the Mathematical Objects**: The statement involves cardinal numbers, specifically the cardinal number $\\aleph_0$, which represents the smallest infinite cardinal, and a generic cardinal number $c$.\n\n2. **Understand the Logical Structure**: The statement is a tautology, asserting that $\\aleph_0 \\leq c$ is equivalent to itself. This is a basic logical identity, often used to test the setup of a formal system or to ensure that the definitions and imports are correct.\n\n3. **Lean Syntax for Cardinal Numbers**: In Lean, cardinal numbers are represented by the type `Cardinal`. The specific cardinal $\\aleph_0$ is denoted by `ℵ₀` in Lean.\n\n4. **Formalizing the Statement in Lean**:\n   - We start by declaring a lemma, which is a way to state a proposition that we intend to prove.\n   - The lemma is named `aleph0_le_lift_tac_43493`, which is a unique identifier for this specific statement.\n   - We introduce a variable `c` of type `Cardinal.{u}`. The `{u}` indicates that `c` is a cardinal number in some universe `u`, which is a technical detail in Lean to handle different sizes of types.\n   - The statement of the lemma is `ℵ₀ ≤ c ↔ ℵ₀ ≤ c`. This uses the logical equivalence operator `↔` to express that the two sides are equivalent.\n\n5. **Imports and Namespace Management**:\n   - The line `import Mathlib` brings in the necessary mathematical libraries that include definitions and theorems about cardinals.\n   - The `open` statements are used to bring certain namespaces into the current context, making it easier to refer to functions and types without needing to prefix them with their module names.\n\n6. **Proof Placeholder**: The `sorry` keyword is used as a placeholder for the proof. In Lean, `sorry` allows the statement to be accepted without providing a proof, which is useful for incomplete developments or trivial tautologies like this one.\n\nIn summary, the Lean code formalizes the tautological statement by declaring a lemma with a cardinal `c`,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 429, "id": 498650, "informal_statement": "Let $x, y, z>0$ and $x+y+z=1$ . Prove that $\\frac{1}{x^2+y^2+z^2}+\\frac{1}{xyz} \\geq 30$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_498650 (x y z : ℝ) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z) (hx1 : x + y + z = 1) : 1 / (x ^ 2 + y ^ 2 + z ^ 2) + 1 / (x * y * z) ≥ 30   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The variables \\( x, y, z \\) are real numbers, as indicated by the condition \\( x, y, z > 0 \\). In Lean, real numbers are represented by `ℝ`.\n\n2. **Express the Conditions**:\n   - The conditions \\( x, y, z > 0 \\) are expressed using inequalities in Lean: `0 < x`, `0 < y`, and `0 < z`.\n   - The condition \\( x + y + z = 1 \\) is directly translated to `x + y + z = 1`.\n\n3. **State the Inequality to Prove**:\n   - The goal is to prove the inequality \\(\\frac{1}{x^2 + y^2 + z^2} + \\frac{1}{xyz} \\geq 30\\).\n   - In Lean, division is represented by `/`, and powers are represented by `^`. Thus, \\(\\frac{1}{x^2 + y^2 + z^2}\\) is written as `1 / (x ^ 2 + y ^ 2 + z ^ 2)`, and \\(\\frac{1}{xyz}\\) is written as `1 / (x * y * z)`.\n   - The inequality \\(\\geq 30\\) is expressed as `≥ 30`.\n\n4. **Structure the Theorem**:\n   - The theorem is named `extract_aug_498650`, which is a placeholder name and can be replaced with a more descriptive one.\n   - The theorem takes the variables \\( x, y, z \\) as arguments, along with the conditions as hypotheses: `hx : 0 < x`, `hy : 0 < y`, `hz : 0 < z`, and `hx1 : x + y + z = 1`.\n   - The conclusion of the theorem is the inequality to be proved.\n\n5. **Use Lean Syntax**:\n   - The theorem is introduced with the keyword `theorem`.\n   - The `:= by sorry` at the end indicates that the proof is not provided and is left as a placeholder (`sorry` is used in Lean to indicate incomplete proofs).\n\nBy following these steps, the informal statement is accurately translated into the formal Lean4 code."}
{"source_file": "herald_data/sample_500.jsonl", "line": 425, "id": 300854, "informal_statement": "For a commutative ring \\(R\\) with characteristic \\(n \\in \\mathbb{N}\\), and an ideal \\(I\\) of \\(R\\), the statement that for all natural numbers \\(x\\), if \\(x\\) cast into \\(R\\) lies in \\(I\\), then \\(x\\) cast into \\(R\\) equals \\(0\\), is equivalent to the comapped ideal of \\(I\\) under the natural number ring homomorphism being contained in the comapped zero ideal under the same homomorphism.", "formal_statement": "import Mathlib\n\nlemma quotient_iff_le_ker_natCast_tac_2249 [CommRing R] (n : ℕ) [CharP R n] (I : Ideal R) : (∀ (x : ℕ), ↑x ∈ I → ↑x = 0) ↔ Ideal.comap (Nat.castRingHom R) I ≤ Ideal.comap (Nat.castRingHom R) ⊥ := sorry", "explanation": "To translate the given informal mathematical statement into the provided Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Commutative Ring \\(R\\) with Characteristic \\(n\\):**\n   - In Lean, a commutative ring is represented by the type class `CommRing R`. The characteristic of a ring \\(R\\) is specified by `[CharP R n]`, which indicates that \\(R\\) has characteristic \\(n\\). This is captured in the lemma's context with `[CommRing R]` and `[CharP R n]`.\n\n2. **Ideal \\(I\\) of \\(R\\):**\n   - An ideal in Lean is represented by the type `Ideal R`. The ideal \\(I\\) is introduced as a parameter in the lemma: `(I : Ideal R)`.\n\n3. **Statement for all natural numbers \\(x\\):**\n   - The universal quantification over natural numbers is expressed in Lean using `∀ (x : ℕ)`. This indicates that the statement applies to all natural numbers \\(x\\).\n\n4. **Casting \\(x\\) into \\(R\\) and checking membership in \\(I\\):**\n   - The casting of a natural number \\(x\\) into the ring \\(R\\) is done using `↑x`, which is Lean's notation for coercion. The condition that this cast element is in the ideal \\(I\\) is expressed as `↑x ∈ I`.\n\n5. **Condition that \\(x\\) cast into \\(R\\) equals \\(0\\):**\n   - The condition that the cast of \\(x\\) equals zero in \\(R\\) is written as `↑x = 0`.\n\n6. **Equivalence to comapped ideal containment:**\n   - The equivalence is expressed using `↔`, which denotes logical equivalence in Lean.\n   - The comapped ideal of \\(I\\) under the natural number ring homomorphism is represented by `Ideal.comap (Nat.castRingHom R) I`. This uses the `comap` function to pull back the ideal \\(I\\) along the ring homomorphism `Nat.castRingHom R`.\n   - The comapped zero ideal is represented by `Ideal.comap (Nat.castRingHom R) ⊥`, where `⊥` denotes the zero"}
{"source_file": "herald_data/sample_500.jsonl", "line": 431, "id": 474680, "informal_statement": "Show that $\\frac{1}{n+1}\\left(1+\\frac{1}{3}+\\cdots+\\frac{1}{2n-1}\\right)>\\frac{1}{n}\\left(\\frac{1}{2}+\\frac{1}{4}+\\cdots+\\frac{1}{2n}\\right)$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_474680 : ∀ n : ℕ, (1 / (n + 1)) * ∑ i in Finset.range n, (1 / (2 * i + 2)) < (1 / n) * ∑ i in Finset.range n, (1 / (2 * i + 1))  :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down the components of the statement and understand how they map to Lean's syntax and libraries.\n\n1. **Understanding the Informal Statement**:\n   - We are given two sums: \n     - The first sum is \\(\\frac{1}{n+1}\\left(1+\\frac{1}{3}+\\cdots+\\frac{1}{2n-1}\\right)\\).\n     - The second sum is \\(\\frac{1}{n}\\left(\\frac{1}{2}+\\frac{1}{4}+\\cdots+\\frac{1}{2n}\\right)\\).\n   - We need to show that the first sum is greater than the second sum for all natural numbers \\(n\\).\n\n2. **Translating the Sums**:\n   - The first sum involves terms of the form \\(\\frac{1}{2i+1}\\) for \\(i\\) ranging from 0 to \\(n-1\\). This is captured in Lean using `∑ i in Finset.range n, (1 / (2 * i + 1))`.\n   - The second sum involves terms of the form \\(\\frac{1}{2i+2}\\) for \\(i\\) ranging from 0 to \\(n-1\\). This is captured in Lean using `∑ i in Finset.range n, (1 / (2 * i + 2))`.\n\n3. **Scaling Factors**:\n   - The first sum is scaled by \\(\\frac{1}{n+1}\\), which is represented in Lean as `(1 / (n + 1))`.\n   - The second sum is scaled by \\(\\frac{1}{n}\\), which is represented in Lean as `(1 / n)`.\n\n4. **Inequality**:\n   - The informal statement requires showing that the first sum is greater than the second sum. In Lean, this is expressed using the `<` operator.\n\n5. **Quantification**:\n   - The statement needs to hold for all natural numbers \\(n\\). In Lean, this is expressed using `∀ n : ℕ`.\n\n6. **Putting It All Together**:\n   - The theorem is named `extract_aug_474680`, which is a placeholder name and can be replaced with a more descriptive name.\n   - The theorem statement in Lean is: \n     ```"}
{"source_file": "herald_data/sample_500.jsonl", "line": 430, "id": 474288, "informal_statement": "Let $a,b,c$ be nonnegative real numbers, no two of which are zero. Prove that $\\left(\\frac{a}{b+c}\\right)^{2}+\\left(\\frac{b}{c+a}\\right)^{2}+\\left(\\frac{c}{a+b}\\right)^{2}+\\frac{2abc}{(a+b)(b+c)(c+a)}\\ge 1$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_474288 (a b c : ℝ) (ha : a ≥ 0) (hb : b ≥ 0) (hc : c ≥ 0) (hab : a + b ≠ 0) (hbc : b + c ≠ 0) (hca : a + c ≠ 0) : (a / (b + c))^2 + (b / (c + a))^2 + (c / (a + b))^2 + (2 * a * b * c) / (a + b) / (b + c) / (c + a) ≥ 1  :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach to formalize each component of the statement. Here's a step-by-step explanation of the translation:\n\n1. **Importing Necessary Libraries**:\n   - The statement begins with `import Mathlib`, which is a common practice to include the necessary mathematical libraries in Lean. This provides access to various mathematical functions and theorems.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to bring specific namespaces into the current context, allowing us to use their definitions and theorems without prefixing them with the namespace.\n\n2. **Defining the Theorem**:\n   - The theorem is named `extract_aug_474288`, which is a unique identifier for this particular theorem. Naming conventions in Lean often use descriptive names, but here it seems to be an autogenerated or placeholder name.\n\n3. **Specifying Variables and Assumptions**:\n   - `(a b c : ℝ)` declares that `a`, `b`, and `c` are real numbers. In Lean, `ℝ` denotes the type of real numbers.\n   - `(ha : a ≥ 0)`, `(hb : b ≥ 0)`, and `(hc : c ≥ 0)` are assumptions that `a`, `b`, and `c` are nonnegative. These are directly derived from the informal statement that specifies `a, b, c` are nonnegative real numbers.\n   - `(hab : a + b ≠ 0)`, `(hbc : b + c ≠ 0)`, and `(hca : a + c ≠ 0)` are conditions ensuring that no two of the numbers are zero. This is a formal way to express that the sum of any two of these numbers is non-zero, which aligns with the informal condition \"no two of which are zero.\"\n\n4. **Formalizing the Inequality**:\n   - The expression `(a / (b + c))^2 + (b / (c + a))^2 + (c / (a + b))^2` represents the sum of the squares of the fractions, as given in the informal statement.\n   - The term `(2 * a * b * c) / (a + b) / (b + c) / (c + a)` corresponds to the fraction involving the product of `a`,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 428, "id": 338790, "informal_statement": "For a language $l$ over an alphabet $\\alpha$, prove that the Kleene star $l^*$ is the set of all strings $x$ for which there exists a list $S$ of non-empty strings from $l$ such that $x$ is the concatenation of the strings in $S$. That is, show that $l^* = \\{ x \\mid \\exists S \\text{ (list of non-empty strings from } l) : x = S.\\text{join} \\}$.", "formal_statement": "import Mathlib\nopen List Set Computability\ntheorem kstar_def_nonempty (l : Language α) :\n    l∗ = { x | ∃ S : List (List α), x = S.join ∧ ∀ y ∈ S, y ∈ l ∧ y ≠ [] } := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down the components of the statement and map them to their corresponding Lean constructs. Here's a step-by-step explanation:\n\n1. **Understanding the Informal Statement**:\n   - We are given a language \\( l \\) over an alphabet \\( \\alpha \\).\n   - We need to prove a property about the Kleene star \\( l^* \\).\n   - The Kleene star \\( l^* \\) is defined as the set of all strings \\( x \\) such that there exists a list \\( S \\) of non-empty strings from \\( l \\) and \\( x \\) is the concatenation of the strings in \\( S \\).\n\n2. **Identifying Key Components**:\n   - **Language \\( l \\)**: In Lean, a language over an alphabet \\( \\alpha \\) is represented as a set of lists of elements of type \\( \\alpha \\), i.e., `Language α`.\n   - **Kleene Star \\( l^* \\)**: In Lean, the Kleene star of a language is denoted by `l∗`.\n   - **Set of Strings**: The set of all strings \\( x \\) satisfying a certain property is represented using set comprehension in Lean.\n   - **Existential Quantifier**: The existence of a list \\( S \\) is expressed using `∃` in Lean.\n   - **List of Non-Empty Strings**: A list of lists where each list is non-empty and belongs to the language \\( l \\).\n\n3. **Formalizing the Statement**:\n   - **Set Comprehension**: The set of strings \\( x \\) is represented as `{ x | ... }` in Lean, where `x` is a list of elements of type \\( \\alpha \\).\n   - **Existential Quantifier**: The existence of a list \\( S \\) is expressed as `∃ S : List (List α), ...`.\n   - **Concatenation**: The concatenation of the strings in \\( S \\) is represented by `S.join` in Lean.\n   - **Non-Empty Strings from \\( l \\)**: For each string \\( y \\) in \\( S \\), it must satisfy `y ∈ l` and `y ≠ []`. This is expressed as `∀ y ∈ S, y ∈ l ∧ y ≠ []`.\n\n4"}
{"source_file": "herald_data/sample_500.jsonl", "line": 432, "id": 224086, "informal_statement": "For any metric space $\\alpha$, measurable space structure $m0$ on $\\alpha$, measures $\\mu$ and $\\rho$ on $\\alpha$ with $\\rho$ and $\\mu$ being locally finite, and a Vitali family $v$ with respect to $\\mu$, if $\\alpha$ is second countable and a Borel space, then for $\\mu$-almost every $x$ in $\\alpha$, the function $a \\mapsto \\frac{\\rho(a)}{\\mu(a)}$ converges in the filter $v$.filterAt $x$ to the Radon-Nikodym derivative of $\\rho$ with respect to $\\mu$ at $x$, denoted as $\\rho.rnDeriv \\mu x$.", "formal_statement": "import Mathlib\nopen MeasureTheory Metric Set Filter TopologicalSpace MeasureTheory.Measure\nopen scoped Filter ENNReal MeasureTheory NNReal Topology\nlemma ae_tendsto_rnDeriv_tac_40603 [MetricSpace α] (m0 : MeasurableSpace α) (μ : Measure α) (v : VitaliFamily μ) [SecondCountableTopology α] [BorelSpace α] [IsLocallyFiniteMeasure μ] (ρ : Measure α) [IsLocallyFiniteMeasure ρ] (t : Measure α) : ∀ᵐ (x : α) ∂μ, Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 (ρ.rnDeriv μ x)) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it corresponds to the Lean4 constructs:\n\n1. **Metric Space and Measurable Space Structure**:\n   - The informal statement begins with \"For any metric space $\\alpha$,\" which is represented in Lean4 by `[MetricSpace α]`. This indicates that `α` is a type equipped with a metric space structure.\n   - The measurable space structure on `α` is denoted by `(m0 : MeasurableSpace α)`, which specifies that `m0` is a measurable space structure on `α`.\n\n2. **Measures and Local Finiteness**:\n   - The measures `μ` and `ρ` on `α` are represented as `(μ : Measure α)` and `(ρ : Measure α)`, indicating that both `μ` and `ρ` are measures on the space `α`.\n   - The condition that `ρ` and `μ` are locally finite is expressed using `[IsLocallyFiniteMeasure μ]` and `[IsLocallyFiniteMeasure ρ]`. These are typeclass instances that assert the local finiteness of the measures.\n\n3. **Vitali Family**:\n   - The Vitali family `v` with respect to `μ` is represented as `(v : VitaliFamily μ)`. This indicates that `v` is a Vitali family associated with the measure `μ`.\n\n4. **Second Countable and Borel Space**:\n   - The condition that `α` is second countable is expressed with `[SecondCountableTopology α]`, which is a typeclass indicating that the topology on `α` is second countable.\n   - The condition that `α` is a Borel space is represented by `[BorelSpace α]`, indicating that the Borel σ-algebra on `α` is compatible with its topology.\n\n5. **Almost Everywhere Convergence**:\n   - The statement \"for $\\mu$-almost every $x$ in $\\alpha$\" is formalized as `∀ᵐ (x : α) ∂μ`, which uses the `∀ᵐ` notation to express \"for almost every\" with respect to the measure `μ`.\n   - The convergence of the function $a \\mapsto \\frac{\\rho(a)}{\\mu(a)}$ in the filter `v.filterAt x`"}
{"source_file": "herald_data/sample_500.jsonl", "line": 426, "id": 220396, "informal_statement": "For any measurable space $(\\alpha, m)$, measure $\\mu$ on $\\alpha$, functions $f, g: \\alpha \\to \\mathbb{R}$, assuming $f$ is almost everywhere strongly measurable with respect to $\\mu$, and $f$ and $g$ are almost everywhere non-positive with respect to $\\mu$, show that the integrability of $-f + (-g)$ with respect to $\\mu$ is equivalent to the conjunction of the integrability of $-f$ and $-g$ with respect to $\\mu$.", "formal_statement": "import Mathlib\nopen scoped Classical\nopen Topology ENNReal MeasureTheory NNReal\nopen Set Filter TopologicalSpace ENNReal EMetric MeasureTheory\nlemma integrable_add_iff_of_nonpos_tac_30374 (m : MeasurableSpace α) (μ : Measure α) (f : α → ℝ) (g : α → ℝ) (h_meas : AEStronglyMeasurable f μ) (hf : f ≤ᶠ[ae μ] 0) (hg : g ≤ᶠ[ae μ] 0) : Integrable (-f + -g) μ ↔ Integrable (-f) μ ∧ Integrable (-g) μ := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures all the components of the statement accurately. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Context and Imports**:\n   - The problem involves measurable spaces, measures, and integrability, which are part of measure theory. Therefore, we import relevant modules from Lean's math library, such as `Mathlib`, and open necessary namespaces like `MeasureTheory`.\n\n2. **Define the Measurable Space and Measure**:\n   - The informal statement starts with \"For any measurable space $(\\alpha, m)$, measure $\\mu$ on $\\alpha$\". In Lean, we represent this by declaring `m : MeasurableSpace α` and `μ : Measure α`. Here, `α` is a type representing the underlying set, `m` is the measurable space structure on `α`, and `μ` is a measure on this space.\n\n3. **Declare the Functions**:\n   - The functions $f$ and $g$ are mappings from $\\alpha$ to $\\mathbb{R}$. In Lean, this is expressed as `f : α → ℝ` and `g : α → ℝ`.\n\n4. **State the Measurability Condition**:\n   - The condition \"assuming $f$ is almost everywhere strongly measurable with respect to $\\mu$\" is formalized using `AEStronglyMeasurable f μ`. This indicates that $f$ is almost everywhere strongly measurable with respect to the measure $\\mu$.\n\n5. **Express the Non-positivity Conditions**:\n   - The conditions \"$f$ and $g$ are almost everywhere non-positive with respect to $\\mu$\" are captured using `f ≤ᶠ[ae μ] 0` and `g ≤ᶠ[ae μ] 0`. The notation `≤ᶠ[ae μ]` denotes \"almost everywhere less than or equal to\" with respect to the measure $\\mu`.\n\n6. **Formulate the Integrability Equivalence**:\n   - The core of the statement is to show the equivalence of integrability conditions. The expression \"the integrability of $-f + (-g)$ with respect to $\\mu$ is equivalent to the conjunction of the integrability of $-f$ and $-g$ with respect to $\\mu$\" is formalized"}
{"source_file": "herald_data/sample_500.jsonl", "line": 434, "id": 507256, "informal_statement": "Let $a,b,c\\in (0,1) $ .prove that \\n $(1-a^{2}b)(1-b^{2}c)(1-c^{2}a)\\geq (1-a^{3})(1-b^{3})(1-c^{3}) $", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_507256 (a b c : ℝ) (ha : 0 < a ∧ a < 1) (hb : 0 < b ∧ b < 1) (hc : 0 < c ∧ c < 1) : (1 - a^2 * b) * (1 - b^2 * c) * (1 - c^2 * a) ≥ (1 - a^3) * (1 - b^3) * (1 - c^3)   :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves three variables \\(a\\), \\(b\\), and \\(c\\) which are elements of the interval \\((0,1)\\). In Lean, these are represented as real numbers (\\(\\mathbb{R}\\)) with additional constraints to specify their range.\n\n2. **Define the Variables in Lean**:\n   - In the formal statement, the variables \\(a\\), \\(b\\), and \\(c\\) are declared as real numbers using `(a b c : ℝ)`. This indicates that \\(a\\), \\(b\\), and \\(c\\) are of type `ℝ`, which is the Lean representation for real numbers.\n\n3. **Express the Constraints**:\n   - The constraints \\(a, b, c \\in (0,1)\\) are expressed using conjunctions of inequalities. In Lean, this is done using the logical conjunction `∧` to combine the inequalities for each variable:\n     - `ha : 0 < a ∧ a < 1` for \\(a\\),\n     - `hb : 0 < b ∧ b < 1` for \\(b\\),\n     - `hc : 0 < c ∧ c < 1` for \\(c\\).\n   - These constraints are passed as hypotheses to the theorem.\n\n4. **State the Inequality to Prove**:\n   - The goal is to prove the inequality \\((1-a^{2}b)(1-b^{2}c)(1-c^{2}a)\\geq (1-a^{3})(1-b^{3})(1-c^{3})\\).\n   - In Lean, this is directly translated into the expression:\n     - `(1 - a^2 * b) * (1 - b^2 * c) * (1 - c^2 * a) ≥ (1 - a^3) * (1 - b^3) * (1 - c^3)`.\n   - The `≥` symbol is used to denote the \"greater than or equal to\" relation.\n\n5. **Structure the Theorem**:\n   - The theorem is named `extract_aug_507256`, which is a placeholder name and can be replaced with a more descriptive one.\n   - The theorem statement includes the variables and"}
{"source_file": "herald_data/sample_500.jsonl", "line": 433, "id": 547139, "informal_statement": "$16a^2+ 16b^2+16c^2 \\geq 9ab + 9 ac + 9bc + \\frac{7}{3}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_547139 (a b c: ℝ) : 16 * a ^ 2 + 16 * b ^ 2 + 16 * c ^ 2 ≥ 9 * a * b + 9 * a * c + 9 * b * c + 7 / 3   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Mathematical Components**: \n   - The informal statement is an inequality involving real numbers \\(a\\), \\(b\\), and \\(c\\).\n   - The left-hand side of the inequality is \\(16a^2 + 16b^2 + 16c^2\\).\n   - The right-hand side is \\(9ab + 9ac + 9bc + \\frac{7}{3}\\).\n\n2. **Choose the Appropriate Lean4 Libraries**:\n   - We need to work with real numbers and inequalities, so we import `Mathlib` which provides a comprehensive set of mathematical tools.\n   - We open `Real` to work with real numbers and their operations.\n   - We open `Nat` and `Topology` as they are commonly used in mathematical proofs, although they might not be directly necessary for this specific theorem.\n\n3. **Define the Variables**:\n   - In Lean, we declare the variables \\(a\\), \\(b\\), and \\(c\\) as real numbers using `(a b c: ℝ)`.\n\n4. **Translate the Inequality**:\n   - The left-hand side \\(16a^2 + 16b^2 + 16c^2\\) is translated to `16 * a ^ 2 + 16 * b ^ 2 + 16 * c ^ 2`.\n   - The right-hand side \\(9ab + 9ac + 9bc + \\frac{7}{3}\\) is translated to `9 * a * b + 9 * a * c + 9 * b * c + 7 / 3`.\n\n5. **Formulate the Theorem**:\n   - We use the `theorem` keyword to define a new theorem named `extract_aug_547139`.\n   - The statement of the theorem is the inequality: `16 * a ^ 2 + 16 * b ^ 2 + 16 * c ^ 2 ≥ 9 * a * b + 9 * a * c + 9 * b * c + 7 / 3`.\n\n6. **Proof Placeholder**:\n   - The `:= by sorry` part indicates that the proof is not yet provided. In Lean, `sorry` is a placeholder that allows the theorem to be accepted syntactically without a proof.\n\nBy following these"}
{"source_file": "herald_data/sample_500.jsonl", "line": 437, "id": 297575, "informal_statement": "For any $x$ in a linearly ordered field $\\alpha$ such that $0 \\leq x < 1$, and for any natural numbers $m$ and $n$ with $m \\leq n$, show that the sum $\\sum_{i=m}^{n-1} x^i$ is less than or equal to $\\frac{x^m}{1-x}$.", "formal_statement": "import Mathlib\nopen Finset MulOpposite\nlemma geom_sum_Ico_le_of_lt_one_tac_15647 [LinearOrderedField α] (x : α) (hx : 0 ≤ x) (h'x : x < 1) (m : ℕ) (n : ℕ) (hmn : m ≤ n) : ∑ i ∈ Ico m n, x ^ i ≤ x ^ m / (1 - x) := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Context**:\n   - The informal statement involves a linearly ordered field $\\alpha$. In Lean, this is represented by `[LinearOrderedField α]`, which is a type class constraint indicating that `α` is a linearly ordered field.\n\n2. **Variables and Assumptions**:\n   - The variable $x$ is an element of the field $\\alpha$ with constraints $0 \\leq x < 1$. In Lean, this is expressed by `(x : α) (hx : 0 ≤ x) (h'x : x < 1)`. Here, `x : α` declares `x` as an element of the field, `hx : 0 ≤ x` asserts that $x$ is non-negative, and `h'x : x < 1` asserts that $x$ is less than 1.\n   - The natural numbers $m$ and $n$ with $m \\leq n$ are represented by `(m : ℕ) (n : ℕ) (hmn : m ≤ n)`. Here, `m : ℕ` and `n : ℕ` declare `m` and `n` as natural numbers, and `hmn : m ≤ n` asserts the condition $m \\leq n$.\n\n3. **The Sum Expression**:\n   - The sum $\\sum_{i=m}^{n-1} x^i$ is expressed in Lean using the `Finset` and `Ico` (interval, closed-open) notation: `∑ i ∈ Ico m n, x ^ i`. The `Ico m n` represents the set of integers from $m$ to $n-1$, and `∑ i ∈ Ico m n, x ^ i` computes the sum of $x^i$ over this set.\n\n4. **The Inequality**:\n   - The goal is to show that this sum is less than or equal to $\\frac{x^m}{1-x}$. In Lean, this is expressed as `∑ i ∈ Ico m n, x ^ i ≤ x ^ m / (1 - x)`. The division is represented by `/`, and"}
{"source_file": "herald_data/sample_500.jsonl", "line": 441, "id": 246281, "informal_statement": "For any natural numbers \\(m\\) and \\(n\\) such that \\(m \\leq n\\), show that the greatest common divisor of \\(n - m\\) and \\(m\\) is equal to the greatest common divisor of \\(n\\) and \\(m\\), i.e., \\((n - m) \\gcd m = n \\gcd m\\).", "formal_statement": "import Mathlib\n\nlemma gcd_sub_self_left_tac_2858 (m : ℕ) (n : ℕ) (h : m ≤ n) : (n - m).gcd m = n.gcd m := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves two natural numbers \\(m\\) and \\(n\\). In Lean, natural numbers are represented by the type `ℕ`.\n\n2. **Express the Condition**:\n   - The condition \\(m \\leq n\\) is a prerequisite for the statement. In Lean, this is expressed using the `≤` operator, which is available for natural numbers.\n\n3. **State the Goal**:\n   - The goal is to show that the greatest common divisor (gcd) of \\(n - m\\) and \\(m\\) is equal to the gcd of \\(n\\) and \\(m\\). In Lean, the gcd of two numbers `a` and `b` is expressed as `a.gcd b`.\n\n4. **Formalize the Statement in Lean**:\n   - We start by defining a lemma, which is a statement that we intend to prove. The lemma is named `gcd_sub_self_left_tac_2858`, which is a unique identifier for this particular statement.\n   - The lemma takes three arguments: `m` and `n`, both of type `ℕ`, and a hypothesis `h` of type `m ≤ n`.\n   - The conclusion of the lemma is the equality `(n - m).gcd m = n.gcd m`.\n\n5. **Use of `sorry`**:\n   - The keyword `sorry` is used as a placeholder for the proof. It indicates that the proof is not yet provided, but the statement is correctly formalized.\n\n6. **Importing Necessary Libraries**:\n   - The statement begins with `import Mathlib`, which is necessary to access mathematical functions and properties, such as the gcd function, that are not part of the core Lean library.\n\nBy following these steps, the informal statement is accurately translated into the Lean4 formal statement. The lemma captures the essence of the problem, and the use of `sorry` indicates that the proof is to be completed."}
{"source_file": "herald_data/sample_500.jsonl", "line": 435, "id": 177938, "informal_statement": "For a simple graph $G$ with vertex set $V$, if $G$'s chromatic number is $0$ and the vertex set $V$ is finite, then show that $V$ is empty.", "formal_statement": "import Mathlib\nopen Fintype Function\nlemma isEmpty_of_chromaticNumber_eq_zero_tac_11656 (G : SimpleGraph V) [Finite V] (h : G.chromaticNumber = 0) : IsEmpty V := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to break down the components of the statement and understand how they map to Lean constructs:\n\n1. **Simple Graph $G$ with Vertex Set $V$**:\n   - In Lean, a simple graph is represented by `SimpleGraph V`, where `V` is the type of vertices. This is captured in the code by `(G : SimpleGraph V)`, indicating that `G` is a simple graph with vertex set `V`.\n\n2. **Chromatic Number of $G$ is $0$**:\n   - The chromatic number of a graph is the minimum number of colors needed to color the vertices such that no two adjacent vertices share the same color. If the chromatic number is $0$, it implies there are no vertices to color. In Lean, this is expressed as `(h : G.chromaticNumber = 0)`, where `h` is a hypothesis stating that the chromatic number of `G` is `0`.\n\n3. **Vertex Set $V$ is Finite**:\n   - The statement specifies that the vertex set $V$ is finite. In Lean, this is indicated by `[Finite V]`, which is a typeclass constraint ensuring that `V` is a finite type.\n\n4. **Show that $V$ is Empty**:\n   - The conclusion we need to prove is that the vertex set `V` is empty. In Lean, this is expressed as `IsEmpty V`, which is a predicate indicating that there are no elements in the type `V`.\n\n5. **Combining the Components**:\n   - The lemma is named `isEmpty_of_chromaticNumber_eq_zero_tac_11656`, which is a descriptive name indicating the purpose of the lemma: to show that `V` is empty when the chromatic number is `0`.\n   - The lemma takes three arguments: the graph `G`, the finiteness of `V`, and the hypothesis `h` that the chromatic number is `0`.\n   - The goal is to prove `IsEmpty V`, which is left as `sorry` in the code, indicating that the proof is not yet provided.\n\nOverall, the Lean code formalizes the informal statement by defining a lemma that takes a simple graph with a finite vertex set and a chromatic number of `0`, and concludes that the vertex set must be empty."}
{"source_file": "herald_data/sample_500.jsonl", "line": 436, "id": 88918, "informal_statement": "For any function \\(f\\) and any set \\(t\\), the image under \\(f\\) of the empty set on the left is the empty set, i.e., \\(f(\\emptyset, t) = \\emptyset\\).", "formal_statement": "import Mathlib\nopen Function Set\ntheorem image₂_empty_left_extracted [DecidableEq γ] {f : α → β → γ} {t : Finset β} : image₂ f ∅ t = ∅ := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean.\n\n1. **Understanding the Informal Statement:**\n   - The statement involves a function \\( f \\) and a set \\( t \\).\n   - It asserts that the image of the empty set under the function \\( f \\), when applied to the empty set on the left, results in the empty set.\n\n2. **Lean4 Code Components:**\n   - `import Mathlib`: This imports the Mathlib library, which contains various mathematical definitions and theorems that are useful for formalizing mathematical concepts.\n   - `open Function Set`: This line opens the `Function` and `Set` namespaces, allowing us to use functions and set operations without prefixing them with the namespace.\n\n3. **Formalizing the Function and Sets:**\n   - `theorem image₂_empty_left_extracted`: This declares a theorem named `image₂_empty_left_extracted`.\n   - `[DecidableEq γ]`: This is a typeclass constraint indicating that equality on type `γ` is decidable. This is often required for operations involving finite sets.\n   - `{f : α → β → γ}`: This defines `f` as a function taking two arguments, one of type `α` and one of type `β`, and returning a value of type `γ`. This matches the informal statement's description of a function \\( f \\).\n\n4. **Formalizing the Sets:**\n   - `{t : Finset β}`: This specifies that `t` is a finite set (or `Finset`) of elements of type `β`. In Lean, `Finset` is used to represent finite sets.\n   - `∅`: This represents the empty set in Lean. The informal statement's mention of the empty set is directly translated to `∅`.\n\n5. **Formalizing the Image Operation:**\n   - `image₂ f ∅ t`: This represents the image of the empty set under the function `f` when applied to the set `t`. The `image₂` function is a specific operation in Lean that takes a binary function and two sets, returning the set of all results of applying the function to each pair of elements from the two sets.\n   - `= ∅`: This asserts that the result of the `image₂` operation is the empty set,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 438, "id": 551628, "informal_statement": "Prove that $2\\sqrt{\\frac{a+b+c}{\\sqrt{ab}+\\sqrt{bc}+\\sqrt{ca}}}\\geq 2$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_551628 (a b c : ℝ) : 2 * Real.sqrt ((a + b + c) / (Real.sqrt (a * b) + Real.sqrt (b * c) + Real.sqrt (c * a))) ≥ 2   :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves three variables: \\(a\\), \\(b\\), and \\(c\\). These are real numbers, as indicated by the context of the problem involving square roots and inequalities. In Lean, real numbers are represented by the type `ℝ`.\n\n2. **Understand the Mathematical Expression**:\n   - The expression to be proven is \\(2\\sqrt{\\frac{a+b+c}{\\sqrt{ab}+\\sqrt{bc}+\\sqrt{ca}}}\\geq 2\\).\n   - This involves basic arithmetic operations (addition, multiplication, division) and the square root function.\n\n3. **Translate Mathematical Functions**:\n   - The square root function in Lean is represented by `Real.sqrt`.\n   - The division and multiplication operations are directly translated using `/` and `*`, respectively.\n\n4. **Structure the Theorem in Lean**:\n   - The theorem is named `extract_aug_551628`, which is a placeholder name and can be replaced with a more descriptive name if desired.\n   - The theorem takes three arguments, `a`, `b`, and `c`, all of type `ℝ`.\n\n5. **Formulate the Inequality**:\n   - The left-hand side of the inequality is `2 * Real.sqrt ((a + b + c) / (Real.sqrt (a * b) + Real.sqrt (b * c) + Real.sqrt (c * a)))`.\n   - The right-hand side is simply `2`.\n   - The inequality is expressed using `≥`, which is the Lean notation for \"greater than or equal to\".\n\n6. **Use Lean's Theorem Proving Syntax**:\n   - The theorem is introduced with the keyword `theorem`.\n   - The proof is initiated with `:= by sorry`, indicating that the proof is not yet provided. The `sorry` keyword is a placeholder that allows the theorem to be syntactically correct without a complete proof.\n\n7. **Import Necessary Libraries**:\n   - The `Mathlib` library is imported to access mathematical functions and types.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to bring relevant definitions and theorems into scope, although not all may be necessary for this specific theorem.\n\nBy following these"}
{"source_file": "herald_data/sample_500.jsonl", "line": 443, "id": 235556, "informal_statement": "For any monoid \\(G\\), and given elements \\(x, y \\in G\\) that commute with each other, along with the conditions that the orders of \\(x\\) and \\(y\\) are non-zero, prove that the order of \\(x\\) is non-zero. Note: This statement is a tautology as the hypothesis already asserts that the order of \\(x\\) is non-zero.", "formal_statement": "import Mathlib\nopen scoped Classical\nopen MulOpposite in\nopen Nat in\nopen Submonoid in\nopen Finset Monoid\nlemma mul_not_mem_of_exponent_two_tac_10908 [Monoid G] (x : G) (y : G) (h : Commute x y) (hx : orderOf x ≠ 0) (hy : orderOf y ≠ 0) : orderOf x ≠ 0 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Context**: The statement involves a monoid \\(G\\) and elements \\(x, y \\in G\\) that commute. The order of an element in a monoid is the smallest positive integer \\(n\\) such that \\(x^n = e\\), where \\(e\\) is the identity element of the monoid. The informal statement is essentially a tautology because it asks to prove that the order of \\(x\\) is non-zero, given that it is non-zero.\n\n2. **Setting Up the Environment**: \n   - The code begins with `import Mathlib`, which imports the necessary mathematical libraries in Lean4.\n   - The `open scoped Classical` line allows the use of classical logic, which is often necessary in mathematical proofs.\n   - The `open MulOpposite` and `open Nat` lines bring into scope operations and definitions related to multiplication and natural numbers, respectively.\n   - The `open Submonoid` and `open Finset Monoid` lines bring into scope definitions and operations related to submonoids and finite sets within monoids.\n\n3. **Defining the Lemma**: \n   - The lemma is named `mul_not_mem_of_exponent_two_tac_10908`, which is a placeholder name likely generated by an automated tool or tactic.\n   - The lemma is parameterized by `[Monoid G]`, indicating that \\(G\\) is a monoid. This is a type class constraint that ensures \\(G\\) has the structure of a monoid.\n\n4. **Specifying the Variables**:\n   - `(x : G) (y : G)` declares \\(x\\) and \\(y\\) as elements of the monoid \\(G\\).\n   - `(h : Commute x y)` is a hypothesis stating that \\(x\\) and \\(y\\) commute, i.e., \\(xy = yx\\).\n   - `(hx : orderOf x ≠ 0)` and `(hy : orderOf y ≠ 0)` are hypotheses stating that the orders of \\(x\\) and \\(y\\) are non-zero.\n\n5. **Stating the Conclusion**:\n   - The conclusion `: orderOf x ≠ 0` is the statement to be proved. However, this is trivially true because it is one"}
{"source_file": "herald_data/sample_500.jsonl", "line": 440, "id": 97927, "informal_statement": "For any short complexes \\(S_1\\) and \\(S_2\\) in a category, and a quasi-isomorphism \\(\\varphi : S_1 \\to S_2\\), show that the induced map \\(\\varphi^{\\mathrm{op}}\\) in the opposite category is also a quasi-isomorphism.", "formal_statement": "import Mathlib\nopen Category Limits\ntheorem quasiIso_opMap_extracted [CategoryTheory.Category.{u_1 : u_2} C] [CategoryTheory.Limits.HasZeroMorphisms C]\n {S₁ S₂ : CategoryTheory.ShortComplex C} [S₁.HasHomology] [S₂.HasHomology] (φ : S₁ ⟶ S₂)\n [CategoryTheory.ShortComplex.QuasiIso φ],\n CategoryTheory.ShortComplex.QuasiIso (CategoryTheory.ShortComplex.opMap φ) := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to follow a series of steps that involve understanding both the mathematical concepts and how they are represented in Lean's type system and libraries.\n\n1. **Understanding the Context**: \n   - We are working within the framework of category theory, specifically dealing with short complexes and quasi-isomorphisms.\n   - A short complex is a sequence of morphisms \\( A \\to B \\to C \\) in a category such that the composition is zero.\n   - A quasi-isomorphism is a morphism between complexes that induces isomorphisms on homology.\n\n2. **Setting Up the Category**:\n   - The Lean code begins by importing necessary modules from the Mathlib library, which provides tools for category theory and limits.\n   - The `CategoryTheory.Category.{u_1 : u_2} C` indicates that we are working in a category `C` with universes `u_1` and `u_2`.\n\n3. **Defining Short Complexes**:\n   - `S₁` and `S₂` are defined as objects of type `CategoryTheory.ShortComplex C`, meaning they are short complexes in the category `C`.\n   - The `[S₁.HasHomology]` and `[S₂.HasHomology]` are typeclass instances that ensure these complexes have well-defined homology.\n\n4. **Quasi-Isomorphism**:\n   - The morphism `φ : S₁ ⟶ S₂` is a morphism between the short complexes `S₁` and `S₂`.\n   - The `[CategoryTheory.ShortComplex.QuasiIso φ]` is a typeclass instance asserting that `φ` is a quasi-isomorphism, i.e., it induces isomorphisms on the homology of the complexes.\n\n5. **Opposite Category and Induced Map**:\n   - The goal is to show that the map induced by `φ` in the opposite category, denoted as `φ^{\\mathrm{op}}`, is also a quasi-isomorphism.\n   - In Lean, this is represented by `CategoryTheory.ShortComplex.opMap φ`, which constructs the morphism in the opposite category.\n\n6. **Theorem Statement**:\n   - The theorem `quasiIso_opMap_extracted` asserts that if `φ` is a quasi-isomorphism, then `CategoryTheory.ShortComplex.opMap"}
{"source_file": "herald_data/sample_500.jsonl", "line": 439, "id": 353825, "informal_statement": "Let \\(a\\) and \\(b\\) be natural numbers with \\(a > 0\\) and \\(p\\) a prime factor of \\(b\\). Show that \\(p\\) is a prime factor of \\(a \\times b\\).", "formal_statement": "import Mathlib\nopen Bool Subtype\nopen Nat\nopen scoped List in\nopen List\nopen List\n/-- If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` -/\ntheorem mem_primeFactorsList_mul_right {p a b : ℕ} (hpb : p ∈ b.primeFactorsList) (ha : a ≠ 0) :\n    p ∈ (a * b).primeFactorsList := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a structured approach that captures the essence of the mathematical concepts and their formal representation in Lean. Here's a step-by-step explanation:\n\n1. **Understanding the Informal Statement**:\n   - We have two natural numbers, \\(a\\) and \\(b\\), with the condition \\(a > 0\\).\n   - There is a prime number \\(p\\) that is a factor of \\(b\\).\n   - We need to show that \\(p\\) is also a prime factor of the product \\(a \\times b\\).\n\n2. **Identifying Key Concepts**:\n   - **Natural Numbers**: In Lean, natural numbers are represented by the type `ℕ`.\n   - **Prime Factor**: A prime factor of a number is a prime number that divides the number without leaving a remainder.\n   - **Product of Numbers**: The product \\(a \\times b\\) is represented as `a * b` in Lean.\n\n3. **Formalizing the Statement in Lean**:\n   - **Theorem Declaration**: We declare a theorem named `mem_primeFactorsList_mul_right` to encapsulate the statement.\n   - **Variables**: We introduce variables `p`, `a`, and `b` of type `ℕ` to represent the prime number and the two natural numbers, respectively.\n   - **Hypotheses**:\n     - `hpb : p ∈ b.primeFactorsList`: This hypothesis states that \\(p\\) is a prime factor of \\(b\\). In Lean, `b.primeFactorsList` is a list of prime factors of `b`, and `p ∈ b.primeFactorsList` asserts that `p` is an element of this list.\n     - `ha : a ≠ 0`: This hypothesis ensures that \\(a > 0\\). In Lean, `a ≠ 0` is used to express that `a` is not zero, which is equivalent to \\(a > 0\\) for natural numbers.\n   - **Conclusion**:\n     - `p ∈ (a * b).primeFactorsList`: The conclusion states that \\(p\\) is a prime factor of \\(a \\times b\\). In Lean, `(a * b).primeFactorsList` gives the list of prime factors of the product `a * b`, and `p ∈ ("}
{"source_file": "herald_data/sample_500.jsonl", "line": 445, "id": 154515, "informal_statement": "For any natural number $n$, and for any $a \\in \\text{Fin } n$ and $b \\in \\text{Fin } (n + 1)$, show that the successor of the predecessor above $b$'s successor in the context of $a$ equals the successor of the predecessor above $b$ in the context of $a$.", "formal_statement": "import Mathlib\nopen Fin Nat Function\nlemma succ_predAbove_succ_tac_55569 (n : ℕ) (a : Fin n) (b : Fin (n + 1)) : a.succ.predAbove b.succ = (a.predAbove b).succ := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to understand the components involved and how they relate to each other in the context of the `Fin` type, which represents finite sets of natural numbers.\n\n1. **Understanding `Fin n`**: \n   - `Fin n` is a type representing natural numbers less than `n`. It is used to model finite sets of numbers, specifically the set `{0, 1, ..., n-1}`.\n\n2. **Variables `a` and `b`**:\n   - The informal statement involves two variables: `a` and `b`.\n   - `a` is an element of `Fin n`, meaning it is a natural number less than `n`.\n   - `b` is an element of `Fin (n + 1)`, meaning it is a natural number less than `n + 1`.\n\n3. **Successor and Predecessor**:\n   - The `succ` function in the context of `Fin` is used to get the successor of a given element, provided it is within bounds.\n   - The `predAbove` function is a bit more complex. It is used to adjust indices when inserting or removing elements in finite sets. Specifically, `a.predAbove b` gives the position of `b` in `Fin n` when `a` is removed from `Fin (n + 1)`.\n\n4. **Formalizing the Statement**:\n   - The informal statement asks us to show that the successor of the predecessor above `b`'s successor in the context of `a` equals the successor of the predecessor above `b` in the context of `a`.\n   - In Lean, this is expressed as `a.succ.predAbove b.succ = (a.predAbove b).succ`.\n\n5. **Breaking Down the Formal Statement**:\n   - `a.succ` is the successor of `a` in `Fin (n + 1)`.\n   - `b.succ` is the successor of `b` in `Fin (n + 2)`.\n   - `a.succ.predAbove b.succ` computes the position of `b.succ` in `Fin (n + 1)` when `a.succ` is removed from `Fin (n + 2)`.\n   - `a.predAbove b` computes the position of `b` in `Fin n` when"}
{"source_file": "herald_data/sample_500.jsonl", "line": 442, "id": 325503, "informal_statement": "For any monoid $R$ equipped with a star multiplication operation, and for any invertible element $r \\in R$ where $r^\\star$ is also invertible, given that $r^\\star \\cdot (r^\\star)^{-1} = r^\\star \\cdot (r^\\star)^{-1} \\cdot (r \\cdot (r^\\star)^{-1})$, show that $r^\\star \\cdot (r^\\star)^{-1} \\cdot r = 1^\\star$.", "formal_statement": "import Mathlib\nopen MulOpposite\nopen scoped NNRat\nopen scoped ComplexConjugate\nlemma star_invOf_tac_17486 [Monoid R] [StarMul R] (r : R) [Invertible r] [Invertible (star r)] (this : star ⅟r = star ⅟r * (star r * ⅟(star r))) : star ⅟r * star r = star 1 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Monoid with Star Multiplication**: \n   - The informal statement begins by considering a monoid \\( R \\) with a star multiplication operation. In Lean, this is represented by `[Monoid R] [StarMul R]`. The `Monoid R` typeclass indicates that \\( R \\) is a monoid, and `StarMul R` indicates that there is a star operation defined on \\( R \\).\n\n2. **Invertible Elements**:\n   - The statement mentions an invertible element \\( r \\in R \\) and that \\( r^\\star \\) is also invertible. In Lean, this is captured by `[Invertible r] [Invertible (star r)]`. The `Invertible r` typeclass ensures that \\( r \\) has an inverse, and `Invertible (star r)` ensures that the star of \\( r \\) is also invertible.\n\n3. **Given Equation**:\n   - The informal statement provides an equation: \\( r^\\star \\cdot (r^\\star)^{-1} = r^\\star \\cdot (r^\\star)^{-1} \\cdot (r \\cdot (r^\\star)^{-1}) \\). In Lean, this is expressed as `(this : star ⅟r = star ⅟r * (star r * ⅟(star r)))`. Here, `star ⅟r` represents \\( r^\\star \\cdot (r^\\star)^{-1} \\), and the equation is directly translated into Lean syntax.\n\n4. **Conclusion to Prove**:\n   - The goal is to show that \\( r^\\star \\cdot (r^\\star)^{-1} \\cdot r = 1^\\star \\). In Lean, this is expressed as `star ⅟r * star r = star 1`. The expression `star ⅟r * star r` corresponds to \\( r^\\star \\cdot (r^\\star)^{-1} \\cdot r \\), and `star 1` represents \\( 1^\\star \\).\n\n5. **Lemma Declaration**:\n   - The entire statement is encapsulated in a lemma named `star_invOf_t"}
{"source_file": "herald_data/sample_500.jsonl", "line": 444, "id": 208806, "informal_statement": "For any measurable spaces $\\alpha$ and $\\beta$, a non-negative real-valued function $f : \\alpha \\to \\beta \\to \\mathbb{R}_{\\geq 0}^{\\infty}$, a kernel $\\kappa : \\alpha \\to \\beta$, where $\\kappa$ is a finite kernel, and a bound $B \\in \\mathbb{R}_{\\geq 0}^{\\infty}$ with $B \\neq \\top$ such that for all $a \\in \\alpha$ and $b \\in \\beta$, $f(a, b) \\leq B$, prove that the kernel $\\kappa$ with density $f$ is also a finite kernel.", "formal_statement": "import Mathlib\nopen MeasureTheory ProbabilityTheory\nopen scoped MeasureTheory ENNReal NNReal\nlemma isFiniteKernel_withDensity_of_bounded_tac_8467 (mα : MeasurableSpace α) (mβ : MeasurableSpace β) (f : α → β → ℝ≥0∞) (κ : Kernel α β) [IsFiniteKernel κ] (B : ℝ≥0∞) (hB_top : B ≠ ⊤) (hf_B : ∀ (a : α) (b : β), f a b ≤ B) : IsFiniteKernel (κ.withDensity f) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that involves understanding the components of the statement and how they map to Lean's syntax and semantics.\n\n1. **Measurable Spaces**: \n   - The informal statement begins with \"For any measurable spaces $\\alpha$ and $\\beta$\". In Lean, measurable spaces are represented by the type `MeasurableSpace`. Thus, we declare `mα : MeasurableSpace α` and `mβ : MeasurableSpace β` to represent the measurable spaces for types `α` and `β`.\n\n2. **Non-negative Real-valued Function**:\n   - The function $f : \\alpha \\to \\beta \\to \\mathbb{R}_{\\geq 0}^{\\infty}$ is a function from $\\alpha$ to $\\beta$ to the extended non-negative reals, denoted by `ℝ≥0∞` in Lean. This is represented as `f : α → β → ℝ≥0∞`.\n\n3. **Kernel**:\n   - The kernel $\\kappa : \\alpha \\to \\beta$ is a function that maps elements of $\\alpha$ to measures on $\\beta$. In Lean, this is represented by `κ : Kernel α β`. The statement specifies that $\\kappa$ is a finite kernel, which is indicated by the type class `[IsFiniteKernel κ]`.\n\n4. **Bound**:\n   - The bound $B \\in \\mathbb{R}_{\\geq 0}^{\\infty}$ with $B \\neq \\top$ is represented in Lean as `B : ℝ≥0∞` with the condition `hB_top : B ≠ ⊤`. The symbol `⊤` represents the top element (infinity) in the extended non-negative reals.\n\n5. **Inequality Condition**:\n   - The condition \"for all $a \\in \\alpha$ and $b \\in \\beta$, $f(a, b) \\leq B$\" is expressed in Lean as `hf_B : ∀ (a : α) (b : β), f a b ≤ B`. This uses Lean's universal quantifier `∀` to state that the inequality holds for all elements of the respective types.\n\n6. **Conclusion**:\n   - The goal is to prove that the kernel $\\kappa$ with density $"}
{"source_file": "herald_data/sample_500.jsonl", "line": 448, "id": 256740, "informal_statement": "For any integers $x$ and $y$ such that $4$ divides $x - y$, and $x$ is odd and not divisible by $2$, and $x - y$ is even, and $y$ is odd, and for any natural number $n$ and $k$, where $n + 1$ can be expressed as $2^{m} \\cdot k$ for some $m$ which is the maximum power of $2$ dividing $n + 1$, if $2$ divides $k$, then $2^{m + 1}$ divides $n + 1$.", "formal_statement": "import Mathlib\nopen Ideal Ideal.Quotient Finset\nlemma two_pow_sub_pow'_tac_13605 (x : ℤ) (y : ℤ) (hxy : 4 ∣ x - y) (hx : ¬2 ∣ x) (hx_odd : Odd x) (hxy_even : Even (x - y)) (hy_odd : Odd y) (n : ℕ) (h : (multiplicity 2 (n + 1)).Dom) (k : ℕ) (hk : n + 1 = 2 ^ (multiplicity 2 (n + 1)).get h * k) : ¬¬2 ∣ k → ¬¬2 ^ ((multiplicity 2 (n + 1)).get h + 1) ∣ n + 1 := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to carefully map each part of the informal statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Quantifiers and Variables**:\n   - The informal statement begins with \"For any integers $x$ and $y$...\". In Lean, we declare these variables with their types: `(x : ℤ) (y : ℤ)`.\n   - The statement also involves natural numbers $n$ and $k$. These are declared as `(n : ℕ) (k : ℕ)`.\n\n2. **Divisibility Conditions**:\n   - The condition \"$4$ divides $x - y$\" is expressed in Lean as `(hxy : 4 ∣ x - y)`.\n   - The condition \"$x$ is odd and not divisible by $2$\" is split into two parts: `(hx : ¬2 ∣ x)` for \"not divisible by $2$\" and `(hx_odd : Odd x)` for \"odd\".\n   - The condition \"$x - y$ is even\" is expressed as `(hxy_even : Even (x - y))`.\n   - The condition \"$y$ is odd\" is expressed as `(hy_odd : Odd y)`.\n\n3. **Expression of $n + 1$**:\n   - The statement \"for any natural number $n$ and $k$, where $n + 1$ can be expressed as $2^{m} \\cdot k$ for some $m$ which is the maximum power of $2$ dividing $n + 1$\" involves the concept of multiplicity.\n   - In Lean, the multiplicity of $2$ in $n + 1$ is handled using `multiplicity 2 (n + 1)`. The domain condition `(h : (multiplicity 2 (n + 1)).Dom)` ensures that the multiplicity is defined.\n   - The expression of $n + 1$ as $2^{m} \\cdot k$ is captured by `(hk : n + 1 = 2 ^ (multiplicity 2 (n + 1)).get h * k)`, where `.get h` retrieves the multiplicity value.\n\n4. **Implication and Conclusion**:\n   - The condition \"if $2$ divides $k$"}
{"source_file": "herald_data/sample_500.jsonl", "line": 451, "id": 488597, "informal_statement": "Let $x$ be positive real numbers . $\\sqrt{ \\frac{1}{x^2+k}}+2 \\sqrt{ \\frac{x}{x+1}}\\leq \\frac{2k+1}{\\sqrt{k(k+1)}}$ Where $k\\in N^+.$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_488597 (k : ℕ) (hx: 0 < x) : √ (1 / (x ^ 2 + k)) + 2 * √ (x / (x + 1)) ≤ (2 * k + 1) / √ (k * (k + 1))  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to carefully map each component of the statement to its corresponding Lean syntax and structure. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Variables and Context:**\n   - The informal statement involves a variable \\( x \\) which is a positive real number, and a parameter \\( k \\) which is a positive natural number (\\( k \\in \\mathbb{N}^+ \\)).\n   - In Lean, real numbers are represented by `Real`, and natural numbers by `ℕ` (Nat).\n\n2. **Defining the Theorem:**\n   - We start by defining a theorem in Lean. The name `extract_aug_488597` is arbitrary and can be any valid identifier.\n   - The theorem takes two parameters: `k` of type `ℕ` and `hx` which is a proof that `x` is positive (`0 < x`).\n\n3. **Translating the Mathematical Expression:**\n   - The expression \\(\\sqrt{ \\frac{1}{x^2+k}} + 2 \\sqrt{ \\frac{x}{x+1}}\\) is translated into Lean as `√ (1 / (x ^ 2 + k)) + 2 * √ (x / (x + 1))`.\n     - `√` is the square root function in Lean.\n     - `^` is used for exponentiation, so `x ^ 2` represents \\( x^2 \\).\n     - `/` is used for division.\n     - `+` and `*` are used for addition and multiplication, respectively.\n\n4. **Translating the Inequality:**\n   - The inequality \\(\\leq \\frac{2k+1}{\\sqrt{k(k+1)}}\\) is translated as `≤ (2 * k + 1) / √ (k * (k + 1))`.\n     - `≤` is the less than or equal to operator in Lean.\n     - The expression `2 * k + 1` represents \\( 2k + 1 \\).\n     - The division by the square root is expressed as `/ √ (k * (k + 1))`.\n\n5. **Specifying the Domain of \\( k \\):**\n   - The informal statement specifies \\( k \\in \\mathbb{N}^+ \\), meaning \\( k \\) is a"}
{"source_file": "herald_data/sample_500.jsonl", "line": 446, "id": 25612, "informal_statement": "For a filter $l$ on a type $\\alpha$, a function $f : \\alpha \\to \\mathbb{C}$, and a function $k : \\alpha \\to \\mathbb{R}_{>0}$, the function $f$ decays superpolynomially with respect to $l$ and $k$ if and only if for every natural number $n$, the function $a \\mapsto |k(a)^n \\cdot f(a)|$ tends to $0$ as $a$ approaches according to the filter $l$.", "formal_statement": "import Mathlib\nopen Topology Polynomial\nopen Filter\ntheorem superpolynomialDecay_iff_abs_tendsto_zero_extracted (l : Filter α) (k f : α → β) [TopologicalSpace β]\n [LinearOrderedCommRing β] [OrderTopology β] :\n Asymptotics.SuperpolynomialDecay l k f ↔ ∀ (n : ℕ), Filter.Tendsto (fun a => |k a ^ n * f a|) l (nhds 0) := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down the components of the statement and understand how they map to Lean's formal language and libraries.\n\n1. **Understanding the Context**:\n   - We are dealing with a filter `l` on a type `α`, which is a common way to describe convergence in topology.\n   - We have two functions: `f : α → ℂ` and `k : α → ℝ_{>0}`. In Lean, we generalize this to `f : α → β` and `k : α → β` where `β` is a topological space with a linear ordered commutative ring structure and an order topology. This generalization allows us to work with a broader class of spaces, not just complex numbers and positive reals.\n\n2. **Superpolynomial Decay**:\n   - The informal statement describes a condition where `f` decays superpolynomially with respect to `l` and `k`. In Lean, this is captured by `Asymptotics.SuperpolynomialDecay l k f`.\n   - This concept is likely defined elsewhere in the Lean library, encapsulating the idea that for every natural number `n`, the function `a ↦ |k(a)^n * f(a)|` tends to `0` as `a` approaches according to the filter `l`.\n\n3. **Formalizing the Condition**:\n   - The condition \"for every natural number `n`, the function `a ↦ |k(a)^n * f(a)|` tends to `0`\" is expressed using `Filter.Tendsto`.\n   - `Filter.Tendsto (fun a => |k a ^ n * f a|) l (nhds 0)` states that the function `a ↦ |k(a)^n * f(a)|` converges to `0` in the neighborhood filter `nhds 0` as `a` approaches according to the filter `l`.\n\n4. **Theorem Statement**:\n   - The theorem `superpolynomialDecay_iff_abs_tendsto_zero_extracted` asserts the equivalence (`↔`) between the superpolynomial decay of `f` with respect to `l` and `k`, and the condition that for every natural number `n`, the function `a ↦ |k(a)^n * f(a)|` tends to `0`.\n   - The"}
{"source_file": "herald_data/sample_500.jsonl", "line": 449, "id": 509305, "informal_statement": "Prove the inequality: $\\sqrt [k]{a_1a_2...a_n}\\ge\\frac{k}{\\frac {1}{a_1} + \\frac {1}{a_2} + ... + \\frac {1}{a_n}}$ for $k = n$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_509305 (n : ℕ) (a : ℕ → ℕ) : (∏ i in Finset.range n, a i)^(1/n) ≥ n / (∑ i in Finset.range n, (1/a i))   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Identify the Variables and Parameters**:\n   - The informal statement involves a sequence of numbers \\(a_1, a_2, \\ldots, a_n\\) and a parameter \\(k\\) which is set to \\(n\\).\n   - In Lean, we represent the sequence as a function \\(a : \\mathbb{N} \\to \\mathbb{N}\\), where \\(a(i)\\) corresponds to \\(a_i\\).\n\n2. **Understand the Mathematical Operations**:\n   - The left side of the inequality is the geometric mean of the sequence, \\(\\sqrt[n]{a_1 a_2 \\ldots a_n}\\).\n   - The right side is the harmonic mean, \\(\\frac{n}{\\frac{1}{a_1} + \\frac{1}{a_2} + \\ldots + \\frac{1}{a_n}}\\).\n\n3. **Translate the Geometric Mean**:\n   - In Lean, the product of a sequence is expressed using the `∏` (big product) operator. We use `Finset.range n` to iterate over the indices from 0 to \\(n-1\\).\n   - The geometric mean is then \\((\\prod_{i=0}^{n-1} a(i))^{1/n}\\), which in Lean is written as `(∏ i in Finset.range n, a i)^(1/n)`.\n\n4. **Translate the Harmonic Mean**:\n   - The sum of reciprocals is expressed using the `∑` (big sum) operator. Again, we use `Finset.range n` for iteration.\n   - The harmonic mean is \\(\\frac{n}{\\sum_{i=0}^{n-1} \\frac{1}{a(i)}}\\), which in Lean is written as `n / (∑ i in Finset.range n, (1/a i))`.\n\n5. **Formulate the Theorem**:\n   - The theorem is named `extract_aug_509305`, which is a placeholder name.\n   - The statement of the theorem in Lean is: for a natural number \\(n\\) and a sequence \\(a\\), the inequality holds: `(∏ i in Finset.range n, a i)^(1/n) ≥ n / (∑ i in Fin"}
{"source_file": "herald_data/sample_500.jsonl", "line": 455, "id": 529512, "informal_statement": "Show that $\\forall n \\in \\mathbb{N}, \\lfloor (1+\\sqrt{2})^n \\rfloor +n -1$ is an even integer.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_529512 (n : ℕ) : Even (Int.floor ((1 + Real.sqrt 2)^n) + n - 1)   :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Informal Statement**: The statement is about proving that for every natural number \\( n \\), the expression \\(\\lfloor (1+\\sqrt{2})^n \\rfloor + n - 1\\) is an even integer. Here, \\(\\lfloor x \\rfloor\\) denotes the floor function, which gives the greatest integer less than or equal to \\( x \\).\n\n2. **Formalizing the Universal Quantifier**: The informal statement begins with \"for all \\( n \\in \\mathbb{N} \\)\", which is formalized in Lean using the universal quantifier `∀`. In Lean, natural numbers are represented by the type `ℕ`.\n\n3. **Translating the Expression**: The expression \\(\\lfloor (1+\\sqrt{2})^n \\rfloor + n - 1\\) needs to be translated into Lean syntax:\n   - The floor function is represented by `Int.floor`.\n   - The expression \\((1+\\sqrt{2})^n\\) is written as `(1 + Real.sqrt 2)^n` in Lean. Here, `Real.sqrt 2` computes the square root of 2 in the real numbers.\n   - The addition and subtraction operations are directly translated using `+` and `-`.\n\n4. **Expressing Evenness**: The statement that the expression is an even integer is formalized using the `Even` predicate in Lean. `Even x` asserts that `x` is an even integer.\n\n5. **Combining the Components**: The theorem is then stated in Lean as:\n   - `theorem extract_aug_529512 (n : ℕ) : Even (Int.floor ((1 + Real.sqrt 2)^n) + n - 1)`.\n   - This line declares a theorem named `extract_aug_529512` which takes a natural number `n` as an argument and asserts that the expression `Int.floor ((1 + Real.sqrt 2)^n) + n - 1` is even.\n\n6. **Using Lean's Libraries**: The `import Mathlib` statement at the beginning includes necessary mathematical libraries, and `open BigOperators`, `open Real`, `open Nat`, and `open Topology` make relevant definitions and theorems available without needing to prefix them with"}
{"source_file": "herald_data/sample_500.jsonl", "line": 452, "id": 445585, "informal_statement": "Prove that for all a,b and c positive numbers \\n $\\frac{a+b+c}{3}\\geq\\sqrt[3]{abc}$ .", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_445585 (a b c : ℝ) : a > 0 ∧ b > 0 ∧ c > 0 → (a + b + c) / 3 ≥ (a * b * c)^(1/3)  :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves three variables \\(a\\), \\(b\\), and \\(c\\), which are specified as positive numbers. In Lean, we represent real numbers using the type `ℝ` (real numbers).\n\n2. **Express the Condition**:\n   - The condition that \\(a\\), \\(b\\), and \\(c\\) are positive is expressed in Lean using inequalities. Specifically, we use `a > 0`, `b > 0`, and `c > 0`.\n\n3. **Translate the Inequality**:\n   - The inequality \\(\\frac{a+b+c}{3} \\geq \\sqrt[3]{abc}\\) needs to be expressed in Lean. The left-hand side \\(\\frac{a+b+c}{3}\\) is written as `(a + b + c) / 3`.\n   - The right-hand side \\(\\sqrt[3]{abc}\\) is expressed using the power operation in Lean as `(a * b * c)^(1/3)`. Here, `^` is used for exponentiation, and `1/3` represents the cube root.\n\n4. **Formulate the Theorem**:\n   - The theorem is stated using the `theorem` keyword in Lean. We give it a name, `extract_aug_445585`, which is a placeholder and can be replaced with a more descriptive name.\n   - The theorem takes three arguments `a`, `b`, and `c` of type `ℝ`.\n   - The hypothesis that \\(a\\), \\(b\\), and \\(c\\) are positive is expressed as `a > 0 ∧ b > 0 ∧ c > 0`.\n   - The conclusion of the theorem is the inequality `(a + b + c) / 3 ≥ (a * b * c)^(1/3)`.\n\n5. **Use of Lean Libraries**:\n   - The `import Mathlib` statement is used to bring in necessary mathematical libraries that provide definitions and theorems related to real numbers and inequalities.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to make various mathematical operations and constants available without needing to prefix them with their module names.\n\n6. **Proof"}
{"source_file": "herald_data/sample_500.jsonl", "line": 453, "id": 203884, "informal_statement": "For any set $s$ in a pseudo metric space $\\alpha$ and any point $x \\in \\alpha$, show that the infimum of the extended distances from $x$ to points in $s$ is equal to the top element if and only if $s$ is the empty set, i.e., $\\inf_{y \\in s} \\text{edist}(x, y) = \\top \\iff s = \\emptyset$.", "formal_statement": "import Mathlib\nopen NNReal ENNReal Topology Set Filter Pointwise Bornology\nopen EMetric\nlemma infEdist_eq_top_iff_tac_21191 [PseudoMetricSpace α] (s : Set α) (x : α) : infEdist x s = ⊤ ↔ s = ∅ := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to break down each component of the statement and map it to the corresponding Lean constructs. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context**:\n   - We are working within the context of a pseudo metric space, denoted as `α`. In Lean, this is represented by the type class `[PseudoMetricSpace α]`.\n   - The statement involves a set `s` and a point `x` in this space.\n\n2. **Identifying the Key Components**:\n   - The informal statement involves the concept of the \"infimum of the extended distances\" from a point `x` to a set `s`. In Lean, this is captured by the function `infEdist x s`, where `infEdist` is a function that computes the infimum of the extended distances from `x` to the set `s`.\n   - The \"extended distances\" refer to the use of `ENNReal` (extended non-negative reals), which allows for the inclusion of infinity (`⊤`) as a possible value.\n\n3. **Formalizing the Statement**:\n   - The goal is to show that `infEdist x s = ⊤` if and only if `s = ∅`. This is a bi-conditional statement, which in Lean is expressed using the `↔` symbol.\n   - The left-hand side of the bi-conditional, `infEdist x s = ⊤`, checks if the infimum of the extended distances is the top element (infinity).\n   - The right-hand side, `s = ∅`, checks if the set `s` is empty.\n\n4. **Constructing the Lean Lemma**:\n   - We start by importing necessary modules from Mathlib that provide the required definitions and theorems for working with pseudo metric spaces, extended non-negative reals, and related concepts.\n   - We then declare a lemma named `infEdist_eq_top_iff_tac_21191`, which is a common practice in Lean to give lemmas unique identifiers.\n   - The lemma takes as parameters a set `s : Set α` and a point `x : α`.\n   - The type of the lemma is the bi-conditional statement `infEdist x s = ⊤ ↔ s = ∅`.\n\n5. **Final Lean Code**:\n   - The complete Lean"}
{"source_file": "herald_data/sample_500.jsonl", "line": 447, "id": 48461, "informal_statement": "For any vector $x$ in $V$ and any real number $r$ such that $0 \\leq r$, show that the oriented angle between $x$ and $r \\cdot x$ is $0$, i.e., $\\angle(x, r \\cdot x) = 0$.", "formal_statement": "import Mathlib\nopen FiniteDimensional Complex\nopen scoped Real RealInnerProductSpace ComplexConjugate\ntheorem oangle_smul_right_self_of_nonneg_extracted [NormedAddCommGroup V] [InnerProductSpace ℝ V] [Fact (finrank ℝ V = 2)]\n (o : Orientation ℝ V (Fin 2)) (x : V) {r : ℝ} : 0 ≤ r → o.oangle x (r • x) = 0 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a series of steps that map the mathematical concepts to their formal counterparts in Lean. Here's a detailed breakdown of the translation process:\n\n1. **Understanding the Context**:\n   - The informal statement involves vectors, real numbers, and angles in a vector space. Specifically, it deals with the oriented angle between a vector and its scalar multiple.\n   - The vector space \\( V \\) is over the real numbers \\( \\mathbb{R} \\), and the dimension of \\( V \\) is 2, which is typical for problems involving angles in a plane.\n\n2. **Setting Up the Environment**:\n   - The Lean code begins with importing necessary libraries and opening relevant namespaces. `Mathlib` is imported to access mathematical structures and theorems.\n   - `FiniteDimensional Complex` and `RealInnerProductSpace` are opened to work with finite-dimensional vector spaces and inner product spaces over the reals, respectively.\n\n3. **Defining the Theorem**:\n   - The theorem is named `oangle_smul_right_self_of_nonneg_extracted`, which suggests it deals with oriented angles (`oangle`) and scalar multiplication (`smul`) under a non-negative condition (`nonneg`).\n\n4. **Specifying the Vector Space**:\n   - `[NormedAddCommGroup V]` and `[InnerProductSpace ℝ V]` are type class constraints that specify \\( V \\) as a normed additive commutative group and an inner product space over \\( \\mathbb{R} \\). This setup is necessary to discuss angles and scalar multiplication in \\( V \\).\n\n5. **Dimension Constraint**:\n   - `[Fact (finrank ℝ V = 2)]` asserts that the real vector space \\( V \\) has a finite dimension of 2. This is crucial because angles are typically defined in two-dimensional spaces.\n\n6. **Orientation**:\n   - `(o : Orientation ℝ V (Fin 2))` introduces an orientation `o` on the vector space \\( V \\). Orientation is needed to define the concept of an oriented angle.\n\n7. **Variables and Hypotheses**:\n   - `(x : V)` introduces a vector \\( x \\) in the vector space \\( V \\).\n   - `{r : ℝ}` introduces a real number \\( r \\) with the condition `0 ≤ r`. This condition is"}
{"source_file": "herald_data/sample_500.jsonl", "line": 450, "id": 76368, "informal_statement": "For any relation $r$ on elements of type $\\alpha$ and any list $l$ of elements of type $\\alpha$, show that the lexicographic order $Lex$ of $l$ with an empty list $[]$ under relation $r$ is false, i.e., $\\neg Lex(r, l, [])$.", "formal_statement": "import Mathlib\nopen Nat\ntheorem not_nil_right_extracted (r : α → α → Prop) (l : List α) : ¬List.Lex r l [] := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Types and Structures**: \n   - The informal statement involves a relation `r` on elements of type `α` and a list `l` of elements of type `α`. In Lean, this is represented by `r : α → α → Prop` and `l : List α`.\n\n2. **Understand the Lexicographic Order**:\n   - The lexicographic order `Lex` is a standard way to compare lists based on a given relation `r`. In Lean, `List.Lex r l₁ l₂` is true if list `l₁` is lexicographically less than list `l₂` under the relation `r`.\n\n3. **Translate the Informal Statement**:\n   - The informal statement claims that for any list `l`, the lexicographic order of `l` with an empty list `[]` is false. This is expressed as `¬Lex(r, l, [])`.\n\n4. **Formalize the Statement in Lean**:\n   - We need to express this as a theorem in Lean. The theorem should take a relation `r` and a list `l` as inputs and prove that `¬List.Lex r l []` holds.\n   - The theorem is named `not_nil_right_extracted`, which suggests that it is about the non-existence of a lexicographic order when the right list is empty.\n\n5. **Structure the Lean Theorem**:\n   - The theorem is defined with the signature `(r : α → α → Prop) (l : List α) : ¬List.Lex r l []`.\n   - This means for any relation `r` and list `l`, the statement `¬List.Lex r l []` is to be proven.\n\n6. **Use of `sorry`**:\n   - The `sorry` keyword is a placeholder in Lean, indicating that the proof is omitted or not yet provided. It allows the theorem to be syntactically correct without a complete proof.\n\n7. **Importing Necessary Libraries**:\n   - The line `import Mathlib` is used to import necessary mathematical libraries that might contain definitions and theorems related to lists and relations.\n\n8. **Opening Necessary Namespaces**:\n   - The `open Nat` statement is included, although it might not be directly necessary for this specific theorem"}
{"source_file": "herald_data/sample_500.jsonl", "line": 457, "id": 255840, "informal_statement": "For any element $g$ in a nontrivial, commutative, simple group $\\alpha$ such that $g$ is not the identity element, show that $\\alpha$ is a cyclic group.", "formal_statement": "import Mathlib\nopen Subgroup\nopen Finset Nat\nopen scoped Classical\nopen Nat\nopen Subgroup\nlemma isCyclic_tac_23958 (a : α) [CommGroup α] [IsSimpleGroup α] [Nontrivial α] (g : α) (hg : g ≠ 1) : IsCyclic α := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in the Lean code.\n\n1. **Understanding the Context:**\n   - The informal statement involves a group $\\alpha$ that is nontrivial, commutative, and simple. We are given an element $g$ in this group that is not the identity, and we need to show that the group is cyclic.\n\n2. **Lean Imports and Setup:**\n   - `import Mathlib`: This imports the Mathlib library, which contains definitions and theorems about groups and other mathematical structures.\n   - `open Subgroup`, `open Finset Nat`, `open scoped Classical`, `open Nat`, `open Subgroup`: These commands open various namespaces and scopes, making it easier to use functions and theorems related to subgroups, finite sets, natural numbers, and classical logic.\n\n3. **Defining the Group and its Properties:**\n   - `α` is the type representing the group. In Lean, types are used to represent sets or structures, and here `α` is a placeholder for our group.\n   - `[CommGroup α]`: This is a typeclass constraint indicating that `α` is a commutative group. In Lean, typeclasses are used to specify that a type has certain properties or operations.\n   - `[IsSimpleGroup α]`: This constraint specifies that `α` is a simple group, meaning it has no nontrivial normal subgroups other than itself and the trivial group.\n   - `[Nontrivial α]`: This indicates that the group is nontrivial, meaning it has more than one element.\n\n4. **Element and Condition:**\n   - `(g : α)`: This declares `g` as an element of the group `α`.\n   - `(hg : g ≠ 1)`: This is a hypothesis stating that `g` is not the identity element of the group. In Lean, `1` is often used to denote the identity element in a group.\n\n5. **Goal: Proving the Group is Cyclic:**\n   - `IsCyclic α`: This is the conclusion we want to prove, namely that the group `α` is cyclic. In Lean, `IsCyclic` is a predicate that asserts a group is cyclic, meaning it can be generated by a single element.\n\n6"}
{"source_file": "herald_data/sample_500.jsonl", "line": 456, "id": 428976, "informal_statement": "Let \\( M \\) be a deterministic finite automaton. Define the function \\( \\text{evalFrom}(s, x) \\) that, given an initial state \\( s \\) and a sequence of inputs \\( x \\), returns the state reached in \\( M \\) after processing \\( x \\) starting from \\( s \\).", "formal_statement": "import Mathlib\nopen Computability\n/-- `M.evalFrom s x` evaluates `M` with input `x` starting from the state `s`. -/\ndef evalFrom (s : σ) : List α → σ := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we need to break down the components of the deterministic finite automaton (DFA) and the function we want to define. Here's the step-by-step explanation:\n\n1. **Understanding the Components of a DFA**:\n   - A deterministic finite automaton \\( M \\) consists of a set of states, an initial state, a set of accepting states, an alphabet of input symbols, and a transition function that determines the next state given a current state and an input symbol.\n   - In Lean, we typically represent the set of states and the alphabet as types, often denoted by `σ` for states and `α` for the alphabet.\n\n2. **Defining the Function `evalFrom`**:\n   - The function `evalFrom` is intended to simulate the DFA starting from a given state `s` and processing a sequence of inputs `x`.\n   - The input `x` is a list of symbols from the alphabet, represented as `List α` in Lean.\n\n3. **Function Signature**:\n   - The function `evalFrom` takes two arguments: an initial state `s` of type `σ` and a list of inputs `x` of type `List α`.\n   - The function returns a state of type `σ`, which is the state reached after processing the entire input list starting from `s`.\n\n4. **Formalizing the Function in Lean**:\n   - We start by importing necessary modules, such as `Mathlib`, which might contain useful definitions and theorems related to automata and computation.\n   - We open the `Computability` namespace, which is likely where DFA-related definitions reside.\n   - We define the function `evalFrom` with the signature `(s : σ) → List α → σ`. This indicates that `evalFrom` is a function that takes a state `s` and returns another function that takes a list of inputs and returns a state.\n\n5. **Documentation Comment**:\n   - The comment `/- ... -/` is a docstring that explains the purpose of the function. It states that `M.evalFrom s x` evaluates the automaton `M` with input `x` starting from the state `s`.\n\n6. **Implementation Placeholder**:\n   - The `:= sorry` part is a placeholder indicating that the implementation of the function is not yet provided. In a complete implementation, this would be replaced with the"}
{"source_file": "herald_data/sample_500.jsonl", "line": 454, "id": 410679, "informal_statement": "For any measure \\(\\mu\\) on a measurable space, prove that \\(\\frac{\\mu}{\\mu(\\Omega)}\\) is either the zero measure or a probability measure, where \\(\\Omega\\) denotes the entire space.", "formal_statement": "import Mathlib\nopen scoped ENNReal NNReal Topology\nopen Set MeasureTheory Measure Filter Function MeasurableSpace ENNReal\nopen scoped symmDiff\ninstance isZeroOrProbabilityMeasureSMul :\n    IsZeroOrProbabilityMeasure ((μ univ)⁻¹ • μ) := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understand the Context**: The informal statement involves a measure \\(\\mu\\) on a measurable space and the operation of scaling this measure by the inverse of its total measure \\(\\mu(\\Omega)\\). The goal is to show that this scaled measure is either the zero measure or a probability measure.\n\n2. **Identify the Components**:\n   - **Measure \\(\\mu\\)**: In Lean, measures are typically represented as objects of a certain type, often involving a measurable space.\n   - **Total Measure \\(\\mu(\\Omega)\\)**: This is the measure of the entire space, denoted as `μ univ` in Lean, where `univ` represents the universal set (entire space).\n   - **Scaling the Measure**: The operation \\(\\frac{\\mu}{\\mu(\\Omega)}\\) is represented as `((μ univ)⁻¹ • μ)` in Lean. Here, `•` denotes scalar multiplication of a measure by a real number, and `⁻¹` denotes taking the inverse.\n\n3. **Formalize the Statement**:\n   - **Zero Measure**: A measure is zero if it assigns zero to every measurable set.\n   - **Probability Measure**: A measure is a probability measure if it assigns a total measure of 1 to the entire space.\n\n4. **Translate to Lean**:\n   - **Type Class Instance**: The goal is to prove that the scaled measure is either zero or a probability measure. In Lean, this is often expressed using type classes. The type class `IsZeroOrProbabilityMeasure` is used to encapsulate this property.\n   - **Instance Declaration**: The line `instance isZeroOrProbabilityMeasureSMul : IsZeroOrProbabilityMeasure ((μ univ)⁻¹ • μ) := sorry` declares an instance of this type class for the scaled measure. The `sorry` indicates that the proof is omitted or yet to be completed.\n\n5. **Lean Imports and Setup**:\n   - **Imports**: The code begins with `import Mathlib`, which is necessary to access the mathematical libraries in Lean that provide definitions and theorems about measures, real numbers, and related concepts.\n   - **Namespaces and Scopes**: The `open` and `open scoped` commands bring various namespaces and notations into scope, such as"}
{"source_file": "herald_data/sample_500.jsonl", "line": 458, "id": 154743, "informal_statement": "For any semiring $R$, additive commutative monoid $N$, module $R$ over $N$, and decidable equality on the index type $\\iota$, consider a predicate $p : \\iota \\to \\mathsf{Prop}$ with decidable instances, a family of submodules $S : \\iota \\to \\mathsf{Submodule}\\ R\\ N$, a function $v$ that maps an element of the finitely supported type $\\Pi_0(i : \\iota), \\uparrow(S\\ i)$ to the submodule $S\\ i$, and an element $i \\in \\iota$ for which $p\\ i$ holds. Show that the image of $i$ under the additive monoid homomorphism from the filter linear map, which filters $v$ by $p$, lies in the supremum of the submodules $S\\ i$ for all $i$ satisfying $p\\ i$.", "formal_statement": "import Mathlib\nopen DFinsupp\nlemma biSup_eq_range_dfinsupp_lsum_tac_12618 [Semiring R] [AddCommMonoid N] [Module R N] [DecidableEq ι] (p : ι → Prop) [DecidablePred p] (S : ι → Submodule R N) (v : Π₀ (i : ι), ↥(S i)) (i : ι) (hp : p i) : ((fun i => (S i).subtype) i).toAddMonoidHom (((filterLinearMap R (fun i => ↥(S i)) p) v) i) ∈ ⨆ (_ : p i), S i := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it corresponds to the Lean constructs. Here's the step-by-step explanation:\n\n1. **Semiring, Additive Commutative Monoid, and Module:**\n   - The informal statement begins by specifying that \\( R \\) is a semiring, \\( N \\) is an additive commutative monoid, and \\( N \\) is a module over \\( R \\). In Lean, these are represented by typeclasses `[Semiring R]`, `[AddCommMonoid N]`, and `[Module R N]`. These typeclasses ensure that the necessary algebraic structures and operations are available for \\( R \\) and \\( N \\).\n\n2. **Decidable Equality on Index Type:**\n   - The index type \\( \\iota \\) has decidable equality, which is represented in Lean by `[DecidableEq ι]`. This allows Lean to decide whether two elements of type \\( \\iota \\) are equal.\n\n3. **Predicate with Decidable Instances:**\n   - The predicate \\( p : \\iota \\to \\mathsf{Prop} \\) with decidable instances is represented by `(p : ι → Prop)` and `[DecidablePred p]` in Lean. The `DecidablePred` typeclass ensures that for any \\( i : \\iota \\), it can be determined whether \\( p(i) \\) holds.\n\n4. **Family of Submodules:**\n   - The family of submodules \\( S : \\iota \\to \\mathsf{Submodule}\\ R\\ N \\) is directly translated to `(S : ι → Submodule R N)`. This indicates that for each index \\( i \\), there is a submodule \\( S(i) \\) of \\( N \\).\n\n5. **Finitely Supported Function:**\n   - The function \\( v \\) mapping elements of the finitely supported type to submodules is represented by `(v : Π₀ (i : ι), ↥(S i))`. The `Π₀` (pi-zero) type in Lean represents finitely supported functions, and `↥(S i)` denotes the elements of the submodule \\( S(i) \\).\n\n6. **Element with Predicate Holding:**\n   - The element \\( i \\in \\iota \\) for which \\( p"}
{"source_file": "herald_data/sample_500.jsonl", "line": 460, "id": 111768, "informal_statement": "For any element \\(a\\) in a semiring \\(R\\), any polynomials \\(p, r \\in R[X]\\), any natural number \\(n\\), and any element \\(b \\in R\\), show that the composition of the polynomial \\(C a \\times (\\text{monomial } n) b\\) with \\(r\\) is equal to \\(C a\\) multiplied by the composition of \\((\\text{monomial } n) b\\) with \\(r\\). In other words, \\((C a \\times (\\text{monomial } n) b) \\circ r = C a \\times ((\\text{monomial } n) b) \\circ r\\).", "formal_statement": "import Mathlib\nopen Finset AddMonoidAlgebra\nopen Polynomial\nlemma C_mul_comp_tac_17227 (a : R) [Semiring R] (p : R[X]) (r : R[X]) (n : ℕ) (b : R) : (C a * (monomial n) b).comp r = C a * ((monomial n) b).comp r := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and semantics.\n\n1. **Understanding the Context**:\n   - We are working within the context of a semiring \\( R \\). In Lean, this is represented by `[Semiring R]`, which is a typeclass constraint indicating that \\( R \\) is a semiring.\n\n2. **Elements and Polynomials**:\n   - The informal statement mentions elements \\( a \\) and \\( b \\) in \\( R \\), and polynomials \\( p \\) and \\( r \\) in \\( R[X] \\). In Lean, these are represented as `a : R`, `b : R`, `p : R[X]`, and `r : R[X]`. Here, `R[X]` denotes the type of polynomials with coefficients in \\( R \\).\n\n3. **Natural Number**:\n   - The natural number \\( n \\) is represented as `n : ℕ` in Lean, where `ℕ` is the type of natural numbers.\n\n4. **Polynomial Construction**:\n   - The informal statement involves constructing polynomials using constants and monomials. In Lean, `C a` represents the constant polynomial with value \\( a \\), and `(monomial n) b` represents the monomial \\( bX^n \\).\n\n5. **Polynomial Composition**:\n   - The composition of polynomials is denoted by `comp` in Lean. Thus, the composition \\((C a \\times (\\text{monomial } n) b) \\circ r\\) is written as `(C a * (monomial n) b).comp r`.\n\n6. **Equality Statement**:\n   - The goal is to show an equality between two polynomial compositions. In Lean, this is expressed using the equality operator `=`.\n\n7. **Formalizing the Statement**:\n   - The lemma is named `C_mul_comp_tac_17227`, which is a unique identifier for this particular result.\n   - The statement is then formalized as:\n     ```lean\n     lemma C_mul_comp_tac_17227 (a : R) [Semiring R] (p : R[X]) (r : R[X]) (n : ℕ) (b : R) :\n       (C a * (monomial n) b).comp r = C a"}
{"source_file": "herald_data/sample_500.jsonl", "line": 459, "id": 5814, "informal_statement": "For any quadratic space $(V, Q)$ over a commutative ring $R$, the change of form map from the Clifford algebra of $(V, Q)$ to itself, with respect to the zero proof of form equivalence, is the identity map on the Clifford algebra. In other words, $\\text{changeForm}^{\\text{zero\\_proof}} = \\text{id}_{\\text{CliffordAlgebra } Q}$, where $\\text{changeForm}^{\\text{zero\\_proof}}$ is the change of form map with the zero proof of form equivalence, and $\\text{id}_{\\text{CliffordAlgebra } Q}$ is the identity map on the Clifford algebra $\\text{CliffordAlgebra } Q$.", "formal_statement": "import Mathlib\nopen LinearMap (BilinMap BilinForm)\ntheorem changeForm_self_extracted [CommRing R] [AddCommGroup M] [Module R M]\n {Q : QuadraticForm R M} : CliffordAlgebra.changeForm ⋯ = LinearMap.id := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to break down the components of the statement and map them to their corresponding Lean constructs. Here's a step-by-step explanation of the translation process:\n\n1. **Understand the Context**: \n   - We are dealing with a quadratic space \\((V, Q)\\) over a commutative ring \\(R\\). In Lean, this is represented using a `QuadraticForm` over a module \\(M\\) with a commutative ring \\(R\\).\n\n2. **Identify the Structures**:\n   - The Clifford algebra associated with a quadratic form \\(Q\\) is a key structure. In Lean, this is represented by `CliffordAlgebra Q`.\n\n3. **Change of Form Map**:\n   - The change of form map is a function that modifies the quadratic form used to define the Clifford algebra. In Lean, this is represented by `CliffordAlgebra.changeForm`.\n\n4. **Zero Proof of Form Equivalence**:\n   - The \"zero proof of form equivalence\" implies that the change of form map is applied with no actual change, i.e., the identity transformation. This is represented by the identity map `LinearMap.id` in Lean.\n\n5. **Formalizing the Statement**:\n   - The theorem states that applying the change of form map with the zero proof of form equivalence results in the identity map on the Clifford algebra. This is expressed in Lean as `CliffordAlgebra.changeForm ⋯ = LinearMap.id`.\n\n6. **Lean Imports and Setup**:\n   - The necessary imports from Lean's math library are included to access the required algebraic structures and operations. Specifically, `Mathlib` is imported, and relevant modules like `LinearMap`, `BilinMap`, and `BilinForm` are opened to use their definitions directly.\n\n7. **Theorem Declaration**:\n   - The theorem is declared with the necessary type class constraints: `[CommRing R]`, `[AddCommGroup M]`, and `[Module R M]`. These ensure that \\(R\\) is a commutative ring, \\(M\\) is an additive commutative group, and \\(M\\) is a module over \\(R\\).\n\n8. **Formal Statement**:\n   - The formal statement in Lean is `theorem changeForm_self_extracted [CommRing R] [AddCommGroup M] [Module R M] {"}
{"source_file": "herald_data/sample_500.jsonl", "line": 464, "id": 554260, "informal_statement": "Prove by induction that $\\sum_{i=2}^{n}\\binom{i}{2}=\\frac{1}{6}n(n^2-1)$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_554260 (n : ℕ) : ∑ i in Finset.Icc 2 n, (i.choose 2) = n * (n^2 - 1) / 6   :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Informal Statement**: \n   - The statement is about proving an identity involving a summation and binomial coefficients. Specifically, it states that the sum of binomial coefficients $\\binom{i}{2}$ from $i = 2$ to $i = n$ is equal to $\\frac{1}{6}n(n^2-1)$.\n\n2. **Identifying the Components**:\n   - **Summation**: The sum is over the range from 2 to n.\n   - **Binomial Coefficient**: $\\binom{i}{2}$ is the binomial coefficient, which can be expressed in Lean as `i.choose 2`.\n   - **Expression on the Right**: The right-hand side of the equation is a polynomial expression in $n$, specifically $\\frac{1}{6}n(n^2-1)$.\n\n3. **Translating to Lean**:\n   - **Imports and Setup**: \n     - `import Mathlib` is used to bring in necessary mathematical libraries.\n     - `open BigOperators` allows the use of summation notation.\n     - `open Real Nat Topology` is used to access real numbers, natural numbers, and topological concepts, though not all may be necessary for this specific theorem.\n\n   - **Theorem Declaration**:\n     - `theorem extract_aug_554260 (n : ℕ) : ...` declares a theorem named `extract_aug_554260` with a parameter `n` of type `ℕ` (natural numbers).\n\n   - **Summation in Lean**:\n     - `∑ i in Finset.Icc 2 n, (i.choose 2)` represents the sum of `i.choose 2` for `i` in the closed interval from 2 to `n`. `Finset.Icc 2 n` creates a finite set of integers from 2 to `n`.\n\n   - **Right-hand Side Expression**:\n     - `n * (n^2 - 1) / 6` is the Lean representation of the polynomial expression $\\frac{1}{6}n(n^2-1)$. Lean uses `*` for multiplication and `/` for division.\n\n4. **Proof Placeholder**:\n   - `:= by sorry` indicates that the proof is not yet"}
{"source_file": "herald_data/sample_500.jsonl", "line": 465, "id": 498190, "informal_statement": "The function $f(x)=0,\\forall x\\in \\mathbb{R}$ it is clearly accepted.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_498190 : ∃ f : ℝ → ℝ, ∀ x, f x = 0   :=  by sorry", "explanation": "To translate the informal statement \"The function \\( f(x) = 0, \\forall x \\in \\mathbb{R} \\) is clearly accepted\" into Lean, we need to formalize the existence of a function \\( f \\) from the real numbers to the real numbers such that for every real number \\( x \\), \\( f(x) = 0 \\).\n\n1. **Existence of a Function**: The informal statement implies the existence of a function \\( f \\). In Lean, we express existence using the existential quantifier `∃`. Therefore, we start with `∃ f : ℝ → ℝ`, which states that there exists a function \\( f \\) from the real numbers to the real numbers.\n\n2. **Universal Quantification**: The statement \\( \\forall x \\in \\mathbb{R}, f(x) = 0 \\) indicates that for every real number \\( x \\), the function \\( f \\) evaluates to 0. In Lean, universal quantification is expressed using `∀`. Thus, we write `∀ x, f x = 0`, which means for all real numbers \\( x \\), \\( f(x) = 0 \\).\n\n3. **Combining Existence and Universality**: The combination of the existential quantifier and the universal quantifier gives us the full statement: `∃ f : ℝ → ℝ, ∀ x, f x = 0`. This states that there exists a function \\( f \\) such that for every real number \\( x \\), \\( f(x) = 0 \\).\n\n4. **Theorem Declaration**: In Lean, we declare this as a theorem. The theorem is named `extract_aug_498190`, which is a placeholder name. The statement of the theorem is followed by `:=` to indicate the beginning of the proof, which is currently left as `by sorry`, indicating that the proof is not yet provided.\n\n5. **Imports and Namespace**: The code begins with `import Mathlib` to include necessary mathematical libraries. The `open` statements (`open BigOperators`, `open Real`, `open Nat`, `open Topology`) are used to bring various mathematical notations and definitions into scope, which might be useful for the proof or related work.\n\nOverall, the Lean code formalizes the existence of a constant zero function over the real numbers, aligning with the informal statement."}
{"source_file": "herald_data/sample_500.jsonl", "line": 461, "id": 456822, "informal_statement": "Let $ a,b $ be nonnegative real numbers such that $a^2+b^2 = a^5+b^5$ . Prove that $ a^2+b^2\\le 2 .$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_456822 (a b : ℝ) (ha : 0 ≤ a) (hb : 0 ≤ b) (hab : a^2 + b^2 = a^5 + b^5) : a^2 + b^2 ≤ 2  :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow a structured approach to ensure that all components of the problem are accurately represented in the formal language. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves two variables, \\( a \\) and \\( b \\), which are specified as nonnegative real numbers. In Lean, real numbers are represented by the type `ℝ`.\n   - We declare these variables in Lean as `(a b : ℝ)`.\n\n2. **Express the Nonnegativity Condition**:\n   - The condition that \\( a \\) and \\( b \\) are nonnegative is expressed as \\( 0 \\le a \\) and \\( 0 \\le b \\).\n   - In Lean, these conditions are represented as `(ha : 0 ≤ a)` and `(hb : 0 ≤ b)`.\n\n3. **Translate the Given Equation**:\n   - The equation \\( a^2 + b^2 = a^5 + b^5 \\) is a crucial part of the problem statement.\n   - In Lean, this is expressed as `(hab : a^2 + b^2 = a^5 + b^5)`.\n\n4. **State the Conclusion to be Proved**:\n   - The goal is to prove that \\( a^2 + b^2 \\le 2 \\).\n   - In Lean, this is written as `a^2 + b^2 ≤ 2`.\n\n5. **Structure the Theorem**:\n   - We encapsulate the entire problem in a theorem named `extract_aug_456822`. The name is arbitrary and can be chosen to reflect the context or source of the problem.\n   - The theorem takes the variables \\( a \\) and \\( b \\), along with the conditions `ha`, `hb`, and `hab`, as inputs and asserts the conclusion `a^2 + b^2 ≤ 2`.\n\n6. **Use of Lean's Libraries**:\n   - The import statements `import Mathlib`, `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are included to ensure that all necessary mathematical operations and types are available. These libraries provide the definitions and theorems related to real numbers, arithmetic operations, and inequalities.\n\n7. **Proof Placeholder**:\n   - The `by sorry` at the end of the theorem"}
{"source_file": "herald_data/sample_500.jsonl", "line": 467, "id": 261307, "informal_statement": "For any strict ordered commutative ring $R$, additive commutative group $V$, and $R$-module structure on $V$, along with an additive torsor structure of $V$ on a set $P$, let $s$ be an affine subspace in $P$ defined over $R$, $x$ and $y$ be elements in $P$, and $v$ be a vector in $V$ such that $v$ is in the direction of $s$. Show that $x$ and $y$ are on the same side of $s$ if and only if $x$ and $y$ are on the same side of $s$ after adding $v$ to both $x$ and $y$.", "formal_statement": "import Mathlib\nopen AffineEquiv AffineMap\nlemma wSameSide_vadd_right_iff_tac_10112 [StrictOrderedCommRing R] [AddCommGroup V] [Module R V] [AddTorsor V P] (s : AffineSubspace R P) (x : P) (y : P) (v : V) (hv : v ∈ s.direction) : s.WSameSide x y ↔ s.WSameSide x y := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it corresponds to the Lean4 constructs:\n\n1. **Strict Ordered Commutative Ring $R$**: In Lean, this is represented by the type class `StrictOrderedCommRing R`. This indicates that $R$ is a commutative ring with a strict order.\n\n2. **Additive Commutative Group $V$**: This is represented by the type class `AddCommGroup V` in Lean. It specifies that $V$ is a group under addition and that the addition operation is commutative.\n\n3. **$R$-module structure on $V$**: This is captured by the type class `Module R V` in Lean, which indicates that $V$ is a module over the ring $R$.\n\n4. **Additive torsor structure of $V$ on a set $P$**: This is represented by the type class `AddTorsor V P` in Lean. An additive torsor is a set $P$ with a free and transitive action by the additive group $V$.\n\n5. **Affine subspace $s$ in $P$ defined over $R$**: In Lean, an affine subspace is represented by `AffineSubspace R P`. This indicates that $s$ is a subspace of the affine space $P$ over the ring $R$.\n\n6. **Elements $x$ and $y$ in $P$**: These are simply variables of type `P` in Lean, representing points in the affine space.\n\n7. **Vector $v$ in $V$ such that $v$ is in the direction of $s$**: The vector $v` is of type `V`, and the condition that it is in the direction of $s` is expressed by the hypothesis `hv : v ∈ s.direction`. Here, `s.direction` gives the direction vector space of the affine subspace $s`.\n\n8. **Same side condition**: The condition that $x$ and $y$ are on the same side of $s$ is represented by `s.WSameSide x y` in Lean. This is a predicate that checks whether the points $x$ and $y$ lie on the same side of the affine subspace $s`.\n\n9. **Adding $v$"}
{"source_file": "herald_data/sample_500.jsonl", "line": 463, "id": 184434, "informal_statement": "For any real number satisfying \\(0 < \\frac{3}{2}\\), show that \\(\\frac{1}{2} \\leq 1\\).", "formal_statement": "import Mathlib\nopen Filter Set MeasureTheory\nopen scoped Nat ENNReal Topology Real\nlemma Gamma_three_div_two_lt_one_tac_16138 (A : 0 < 3 / 2) : 1 / 2 ≤ 1 := sorry", "explanation": "To translate the informal statement into the formal Lean4 code, we follow these steps:\n\n1. **Identify the Core Mathematical Statement**: The informal statement is essentially asking us to show that \\(\\frac{1}{2} \\leq 1\\), given the condition \\(0 < \\frac{3}{2}\\). The condition \\(0 < \\frac{3}{2}\\) is trivially true since \\(\\frac{3}{2}\\) is a positive real number. Therefore, the core mathematical statement to prove is \\(\\frac{1}{2} \\leq 1\\).\n\n2. **Formalize the Given Condition**: In Lean, we express the condition \\(0 < \\frac{3}{2}\\) using the syntax `0 < 3 / 2`. This is a straightforward translation of the inequality into Lean's syntax for real numbers.\n\n3. **Formalize the Conclusion**: The conclusion \\(\\frac{1}{2} \\leq 1\\) is directly translated into Lean as `1 / 2 ≤ 1`. This uses Lean's syntax for expressing inequalities between real numbers.\n\n4. **Structure the Lemma**: In Lean, we encapsulate the statement we want to prove within a `lemma`. The lemma is named `Gamma_three_div_two_lt_one_tac_16138`, which is a unique identifier for this particular statement. The name is arbitrary and can be chosen to reflect the content or context of the lemma.\n\n5. **Specify the Hypothesis and Conclusion**: The hypothesis `A : 0 < 3 / 2` is included in the lemma's parameters, indicating that this is a given condition for the lemma. The conclusion `1 / 2 ≤ 1` follows the colon `:` in the lemma declaration, indicating what we need to prove.\n\n6. **Use of `sorry`**: The keyword `sorry` is used as a placeholder in Lean to indicate that the proof is not yet provided. It allows the code to compile without errors, even though the proof is incomplete.\n\n7. **Import Necessary Libraries**: The code begins with importing several libraries such as `Mathlib`, and opening namespaces like `Filter`, `Set`, `MeasureTheory`, etc. These imports are standard in Lean to provide access to a wide range of mathematical definitions and theorems, although they are not directly used in this simple lemma.\n\nIn summary, the formal statement in Lean"}
{"source_file": "herald_data/sample_500.jsonl", "line": 462, "id": 229475, "informal_statement": "For any functions $f : \\alpha \\to \\beta$ and $g : \\beta \\to \\gamma$, show that the range of the composition $g \\circ f$ is a subset of the range of $g$, i.e., $\\text{range}(g \\circ f) \\subseteq \\text{range}(g)$.", "formal_statement": "import Mathlib\nopen Function Set\nopen scoped symmDiff in\nopen scoped symmDiff in\nopen scoped symmDiff in\nlemma range_comp_subset_range_tac_25153 (f : α → β) (g : β → γ) : range (g ∘ f) ⊆ range g := sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow these steps:\n\n1. **Understand the Informal Statement**: The statement involves two functions, \\( f : \\alpha \\to \\beta \\) and \\( g : \\beta \\to \\gamma \\). We are asked to show that the range of the composition \\( g \\circ f \\) is a subset of the range of \\( g \\).\n\n2. **Identify Key Concepts**: \n   - **Functions and Composition**: \\( g \\circ f \\) denotes the composition of \\( f \\) and \\( g \\), which is a function from \\( \\alpha \\) to \\( \\gamma \\).\n   - **Range of a Function**: The range of a function \\( h : X \\to Y \\) is the set of all values \\( h(x) \\) for \\( x \\in X \\).\n   - **Subset Relation**: The statement requires proving that every element in the range of \\( g \\circ f \\) is also in the range of \\( g \\).\n\n3. **Translate to Lean4 Syntax**:\n   - **Import Necessary Modules**: We import `Mathlib` to access mathematical definitions and theorems. We also open the `Function` and `Set` namespaces to use function and set operations conveniently.\n   - **Define the Lemma**: We declare a lemma named `range_comp_subset_range_tac_25153` with parameters \\( f \\) and \\( g \\) of types \\( \\alpha \\to \\beta \\) and \\( \\beta \\to \\gamma \\), respectively.\n   - **State the Goal**: The goal is to prove `range (g ∘ f) ⊆ range g`. In Lean, `range` is a function that takes a function and returns its range as a set. The subset relation is denoted by `⊆`.\n\n4. **Formalize the Proof Structure**:\n   - The lemma is stated with a `sorry` placeholder, indicating that the proof is not yet provided. In a complete formalization, this would be replaced with a proof showing that for any \\( x \\in \\alpha \\), \\( (g \\circ f)(x) \\) is in the range of \\( g \\).\n\n5. **Lean4 Code Explanation**:\n   - `import Mathlib`: Imports the Mathlib library for mathematical constructs.\n   - `open Function Set`: Opens the `Function"}
{"source_file": "herald_data/sample_500.jsonl", "line": 469, "id": 489693, "informal_statement": "$x_i>0,i=1,...,n,n\\geq 3$ ,prove that: $\\prod_{i=1}^n{x_i}(\\sum_{i=1}^n{\\frac{1}{x_i(x_i+n)}})\\le \\frac{n}{n+1}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_489693 (n : ℕ) (x : ℕ → ℝ) (hx : ∀ i, x i > 0) (hn : 3 ≤ n): (∏ i in Finset.range n, x i) * (∑ i in Finset.range n, (1 / (x i * (x i + n)))) ≤ n / (n + 1)  :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to carefully map each component of the informal statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Variables and Quantifiers:**\n   - The informal statement involves a sequence of positive real numbers \\( x_i \\) for \\( i = 1, \\ldots, n \\) with \\( n \\geq 3 \\).\n   - In Lean, we represent the sequence \\( x_i \\) as a function `x : ℕ → ℝ`, where `x i` gives the \\( i \\)-th element of the sequence.\n\n2. **Constraints on Variables:**\n   - The condition \\( x_i > 0 \\) for all \\( i \\) is expressed in Lean as a hypothesis `hx : ∀ i, x i > 0`.\n   - The condition \\( n \\geq 3 \\) is expressed as `hn : 3 ≤ n`.\n\n3. **Product and Sum Notation:**\n   - The product \\(\\prod_{i=1}^n x_i\\) is represented using Lean's `∏` notation, specifically `∏ i in Finset.range n, x i`. This uses `Finset.range n` to iterate over the indices from 0 to \\( n-1 \\).\n   - The sum \\(\\sum_{i=1}^n \\frac{1}{x_i(x_i+n)}\\) is represented using Lean's `∑` notation, specifically `∑ i in Finset.range n, (1 / (x i * (x i + n)))`.\n\n4. **Inequality to Prove:**\n   - The inequality \\(\\prod_{i=1}^n x_i \\cdot \\sum_{i=1}^n \\frac{1}{x_i(x_i+n)} \\le \\frac{n}{n+1}\\) is directly translated into Lean as:\n     ```lean\n     (∏ i in Finset.range n, x i) * (∑ i in Finset.range n, (1 / (x i * (x i + n)))) ≤ n / (n + 1)\n     ```\n\n5. **Theorem Declaration:**\n   - The theorem is declared with a name `extract_aug_489693` and includes the necessary imports for"}
{"source_file": "herald_data/sample_500.jsonl", "line": 470, "id": 139820, "informal_statement": "For any categories $C$, $D$, and $E$ with monoidal structures, and for any lax monoidal functors $F: C \\to D$ and $G: D \\to E$, and for any objects $X, Y, Z \\in C$, show that the following diagram commutes:\n\\[\n\\begin{tikzcd}\nG(F(X) \\otimes F(Y)) \\ar[r, \"G(\\mu_{X,Y})\"] \\ar[d, \"G(F(\\alpha_{X,Y,Z}))\"'] & G(F(X \\otimes Y)) \\ar[d, \"G(F(\\alpha_{X \\otimes Y, Z}))\"] \\\\\nG(F(X)) \\otimes G(F(Y) \\otimes F(Z)) \\ar[r, \"G(\\mu_{Y,Z})\"] & G(F(X)) \\otimes G(F(Y \\otimes Z))\n\\end{tikzcd}\n\\]\nwhere $\\mu$ denotes the monoidal structure of the lax monoidal functors, $\\alpha$ denotes the associativity isomorphism in $C$, and $F(\\alpha_{X,Y,Z}).\\hom$ denotes the morphism component of the natural transformation $F(\\alpha)$ applied to $X, Y, Z$.", "formal_statement": "import Mathlib\nopen CategoryTheory\nopen CategoryTheory.Category\nopen CategoryTheory.Functor\nopen MonoidalCategory\nopen MonoidalCategory\nlemma comp_tac_17066 [Category.{v₁, u₁} C] [MonoidalCategory C] [Category.{v₂, u₂} D] [MonoidalCategory D] [Category.{v₃, u₃} E] [MonoidalCategory E] (F : LaxMonoidalFunctor C D) (G : LaxMonoidalFunctor D E) (X : C) (Y : C) (Z : C) : G.μ (F.obj X) (F.obj Y) ▷ G.obj (F.obj Z) ≫\n    G.μ (F.obj X ⊗ F.obj Y) (F.obj Z) ≫\n      G.map (F.μ X Y ▷ F.obj Z) ≫ G.map (F.μ (X ⊗ Y) Z) ≫ G.map (F.map (α_ X Y Z).hom) =\n  (α_ (G.obj (F.obj X)) (G.obj (F.obj Y)) (G.obj (F.obj Z))).hom ≫\n    G.obj (F.obj X) ◁ (G.μ (F.obj Y) (F.obj Z) ≫ G.map (F.μ Y Z)) ≫\n      G.μ (F.obj X) (F.obj (Y ⊗ Z)) ≫ G.map (F.μ X (Y ⊗ Z)) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to carefully consider the components involved in the diagram and how they correspond to the elements in the Lean code. Here's a step-by-step explanation of the translation process:\n\n1. **Categories and Monoidal Structures**: \n   - The informal statement involves categories \\( C \\), \\( D \\), and \\( E \\) with monoidal structures. In Lean, these are represented by the typeclasses `[Category.{v₁, u₁} C]`, `[MonoidalCategory C]`, and similarly for \\( D \\) and \\( E \\). The `Category` typeclass provides the basic categorical structure, while `MonoidalCategory` adds the monoidal structure.\n\n2. **Lax Monoidal Functors**:\n   - The functors \\( F: C \\to D \\) and \\( G: D \\to E \\) are lax monoidal functors. In Lean, these are represented by `LaxMonoidalFunctor C D` and `LaxMonoidalFunctor D E`. These functors preserve the monoidal structure up to specified natural transformations.\n\n3. **Objects in the Category**:\n   - The objects \\( X, Y, Z \\in C \\) are represented in Lean as variables of type `C`, i.e., `(X : C)`, `(Y : C)`, `(Z : C)`.\n\n4. **Diagram Components**:\n   - The diagram involves morphisms that are constructed using the monoidal structure of the functors and the associativity isomorphism in \\( C \\).\n\n5. **Monoidal Structure of Functors**:\n   - The morphism \\( G(F(X) \\otimes F(Y)) \\to G(F(X \\otimes Y)) \\) is represented by `G.μ (F.obj X) (F.obj Y)`, where `G.μ` is the monoidal structure map of the functor \\( G \\).\n\n6. **Associativity Isomorphism**:\n   - The associativity isomorphism \\( \\alpha_{X,Y,Z} \\) in \\( C \\) is represented by `(α_ X Y Z).hom` in Lean. The `α_` is a notation for the associativity isomorphism in a monoidal category.\n\n7. **Commutative Diagram**:\n   - The goal is to show that a certain composition of morphisms is equal to another"}
{"source_file": "herald_data/sample_500.jsonl", "line": 468, "id": 127257, "informal_statement": "For any nontrivially normed field $\\mathbb{K}$, normed additive commutative group $E$, normed space $\\mathbb{K} E$, and topological spaces $H$ and $M$, given a partial homeomorphism $f$ from $M$ to $H$, a model with corners $I$ over $\\mathbb{K} E$ in $H$, a point $x$ in $M$, and the hypothesis that $x$ belongs to the source of $f$, show that $x$ is indeed in the source of $f$.", "formal_statement": "import Mathlib\nopen Set Filter Function\nopen scoped Manifold Filter Topology\nopen TopologicalSpace\nopen TopologicalSpace\nopen scoped Topology\nlemma extend_source_mem_nhds_tac_37654 [NontriviallyNormedField 𝕜] [NormedAddCommGroup E] [NormedSpace 𝕜 E] [TopologicalSpace H] [TopologicalSpace M] (f : PartialHomeomorph M H) (I : ModelWithCorners 𝕜 E H) (x : M) (h : x ∈ f.source) : x ∈ f.source := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Mathematical Structures:**\n   - The informal statement involves several mathematical structures: a nontrivially normed field $\\mathbb{K}$, a normed additive commutative group $E$, a normed space $\\mathbb{K} E$, and topological spaces $H$ and $M$.\n   - In Lean, these are represented by type classes and instances. Specifically:\n     - `NontriviallyNormedField 𝕜` represents the nontrivially normed field $\\mathbb{K}$.\n     - `NormedAddCommGroup E` represents the normed additive commutative group $E$.\n     - `NormedSpace 𝕜 E` represents the normed space $\\mathbb{K} E$.\n     - `TopologicalSpace H` and `TopologicalSpace M` represent the topological spaces $H$ and $M$.\n\n2. **Define the Partial Homeomorphism:**\n   - The informal statement mentions a partial homeomorphism $f$ from $M$ to $H$. In Lean, this is represented by `PartialHomeomorph M H`, which is a structure that includes a function and its inverse, both continuous, with specified domains and codomains.\n\n3. **Model with Corners:**\n   - The model with corners $I$ over $\\mathbb{K} E$ in $H$ is represented by `ModelWithCorners 𝕜 E H` in Lean. This structure is used in the context of manifolds to handle charts and coordinate changes.\n\n4. **Point and Hypothesis:**\n   - The point $x$ in $M$ is simply a variable of type `M`.\n   - The hypothesis that $x$ belongs to the source of $f$ is expressed as `h : x ∈ f.source`.\n\n5. **Conclusion:**\n   - The conclusion is to show that $x$ is in the source of $f$, which is trivially true given the hypothesis. In Lean, this is expressed as `x ∈ f.source`.\n\n6. **Formalizing the Lemma:**\n   - The lemma is named `extend_source_mem_nhds_tac_37654`, which is a placeholder name.\n   - The lemma takes the structures and hypothesis as"}
{"source_file": "herald_data/sample_500.jsonl", "line": 466, "id": 52660, "informal_statement": "Show that the canonical map from a space \\(X\\) equipped with the property \\(P\\) as a compact Hausdorff-like space back to its underlying type is the identity map, i.e., the space \\(X\\) as a compact Hausdorff-like space with property \\(P\\) is identified with its underlying type \\(X\\).", "formal_statement": "import Mathlib\nopen CategoryTheory\ntheorem coe_of_extracted (P : TopCat → Prop) (X : Type u) [TopologicalSpace X] [CompactSpace X] [T2Space X]\n [CompHausLike.HasProp P X] : ↑(CompHausLike.of P X).toTop = X := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand the components involved in both the informal and formal statements and how they correspond to each other. Here's a step-by-step explanation:\n\n1. **Understanding the Informal Statement:**\n   - We have a space \\(X\\) with a property \\(P\\).\n   - The space is described as \"compact Hausdorff-like,\" which suggests it has properties similar to a compact Hausdorff space.\n   - The task is to show that the canonical map from this space, when considered with property \\(P\\), back to its underlying type is the identity map. This means that the space with the additional structure is essentially the same as the original space \\(X\\).\n\n2. **Identifying Key Components:**\n   - **Space \\(X\\):** This is a type equipped with a topological structure.\n   - **Property \\(P\\):** A property that the space \\(X\\) satisfies, which is relevant in the context of compact Hausdorff-like spaces.\n   - **Canonical Map:** A map that takes the structured space back to its underlying type, which in this case should be the identity map.\n\n3. **Formalizing in Lean4:**\n   - **Imports and Setup:**\n     - `import Mathlib` and `open CategoryTheory` are used to bring in necessary libraries and open the category theory namespace, which is likely where the `CompHausLike` structure is defined.\n   \n   - **Theorem Declaration:**\n     - `theorem coe_of_extracted` is the name of the theorem, indicating that we are dealing with a coercion or extraction from a structured space.\n   \n   - **Parameters:**\n     - `(P : TopCat → Prop)`: This defines \\(P\\) as a property applicable to topological categories (`TopCat`).\n     - `(X : Type u)`: \\(X\\) is a type in some universe `u`.\n     - `[TopologicalSpace X]`: \\(X\\) is equipped with a topological space structure.\n     - `[CompactSpace X]`: \\(X\\) is a compact space.\n     - `[T2Space X]`: \\(X\\) is a Hausdorff space (T2 space).\n     - `[CompHausLike.HasProp P X]`: \\(X\\) satisfies the property \\(P\\) in the context of being compact Hausdorff-like."}
{"source_file": "herald_data/sample_500.jsonl", "line": 472, "id": 568085, "informal_statement": "Find the value of $f(100)$ if $f(n) = \\frac{n+1}{n-1}$ for all positive integers $n > 1$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_568085 (f : ℕ → ℝ) (hf : ∀ n, 1 < n → f n = (n + 1) / (n - 1)) : f 100 = 101 / 99   :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we follow these steps:\n\n1. **Identify the Function and Domain**: The informal statement defines a function \\( f(n) = \\frac{n+1}{n-1} \\) for all positive integers \\( n > 1 \\). This indicates that \\( f \\) is a function from natural numbers (ℕ) to real numbers (ℝ), with the condition that it is only defined for \\( n > 1 \\).\n\n2. **Define the Function in Lean**: In Lean, we represent this function as `f : ℕ → ℝ`, indicating that \\( f \\) takes a natural number and returns a real number. The condition \\( n > 1 \\) is expressed in Lean as `1 < n`.\n\n3. **Express the Function's Formula**: The formula \\( f(n) = \\frac{n+1}{n-1} \\) is translated into Lean as `f n = (n + 1) / (n - 1)`. This is expressed in the hypothesis `hf : ∀ n, 1 < n → f n = (n + 1) / (n - 1)`, which states that for all natural numbers \\( n \\) greater than 1, the function \\( f \\) satisfies this equation.\n\n4. **State the Goal**: The goal is to find the value of \\( f(100) \\). In Lean, this is expressed as `f 100 = 101 / 99`. This is the conclusion of the theorem, which we aim to prove.\n\n5. **Structure the Theorem**: The theorem is structured as follows:\n   - `theorem extract_aug_568085`: This is the name of the theorem.\n   - `(f : ℕ → ℝ)`: This declares the function \\( f \\) from natural numbers to real numbers.\n   - `(hf : ∀ n, 1 < n → f n = (n + 1) / (n - 1))`: This is the hypothesis that defines the behavior of \\( f \\) for \\( n > 1 \\).\n   - `: f 100 = 101 / 99`: This is the statement we want to prove, that \\( f(100) = \\frac{101}{99} \\).\n\n6. **Proof Placeholder**: The `:= by sorry`"}
{"source_file": "herald_data/sample_500.jsonl", "line": 471, "id": 498288, "informal_statement": "Let $x>0.$ Prove that $x+\\frac{8}{x}-\\frac{1}{x+1} \\geq 6\\sqrt{3}-5$. Equality occurs when $x=\\sqrt{3}+1$.", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_498288 (x : ℝ) (hx : 0 < x) : x + 8 / x - 1 / (x + 1) ≥ 6 * Real.sqrt 3 - 5   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4 code, we need to follow a series of steps to ensure that each component of the informal statement is accurately represented in the formal language of Lean. Here's the step-by-step explanation:\n\n1. **Identify the Variables and Assumptions:**\n   - The informal statement begins with \"Let \\( x > 0 \\).\" This indicates that \\( x \\) is a positive real number. In Lean, we represent real numbers using the type `ℝ` and the condition \\( x > 0 \\) is expressed as `0 < x`.\n\n2. **Translate the Expression:**\n   - The expression to be proven is \\( x + \\frac{8}{x} - \\frac{1}{x+1} \\geq 6\\sqrt{3} - 5 \\).\n   - In Lean, addition, subtraction, and division are expressed using `+`, `-`, and `/`, respectively. The square root function is represented by `Real.sqrt`.\n   - Therefore, the expression becomes `x + 8 / x - 1 / (x + 1) ≥ 6 * Real.sqrt 3 - 5`.\n\n3. **Structure the Theorem:**\n   - The theorem is named `extract_aug_498288`, which is a unique identifier for this particular result.\n   - The theorem takes a single argument `x : ℝ`, indicating that \\( x \\) is a real number.\n   - The assumption `hx : 0 < x` is included to represent the condition \\( x > 0 \\).\n\n4. **State the Conclusion:**\n   - The conclusion of the theorem is the inequality `x + 8 / x - 1 / (x + 1) ≥ 6 * Real.sqrt 3 - 5`.\n   - This is the main statement that needs to be proven under the given assumption.\n\n5. **Use of Lean Libraries:**\n   - The `import Mathlib` statement is used to include the necessary mathematical libraries that provide definitions and theorems for real numbers, arithmetic operations, and other mathematical constructs.\n   - The `open BigOperators`, `open Real`, `open Nat`, and `open Topology` statements are used to bring various mathematical notations and operations into scope, making them easier to use in the theorem.\n\n6. **Proof Placeholder:**\n   - The `:= by sorry` part indicates that the proof is not yet"}
{"source_file": "herald_data/sample_500.jsonl", "line": 475, "id": 540429, "informal_statement": "Prove that for all real $x,y,z$ $\\frac{x^2-y^2}{2x^2+1}+\\frac{y^2-z^2}{2y^2+1}+\\frac{z^2-x^2}{2z^2+1}\\leq 0$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_540429 (x y z : ℝ) :\n  (x^2 - y^2) / (2 * x^2 + 1) + (y^2 - z^2) / (2 * y^2 + 1) + (z^2 - x^2) / (2 * z^2 + 1) ≤ 0   :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The informal statement involves three variables \\(x\\), \\(y\\), and \\(z\\), which are specified as real numbers. In Lean, real numbers are represented by the type `ℝ`.\n\n2. **Structure of the Statement**:\n   - The statement is a universal quantification over all real numbers \\(x\\), \\(y\\), and \\(z\\). In Lean, this is expressed by taking \\(x\\), \\(y\\), and \\(z\\) as arguments to the theorem.\n\n3. **Mathematical Expression**:\n   - The expression to be proved is \\(\\frac{x^2-y^2}{2x^2+1}+\\frac{y^2-z^2}{2y^2+1}+\\frac{z^2-x^2}{2z^2+1}\\leq 0\\).\n   - In Lean, arithmetic operations and expressions are written using standard mathematical symbols, with some differences:\n     - Exponentiation is written using the `^` operator.\n     - Division is represented by the `/` operator.\n     - Addition and subtraction are represented by `+` and `-`, respectively.\n\n4. **Formalizing the Expression**:\n   - The expression \\((x^2 - y^2) / (2x^2 + 1)\\) is written in Lean as `(x^2 - y^2) / (2 * x^2 + 1)`.\n   - Similarly, \\((y^2 - z^2) / (2y^2 + 1)\\) is written as `(y^2 - z^2) / (2 * y^2 + 1)`.\n   - And \\((z^2 - x^2) / (2z^2 + 1)\\) is written as `(z^2 - x^2) / (2 * z^2 + 1)`.\n\n5. **Combining the Expressions**:\n   - The sum of these three expressions is written as:\n     ```lean\n     (x^2 - y^2) / (2 * x^2 + 1) + (y^2 - z^2) / (2 * y^2 + 1) + (z^"}
{"source_file": "herald_data/sample_500.jsonl", "line": 474, "id": 475113, "informal_statement": "Problem 2:PKH: For all $ a,b,c\\ge 0$ and $ a+b+c=1$ we have $ \\sqrt{a+\\frac{(b-c)^2}{4}}+\\sqrt{b+\\frac{(c-a)^2}{4}}+\\sqrt{c+\\frac{(a-b)^2}{4}}\\le 2$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_475113 (a b c : ℝ) (ha : 0 ≤ a) (hb : 0 ≤ b) (hc : 0 ≤ c) (hab : a + b + c = 1) :  Real.sqrt (a + (b - c) ^ 2 / 4) + Real.sqrt (b + (c - a) ^ 2 / 4) + Real.sqrt (c + (a - b) ^ 2 / 4) ≤ 2  :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to break down each component of the problem and understand how it is represented in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Variables and Conditions**:\n   - The problem involves three non-negative real numbers \\( a, b, c \\) such that \\( a + b + c = 1 \\).\n   - In Lean, we declare these variables as real numbers using `(a b c : ℝ)`.\n   - The non-negativity conditions \\( a, b, c \\ge 0 \\) are expressed as `(ha : 0 ≤ a)`, `(hb : 0 ≤ b)`, and `(hc : 0 ≤ c)`.\n\n2. **Expressing the Sum Condition**:\n   - The condition \\( a + b + c = 1 \\) is directly translated to `(hab : a + b + c = 1)`.\n\n3. **Formulating the Expression**:\n   - The expression to be evaluated is \\( \\sqrt{a+\\frac{(b-c)^2}{4}} + \\sqrt{b+\\frac{(c-a)^2}{4}} + \\sqrt{c+\\frac{(a-b)^2}{4}} \\).\n   - In Lean, the square root function is `Real.sqrt`.\n   - The expression is translated as `Real.sqrt (a + (b - c) ^ 2 / 4) + Real.sqrt (b + (c - a) ^ 2 / 4) + Real.sqrt (c + (a - b) ^ 2 / 4)`.\n\n4. **Stating the Inequality**:\n   - The goal is to show that the sum of these square roots is less than or equal to 2.\n   - This is expressed in Lean as `≤ 2`.\n\n5. **Constructing the Theorem**:\n   - The theorem is named `extract_aug_475113`, which is a placeholder name and can be replaced with a more descriptive one.\n   - The theorem statement combines all the above components: the variables, their conditions, the expression, and the inequality.\n   - The full theorem statement is:\n     ```lean\n     theorem extract_aug_475113 (a b c : ℝ) (ha : 0 ≤ a) (hb : 0 ≤ b) (hc : 0 ≤ c) (hab : a"}
{"source_file": "herald_data/sample_500.jsonl", "line": 477, "id": 478622, "informal_statement": "If $0\\leq x,y,z \\leq 1$ , prove that the following inequality holds: $\\frac{x}{1+y+z}+\\frac{y}{1+z+x}+\\frac{z}{1+x+y}+(1-x)(1-y)(1-z) \\leq 1 $", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_478622 (x y z : ℝ) (hx : 0 ≤ x ∧ x ≤ 1) (hy : 0 ≤ y ∧ y ≤ 1) (hz : 0 ≤ z ∧ z ≤ 1) : x / (1 + y + z) + y / (1 + z + x) + z / (1 + x + y) + (1 - x) * (1 - y) * (1 - z) ≤ 1  :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Understand the Variables and Domain**: \n   - The variables \\( x, y, z \\) are real numbers constrained by \\( 0 \\leq x, y, z \\leq 1 \\). This means each variable is within the closed interval \\([0, 1]\\).\n\n2. **Formalize the Variables and Constraints**:\n   - In Lean, we declare \\( x, y, z \\) as real numbers using `(x y z : ℝ)`.\n   - The constraints \\( 0 \\leq x \\leq 1 \\), \\( 0 \\leq y \\leq 1 \\), and \\( 0 \\leq z \\leq 1 \\) are expressed using conjunctions: `(hx : 0 ≤ x ∧ x ≤ 1)`, `(hy : 0 ≤ y ∧ y ≤ 1)`, and `(hz : 0 ≤ z ∧ z ≤ 1)`.\n\n3. **Translate the Inequality**:\n   - The inequality to prove is \\(\\frac{x}{1+y+z} + \\frac{y}{1+z+x} + \\frac{z}{1+x+y} + (1-x)(1-y)(1-z) \\leq 1\\).\n   - In Lean, division is expressed using `/`, and multiplication is expressed using `*`.\n   - The expression is directly translated as `x / (1 + y + z) + y / (1 + z + x) + z / (1 + x + y) + (1 - x) * (1 - y) * (1 - z) ≤ 1`.\n\n4. **Structure the Theorem**:\n   - The theorem is named `extract_aug_478622`, which is an arbitrary identifier.\n   - The theorem statement includes the variables, their constraints, and the inequality to be proven.\n   - The structure is: `theorem extract_aug_478622 (x y z : ℝ) (hx : 0 ≤ x ∧ x ≤ 1) (hy : 0 ≤ y ∧ y ≤ 1) (hz : 0 ≤ z ∧ z ≤ 1) : ... ≤ 1`.\n\n5. **Proof Placeholder**:\n   - The proof is not provided, so a placeholder"}
{"source_file": "herald_data/sample_500.jsonl", "line": 476, "id": 458495, "informal_statement": "Prove that for positive real numbers x, y, and z, the following inequalities hold:\\n1. $\\frac{x^2}{y^2+z^2} + \\frac{y^2}{z^2+x^2} + \\frac{z^2}{x^2+y^2} \\geq \\frac{x}{y+z} + \\frac{y}{z+x} + \\frac{z}{x+y}$\\n2. $\\frac{x^3}{y^3+z^3} + \\frac{y^3}{z^3+x^3} + \\frac{z^3}{x^3+y^3} \\geq \\frac{x^2}{y^2+z^2} + \\frac{y^2}{z^2+x^2} + \\frac{z^2}{x^2+y^2}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_458495 (x y z : ℝ) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z) : (x ^ 2 / (y ^ 2 + z ^ 2) + y ^ 2 / (z ^ 2 + x ^ 2) + z ^ 2 / (x ^ 2 + y ^ 2)) ≥ (x / (y + z) + y / (z + x) + z / (x + y))  :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach to formalize the problem. Here's a step-by-step explanation of how the informal statement is translated into the Lean4 code:\n\n1. **Understanding the Context**: \n   - The problem involves proving inequalities for positive real numbers \\( x, y, z \\).\n   - The inequalities involve expressions with powers and sums of these variables.\n\n2. **Setting Up the Environment**:\n   - We start by importing necessary modules from Lean's math library. `Mathlib` is a comprehensive library that includes various mathematical tools and theorems.\n   - We open `BigOperators`, `Real`, `Nat`, and `Topology` to access operations and properties related to real numbers and natural numbers, which are essential for handling the expressions and inequalities.\n\n3. **Defining the Theorem**:\n   - We declare a theorem named `extract_aug_458495`. The name is arbitrary and can be chosen to reflect the content or context of the theorem.\n   - The theorem takes three arguments \\( x, y, z \\) of type `ℝ`, which represents real numbers in Lean.\n\n4. **Specifying Conditions**:\n   - We include hypotheses `hx`, `hy`, and `hz` to assert that \\( x, y, z \\) are positive real numbers. This is done using the conditions `0 < x`, `0 < y`, and `0 < z`.\n\n5. **Formalizing the Inequality**:\n   - The first inequality from the informal statement is formalized as:\n     \\[\n     \\frac{x^2}{y^2+z^2} + \\frac{y^2}{z^2+x^2} + \\frac{z^2}{x^2+y^2} \\geq \\frac{x}{y+z} + \\frac{y}{z+x} + \\frac{z}{x+y}\n     \\]\n   - This is directly translated into Lean syntax using the `^` operator for exponentiation and `/` for division. The `≥` symbol is used for the inequality.\n\n6. **Using `by sorry`**:\n   - The `:= by sorry` part indicates that the proof is not provided. In Lean, `sorry` is a placeholder that allows the theorem to be accepted syntactically without a proof. It is used here to focus on the translation of the statement rather"}
{"source_file": "herald_data/sample_500.jsonl", "line": 473, "id": 333047, "informal_statement": "For any natural numbers $m, M, N$, and any composition $i$ in the target set of the partial sum of compositions defined by $m, M, N$, there exists a composition $j$ in the source set of the partial sum of compositions defined by $m, M, N$ such that $\\text{compChangeOfVariables}(m, M, N, j) = i$.", "formal_statement": "import Mathlib\nopen Filter List\nopen scoped Topology NNReal ENNReal\nopen FormalMultilinearSeries\ntheorem compPartialSumTargetSet_image_compPartialSumSource (m M N : ℕ)\n    (i : Σ n, Composition n) (hi : i ∈ compPartialSumTargetSet m M N) :\n    ∃ (j : _) (hj : j ∈ compPartialSumSource m M N), compChangeOfVariables m M N j hj = i := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and semantics.\n\n1. **Quantifiers and Variables**:\n   - The informal statement begins with \"For any natural numbers $m, M, N$,\" which translates to `(m M N : ℕ)` in Lean. This declares `m`, `M`, and `N` as natural numbers (`ℕ`).\n   - The phrase \"and any composition $i$ in the target set\" is represented by `(i : Σ n, Composition n) (hi : i ∈ compPartialSumTargetSet m M N)`. Here, `i` is a dependent pair (sigma type `Σ n, Composition n`), which means `i` is a composition of some natural number `n`. The condition `hi : i ∈ compPartialSumTargetSet m M N` ensures that `i` is in the target set defined by `m`, `M`, and `N`.\n\n2. **Existential Quantifier**:\n   - The informal statement continues with \"there exists a composition $j$ in the source set,\" which is expressed in Lean as `∃ (j : _) (hj : j ∈ compPartialSumSource m M N)`. This states that there exists some `j` (the underscore `_` indicates that the type will be inferred) such that `j` is in the source set `compPartialSumSource m M N`.\n\n3. **Function Application**:\n   - The condition \"$\\text{compChangeOfVariables}(m, M, N, j) = i$\" is formalized as `compChangeOfVariables m M N j hj = i`. This asserts that applying the function `compChangeOfVariables` to `m`, `M`, `N`, `j`, and the proof `hj` that `j` is in the source set, results in `i`.\n\n4. **Theorem Declaration**:\n   - The entire statement is encapsulated in a theorem named `compPartialSumTargetSet_image_compPartialSumSource`. The theorem takes `m`, `M`, `N`, `i`, and `hi` as parameters and asserts the existence of such a `j` and `hj`.\n\n5. **Imports and Context**:\n   - The code begins with `import Mathlib` to include necessary mathematical"}
{"source_file": "herald_data/sample_500.jsonl", "line": 478, "id": 166893, "informal_statement": "For any natural number $n$, and given a multivariate functor $F$ that is lawful, let $P$ be a property on elements of $F\\alpha$ and $q$ be a property on elements of $F\\beta$. Let $f: \\alpha \\to \\beta$ and $g: \\beta \\to \\alpha$ be functions between types $\\alpha$ and $\\beta$. Suppose there is a condition $h_1$ that for all $u$ in $F\\alpha$, the property $P(u)$ holds if and only if the property $q(f <$$> u)$ holds, where $f <$$> u$ is the map of $u$ through $F$ using $f$. Given an element $u$ in $F\\beta$ and a condition $h_2$ that the property $q(u)$ holds, show that the property $q$ also holds for the element obtained by first mapping $u$ through $g$ and then through $f$, i.e., $q(f <$$> g <$$> u)$.", "formal_statement": "import Mathlib\nopen MvFunctor\nopen Nat TypeVec\nopen LawfulMvFunctor\nlemma exists_iff_exists_of_mono_tac_3810 (n : ℕ) [MvFunctor F] [LawfulMvFunctor F] (P : F α → Prop) (q : F β → Prop) (f : α ⟹ β) (g : β ⟹ α) (h₁ : ∀ (u : F α), P u ↔ q (f <$$> u)) (u : F β) (h₂ : q u) : q (f <$$> g <$$> u) := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the problem and its requirements. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context**:\n   - We are dealing with a multivariate functor `F` that is lawful. This implies that `F` satisfies certain functorial laws, such as identity and composition laws.\n   - We have two types, `α` and `β`, and two properties, `P` and `q`, defined on elements of `F α` and `F β`, respectively.\n   - There are two functions, `f: α ⟹ β` and `g: β ⟹ α`, which are natural transformations between these types.\n\n2. **Formalizing the Functor and Lawfulness**:\n   - In Lean, we use `MvFunctor F` to denote that `F` is a multivariate functor.\n   - `LawfulMvFunctor F` indicates that `F` adheres to the functorial laws.\n\n3. **Defining the Properties**:\n   - `P : F α → Prop` and `q : F β → Prop` are properties (predicates) on elements of `F α` and `F β`, respectively.\n\n4. **Defining the Functions**:\n   - `f : α ⟹ β` and `g : β ⟹ α` are defined using the notation `⟹`, which is often used in Lean to denote a natural transformation or a function between types in the context of functors.\n\n5. **Expressing the Conditions**:\n   - The condition `h₁` is expressed as `∀ (u : F α), P u ↔ q (f <$$> u)`. This means for every element `u` in `F α`, the property `P(u)` holds if and only if `q(f <$$> u)` holds. Here, `<$$>` is the notation for mapping a function over a functorial structure in Lean.\n   - The condition `h₂` is simply `q u`, indicating that the property `q` holds for the element `u` in `F β`.\n\n6. **The Goal**:\n   - We need to show that `q(f <$$> g <$$> u)` holds. This involves mapping `u` first through"}
{"source_file": "herald_data/sample_500.jsonl", "line": 480, "id": 482985, "informal_statement": "Let $a=\\frac{y}{x}; b=\\frac{z}{y}; c=\\frac{x}{z}$ with $x; y; z>0$ we need \\n\\n $$\\frac{x^2}{yz}+\\frac{y^2}{xz}+\\frac{z^2}{xy} \\ge \\frac{3}{2}(\\frac{y}{x}+\\frac{z}{y}+\\frac{x}{z}-1)$$ \\n\\n equivalent to \\n\\n $$2(x^3+y^3+z^3) +3xyz \\ge 3(x^2y+y^2z+z^2x)$$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_482985 (x y z : ℝ) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z) : 2 * (x ^ 3 + y ^ 3 + z ^ 3) + 3 * x * y * z ≥ 3 * (x ^ 2 * y + y ^ 2 * z + z ^ 2 * x)  :=  by sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a series of steps to ensure that the formalization accurately captures the essence of the problem. Here's how the translation is achieved:\n\n1. **Identify Variables and Assumptions**:\n   - The informal statement involves three positive real numbers \\( x, y, z \\).\n   - The conditions \\( x, y, z > 0 \\) are crucial as they ensure the expressions are well-defined (e.g., no division by zero).\n\n2. **Translate Variables and Assumptions**:\n   - In Lean, we declare \\( x, y, z \\) as real numbers using `(x y z : ℝ)`.\n   - The positivity conditions are translated as hypotheses: `(hx : 0 < x)`, `(hy : 0 < y)`, `(hz : 0 < z)`.\n\n3. **Understand the Mathematical Expression**:\n   - The informal statement provides an inequality involving sums and products of powers of \\( x, y, z \\).\n   - The goal is to prove that \\( 2(x^3 + y^3 + z^3) + 3xyz \\ge 3(x^2y + y^2z + z^2x) \\).\n\n4. **Translate the Inequality**:\n   - The inequality is directly translated into Lean using the `≥` operator.\n   - The left-hand side is `2 * (x ^ 3 + y ^ 3 + z ^ 3) + 3 * x * y * z`.\n   - The right-hand side is `3 * (x ^ 2 * y + y ^ 2 * z + z ^ 2 * x)`.\n\n5. **Structure the Theorem**:\n   - The theorem is named `extract_aug_482985`, which is a placeholder name that can be replaced with a more descriptive one.\n   - The theorem statement includes the variables, their positivity conditions, and the inequality to be proven.\n\n6. **Use of Lean Libraries**:\n   - The `import Mathlib` statement is used to bring in necessary mathematical libraries.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are included to ensure access to relevant operations and properties, such as real number operations and inequalities.\n\n7. **Proof Placeholder**:\n   - The `:= by sorry` indicates that the proof is not yet provided"}
{"source_file": "herald_data/sample_500.jsonl", "line": 482, "id": 259253, "informal_statement": "For any natural number $n$, show that the cardinality of the type `ULift (Fin (n + 1))` is equal to the cardinality of the type `Option (ULift (Fin n))`, when both are cast to natural numbers. In other words, demonstrate that the number of elements in `ULift (Fin (n + 1))` is the same as the number of elements in `Option (ULift (Fin n))`, when these quantities are viewed as natural numbers.", "formal_statement": "import Mathlib\nopen Mathlib (Vector)\nopen Function Set Order\nlemma cast_succ_tac_15767 (n : ℕ) : ↑(Fintype.card (ULift.{u, 0} (Fin (n + 1)))) = ↑(Fintype.card (Option (ULift.{u, 0} (Fin n)))) := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand both the mathematical concepts involved and how they are represented in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Types:**\n   - `Fin (n + 1)`: This is a type representing the finite set of natural numbers `{0, 1, ..., n}`. It has `n + 1` elements.\n   - `ULift (Fin (n + 1))`: `ULift` is a type constructor that \"lifts\" a type to a higher universe level. In this context, it doesn't change the cardinality of the type; it just allows the type to be used in a more general setting.\n   - `Option (ULift (Fin n))`: `Option` is a type that adds an additional \"none\" element to a type, effectively increasing its cardinality by one. Thus, `Option (ULift (Fin n))` has `n + 1` elements because `Fin n` has `n` elements, and `Option` adds one more.\n\n2. **Cardinality in Lean:**\n   - `Fintype.card`: This function computes the cardinality of a finite type. In Lean, `Fintype` is a typeclass that provides a way to handle finite types and their cardinalities.\n\n3. **Casting to Natural Numbers:**\n   - The `↑` symbol in Lean is used to denote a coercion or cast. Here, it is used to cast the cardinality, which is a natural number, to the type `ℕ` (natural numbers) explicitly. This is often necessary in Lean to ensure type correctness, especially when dealing with different numeric types or universe levels.\n\n4. **Formalizing the Statement:**\n   - The lemma `cast_succ_tac_15767` is defined to take a natural number `n` as input.\n   - The goal is to show that the cardinality of `ULift (Fin (n + 1))` is equal to the cardinality of `Option (ULift (Fin n))`, both cast to natural numbers.\n   - The statement `↑(Fintype.card (ULift.{u, 0} (Fin (n + 1)))) = ↑(Fintype.card (Option (ULift.{u, 0} (Fin n))))` captures this equality"}
{"source_file": "herald_data/sample_500.jsonl", "line": 483, "id": 290786, "informal_statement": "For any sets $\\alpha$, $\\beta$, and $\\gamma$ equipped with supremum structures, and given $g: \\beta \\to \\gamma$ and $f_1, f_2: \\alpha \\to \\beta$ as supremum-preserving functions, along with the injectivity of $g$ and the condition $g \\circ f_1 = g \\circ f_2$, prove that for any $a \\in \\alpha$, $g(f_1(a)) = g(f_2(a))$.", "formal_statement": "import Mathlib\nopen Function OrderDual Set\nlemma cancel_left_tac_12099 [SupSet α] [SupSet β] [SupSet γ] (g : sSupHom β γ) (f₁ : sSupHom α β) (f₂ : sSupHom α β) (hg : Injective ⇑g) (h : g.comp f₁ = g.comp f₂) (a : α) : g (f₁ a) = g (f₂ a) := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to follow these steps:\n\n1. **Identify the Structures**: The informal statement involves sets $\\alpha$, $\\beta$, and $\\gamma$ equipped with supremum structures. In Lean, these are represented by types with the `SupSet` typeclass, which indicates that these types have a supremum operation defined.\n\n2. **Define the Functions**: The functions $g: \\beta \\to \\gamma$ and $f_1, f_2: \\alpha \\to \\beta$ are described as supremum-preserving. In Lean, such functions are represented by the `sSupHom` type, which stands for \"supremum homomorphism\". This type ensures that the functions preserve the supremum structure.\n\n3. **Injectivity Condition**: The function $g$ is injective. In Lean, this is expressed using the `Injective` predicate applied to the function `g`. The notation `⇑g` is used to denote the function application of `g` as a function rather than as a homomorphism.\n\n4. **Equality of Compositions**: The condition $g \\circ f_1 = g \\circ f_2$ is expressed in Lean as `g.comp f₁ = g.comp f₂`. The `comp` method is used to denote function composition in the context of homomorphisms.\n\n5. **Statement of the Lemma**: The goal is to prove that for any $a \\in \\alpha$, $g(f_1(a)) = g(f_2(a))$. This is directly translated into the lemma statement as `g (f₁ a) = g (f₂ a)`.\n\n6. **Formalizing the Lemma**: The lemma is declared with the necessary typeclass instances `[SupSet α]`, `[SupSet β]`, and `[SupSet γ]` to ensure that $\\alpha$, $\\beta$, and $\\gamma$ have supremum structures. The functions `g`, `f₁`, and `f₂` are declared as `sSupHom` to indicate they are supremum-preserving. The injectivity of `g` is included as a hypothesis `hg`, and the equality of compositions as `h`.\n\n7. **Proof Placeholder**: The `:= sorry` at the end of the lemma indicates that the proof is not yet provided. In Lean, `sorry"}
{"source_file": "herald_data/sample_500.jsonl", "line": 479, "id": 508820, "informal_statement": "Let $a,b,c>0 $ and $ abc=1.$ Prove that \\n $$\\left (\\frac{a^2}{b+c}+\\frac{b}{2c}\\right)\\left (\\frac{b^2}{c+a}+\\frac{c}{2a}\\right)\\left (\\frac{c^2}{a+b}+\\frac{a}{2b}\\right))\\geq 1$$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_508820 (a b c : ℝ) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (habc : a * b * c = 1) : (a^2 / (b + c) + b / (2 * c)) * (b^2 / (c + a) + c / (2 * a)) * (c^2 / (a + b) + a / (2 * b)) ≥ 1   :=  by sorry", "explanation": "To translate the informal mathematical statement into Lean4, we need to follow a structured approach to ensure that all components of the problem are accurately represented in the formal language. Here's a step-by-step explanation of the translation process:\n\n1. **Identify the Variables and Their Types:**\n   - The informal statement involves three positive real numbers \\(a\\), \\(b\\), and \\(c\\). In Lean, these are represented as variables of type `ℝ` (real numbers).\n   - The conditions \\(a, b, c > 0\\) are expressed using inequalities in Lean.\n\n2. **Express the Given Condition:**\n   - The condition \\(abc = 1\\) is a product condition that must be included as a hypothesis in the theorem. In Lean, this is expressed as `a * b * c = 1`.\n\n3. **Formalize the Inequality:**\n   - The main goal is to prove an inequality involving expressions with \\(a\\), \\(b\\), and \\(c\\). The expression \\(\\left(\\frac{a^2}{b+c} + \\frac{b}{2c}\\right)\\left(\\frac{b^2}{c+a} + \\frac{c}{2a}\\right)\\left(\\frac{c^2}{a+b} + \\frac{a}{2b}\\right) \\geq 1\\) is directly translated into Lean using arithmetic operations and inequalities.\n\n4. **Structure the Theorem:**\n   - The theorem is named `extract_aug_508820`, which is a unique identifier for this particular statement.\n   - The theorem takes as input the variables \\(a\\), \\(b\\), and \\(c\\), along with the hypotheses that \\(a\\), \\(b\\), and \\(c\\) are positive and that their product is 1.\n\n5. **Use Lean's Syntax for Mathematical Operations:**\n   - Division is represented by `/`, multiplication by `*`, and addition by `+`.\n   - The inequality \\(\\geq\\) is represented by `≥` in Lean.\n\n6. **Include Necessary Imports:**\n   - The `Mathlib` import is included to access mathematical libraries and tools.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to bring relevant mathematical operations and types into scope.\n\n7. **Complete the Theorem Statement:**\n   - The theorem statement is"}
{"source_file": "herald_data/sample_500.jsonl", "line": 481, "id": 271786, "informal_statement": "For a topological space $X$ and a subset $A$ of $X$, suppose the derived set of $A$ is contained in $A$. If $a$ is a cluster point of the collection of open subsets of $A$ but $a$ is not in $A$, show that this leads to a contradiction.", "formal_statement": "import Mathlib\nopen Filter Topology\nlemma isClosed_iff_derivedSet_subset_tac_2125 [TopologicalSpace X] (A : Set X) (h : derivedSet A ⊆ A) (a : X) (ha : ClusterPt a (𝓟 A)) (nh : a ∉ A) : False := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formal elements in Lean. Here's the step-by-step explanation:\n\n1. **Topological Space and Subset**:\n   - The informal statement begins with \"For a topological space $X$ and a subset $A$ of $X$\". In Lean, this is represented by `[TopologicalSpace X]` and `(A : Set X)`. The `TopologicalSpace X` indicates that `X` is a topological space, and `A : Set X` specifies that `A` is a subset of `X`.\n\n2. **Derived Set Containment**:\n   - The condition \"the derived set of $A$ is contained in $A$\" is formalized as `(h : derivedSet A ⊆ A)`. Here, `derivedSet A` represents the derived set of `A`, and `⊆` is the subset relation, indicating that every point in the derived set of `A` is also in `A`.\n\n3. **Cluster Point**:\n   - The statement \"if $a$ is a cluster point of the collection of open subsets of $A$\" is captured by `(ha : ClusterPt a (𝓟 A))`. In Lean, `ClusterPt a (𝓟 A)` means that `a` is a cluster point with respect to the filter `𝓟 A`, where `𝓟 A` is the principal filter generated by the set `A`. This captures the idea that every neighborhood of `a` intersects `A` in a non-trivial way.\n\n4. **Point Not in Subset**:\n   - The condition \"but $a$ is not in $A$\" is expressed as `(nh : a ∉ A)`. The symbol `∉` denotes that `a` is not an element of the set `A`.\n\n5. **Contradiction**:\n   - The goal is to show that these conditions lead to a contradiction. In Lean, this is expressed by the conclusion `: False`. The lemma is named `isClosed_iff_derivedSet_subset_tac_2125`, and the `:= sorry` indicates that the proof is not provided, but the structure of the statement is set up to derive a contradiction.\n\nOverall, the Lean code formalizes the informal statement by defining"}
{"source_file": "herald_data/sample_500.jsonl", "line": 485, "id": 519238, "informal_statement": "Find the value of \\\\(cos\\\\frac{\\\\pi}{7}\\\\left(1-2sin\\\\frac{\\\\pi}{14} \\\\right).\\\\)", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_519238 (c : ℝ) : (cos (π / 7) * (1 - 2 * sin (π / 14))) = 1 / 2   :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow these steps:\n\n1. **Understanding the Mathematical Expression**: The informal statement asks for the value of the expression \\( \\cos\\left(\\frac{\\pi}{7}\\right)\\left(1 - 2\\sin\\left(\\frac{\\pi}{14}\\right)\\right) \\). This is a specific trigonometric expression involving cosine and sine functions with arguments that are fractions of \\(\\pi\\).\n\n2. **Identifying the Goal**: The goal is to find the value of this expression. In the context of Lean, this means proving that this expression is equal to a specific value, which is given as \\(\\frac{1}{2}\\).\n\n3. **Setting Up the Lean Environment**: \n   - `import Mathlib`: This imports the Mathlib library, which contains a wide range of mathematical definitions and theorems, including those related to trigonometric functions.\n   - `open BigOperators`, `open Real`, `open Nat`, `open Topology`: These commands open various namespaces to make their contents directly accessible. `Real` is particularly relevant here as it provides access to real number operations and trigonometric functions.\n\n4. **Formalizing the Theorem**: \n   - `theorem extract_aug_519238 (c : ℝ) : ... := by sorry`: This line declares a theorem named `extract_aug_519238`. The name is arbitrary and likely generated automatically or chosen to be unique. The theorem states that for a real number `c`, the expression \\( \\cos\\left(\\frac{\\pi}{7}\\right)\\left(1 - 2\\sin\\left(\\frac{\\pi}{14}\\right)\\right) \\) equals \\(\\frac{1}{2}\\).\n   - The `c : ℝ` part introduces a real number `c`, but it is not used in the theorem statement. This might be a placeholder or an artifact of a more general context.\n\n5. **Expression Translation**:\n   - `cos (π / 7)`: This directly translates the cosine function with the argument \\(\\frac{\\pi}{7}\\).\n   - `sin (π / 14)`: This directly translates the sine function with the argument \\(\\frac{\\pi}{14}\\).\n   - `1 - 2 * sin (π / 14)`: This represents the expression \\(1"}
{"source_file": "herald_data/sample_500.jsonl", "line": 487, "id": 287940, "informal_statement": "For any field $K$, prime number $p$, and natural number $n$, if $K$ has characteristic $p$ and is a module over $\\mathbb{Z}/p\\mathbb{Z}$, show that there exists a natural number $n$ such that $p$ is prime and $q = p^n$.", "formal_statement": "import Mathlib\nopen Finset\nopen scoped Polynomial\nopen Polynomial\nlemma card_tac_10111 [Field K] (p : ℕ) [CharP K p] (hp : Fact (Nat.Prime p)) (this : Module (ZMod p) K) (n : ℕ) : ∃ n, Nat.Prime p ∧ q = p ^ ↑n := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to break down each component of the statement and see how it corresponds to the formalized version in Lean. Here's the step-by-step explanation:\n\n1. **Understanding the Context**:\n   - The informal statement involves a field \\( K \\), a prime number \\( p \\), and a natural number \\( n \\). It states a condition about the characteristic of \\( K \\) and its module structure over \\(\\mathbb{Z}/p\\mathbb{Z}\\).\n\n2. **Field \\( K \\)**:\n   - In Lean, a field is represented by the type class `Field K`. This is indicated by `[Field K]` in the lemma, which specifies that \\( K \\) is a field.\n\n3. **Prime Number \\( p \\)**:\n   - The prime number \\( p \\) is represented as a natural number in Lean, denoted by `(p : ℕ)`. The fact that \\( p \\) is prime is captured by the type class `Fact (Nat.Prime p)`, which is included as `(hp : Fact (Nat.Prime p))`. This ensures that \\( p \\) is recognized as a prime number within the context of the lemma.\n\n4. **Characteristic \\( p \\) of Field \\( K \\)**:\n   - The condition that \\( K \\) has characteristic \\( p \\) is expressed using the type class `CharP K p`, which is included as `[CharP K p]`. This indicates that the characteristic of the field \\( K \\) is \\( p \\).\n\n5. **Module Structure over \\(\\mathbb{Z}/p\\mathbb{Z}\\)**:\n   - The statement that \\( K \\) is a module over \\(\\mathbb{Z}/p\\mathbb{Z}\\) is represented by the type class `Module (ZMod p) K`, included as `(this : Module (ZMod p) K)`. Here, `ZMod p` represents the ring \\(\\mathbb{Z}/p\\mathbb{Z}\\).\n\n6. **Existence of Natural Number \\( n \\)**:\n   - The goal is to show the existence of a natural number \\( n \\) such that \\( p \\) is prime and \\( q = p^n \\). In Lean, this is expressed as `∃ n, Nat.Prime p ∧ q = p ^"}
{"source_file": "herald_data/sample_500.jsonl", "line": 486, "id": 250871, "informal_statement": "For any nontrivially normed field $\\mathbb{K}$, normed additive commutative group $E$, normed space $\\mathbb{K} E$, normed additive commutative group $F$, and normed space $\\mathbb{K} F$, suppose $f$ is a function from $E$ to $F$, $n$ is an extended natural number, $p$ is a formal multilinear series from $E$ to $F$, and $H$ is the assertion that $f$ has a Taylor series up to order $n$ represented by $p$ on the entire space $E$. Given a natural number $m$ and the condition that $m$ is less than or equal to $n$, show that the mapping $x \\mapsto p(x, m)$ is continuous on the entire space $E$.", "formal_statement": "import Mathlib\nopen scoped Classical\nopen NNReal Topology Filter\nopen Set Fin Filter Function\nlemma hasFTaylorSeriesUpToOn_univ_iff_tac_62402 [NontriviallyNormedField 𝕜] [NormedAddCommGroup E] [NormedSpace 𝕜 E] [NormedAddCommGroup F] [NormedSpace 𝕜 F] (f : E → F) (n : ℕ∞) (p : E → FormalMultilinearSeries 𝕜 E F) (H : HasFTaylorSeriesUpToOn n f p univ) (m : ℕ) (hm : ↑m ≤ n) : ContinuousOn (fun x => p x m) univ := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a structured approach that captures the essence of the mathematical concepts and their relationships. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Context and Imports**:\n   - The problem involves concepts from analysis, specifically normed fields, normed spaces, and Taylor series. Therefore, we import relevant libraries from Mathlib that provide the necessary definitions and theorems for these concepts.\n\n2. **Defining the Mathematical Structures**:\n   - **Nontrivially Normed Field**: The type `𝕜` is specified as a `[NontriviallyNormedField 𝕜]`, indicating that `𝕜` is a field equipped with a norm that is nontrivial (i.e., not all elements have the same norm).\n   - **Normed Additive Commutative Groups and Spaces**: `E` and `F` are defined as `[NormedAddCommGroup E]` and `[NormedAddCommGroup F]`, respectively, meaning they are additive commutative groups with a norm. Additionally, `[NormedSpace 𝕜 E]` and `[NormedSpace 𝕜 F]` indicate that `E` and `F` are normed spaces over the field `𝕜`.\n\n3. **Function and Series Definitions**:\n   - The function `f : E → F` represents the mapping from space `E` to space `F`.\n   - The series `p : E → FormalMultilinearSeries 𝕜 E F` is a formal multilinear series, which is a sequence of multilinear maps from `E` to `F` over the field `𝕜`.\n\n4. **Taylor Series Hypothesis**:\n   - The hypothesis `H : HasFTaylorSeriesUpToOn n f p univ` asserts that the function `f` has a Taylor series up to order `n` represented by `p` on the entire space `E` (denoted by `univ` for the universal set).\n\n5. **Natural Number and Continuity Condition**:\n   - The natural number `m : ℕ` and the condition `hm : ↑m ≤ n` specify that `m` is less than or equal to `n`, where `n` is an extended natural number (`ℕ∞`), allowing for"}
{"source_file": "herald_data/sample_500.jsonl", "line": 488, "id": 472278, "informal_statement": "Let $m,n\\in \\mathbb{N}^*$ . Prove that $m$ divides $n$ if and only if $x^{m-1}+C_m^1x^{m-2}+C_m^2x^{m-3}+\\ldots+C_m^{m-1}$ divides $x^{n-1}+C_n^1x^{n-2}+C_n^2x^{n-3}+\\ldots+C_n^{n-1}$ .", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_472278 (m n : ℕ) (hm : 1 < m) (hn : 1 < n) : m ∣ n ↔ (∑ i in Finset.range (m - 1), (m.choose i : ℤ) * x ^ i) ∣ ∑ i in Finset.range (n - 1), (n.choose i : ℤ) * x ^ i  :=  by sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a series of steps that capture the essence of the problem and its formalization in Lean. Here's the breakdown:\n\n1. **Understanding the Informal Statement**:\n   - We are given two natural numbers \\( m \\) and \\( n \\) that are greater than zero (\\( m, n \\in \\mathbb{N}^* \\)).\n   - The task is to prove that \\( m \\) divides \\( n \\) if and only if a certain polynomial expression related to \\( m \\) divides another polynomial expression related to \\( n \\).\n\n2. **Formalizing the Natural Numbers**:\n   - In Lean, natural numbers are represented by the type `ℕ`. However, the informal statement specifies \\( m, n \\in \\mathbb{N}^* \\), meaning they are positive. In Lean, this is typically handled by ensuring \\( m > 1 \\) and \\( n > 1 \\) since \\( \\mathbb{N}^* \\) usually means positive integers.\n\n3. **Polynomial Expressions**:\n   - The polynomial expressions are sums of terms involving binomial coefficients and powers of \\( x \\).\n   - The expression for \\( m \\) is \\( x^{m-1} + C_m^1 x^{m-2} + \\ldots + C_m^{m-1} \\).\n   - The expression for \\( n \\) is \\( x^{n-1} + C_n^1 x^{n-2} + \\ldots + C_n^{n-1} \\).\n\n4. **Using Binomial Coefficients**:\n   - In Lean, binomial coefficients are accessed using `Nat.choose`. The expression `m.choose i` represents the binomial coefficient \\( C_m^i \\).\n\n5. **Formalizing the Polynomial Division**:\n   - The polynomials are represented as sums over a range of indices. In Lean, this is done using `Finset.range`.\n   - The polynomial for \\( m \\) is represented as `∑ i in Finset.range (m - 1), (m.choose i : ℤ) * x ^ i`.\n   - Similarly, the polynomial for \\( n \\) is `∑ i in Finset.range (n - 1), (n.choose i : ℤ) * x ^ i`.\n\n6. **Divisibility"}
{"source_file": "herald_data/sample_500.jsonl", "line": 484, "id": 557770, "informal_statement": "Prove that $ (\\frac{a^{2}-b^{2}}{2})^{2}\\geq \\sqrt{\\frac{a^{2}+b^{2}}{2}}-\\frac{a+b}{2} $", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_557770 (a b : ℝ) : ((a^2 - b^2) / 2)^2 ≥ Real.sqrt ((a^2 + b^2) / 2) - (a + b) / 2   :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**: \n   - The variables in the informal statement are \\(a\\) and \\(b\\), which are real numbers. In Lean, real numbers are represented by `ℝ`.\n\n2. **Translate Mathematical Operations**:\n   - The expression \\((\\frac{a^{2}-b^{2}}{2})^{2}\\) involves subtraction, division, and exponentiation. In Lean, subtraction is `-`, division is `/`, and exponentiation is `^`.\n   - The expression \\(\\sqrt{\\frac{a^{2}+b^{2}}{2}}\\) involves addition, division, and the square root function. In Lean, addition is `+`, division is `/`, and the square root function is `Real.sqrt`.\n\n3. **Translate the Inequality**:\n   - The inequality \\((\\frac{a^{2}-b^{2}}{2})^{2} \\geq \\sqrt{\\frac{a^{2}+b^{2}}{2}} - \\frac{a+b}{2}\\) is directly translated to `≥` in Lean, which is the symbol for \"greater than or equal to\".\n\n4. **Structure the Theorem**:\n   - In Lean, a theorem is declared using the `theorem` keyword followed by a name, in this case, `extract_aug_557770`.\n   - The variables \\(a\\) and \\(b\\) are introduced with their types: `(a b : ℝ)`.\n   - The statement of the theorem follows the colon `:`, and it is the formal translation of the inequality.\n\n5. **Use of Libraries**:\n   - The `import Mathlib` statement is used to import necessary mathematical libraries that provide definitions and theorems for real numbers and operations.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to bring into scope various operations and theorems related to real numbers, natural numbers, and topology, which might be useful for the proof.\n\n6. **Proof Placeholder**:\n   - The `:= by sorry` part indicates that the proof is not yet provided. The `sorry` keyword is a placeholder in Lean that allows the theorem to be accepted without a proof, useful during development.\n\nBy following these steps,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 490, "id": 299611, "informal_statement": "For any normed additive commutative group $F$, normed space over $\\mathbb{C}$, and complete space $F$, given a function $f : \\mathbb{C} \\to F$, complex numbers $z, w \\in \\mathbb{C}$, a real number $r > 0$, and under the conditions that $f$ is differentiable and continuous on the closed ball $B[z; r]$ centered at $z$ with radius $r$, $z$ is a point of maximum for the norm of $f$ on $B[z; r]$, $w$ lies within $B[z; r]$, and the norm of $f(w)$ is less than the norm of $f(z)$, show that the norm of the line integral of $(\\zeta - z)^{-1} \\cdot f(\\zeta)$ over the circle $C(z, r)$ centered at $z$ with radius $r$ is less than $2\\pi$ times the norm of $f(z)$, i.e.,\n\\[\n\\left\\lVert\\oint_{\\zeta \\in C(z, r)} (\\zeta - z)^{-1} \\cdot f(\\zeta) d\\zeta\\right\\rVert < 2\\pi \\left\\lVert f(z) \\right\\rVert.\n\\]", "formal_statement": "import Mathlib\nopen TopologicalSpace Metric Set Filter Asymptotics Function MeasureTheory AffineMap Bornology\nopen scoped Topology Filter NNReal Real\nlemma norm_max_aux₁_tac_5279 [NormedAddCommGroup F] [NormedSpace ℂ F] [CompleteSpace F] (f : ℂ → F) (z : ℂ) (w : ℂ) (r : ℝ) (hd : DiffContOnCl ℂ f (ball z r)) (hz : IsMaxOn (norm ∘ f) (closedBall z r) z) (hw : w ∈ closedBall z r) (hw_lt : ‖f w‖ < ‖f z‖) (hr : 0 < r) (this : ‖∮ (ζ : ℂ) in C(z, r), (ζ - z)⁻¹ • f ζ‖ < 2 * π * ‖f z‖) : ‖∮ (ζ : ℂ) in C(z, r), (ζ - z)⁻¹ • f ζ‖ < 2 * π * ‖f z‖ := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to carefully map each component of the informal statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Context and Assumptions**:\n   - The informal statement begins by specifying the context: a normed additive commutative group `F`, which is also a normed space over the complex numbers `ℂ` and a complete space. In Lean, these are represented by the typeclass constraints `[NormedAddCommGroup F]`, `[NormedSpace ℂ F]`, and `[CompleteSpace F]`.\n\n2. **Function and Variables**:\n   - The function `f : ℂ → F` is a mapping from complex numbers to the space `F`. This is directly translated as `(f : ℂ → F)` in the lemma signature.\n   - The complex numbers `z` and `w` are variables in the complex plane, represented as `(z : ℂ)` and `(w : ℂ)`.\n   - The real number `r > 0` is the radius of the ball and circle, represented as `(r : ℝ)` with the condition `(hr : 0 < r)` ensuring that `r` is positive.\n\n3. **Differentiability and Continuity**:\n   - The condition that `f` is differentiable and continuous on the closed ball `B[z; r]` is captured by the hypothesis `(hd : DiffContOnCl ℂ f (ball z r))`. Here, `DiffContOnCl` is a Lean predicate that asserts differentiability and continuity on the closure of the ball.\n\n4. **Maximum Norm Condition**:\n   - The condition that `z` is a point of maximum for the norm of `f` on `B[z; r]` is represented by `(hz : IsMaxOn (norm ∘ f) (closedBall z r) z)`. `IsMaxOn` is a predicate indicating that the function `norm ∘ f` achieves a maximum at `z` on the closed ball.\n\n5. **Point `w` and Norm Condition**:\n   - The condition that `w` lies within `B[z; r]` is expressed as `(hw : w ∈ closedBall z r)`.\n   - The condition that the norm of `f(w)` is less than the norm of `f(z"}
{"source_file": "herald_data/sample_500.jsonl", "line": 489, "id": 81250, "informal_statement": "For any element \\( a \\) in \\( \\alpha \\) and any element \\( c \\) in \\( \\alpha \\) with \\( 0 < c \\), show that the preimage of the left open interval \\( (-\\infty, a) \\) under the function \\( x \\mapsto x \\cdot c \\) is the left open interval \\( (-\\infty, a / c) \\). In other words, \\[ (x \\mapsto x \\cdot c)^{-1}((- \\infty, a)) = (-\\infty, a / c). \\]", "formal_statement": "import Mathlib\nopen Interval Pointwise\ntheorem preimage_mul_const_Iio_extracted [LinearOrderedField α] (a : α) {c : α} : 0 < c → (fun x => x * c) ⁻¹' Set.Iio a = Set.Iio (a / c) := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to follow a structured approach that involves understanding the mathematical concepts, identifying the appropriate Lean constructs, and then writing the formal statement. Here's a step-by-step explanation of the translation process:\n\n1. **Understanding the Mathematical Context**:\n   - We are dealing with a function \\( x \\mapsto x \\cdot c \\) where \\( c \\) is a positive element of a type \\( \\alpha \\).\n   - The task is to find the preimage of the interval \\( (-\\infty, a) \\) under this function, which should be \\( (-\\infty, a / c) \\).\n\n2. **Identifying the Type and Structure**:\n   - The type \\( \\alpha \\) is specified to be a `LinearOrderedField`. This is necessary because we need the properties of a field (for division) and a linear order (for intervals and comparisons).\n   - The elements \\( a \\) and \\( c \\) are of type \\( \\alpha \\).\n\n3. **Formalizing the Function and Preimage**:\n   - The function \\( x \\mapsto x \\cdot c \\) is represented in Lean as `fun x => x * c`.\n   - The preimage of a set under a function in Lean is denoted by `⁻¹'`. Thus, `(fun x => x * c) ⁻¹' Set.Iio a` represents the preimage of the interval \\( (-\\infty, a) \\).\n\n4. **Expressing the Interval**:\n   - The interval \\( (-\\infty, a) \\) is represented in Lean as `Set.Iio a`, where `Iio` stands for \"interval open on the left\".\n   - Similarly, the interval \\( (-\\infty, a / c) \\) is represented as `Set.Iio (a / c)`.\n\n5. **Constructing the Theorem**:\n   - The theorem is named `preimage_mul_const_Iio_extracted` to reflect its purpose: finding the preimage of a left open interval under multiplication by a constant.\n   - The theorem takes parameters `a : α` and `{c : α}`. The curly braces around `c` indicate that it is an implicit argument, which is common for conditions or assumptions like `0 < c`.\n   - The condition `0 < c` is explicitly stated as a hypothesis in"}
{"source_file": "herald_data/sample_500.jsonl", "line": 491, "id": 245888, "informal_statement": "In a Euclidean space where \\(V\\) is a normed additive commutative group, equipped with an inner product over \\(\\mathbb{R}\\), and \\(P\\) is a metric space with \\(V\\) as its normed additive torsor, for any three distinct points \\(p_1, p_2, p_3\\) in \\(P\\) such that \\(p_1 \\neq p_2\\), \\(p_1 \\neq p_3\\), and \\(p_3 = p_2\\), show that the following conditions are equivalent:\n\\[\n(p_1 \\neq p_2 \\text{ and } p_1 \\text{ is between } p_2 \\text{ and } p_3 \\text{ over } \\mathbb{R}) \\text{ or } (p_3 \\neq p_2 \\text{ and } p_3 \\text{ is between } p_2 \\text{ and } p_1 \\text{ over } \\mathbb{R})\n\\]\nand\n\\[\n(p_1 = p_3 \\text{ and } p_1 \\neq p_2) \\text{ or } p_1 \\text{ is strictly between } p_2 \\text{ and } p_3 \\text{ over } \\mathbb{R} \\text{ or } p_3 \\text{ is strictly between } p_2 \\text{ and } p_1 \\text{ over } \\mathbb{R}.\n\\]", "formal_statement": "import Mathlib\nopen Real RealInnerProductSpace\nopen InnerProductGeometry\nlemma angle_eq_zero_iff_eq_and_ne_or_sbtw_tac_18257 [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] (p₁ : P) (p₂ : P) (p₃ : P) (hp₁p₂ : ¬p₁ = p₂) (hp₁p₃ : ¬p₁ = p₃) (hp₃p₂ : p₃ = p₂) : p₁ ≠ p₂ ∧ Wbtw ℝ p₂ p₁ p₃ ∨ p₃ ≠ p₂ ∧ Wbtw ℝ p₂ p₃ p₁ ↔ p₁ = p₃ ∧ p₁ ≠ p₂ ∨ Sbtw ℝ p₂ p₁ p₃ ∨ Sbtw ℝ p₂ p₃ p₁ := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully map each component of the informal statement to its corresponding formal representation in Lean. Here's a step-by-step explanation of the translation process:\n\n1. **Context Setup**:\n   - The informal statement involves a Euclidean space with a normed additive commutative group \\(V\\) and an inner product over \\(\\mathbb{R}\\). In Lean, this is represented by the type class constraints `[NormedAddCommGroup V]` and `[InnerProductSpace ℝ V]`.\n   - The space \\(P\\) is a metric space with \\(V\\) as its normed additive torsor. This is captured by `[MetricSpace P]` and `[NormedAddTorsor V P]`.\n\n2. **Variables and Assumptions**:\n   - The points \\(p_1\\), \\(p_2\\), and \\(p_3\\) are represented as variables `p₁`, `p₂`, and `p₃` of type `P`.\n   - The conditions \\(p_1 \\neq p_2\\), \\(p_1 \\neq p_3\\), and \\(p_3 = p_2\\) are represented by the hypotheses `hp₁p₂ : ¬p₁ = p₂`, `hp₁p₃ : ¬p₁ = p₃`, and `hp₃p₂ : p₃ = p₂`.\n\n3. **Translation of Conditions**:\n   - The condition \\(p_1 \\neq p_2 \\text{ and } p_1 \\text{ is between } p_2 \\text{ and } p_3 \\text{ over } \\mathbb{R}\\) is translated to `p₁ ≠ p₂ ∧ Wbtw ℝ p₂ p₁ p₃`. Here, `Wbtw` represents the \"weakly between\" relation over the reals.\n   - Similarly, \\(p_3 \\neq p_2 \\text{ and } p_3 \\text{ is between } p_2 \\text{ and } p_1 \\text{ over } \\mathbb{R}\\) is translated to `p₃ ≠ p₂ ∧ Wbtw ℝ p₂ p₃ p₁`.\n\n4. **Equivalence Statement**:"}
{"source_file": "herald_data/sample_500.jsonl", "line": 495, "id": 577553, "informal_statement": "Given $x,y,z>0$ and $xy+yz+zx=1$, prove that $\\frac{x}{xy+1}+\\frac{y}{yz+1}+\\frac{z}{zx+1}\\ge \\frac{3\\sqrt{3}}{4}$", "formal_statement": "import Mathlib\nopen BigOperators\nopen Real Nat Topology\n\ntheorem extract_aug_577553 (x y z : ℝ) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z) (h : x * y + y * z + z * x = 1) : 3 * Real.sqrt 3 / 4 ≤ x / (x * y + 1) + y / (y * z + 1) + z / (z * x + 1)   :=  by sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to follow these steps:\n\n1. **Identify the Variables and Their Types**:\n   - The informal statement involves three positive real numbers \\(x\\), \\(y\\), and \\(z\\). In Lean, these are represented as variables of type `ℝ` (real numbers).\n\n2. **Express the Conditions**:\n   - The condition \\(x, y, z > 0\\) is expressed using the inequalities `0 < x`, `0 < y`, and `0 < z`.\n   - The condition \\(xy + yz + zx = 1\\) is directly translated to `x * y + y * z + z * x = 1`.\n\n3. **State the Inequality to Prove**:\n   - The goal is to prove the inequality \\(\\frac{x}{xy+1} + \\frac{y}{yz+1} + \\frac{z}{zx+1} \\ge \\frac{3\\sqrt{3}}{4}\\).\n   - In Lean, this is expressed as `3 * Real.sqrt 3 / 4 ≤ x / (x * y + 1) + y / (y * z + 1) + z / (z * x + 1)`.\n\n4. **Structure the Theorem**:\n   - The theorem is named `extract_aug_577553`, which is a placeholder name and can be replaced with a more descriptive one.\n   - The theorem takes the variables \\(x\\), \\(y\\), and \\(z\\) as inputs, along with the conditions `hx`, `hy`, `hz` for positivity and `h` for the sum condition.\n   - The conclusion of the theorem is the inequality we aim to prove.\n\n5. **Use of Lean Libraries**:\n   - The `import Mathlib` statement is used to bring in necessary mathematical libraries.\n   - `open BigOperators`, `open Real`, `open Nat`, and `open Topology` are used to access specific operations and functions related to real numbers and other mathematical constructs.\n\n6. **Proof Placeholder**:\n   - The `:= by sorry` part indicates that the proof is not yet provided. In Lean, `sorry` is a placeholder that allows the theorem to be stated without an immediate proof.\n\nBy following these steps, the informal mathematical statement is systematically translated into a formal statement in Lean4, capturing"}
{"source_file": "herald_data/sample_500.jsonl", "line": 492, "id": 284917, "informal_statement": "For any type \\(\\iota\\) and a family of sets \\(f : \\iota \\to \\mathcal{P}(\\alpha)\\) in a topological space \\(\\alpha\\) that is also an Alexandrov discrete space, show that the complement of the closure of the union of the family is equal to the union of the complements of the closures of the sets in the family, i.e., \\((\\overline{\\bigcup_{i} f(i)})^c = \\bigcup_{i} (\\overline{f(i)})^c\\).", "formal_statement": "import Mathlib\nopen Filter Set TopologicalSpace\nopen scoped Topology\nlemma closure_iUnion_tac_4677 (ι : Sort u_1) [TopologicalSpace α] [AlexandrovDiscrete α] (f : ι → Set α) : (closure (⋃ i, f i))ᶜ = (⋃ i, closure (f i))ᶜ := sorry", "explanation": "To translate the given informal mathematical statement into the formal Lean4 code, we need to follow a series of steps that align the informal concepts with their formal counterparts in Lean's mathematical library. Here's the step-by-step explanation:\n\n1. **Understanding the Context**:\n   - The statement involves a topological space \\(\\alpha\\) that is an Alexandrov discrete space. This means every point has a minimal neighborhood, and closures of sets are determined by their finite intersections.\n   - We have a family of sets \\(f : \\iota \\to \\mathcal{P}(\\alpha)\\), where \\(\\iota\\) is an index type, and \\(\\mathcal{P}(\\alpha)\\) denotes the power set of \\(\\alpha\\).\n\n2. **Formalizing the Type and Topological Space**:\n   - In Lean, we declare a type \\(\\iota\\) using `Sort u_1`, which allows \\(\\iota\\) to be any type, including types of any universe level.\n   - We specify that \\(\\alpha\\) is a topological space with `[TopologicalSpace α]`.\n   - We also specify that \\(\\alpha\\) is an Alexandrov discrete space with `[AlexandrovDiscrete α]`.\n\n3. **Defining the Family of Sets**:\n   - The family of sets \\(f\\) is represented as a function `f : ι → Set α` in Lean. This means for each index \\(i\\) in \\(\\iota\\), \\(f(i)\\) is a subset of \\(\\alpha\\).\n\n4. **Expressing the Closure and Union**:\n   - The closure of a set in Lean is denoted by `closure`. Thus, \\(\\overline{\\bigcup_{i} f(i)}\\) is written as `closure (⋃ i, f i)`.\n   - The union of the family of sets is expressed using `⋃ i, f i`, which is the Lean notation for the union over an index set.\n\n5. **Expressing Complements**:\n   - The complement of a set \\(A\\) in Lean is denoted by `Aᶜ`. Therefore, the complement of the closure of the union is `(closure (⋃ i, f i))ᶜ`.\n   - Similarly, the complement of the closure of each set in the family is `(closure (f i))ᶜ`."}
{"source_file": "herald_data/sample_500.jsonl", "line": 499, "id": 242499, "informal_statement": "For any commutative semiring $R$, semirings $A$, $B$, and $C$, with $R$-algebra structures on $A$, $B$, and $C$, and given elements $r \\in R$, $a \\in A$, and $b \\in B$, show that the pair of elements $(a \\cdot (\\text{algebraMap } R \\to A)(r), b \\cdot (\\text{algebraMap } R \\to B)(r))$ is equal to itself, i.e., $(a \\cdot (\\text{algebraMap } R \\to A)(r), b \\cdot (\\text{algebraMap } R \\to B)(r)) = (a \\cdot (\\text{algebraMap } R \\to A)(r), b \\cdot (\\text{algebraMap } R \\to B)(r))$.", "formal_statement": "import Mathlib\nopen Algebra\nlemma algebra_tac_831 [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B] [Semiring C] [Algebra R C] (r : R) (a : A) (b : B) : (a * (algebraMap R A) r, b * (algebraMap R B) r) = (a * (algebraMap R A) r, b * (algebraMap R B) r) := sorry", "explanation": "To translate the given informal mathematical statement into Lean4 code, we need to follow a structured approach that involves understanding the mathematical concepts and how they are represented in Lean. Here's a step-by-step explanation of the translation:\n\n1. **Identify the Mathematical Structures**:\n   - The statement involves a commutative semiring \\( R \\) and semirings \\( A \\), \\( B \\), and \\( C \\).\n   - Each of these semirings \\( A \\), \\( B \\), and \\( C \\) has an \\( R \\)-algebra structure.\n\n2. **Translate the Structures into Lean**:\n   - In Lean, a commutative semiring is represented by the typeclass `CommSemiring`.\n   - A semiring is represented by the typeclass `Semiring`.\n   - An \\( R \\)-algebra structure on a semiring is represented by the typeclass `Algebra R`.\n\n3. **Declare the Typeclass Instances**:\n   - We declare that \\( R \\) is a commutative semiring using `[CommSemiring R]`.\n   - We declare that \\( A \\), \\( B \\), and \\( C \\) are semirings using `[Semiring A]`, `[Semiring B]`, and `[Semiring C]`.\n   - We declare that \\( A \\), \\( B \\), and \\( C \\) have \\( R \\)-algebra structures using `[Algebra R A]`, `[Algebra R B]`, and `[Algebra R C]`.\n\n4. **Declare the Variables**:\n   - The elements \\( r \\in R \\), \\( a \\in A \\), and \\( b \\in B \\) are declared as variables in the lemma statement: `(r : R) (a : A) (b : B)`.\n\n5. **Use the `algebraMap` Function**:\n   - The `algebraMap` function is used to map elements from the base ring \\( R \\) to the algebra \\( A \\) or \\( B \\). In Lean, this is written as `(algebraMap R A) r` and `(algebraMap R B) r`.\n\n6. **Construct the Pair and Equality**:\n   - The pair of elements is constructed as `(a * (algebraMap R A) r, b * (algebraMap R B) r)`.\n   - The statement asserts that this pair is equal to itself,"}
{"source_file": "herald_data/sample_500.jsonl", "line": 494, "id": 335838, "informal_statement": "For a negative constant \\( r \\), the function \\( x \\mapsto \\frac{f(x)}{r} \\) tends to \\( \\infty \\) along a filter \\( l \\) if and only if \\( f(x) \\) tends to \\( -\\infty \\) along \\( l \\). Formally, \\( \\frac{f(x)}{r} \\xrightarrow[l]{} \\infty \\iff f(x) \\xrightarrow[l]{} -\\infty \\) for \\( r < 0 \\).", "formal_statement": "import Mathlib\nopen Set\nopen Filter\n/-- If `r` is a negative constant, `fun x ↦ f x / r` tends to infinity along a filter `l`\nif and only if `f` tends to negative infinity along `l`. -/\nlemma tendsto_div_const_atTop_of_neg (hr : r < 0) :\n    Tendsto (fun x ↦ f x / r) l atTop ↔ Tendsto f l atBot := sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and map it to its corresponding Lean constructs. Here's the step-by-step explanation:\n\n1. **Understanding the Informal Statement**:\n   - We have a function \\( x \\mapsto \\frac{f(x)}{r} \\) where \\( r \\) is a negative constant.\n   - The function is said to \"tend to infinity\" along a filter \\( l \\).\n   - This is equivalent to saying that \\( f(x) \\) tends to \\(-\\infty\\) along the same filter \\( l \\).\n\n2. **Identifying Lean Constructs**:\n   - **Filter**: In Lean, filters are used to describe the behavior of functions at infinity or other limiting processes. The filter \\( l \\) is a parameter in the statement.\n   - **Tendsto**: The `Tendsto` predicate in Lean is used to express that a function approaches a certain limit along a filter. Specifically, `Tendsto (fun x ↦ f x / r) l atTop` means the function \\( x \\mapsto \\frac{f(x)}{r} \\) tends to infinity along the filter \\( l \\).\n   - **atTop and atBot**: These are specific filters in Lean representing the concepts of tending to \\( \\infty \\) and \\(-\\infty\\), respectively. `atTop` is used for positive infinity, and `atBot` is used for negative infinity.\n\n3. **Formalizing the Statement**:\n   - **Lemma Declaration**: We start by declaring a lemma named `tendsto_div_const_atTop_of_neg`. This lemma will encapsulate the equivalence we want to prove.\n   - **Assumption on \\( r \\)**: The condition \\( r < 0 \\) is expressed as a hypothesis `hr : r < 0` in the lemma. This is crucial because the behavior of the function depends on \\( r \\) being negative.\n   - **Equivalence Statement**: The core of the lemma is the equivalence between the two `Tendsto` statements:\n     - `Tendsto (fun x ↦ f x / r) l atTop` corresponds to the function \\( x \\mapsto \\frac{f(x)}{r} \\) tending to infinity.\n     - `Tendsto f l"}
{"source_file": "herald_data/sample_500.jsonl", "line": 498, "id": 158161, "informal_statement": "For any element \\(x\\) in a strictly ordered ring \\(\\alpha\\), given that \\(x + 1 \\leq 0\\) and \\(x \\leq 0\\), and for any natural number \\(n\\) with \\(n\\) being odd, if it holds that \\(1 \\leq \\sum_{i=0}^{n-1} x^i\\), prove that \\(x \\cdot \\left(\\sum_{i=0}^{n-1} x^i\\right) + 1 \\leq 0\\). Otherwise, if \\(n\\) is not odd (i.e., \\(n\\) is even), show that \\(1 \\leq x \\cdot \\left(\\sum_{i=0}^{n-1} x^i\\right) + 1\\).", "formal_statement": "import Mathlib\nopen Finset MulOpposite\nlemma geom_sum_alternating_of_le_neg_one_tac_20669 (x : α) [StrictOrderedRing α] (hx : x + 1 ≤ 0) (hx0 : x ≤ 0) (n : ℕ) (h : ¬Even n) (ih : 1 ≤ ∑ i ∈ range n, x ^ i) : if ¬Even n then x * ∑ i ∈ range n, x ^ i + 1 ≤ 0 else 1 ≤ x * ∑ i ∈ range n, x ^ i + 1 := sorry", "explanation": "To translate the informal mathematical statement into the given Lean4 code, we need to follow a structured approach that captures the essence of the problem and its conditions. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context**:\n   - We are dealing with a strictly ordered ring \\(\\alpha\\), which is a ring equipped with a strict total order compatible with the ring operations.\n   - The problem involves an element \\(x\\) of this ring and a natural number \\(n\\).\n\n2. **Formalizing the Hypotheses**:\n   - The conditions \\(x + 1 \\leq 0\\) and \\(x \\leq 0\\) are straightforward inequalities in the ring \\(\\alpha\\). In Lean, these are represented as `hx : x + 1 ≤ 0` and `hx0 : x ≤ 0`.\n   - The condition that \\(n\\) is odd is expressed as `¬Even n` in Lean, where `Even` is a predicate that checks if a number is even. The negation `¬` indicates that \\(n\\) is not even, hence odd.\n   - The inequality \\(1 \\leq \\sum_{i=0}^{n-1} x^i\\) is represented using Lean's `Finset` and `range` constructs to sum powers of \\(x\\) from 0 to \\(n-1\\). This is written as `ih : 1 ≤ ∑ i ∈ range n, x ^ i`.\n\n3. **Formalizing the Conclusion**:\n   - The conclusion involves a conditional statement based on whether \\(n\\) is odd or even.\n   - If \\(n\\) is odd, the goal is to prove \\(x \\cdot \\left(\\sum_{i=0}^{n-1} x^i\\right) + 1 \\leq 0\\). This is expressed in Lean as `x * ∑ i ∈ range n, x ^ i + 1 ≤ 0`.\n   - If \\(n\\) is even, the goal is to show \\(1 \\leq x \\cdot \\left(\\sum_{i=0}^{n-1} x^i\\right) + 1\\). This is expressed as `1 ≤ x * ∑ i ∈ range n, x ^ i + 1`.\n\n4. **Structuring the Lemma**:"}
{"source_file": "herald_data/sample_500.jsonl", "line": 493, "id": 354600, "informal_statement": "For $x \\in (0, 1)$ and $y, z \\in \\mathbb{R}$ with $z < y$, prove that $x^y < x^z$.", "formal_statement": "import Mathlib\nopen scoped Classical\nopen Real NNReal ENNReal ComplexConjugate\nopen Finset Function Set\ntheorem rpow_lt_rpow_of_exponent_gt {x : ℝ≥0∞} {y z : ℝ} (hx0 : 0 < x) (hx1 : x < 1) (hyz : z < y) :\n    x ^ y < x ^ z := sorry", "explanation": "To translate the informal mathematical statement into the formal Lean4 code, we need to break down each component of the statement and understand how it maps to Lean's syntax and libraries.\n\n1. **Understanding the Variables and Domains:**\n   - The informal statement involves variables \\( x \\), \\( y \\), and \\( z \\).\n   - \\( x \\in (0, 1) \\) indicates that \\( x \\) is a real number strictly between 0 and 1.\n   - \\( y, z \\in \\mathbb{R} \\) indicates that both \\( y \\) and \\( z \\) are real numbers.\n   - The condition \\( z < y \\) specifies an ordering between \\( z \\) and \\( y \\).\n\n2. **Formalizing the Variables:**\n   - In Lean, we use `{x : ℝ≥0∞}` to denote that \\( x \\) is a non-negative extended real number. This is a broader type that includes real numbers and positive infinity, but the constraints will ensure \\( x \\) is in the interval (0, 1).\n   - `{y z : ℝ}` directly translates the real numbers \\( y \\) and \\( z \\).\n\n3. **Translating the Conditions:**\n   - The condition \\( x \\in (0, 1) \\) is split into two parts: \\( 0 < x \\) and \\( x < 1 \\). These are represented by the hypotheses `hx0 : 0 < x` and `hx1 : x < 1`.\n   - The condition \\( z < y \\) is directly translated to `hyz : z < y`.\n\n4. **Formalizing the Conclusion:**\n   - The conclusion \\( x^y < x^z \\) is expressed in Lean as `x ^ y < x ^ z`. The `^` operator is used for exponentiation in Lean, similar to mathematical notation.\n\n5. **Structuring the Theorem:**\n   - The theorem is named `rpow_lt_rpow_of_exponent_gt`, which describes the property being proven: the result of raising \\( x \\) to a power is less when the exponent is greater, given the conditions on \\( x \\).\n   - The theorem takes the form of a standard Lean theorem declaration, starting with `theorem` followed by the name, the type declarations, the hypotheses, and the conclusion.\n\n6. **Using Lean Libraries:"}
{"source_file": "herald_data/sample_500.jsonl", "line": 497, "id": 145099, "informal_statement": "For any commutative ring $R$ and any $R$-modules $M$, $N$, and $P$, given a morphism $f : M \\otimes N \\to P$ in the category of $R$-modules, and for any $m \\in M$ and $n \\in N$, show that the composed morphism obtained by tensoring $n$ with $m$ through $f$ and the canonical isomorphism $\\beta_{N, M} : N \\otimes M \\to M \\otimes N$, evaluated at $m$ and $n$, equals itself. Specifically, demonstrate that $\\left(\\left(\\lambda f . \\left(\\left(\\beta_{N, M}\\right)_{\\ast} \\circ f\\right)_{\\ast}\\right) f\\right) n\\right) m = \\left(\\left(\\lambda f . \\left(\\left(\\beta_{N, M}\\right)_{\\ast} \\circ f\\right)_{\\ast}\\right) f\\right) n\\right) m$.", "formal_statement": "import Mathlib\nopen CategoryTheory Opposite\nopen MonoidalCategory\nlemma monoidalClosed_pre_app_tac_1332 [CommRing R] (M : ModuleCat R) (N : ModuleCat R) (P : ModuleCat R) (f : (MonoidalCategory.tensorLeft M).obj N ⟶ P) (m : ↑M) (n : ↑N) : (((fun f => (TensorProduct.mk R ↑N ↑M).compr₂ ((β_ N M).hom ≫ f)) f) n) m =\n  (((fun f => (TensorProduct.mk R ↑N ↑M).compr₂ ((β_ N M).hom ≫ f)) f) n) m := sorry", "explanation": "To translate the given informal mathematical statement into Lean4, we need to carefully consider the components involved in the statement and how they correspond to Lean's formal language. Here's a step-by-step explanation of the translation:\n\n1. **Understanding the Context**: \n   - We are working within the category of $R$-modules, where $R$ is a commutative ring. In Lean, this is represented using `CommRing R` for the ring and `ModuleCat R` for the category of $R$-modules.\n\n2. **Identifying the Objects and Morphisms**:\n   - The objects $M$, $N$, and $P$ are $R$-modules, represented as `ModuleCat R` in Lean.\n   - The morphism $f : M \\otimes N \\to P$ is a morphism in the category of $R$-modules, represented as `f : (MonoidalCategory.tensorLeft M).obj N ⟶ P` in Lean. Here, `(MonoidalCategory.tensorLeft M).obj N` represents the tensor product $M \\otimes N$.\n\n3. **Canonical Isomorphism**:\n   - The canonical isomorphism $\\beta_{N, M} : N \\otimes M \\to M \\otimes N$ is represented in Lean as `(β_ N M).hom`. This is the homomorphism part of the isomorphism in the monoidal category of $R$-modules.\n\n4. **Tensoring and Composition**:\n   - The operation of tensoring $n$ with $m$ through $f$ and the canonical isomorphism is expressed using `TensorProduct.mk R ↑N ↑M`. This constructs the tensor product in Lean.\n   - The composition of morphisms is represented using the composition operator `≫` in Lean, which corresponds to the composition of functions.\n\n5. **Formalizing the Statement**:\n   - The informal statement asks us to show that a certain composed morphism evaluated at $m$ and $n$ equals itself. This is a tautology, and in Lean, it is expressed as an equality of expressions.\n   - The expression `(((fun f => (TensorProduct.mk R ↑N ↑M).compr₂ ((β_ N M).hom ≫ f)) f) n) m` represents the evaluation of the composed morphism at $n$ and $m`.\n   - The lemma states that"}
{"source_file": "herald_data/sample_500.jsonl", "line": 496, "id": 84494, "informal_statement": "For any element \\( x \\) in \\( F(\\text{append1}(\\alpha, \\text{Fix } F \\alpha)) \\), show that \\( \\text{Fix.dest}(\\text{Fix.mk } x) \\) is equal to \\( x \\).", "formal_statement": "import Mathlib\nopen TypeVec\nopen MvFunctor (LiftP LiftR)\nopen MvFunctor\ntheorem dest_mk_extracted {n : ℕ} {F : TypeVec.{u} (n + 1) → Type u} [q : MvQPF F] {α : TypeVec.{u} n} (x : F (α ::: MvQPF.Fix F α)) :\n (MvQPF.Fix.mk x).dest = x := sorry", "explanation": "To translate the informal statement into the given Lean4 code, we need to understand the components involved and how they relate to each other in both the informal and formal contexts.\n\n1. **Understanding the Context**:\n   - The informal statement involves a functor \\( F \\) and its fixed point construction. The fixed point of a functor is a common concept in category theory and functional programming, often used to define recursive data types.\n   - The Lean code uses `MvQPF`, which stands for \"multivariate quotient polynomial functor\". This is a generalization of polynomial functors to multiple variables, allowing for more complex data structures.\n\n2. **Components of the Formal Statement**:\n   - `n : ℕ`: This represents the number of type variables involved, indicating that `F` is a functor that takes `n + 1` type arguments.\n   - `F : TypeVec.{u} (n + 1) → Type u`: This defines `F` as a functor from a vector of `n + 1` types to a single type. `TypeVec` is a type vector, which is a tuple of types.\n   - `[q : MvQPF F]`: This is a typeclass constraint indicating that `F` is a multivariate quotient polynomial functor.\n   - `α : TypeVec.{u} n`: This is a vector of `n` types, which are the first `n` arguments to the functor `F`.\n   - `x : F (α ::: MvQPF.Fix F α)`: This specifies that `x` is an element of the functor `F` applied to a type vector consisting of `α` followed by `MvQPF.Fix F α`. The `:::` operator appends a type to a type vector.\n\n3. **Translation of the Informal Statement**:\n   - The informal statement asks us to show that for any element \\( x \\) in \\( F(\\text{append1}(\\alpha, \\text{Fix } F \\alpha)) \\), a certain property holds. In Lean, `append1` is represented by `:::` and `\\text{Fix } F \\alpha` is represented by `MvQPF.Fix F α`.\n   - The property to show is that `Fix.dest(Fix.mk x) = x`. In Lean, `Fix.mk` constructs a fixed point from an"}
