name,domain,status,steps,compile_status,io_error,nl_statement,lean4_code,validate_score,validate_reason,equivalent
jirilebl_ca_ca_758,Complex Analysis,success,4,0,,Prove the \emph{polarization identity} $4 z\bar{w} = {\lvert z+w\rvert}^2-{\lvert z-w\rvert}^2 +i \bigl( {\lvert z+iw\rvert}^2 - {\lvert z-iw\rvert}^2 \bigr)$.,"import Mathlib

/-- Polarization identity for complex numbers:
    4 z ‚¨ù conj w = |z+w|^2 - |z-w|^2 + i (|z+iw|^2 - |z-iw|^2)
-/
theorem polarization_identity (z w : ‚ÑÇ) :
  4 * z * Complex.conj w =
    (Complex.abs (z + w)) ^ 2 - (Complex.abs (z - w)) ^ 2 +
    Complex.i * ((Complex.abs (z + Complex.i * w)) ^ 2 - (Complex.abs (z - Complex.i * w)) ^ 2) := by sorry
",10,"### BEGIN THOUGHT
Line-by-line translation:
- `import Mathlib`: Brings in Mathlib, including complex numbers and absolute value.
- The comment describes the polarization identity for complex numbers, matching the natural language statement.
- `theorem polarization_identity (z w : ‚ÑÇ) :` Introduces complex variables z, w.
- `4 * z * Complex.conj w = ...` Left-hand side is exactly 4 z times the complex conjugate of w, i.e., 4 z \bar{w}.
- `(Complex.abs (z + w)) ^ 2 - (Complex.abs (z - w)) ^ 2 + ...` First part of the right-hand side: |z+w|^2 - |z-w|^2, with Complex.abs denoting the complex modulus and ^2 the square (a real number coerced to ‚ÑÇ in the equality).
- `Complex.i * ((Complex.abs (z + Complex.i * w)) ^ 2 - (Complex.abs (z - Complex.i * w)) ^ 2)` Second part: i times (|z + i w|^2 - |z - i w|^2). Complex.i is i, and Complex.i * w is iw. The absolute values are modulus, squared, as in the statement.
- `:= by sorry` The proof is omitted, which is acceptable per the task; we only audit the statement.

Whole translation check:
- The Lean theorem states exactly the complex polarization identity: 4 z \bar{w} equals |z+w|^2 - |z-w|^2 + i (|z+iw|^2 - |z-iw|^2). Types and coercions are consistent: the right-hand side is a sum of a real and i times a real, interpreted in ‚ÑÇ.

Final check:
- The two statements are the same. No auxiliary/vacuous definitions are introduced. No discrepancies in constants, operations, or notation. This is a faithful formalization of the given natural language identity.
### END THOUGHT",1
jirilebl_ca_ca_1326,Complex Analysis,success,2,1,,"Use $e^{z+w} = e^z e^w$ and $e^0 = 1 \not= 0$ to show that $e^z \not=0$ for all $z \in \mathbb{C}$. In other words, show that if a function $f$ satisfies $f(z+w)=f(z)f(w)$ and $f(0) = 1$, then $f(z) \not= 0$ for all $z$.","import Mathlib

/-!
We state two related lemmas (without proof):
1) If f : ‚ÑÇ ‚Üí ‚ÑÇ satisfies f(z+w) = f z * f w and f 0 = 1, then f z ‚â† 0 for all z.
2) As a special case, the complex exponential never vanishes: exp z ‚â† 0 for all z.
-/

theorem multiplicative_function_nonzero {f : Complex ‚Üí Complex}
  (hf : ‚àÄ z w : Complex, f (z + w) = f z * f w)
  (h0 : f 0 = 1) : ‚àÄ z : Complex, f z ‚â† 0 := by sorry

theorem exp_ne_zero : ‚àÄ z : Complex, Complex.exp z ‚â† 0 := by sorry",10,"### BEGIN THOUGHT
Line-by-line translation:
- `import Mathlib`: Brings in Mathlib; neutral for content.
- Comment explains intent: two related lemmas, (1) the general multiplicative functional equation implies nonvanishing, (2) the special case for the complex exponential.
- `theorem multiplicative_function_nonzero {f : Complex ‚Üí Complex} (hf : ‚àÄ z w : Complex, f (z + w) = f z * f w) (h0 : f 0 = 1) : ‚àÄ z : Complex, f z ‚â† 0 := by sorry` translates to: Let f: ‚ÑÇ ‚Üí ‚ÑÇ. If for all z,w ‚àà ‚ÑÇ we have f(z+w) = f(z) f(w) and f(0) = 1, then for all z ‚àà ‚ÑÇ, f(z) ‚â† 0. This is exactly the ‚Äúin other words‚Äù general statement in the prompt.
- `theorem exp_ne_zero : ‚àÄ z : Complex, Complex.exp z ‚â† 0 := by sorry` translates to: For all z ‚àà ‚ÑÇ, e^z ‚â† 0. This is the special case requested, derived from the properties e^{z+w} = e^z e^w and e^0 = 1.

Assessment of faithfulness:
- The code states the two theorems precisely as in the natural language: the general multiplicative functional equation result and its special case for the complex exponential. There are no auxiliary or vacuous definitions; no placeholders beyond the proofs (`sorry`), which are allowed per the task as we are only judging the correctness of the formal statements relative to the natural language.
- Domains and quantifiers match exactly (Complex = ‚ÑÇ). The properties used in the natural language (multiplicativity and value at 0) appear as hypotheses in the general theorem, and the nonvanishing of exp is stated directly as the special case.

Final check:
- The two math statements are the same: the code faithfully formalizes both the general ‚Äúin other words‚Äù statement and the specific exponential nonvanishing conclusion. No discrepancies or hidden generalizations/specializations that change meaning.

### END THOUGHT",1
jirilebl_ca_ca_5485,Complex Analysis,success,4,0,,"Suppose $f \colon \mathbb{D} \to \mathbb{D}$ is holomorphic and $f(0) = 0$, then $\lvert f'(0)\rvert \leq 1$.","import Mathlib

/-- Schwarz lemma: if f : ùîª ‚Üí ùîª is holomorphic and f(0) = 0 then |f'(0)| ‚â§ 1. -/
theorem schwarz_lemma {f : ‚ÑÇ ‚Üí ‚ÑÇ} (h : HolomorphicOn f (metric.ball (0 : ‚ÑÇ) 1)) (h0 : f 0 = 0) : |deriv f 0| ‚â§ 1 := by sorry
",3,"### BEGIN THOUGHT
1) Line-by-line translation of the Lean code:
- `import Mathlib`: bring in Mathlib.
- The theorem statement:
  `theorem schwarz_lemma {f : ‚ÑÇ ‚Üí ‚ÑÇ} (h : HolomorphicOn f (metric.ball (0 : ‚ÑÇ) 1)) (h0 : f 0 = 0) : |deriv f 0| ‚â§ 1 := by sorry`
  Natural language: Let f be a complex function defined on ‚ÑÇ. Assume f is holomorphic on the open unit ball {z : |z| < 1} and that f(0) = 0. Then |f'(0)| ‚â§ 1.

2) Compare with the natural language statement:
- Original statement: Suppose f : ùîª ‚Üí ùîª is holomorphic and f(0) = 0, then |f'(0)| ‚â§ 1. Here ùîª is the open unit disk. This includes two parts:
  - Domain: f is defined on ùîª and holomorphic there.
  - Codomain constraint: f maps ùîª into ùîª, i.e., |f(z)| < 1 for all z with |z| < 1.
- Lean statement similarities:
  - Holomorphic on ùîª: captured by `HolomorphicOn f (metric.ball (0 : ‚ÑÇ) 1)`.
  - f(0) = 0: captured by `h0 : f 0 = 0`.
- Lean statement differences (crucial):
  - Missing the assumption that f maps the disk into itself (no hypothesis ensuring |f z| < 1 for |z| < 1). The function is just ‚ÑÇ ‚Üí ‚ÑÇ with holomorphicity on the disk; it could send points of the disk outside the disk.
  - Domain type is ‚ÑÇ ‚Üí ‚ÑÇ rather than ùîª ‚Üí ùîª. This alone is okay as a generalization, but only if the mapping-into-disk condition is included. Here it is not.

3) Final check: Are the problems the same?
- No. The Lean theorem omits the key hypothesis that f(ùîª) ‚äÜ ùîª. Without this, the conclusion is false (e.g., f(z) = 2z is holomorphic on the disk, f(0)=0, but |f'(0)| = 2 > 1). Thus the Lean statement is not a faithful translation of the Schwarz lemma as stated.
- There are no auxiliary/vacuous definitions; the issue is the missing essential hypothesis.

Conclusion: Not faithful due to the missing boundedness hypothesis f(ùîª) ‚äÜ ùîª.
### END THOUGHT",0
jirilebl_ca_ca_2441,Complex Analysis,success,5,0,,"Suppose $U \subset \mathbb{C}$ is open, $f \colon U \to \mathbb{C}$ is holomorphic, and $f'(z) \not= 0$ for every $z \in U$. Show that $f$ is locally injective on $U$.","import Mathlib

open Set Function

/--
If f is holomorphic on an open set U and its complex derivative never vanishes on U,
then f is locally injective on U: for every z in U there is an open neighbourhood V ‚äÜ U
on which f is injective.
-/
theorem holomorphic_on_deriv_ne_zero_locally_injective_on {U : Set ‚ÑÇ} (hU : IsOpen U)
  {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : IsHolomorphicOn f U) (h : ‚àÄ z ‚àà U, deriv f z ‚â† 0) :
  ‚àÄ z ‚àà U, ‚àÉ V, IsOpen V ‚àß z ‚àà V ‚àß V ‚äÜ U ‚àß InjectiveOn f V := by sorry",10,"### BEGIN THOUGHT
1) Line-by-line translation:
- import Mathlib; open Set Function: Brings in mathlib and relevant namespaces.
- The theorem holomorphic_on_deriv_ne_zero_locally_injective_on states: Let U be a subset of ‚ÑÇ with hU : IsOpen U. Let f : ‚ÑÇ ‚Üí ‚ÑÇ and assume hf : IsHolomorphicOn f U (i.e., f is holomorphic on U), and assume h : ‚àÄ z ‚àà U, deriv f z ‚â† 0 (the complex derivative is nonzero at every point of U). Then the conclusion is: ‚àÄ z ‚àà U, ‚àÉ V, IsOpen V ‚àß z ‚àà V ‚àß V ‚äÜ U ‚àß InjectiveOn f V. That is, for each z in U there exists an open set V with z ‚àà V, V contained in U, and f is injective on V.

2) Faithfulness to the natural language statement:
- Natural statement: U ‚äÜ ‚ÑÇ open; f : U ‚Üí ‚ÑÇ holomorphic; f'(z) ‚â† 0 for all z ‚àà U; conclude f is locally injective on U.
- Lean statement: Uses f : ‚ÑÇ ‚Üí ‚ÑÇ with holomorphic-on-U predicate instead of f : U ‚Üí ‚ÑÇ. This is a standard and equivalent formalization. The assumption h enforces f'(z) ‚â† 0 for all z ‚àà U. The conclusion matches ‚Äúlocally injective on U‚Äù: for every z ‚àà U, there is an open neighborhood V contained in U on which f is injective. Requiring V to be open in ‚ÑÇ and contained in U is slightly stronger than ‚Äúopen in the subspace topology of U,‚Äù but equivalent for local injectivity purposes.

3) Final check: The two problems are the same. No auxiliary vacuous definitions are introduced; the theorem statement directly formalizes the claim. Any minor formalization choices (domain ‚ÑÇ with HolomorphicOn vs. domain U) are standard and faithful.

### END THOUGHT",1
jirilebl_ca_ca_2577,Complex Analysis,success,4,0,,"Let $U \subset \mathbb{C}$ be an open set and $f \colon U \to \mathbb{C}$ be a holomorphic function. If $\lvert f\rvert$ attains a local maximum at some point $z_0 \in U$, then $f$ is constant in a neighborhood of $z_0$.","import Mathlib

open Metric Set

/-- Maximum modulus principle (local version).
If U ‚äÜ ‚ÑÇ is open and f : U ‚Üí ‚ÑÇ is holomorphic (differentiable on U),
and |f| attains a local maximum at z0 ‚àà U, then f is constant in a neighborhood of z0. -/
lemma maximum_modulus_principle_local {U : Set ‚ÑÇ} (hU : IsOpen U) {f : ‚ÑÇ ‚Üí ‚ÑÇ}
  (hf : DifferentiableOn ‚ÑÇ f U) {z0 : ‚ÑÇ} (hz0 : z0 ‚àà U)
  (hmax : ‚àÉ r > 0, ball z0 r ‚äÜ U ‚àß ‚àÄ z ‚àà ball z0 r, |f z| ‚â§ |f z0|) :
  ‚àÉ r > 0, ‚àÄ z ‚àà ball z0 r, f z = f z0 := by sorry
",10,"### BEGIN THOUGHT
1) Line-by-line translation:
- `lemma maximum_modulus_principle_local {U : Set ‚ÑÇ} (hU : IsOpen U) {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : DifferentiableOn ‚ÑÇ f U) {z0 : ‚ÑÇ} (hz0 : z0 ‚àà U)` sets the context: U is an open subset of ‚ÑÇ, f is a complex-valued function on ‚ÑÇ that is complex differentiable on U (i.e., holomorphic on U), and z0 ‚àà U.
- The hypothesis `(hmax : ‚àÉ r > 0, ball z0 r ‚äÜ U ‚àß ‚àÄ z ‚àà ball z0 r, |f z| ‚â§ |f z0|)` formalizes that |f| attains a local maximum at z0: there exists a positive radius r such that the open Euclidean ball around z0 of radius r is contained in U and on this ball |f z| ‚â§ |f z0|.
- The conclusion `‚àÉ r > 0, ‚àÄ z ‚àà ball z0 r, f z = f z0` states that there exists a positive radius r such that f is constant on the open ball around z0 of radius r; i.e., f is constant in a neighborhood of z0.

2) Whole translation faithfulness:
- The natural statement: If U ‚äÜ ‚ÑÇ is open, f: U ‚Üí ‚ÑÇ is holomorphic, and |f| has a local maximum at z0 ‚àà U, then f is constant in a neighborhood of z0.
- The Lean version matches this: it uses DifferentiableOn ‚ÑÇ f U to express holomorphic on U; it encodes the local maximum via existence of a ball contained in U on which |f| ‚â§ |f z0|; and concludes existence of a radius making f constant on a ball around z0, which is exactly a neighborhood.

3) Comparison and potential differences:
- Domain of f: The Lean code takes f : ‚ÑÇ ‚Üí ‚ÑÇ with differentiability restricted to U, whereas the natural language has f : U ‚Üí ‚ÑÇ. This is a standard and harmless reformulation; values of f outside U are irrelevant.
- The hypothesis includes `ball z0 r ‚äÜ U`, which is equivalent to saying |f| has a local maximum at z0 in U since U is open, so one can shrink any neighborhood to a ball inside U.
- The conclusion does not explicitly say `ball z0 r ‚äÜ U`, but asserting constancy on a ball is even stronger than needed; since U is open and z0 ‚àà U, one can always choose r small enough so the ball lies in U. This does not detract from faithfulness.
- No vacuous or placeholder definitions are used; all terms are standard Mathlib notions.

Conclusion: The Lean statement is a faithful formalization of the given natural language result.
### END THOUGHT",1
jirilebl_ca_ca_2353,Complex Analysis,success,5,0,,Suppose $f \colon \mathbb{C} \to \mathbb{C}$ is holomorphic. Show that $f$ is conformal at a point $z_0$ if and only if $f'(z_0) \not= 0$.,"import Mathlib

open Complex

variable {f : ‚ÑÇ ‚Üí ‚ÑÇ} {z0 : ‚ÑÇ}

theorem is_holomorphic_at.is_conformal_at_iff_deriv_ne_zero (hf : IsHolomorphicAt f z0) :
  (IsConformalAt f z0) ‚Üî deriv f z0 ‚â† 0 := by sorry
",10,"### BEGIN THOUGHT
1) Line-by-line translation:
- `import Mathlib` and `open Complex`: Set up the environment and open the Complex namespace; no mathematical content change.
- `variable {f : ‚ÑÇ ‚Üí ‚ÑÇ} {z0 : ‚ÑÇ}`: We work with a complex function f: ‚ÑÇ ‚Üí ‚ÑÇ and a point z0 ‚àà ‚ÑÇ.
- `theorem is_holomorphic_at.is_conformal_at_iff_deriv_ne_zero (hf : IsHolomorphicAt f z0) : (IsConformalAt f z0) ‚Üî deriv f z0 ‚â† 0 := by sorry`:
  This states: Assuming f is holomorphic at z0, f is conformal at z0 if and only if the (complex) derivative of f at z0 is nonzero.

2) Faithfulness to the natural language statement:
- Natural language: ‚ÄúSuppose f: ‚ÑÇ ‚Üí ‚ÑÇ is holomorphic. Show that f is conformal at a point z0 iff f‚Ä≤(z0) ‚â† 0.‚Äù
- Lean: Assumes f is holomorphic at z0 (a local condition), then proves conformality at z0 ‚Üî derivative ‚â† 0. This is a slight generalization (only needs holomorphic at z0 rather than globally holomorphic), which is acceptable per the guidelines. The predicate `IsConformalAt f z0` matches ‚Äúf is conformal at z0,‚Äù and `deriv f z0` for f: ‚ÑÇ ‚Üí ‚ÑÇ denotes the complex derivative at z0. Thus, the logical content matches exactly.

3) Final check:
- No auxiliary/vacuous definitions; no placeholders except the proof `sorry` (which is allowed for translation auditing). The statement is standard and uses Mathlib notions directly. The only difference is the local vs global holomorphic assumption, which is a harmless generalization. Therefore, the translation is faithful.

### END THOUGHT",1
jirilebl_ca_ca_5157,Complex Analysis,success,5,0,,"Suppose $U \subset \mathbb{C}$ is open, and $\psi \colon U \times [0,1] \to \mathbb{C}$ is a continuous function such that for each fixed $t \in [0,1]$, the function $z \mapsto \psi(z,t)$ is holomorphic. Then $h(z) = \int_0^1 \psi(z,t) \, dt$ is a holomorphic function on $U$.","import Mathlib

/-!
Suppose U ‚äÇ ‚ÑÇ is open, and œà : U √ó [0,1] ‚Üí ‚ÑÇ is a continuous function such that for each fixed t ‚àà [0,1],
the function z ‚Ü¶ œà(z,t) is holomorphic. Then h(z) = ‚à´_0^1 œà(z,t) dt is a holomorphic function on U.
-/

open Set

theorem is_holomorphic_of_integral_of_holomorphic_family
  {U : Set ‚ÑÇ} (psi : ‚ÑÇ √ó ‚Ñù ‚Üí ‚ÑÇ)
  (U_open : IsOpen U)
  (psi_cont : ContinuousOn psi (U √óÀ¢ (Icc (0 : ‚Ñù) 1)))
  (psi_holo : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1, IsHolomorphicOn (fun z => psi (z, t)) U) :
  IsHolomorphicOn (fun z => ‚à´ t in (0 : ‚Ñù)..1, psi (z, t)) U := by sorry
",10,"### BEGIN THOUGHT
Step-by-step translation of the Lean code:
- The theorem is named `is_holomorphic_of_integral_of_holomorphic_family`.
- `{U : Set ‚ÑÇ}`: U is a subset of the complex plane ‚ÑÇ.
- `(psi : ‚ÑÇ √ó ‚Ñù ‚Üí ‚ÑÇ)`: œà is a function from ‚ÑÇ √ó ‚Ñù to ‚ÑÇ. Although defined on all of ‚ÑÇ √ó ‚Ñù, it will only be assumed continuous on the subset U √ó [0,1]. This matches the natural statement up to harmless extension.
- `(U_open : IsOpen U)`: U is open.
- `(psi_cont : ContinuousOn psi (U √óÀ¢ (Icc (0 : ‚Ñù) 1)))`: œà is continuous on U √ó [0,1] (Icc 0 1 is the closed interval [0,1]). This matches the statement that œà: U √ó [0,1] ‚Üí ‚ÑÇ is continuous.
- `(psi_holo : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1, IsHolomorphicOn (fun z => psi (z, t)) U)`: For each fixed t ‚àà [0,1], the function z ‚Ü¶ œà(z,t) is holomorphic on U.
- Conclusion: `IsHolomorphicOn (fun z => ‚à´ t in (0 : ‚Ñù)..1, psi (z, t)) U`: The function h(z) = ‚à´_0^1 œà(z,t) dt is holomorphic on U. The notation `‚à´ t in 0..1` is the interval integral over [0,1], matching the natural statement.

Faithfulness assessment:
- All assumptions in the natural language statement are present: U open, œà continuous on U √ó [0,1], and for each t, z ‚Ü¶ œà(z,t) holomorphic on U.
- The conclusion matches exactly: the z-function obtained by integrating œà over t from 0 to 1 is holomorphic on U.
- The only technical deviation is that œà is typed on ‚ÑÇ √ó ‚Ñù but only assumed continuous on U √ó [0,1], which is standard and faithful.
- No vacuous or placeholder definitions; all terms are from Mathlib, and the theorem is a clean statement without auxiliary fake definitions.

Final check:
- The Lean theorem is the same mathematical statement as the original. No differences in meaning.
### END THOUGHT",1
jirilebl_ca_ca_2718,Complex Analysis,success,5,0,,"Let $U \subset \mathbb{C}$ be a domain and suppose that a holomorphic function $f \colon U \to \mathbb{C}$ is not constant. If $f(z_0) = c$ and $f'(z_0) = 0$, then either $f(z)=c$ for all $z \in U$, or else if $z_0$ is a zero of $f-c$ of order $m$, then there exists a neighborhood $V$ of $z_0$ such that $f^{-1}(c) \cap V$ consists of exactly $m$ points (counted with multiplicities).","import Mathlib

/--
Let U ‚äÜ ‚ÑÇ be a domain and suppose that a holomorphic function f : U ‚Üí ‚ÑÇ is not constant.
If f(z0) = c and f'(z0) = 0, then either f(z) = c for all z ‚àà U, or else if z0 is a zero
of f - c of order m, then there exists a neighborhood V of z0 such that f^{-1}({c}) ‚à© V
consists of exactly m points (counted with multiplicities).

This statement is expressed here in a form asserting the local factorisation
f(z) - c = (z - z0)^m * g(z) with g holomorphic and g(z0) ‚â† 0, which is equivalent
to the usual formulation about the number of solutions counted with multiplicity.
-/
theorem jirilebl_ca_ca_2718 {U : Set ‚ÑÇ} {f : ‚ÑÇ ‚Üí ‚ÑÇ}
  (hU_open : IsOpen U) (hU_conn : IsConnected U) (hf : IsHolomorphicOn f U)
  (hf_nonconst : ¬¨ IsConstantOn f U) {z0 c : ‚ÑÇ} (hz0 : z0 ‚àà U)
  (hfv : f z0 = c) (hder : HasDerivAt f (0 : ‚ÑÇ) z0) :
  (‚àÄ z ‚àà U, f z = c) ‚à®
  ‚àÉ (m : ‚Ñï) (hm : 1 ‚â§ m) (V : Set ‚ÑÇ) (g : ‚ÑÇ ‚Üí ‚ÑÇ),
    IsOpen V ‚àß z0 ‚àà V ‚àß V ‚äÜ U ‚àß IsHolomorphicOn g V ‚àß g z0 ‚â† 0 ‚àß
    ‚àÄ z ‚àà V, f z - c = (z - z0) ^ m * g z := by sorry
",10,"### BEGIN THOUGHT
Step 1: Line-by-line translation of the Lean code
- Context: U : Set ‚ÑÇ, f : ‚ÑÇ ‚Üí ‚ÑÇ. Assumptions:
  - hU_open : IsOpen U ‚Äî U is open.
  - hU_conn : IsConnected U ‚Äî U is connected (and hence nonempty). So U is a domain in the complex-analysis sense.
  - hf : IsHolomorphicOn f U ‚Äî f is holomorphic on U.
  - hf_nonconst : ¬¨ IsConstantOn f U ‚Äî f is not constant on U.
  - hz0 : z0 ‚àà U ‚Äî the point z0 is in U.
  - hfv : f z0 = c ‚Äî f(z0) = c.
  - hder : HasDerivAt f 0 z0 ‚Äî f‚Ä≤(z0) = 0 (complex derivative zero).

- Conclusion (disjunction): Either
  - (‚àÄ z ‚àà U, f z = c) ‚Äî f is identically equal to c on U, or
  - there exist m : ‚Ñï with 1 ‚â§ m, an open neighborhood V of z0 contained in U, and a function g : ‚ÑÇ ‚Üí ‚ÑÇ such that g is holomorphic on V, g(z0) ‚â† 0, and for all z ‚àà V,
    f z ‚àí c = (z ‚àí z0)^m * g z.

This is the standard local factorization at a zero of order m.

Step 2: Compare to the natural language statement
Natural language: Let U ‚äÜ ‚ÑÇ be a domain and f : U ‚Üí ‚ÑÇ holomorphic and not constant. If f(z0) = c and f‚Ä≤(z0) = 0, then either f(z) = c for all z ‚àà U, or else if z0 is a zero of f ‚àí c of order m, then there exists a neighborhood V of z0 such that f‚Åª¬π(c) ‚à© V consists of exactly m points (counted with multiplicities).

- Domain/holomorphic/nonconstant: Matches hU_open, hU_conn, hf, hf_nonconst.
- f(z0) = c and f‚Ä≤(z0) = 0: Matches hfv, hder.
- Conclusion: The Lean code uses a standard equivalent formulation: the existence of m ‚â• 1 and g holomorphic with g(z0) ‚â† 0 such that f(z) ‚àí c = (z ‚àí z0)^m g(z) on a neighborhood V of z0. This is equivalent to saying: z0 is a zero of order m and, for small enough V, the zeros of f ‚àí c in V are exactly z0 with multiplicity m ‚Äî i.e., f‚Åª¬π({c}) ‚à© V consists of exactly m points counted with multiplicities.

- The code includes the disjunction with the constant case, despite having the hypothesis ¬¨ IsConstantOn f U. This is harmless: given hfv and hz0, ‚Äúf is constant on U‚Äù would imply f ‚â° c on U; so under ¬¨ IsConstantOn f U, the first disjunct is impossible, leaving the second. Presenting the disjunction is faithful to the natural language which itself stated an ""either/or"".

- The code asks V ‚äÜ U (natural, since holomorphicity is only assumed on U) and asserts m ‚â• 1 (compatible; with f‚Ä≤(z0)=0 and nonconstant, one actually has m ‚â• 2, but the natural language did not state this bound explicitly, and m ‚â• 1 suffices for an equivalent formulation).

- The code expresses the ‚Äúcounted with multiplicities‚Äù part via local factorization, which is standard and explicitly acknowledged in the comment as an equivalent formulation.

Step 3: Final check
- No vacuous or placeholder definitions are introduced.
- All notions used are standard mathlib-like predicates (IsOpen, IsConnected, IsHolomorphicOn, HasDerivAt, etc.).
- The conclusion is an equivalent reformulation of the stated multiplicity claim and includes the necessary neighborhood and inclusion V ‚äÜ U.

Therefore, the Lean statement is a faithful formalization (via an equivalent formulation) of the natural language statement.
### END THOUGHT",1
jirilebl_ca_ca_3078,Complex Analysis,success,6,0,,"If $f \colon U \to \mathbb{C}$ is a holomorphic function on a domain $U \subset \mathbb{C}$, then $f$ is analytic. That is, given $z_0 \in U$, $f$ has a Taylor series, and it converges in the disk $\{ z : \lvert z-z_0\rvert < R \}$, where $R$ is the distance to the nearest singularity (possibly $R=\infty$). Furthermore, the sum of the series is $f$.","import Mathlib

/-- If f is holomorphic on an open domain U ‚äÜ ‚ÑÇ, then f is analytic on U. -/
theorem holomorphic_on_is_analytic {U : Set ‚ÑÇ} {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hU : IsOpen U)
  (hf : IsHolomorphicOn f U) : IsAnalyticOn f U := by sorry
",7,"### BEGIN THOUGHT
1) Line-by-line translation:
- `import Mathlib`: Uses Mathlib library.
- Docstring: States the intended theorem: if f is holomorphic on an open domain U ‚äÜ ‚ÑÇ, then f is analytic on U.
- `theorem holomorphic_on_is_analytic {U : Set ‚ÑÇ} {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hU : IsOpen U) (hf : IsHolomorphicOn f U) : IsAnalyticOn f U := by sorry` translates to: For any subset U of ‚ÑÇ and function f: ‚ÑÇ ‚Üí ‚ÑÇ, if U is open and f is holomorphic on U, then f is analytic on U. The proof is omitted (`sorry`).

2) Faithfulness to the natural language statement:
- The natural language statement has two parts:
  (a) Holomorphic ‚áí analytic on a domain U ‚äÜ ‚ÑÇ. This is captured by the theorem statement (modulo that the code only assumes U is open, not necessarily connected; this is a harmless generalization since the implication holds without connectedness).
  (b) A precise description of the Taylor series: for each z‚ÇÄ ‚àà U, f has a Taylor series that converges on the disk |z ‚àí z‚ÇÄ| < R, where R is the distance to the nearest singularity (possibly ‚àû), and the series sums to f. The code does not state anything about the radius of convergence equalling the distance to the nearest singularity; it only asserts analyticity. The ‚Äúsum equals f‚Äù aspect is typically part of the definition of analytic in mathlib (local equality to a power series on a ball), so that part is implicitly covered by IsAnalyticOn. But the specific identification of the radius R as the distance to the nearest singularity (maximal radius) is not present.

3) Final comparison:
- Same: Holomorphic implies analytic (first sentence) and the equality of f with its local power series is embedded in IsAnalyticOn.
- Different: The explicit characterization of the radius of convergence as the distance to the nearest singularity (possibly ‚àû) is missing from the Lean statement. Also, the natural language uses ‚Äúdomain‚Äù (open and connected) while the Lean code assumes only ‚Äúopen‚Äù; this is a slight generalization and acceptable.

Conclusion: The code captures only the first, basic part (holomorphic ‚áí analytic) and omits the substantial radius-of-convergence/nearest singularity claim. Hence it is not a faithful full translation of the given statement.
### END THOUGHT",0
jirilebl_ca_ca_997,Complex Analysis,success,5,0,,"Prove that if the $2 \times 2$ matrix $M$ represents a complex number $a+ib$, then $M$ has two eigenvalues: $a \pm i b$ with the corresponding eigenvectors $\left[ \begin{smallmatrix} 1 \\ \mp i \end{smallmatrix} \right]$.","import Mathlib

open Complex
open Matrix

theorem matrix_represents_complex_has_eigenpairs (a b : ‚Ñù) :
  let M : Matrix (Fin 2) (Fin 2) ‚Ñù :=
    Matrix.ofFun fun i j =>
      if i = 0 ‚àß j = 0 then a
      else if i = 0 ‚àß j = 1 then -b
      else if i = 1 ‚àß j = 0 then b
      else a
  let M‚ÑÇ : Matrix (Fin 2) (Fin 2) ‚ÑÇ := M.map (fun r => (r : ‚ÑÇ))
  let v_pos : Fin 2 ‚Üí ‚ÑÇ := fun i => if i = 0 then (1 : ‚ÑÇ) else -Complex.I
  let v_neg : Fin 2 ‚Üí ‚ÑÇ := fun i => if i = 0 then (1 : ‚ÑÇ) else Complex.I
  (‚àÄ i, ‚àë j, M‚ÑÇ i j * v_pos j = ((a : ‚ÑÇ) + Complex.I * (b : ‚ÑÇ)) * v_pos i) ‚àß
  (‚àÄ i, ‚àë j, M‚ÑÇ i j * v_neg j = ((a : ‚ÑÇ) - Complex.I * (b : ‚ÑÇ)) * v_neg i) := by sorry",10,"### BEGIN THOUGHT
Step-by-step translation of the Lean code:
- Imports and opens: `open Complex` and `open Matrix` just bring notations and names into scope.
- The theorem `matrix_represents_complex_has_eigenpairs (a b : ‚Ñù)` asserts a statement for arbitrary real numbers a and b.
- `let M : Matrix (Fin 2) (Fin 2) ‚Ñù := ...` defines the 2√ó2 real matrix with entries
  M = [[a, -b], [b, a]]. This is exactly the standard real matrix representing the complex number a + i b under the usual ‚Ñù-linear identification ‚ÑÇ ‚âÉ ‚Ñù^2.
- `let M‚ÑÇ : Matrix (Fin 2) (Fin 2) ‚ÑÇ := M.map (fun r => (r : ‚ÑÇ))` views M as a complex matrix by coercing its entries from ‚Ñù to ‚ÑÇ, matching the intent to talk about complex eigenvalues/eigenvectors.
- `let v_pos : Fin 2 ‚Üí ‚ÑÇ := fun i => if i = 0 then (1 : ‚ÑÇ) else -Complex.I` defines the vector v_pos = [1; ‚àíi].
- `let v_neg : Fin 2 ‚Üí ‚ÑÇ := fun i => if i = 0 then (1 : ‚ÑÇ) else Complex.I` defines the vector v_neg = [1; i].
- The conclusion is a conjunction of two statements:
  ‚Ä¢ For all i, ‚àë j, M‚ÑÇ i j * v_pos j = ((a : ‚ÑÇ) + Complex.I * (b : ‚ÑÇ)) * v_pos i. This is exactly the coordinate-wise statement (M‚ÑÇ ¬∑ v_pos) = (a + i b) ¬∑ v_pos, i.e., v_pos is an eigenvector with eigenvalue a + i b.
  ‚Ä¢ For all i, ‚àë j, M‚ÑÇ i j * v_neg j = ((a : ‚ÑÇ) - Complex.I * (b : ‚ÑÇ)) * v_neg i. This states v_neg is an eigenvector with eigenvalue a ‚àí i b.
No auxiliary vacuous definitions are introduced; the `let` bindings are concrete and correctly specify the matrix and eigenvectors. The use of sums over j expresses the matrix‚Äìvector product in components and is equivalent to the eigenvector relation.

Comparison to the natural language statement:
- The phrase ‚Äúthe 2√ó2 matrix M represents a complex number a+ib‚Äù means M = [[a, ‚àíb], [b, a]] over ‚Ñù. The code explicitly defines M to be that matrix, which is an equivalent way to formalize the hypothesis.
- The eigenvalues claimed are a ¬± i b, with corresponding eigenvectors [1; ‚àì i]. The code states exactly that: v_pos = [1; ‚àíi] corresponds to a + i b, and v_neg = [1; i] corresponds to a ‚àí i b.
- The code works over ‚ÑÇ by coercing M to a complex matrix, matching the intended setting for complex eigenvalues/eigenvectors.
- The natural language does not require distinctness of eigenvalues; the code likewise does not assert distinctness (and correctly handles b = 0 as a degenerate case where both eigenvalues coincide).

Final check:
- The formal statement exactly matches the mathematical content: for the standard real matrix representing a + i b, the given complex eigenpairs hold. There are no extraneous assumptions and no weakening/strengthening of the claim beyond the standard formulation.

Conclusion: The Lean code is a faithful translation of the natural language statement.
### END THOUGHT",1
