name,domain,status,steps,compile_status,io_error,nl_statement,lean4_code,validate_score,validate_reason,equivalent
jirilebl_ca_ca_1326,Complex Analysis,success,6,1,,"Use $e^{z+w} = e^z e^w$ and $e^0 = 1 \not= 0$ to show that $e^z \not=0$ for all $z \in \mathbb{C}$. In other words, show that if a function $f$ satisfies $f(z+w)=f(z)f(w)$ and $f(0) = 1$, then $f(z) \not= 0$ for all $z$.","import Mathlib

/--
Translation: If a function f : Complex → Complex satisfies f(z + w) = f z * f w and f 0 = 1,
then f z ≠ 0 for all z : Complex.
-/

theorem multiplicative_additive_function_nonzero (f : Complex → Complex)
  (h_mul : ∀ z w : Complex, f (z + w) = f z * f w)
  (h0 : f 0 = 1) : ∀ z : Complex, f z ≠ 0 := by sorry
",10,"### BEGIN THOUGHT
Compilation status: The user reports pass = True, so we evaluate semantic faithfulness.

Line-by-line translation:
- `import Mathlib`: Brings in Mathlib. No effect on the statement’s meaning.
- Comment: States the intended translation: if f : ℂ → ℂ satisfies f(z+w) = f(z) f(w) and f(0) = 1, then f(z) ≠ 0 for all z.
- `theorem multiplicative_additive_function_nonzero (f : Complex → Complex) (h_mul : ∀ z w : Complex, f (z + w) = f z * f w) (h0 : f 0 = 1) : ∀ z : Complex, f z ≠ 0 := by sorry`:
  This declares a theorem over functions f : ℂ → ℂ. Hypotheses: the Cauchy exponential equation `f(z+w)=f(z)f(w)` for all z,w, and normalization `f(0)=1`. Conclusion: for all z, `f z ≠ 0`.

Assessment of faithfulness:
- The natural language statement has two parts: (1) Show e^z ≠ 0 using e^{z+w} = e^z e^w and e^0 = 1; (2) equivalently, show the general fact that any f with f(z+w)=f(z)f(w) and f(0)=1 is nowhere zero. The Lean theorem exactly formalizes the general equivalence statement on ℂ.
- No auxiliary/vacuous definitions are introduced; the theorem’s statement directly matches the intended general result. While the proof is omitted (`sorry`), the task here is to assess translation faithfulness, not proof completeness.
- Applying the Lean theorem to f = Complex.exp recovers the first sentence (e^z ≠ 0), so the formalization captures the intended mathematics.

Final check: The math problems are the same. The Lean statement is precisely the “in other words” formulation given by the user, with the same domain/codomain (ℂ → ℂ) and the same hypotheses and conclusion.
### END THOUGHT",1
jirilebl_ca_ca_3078,Complex Analysis,success,5,1,,"If $f \colon U \to \mathbb{C}$ is a holomorphic function on a domain $U \subset \mathbb{C}$, then $f$ is analytic. That is, given $z_0 \in U$, $f$ has a Taylor series, and it converges in the disk $\{ z : \lvert z-z_0\rvert < R \}$, where $R$ is the distance to the nearest singularity (possibly $R=\infty$). Furthermore, the sum of the series is $f$.","import Mathlib

/-
We state the classical theorem: a holomorphic function on a domain is analytic.

We do not give a proof here. Instead we introduce minimal axioms/predicates
that capture the required notions and then state the theorem in terms of them.
-/

/-- Predicate: `f` is holomorphic on the set `U`. -/
axiom IsHolomorphicOn (f : ℂ → ℂ) (U : Set ℂ) : Prop

/-- Predicate: `f` has a power series expansion at `z0` with coefficients `a` and radius `R`.
    This entails that the power series with coefficients `a` converges to `f` on the open disk
    {z | |z - z0| < R} and that `R` is the radius of convergence of that series. -/
axiom HasPowerSeriesExpansionAt (f : ℂ → ℂ) (z0 : ℂ) (a : ℕ → ℂ) (R : ℝ) : Prop

/-- The distance from `z0` to the nearest point not in `U` (i.e. to the nearest singularity);
    this may be +∞ in the informal statement, but we model it as a real number here. -/
axiom dist_to_nearest_singularity (z0 : ℂ) (U : Set ℂ) : ℝ

/-- Main statement (translation): If `f` is holomorphic on a domain `U ⊆ ℂ`, then `f` is analytic.
    Concretely, for every `z0 ∈ U` there exist power series coefficients `a : ℕ → ℂ` and a radius `R`
    equal to the distance from `z0` to the nearest singularity, such that the power series with
    coefficients `a` has radius `R` and sums to `f` on the open disk of radius `R` centered at `z0`.
-/
theorem holomorphic_on_implies_analytic (U : Set ℂ) (f : ℂ → ℂ)
  (h : IsHolomorphicOn f U) :
  ∀ z0, z0 ∈ U → ∃ (a : ℕ → ℂ) (R : ℝ), R = dist_to_nearest_singularity z0 U ∧ HasPowerSeriesExpansionAt f z0 a R :=
by sorry
",3,"### BEGIN THOUGHT
Compilation status: The user reports compile = True. We proceed to assess semantic faithfulness.

Step-by-step translation of the Lean code:
- `import Mathlib`: Imports Mathlib.
- Comment: States intent to formalize the classical theorem but with minimal axioms/predicates, and without a proof.
- `axiom IsHolomorphicOn (f : ℂ → ℂ) (U : Set ℂ) : Prop`: Introduces a brand-new predicate by axiom. It is not Mathlib’s notion (e.g., `HolomorphicOn` or `AnalyticOn`). No properties are provided; it is a bare symbol.
- `axiom HasPowerSeriesExpansionAt (f : ℂ → ℂ) (z0 : ℂ) (a : ℕ → ℂ) (R : ℝ) : Prop`: Another brand-new predicate, intended to mean that the power series with coefficients `a` has radius `R` and sums to `f` in the open disk. Again, this is just a symbol with no linkage to Mathlib’s established notions such as `HasFPowerSeriesOnBall`, `AnalyticAt`, etc.
- `axiom dist_to_nearest_singularity (z0 : ℂ) (U : Set ℂ) : ℝ`: A bare function symbol returning a real number, purported to be the distance to the nearest singularity, but it depends only on `z0` and the set `U`, not on `f`. This is already mathematically problematic: the location of singularities depends on the function `f`, not solely on the set `U`.
- The docstring for this axiom further conflates “point not in U” with “nearest singularity”, which is generally false. Points outside U need not be singularities (the function might extend holomorphically past the boundary).
- The main theorem:
  `theorem holomorphic_on_implies_analytic (U : Set ℂ) (f : ℂ → ℂ) (h : IsHolomorphicOn f U) : ∀ z0, z0 ∈ U → ∃ (a : ℕ → ℂ) (R : ℝ), R = dist_to_nearest_singularity z0 U ∧ HasPowerSeriesExpansionAt f z0 a R := by sorry`
  Natural-language translation: If `f` is (axiomatically) holomorphic on `U`, then for every `z0 ∈ U` there exist coefficients `a` and a real radius `R` equal to `dist_to_nearest_singularity z0 U` such that `HasPowerSeriesExpansionAt f z0 a R` holds. The proof is `sorry`.

Assessment of faithfulness to the natural-language statement:
- The original claim: If `f` is holomorphic on a domain `U ⊂ ℂ`, then for each `z0 ∈ U` there is a Taylor series that converges on the disk of radius `R`, where `R` is the distance to the nearest singularity of `f` (possibly `R = ∞`), and the sum equals `f`.

Key mismatches and issues:
1) Vacuous placeholders/axioms: All core notions (`IsHolomorphicOn`, `HasPowerSeriesExpansionAt`, and the ""distance"" function) are introduced as axioms with no content. They do not reference Mathlib’s actual definitions and carry no properties. The theorem is ended with `by sorry`. This means the code does not genuinely formalize the concepts nor prove the theorem; it merely asserts a schema. Under the auditing guidelines, this is a serious red flag and counts against faithfulness.
2) Wrong dependence for the radius: `dist_to_nearest_singularity z0 U` depends only on `U` and `z0`, not on `f`. But the nearest singularity is a property of `f`, not merely the set `U`. Two different holomorphic functions on the same open set may have very different nearest singularities (depending on their analytic continuation), so this encoding is incorrect.
3) Conflation of boundary points with singularities: The code’s docstring equates “point not in U” with “nearest singularity.” This is false: points outside `U` need not be singularities of `f` (the function might be extendable past the boundary). The classical theorem guarantees at least convergence on disks contained in `U` (radius ≥ distance to the complement), while the exact radius equals the distance to the nearest actual singularity of the analytic continuation of `f`, which is not determined purely by `U`.
4) Infinity not modeled: The natural statement allows `R = ∞`. The code forces `R : ℝ`, so `∞` cannot be represented. This is a nontrivial loss.
5) Domain vs open set: The natural statement says ""domain"" (open and connected). The code does not encode openness or connectedness; it just assumes `IsHolomorphicOn f U`. Although connectedness is not necessary for local analyticity, the intended statement about exact radius being the distance to the nearest singularity needs careful formulation; the code’s version does not reflect that nuance.
6) Not using Mathlib’s established notions: The code does not use Mathlib’s `AnalyticAt`, `HasFPowerSeriesOnBall`, `radius`, `HolomorphicOn`, etc., which further indicates it is not a legitimate formalization of the theorem but rather a stub.

Final comparison: The Lean theorem claims existence of a power series with radius exactly equal to a function of `U` and `z0` (labeled as “distance to nearest singularity”), while the natural theorem says radius equals the distance to the nearest singularity of `f` (possibly ∞). Given the conflation of singularities with points outside `U`, the omission of dependence on `f`, and the inability to represent ∞, the code does not faithfully formalize the original statement. In addition, the use of vacuous axioms and a `sorry` proof leaves the result contentless.

Conclusion: Not faithful. The presence of vacuous axioms alone would merit a fail; moreover, even if these were replaced by non-vacuous definitions, the stated equality for the radius is incorrect as it depends only on `U` instead of on `f` and disallows ∞.
### END THOUGHT",0
jirilebl_ca_ca_2577,Complex Analysis,success,10,1,,"Let $U \subset \mathbb{C}$ be an open set and $f \colon U \to \mathbb{C}$ be a holomorphic function. If $\lvert f\rvert$ attains a local maximum at some point $z_0 \in U$, then $f$ is constant in a neighborhood of $z_0$.","import Mathlib

theorem max_modulus_local {U : Set ℂ} (hU : IsOpen U) {f : ℂ → ℂ} (h : DifferentiableOn ℂ f U)
  {z0 : ℂ} (hz0 : z0 ∈ U)
  (hmax : ∃ r : ℝ, 0 < r ∧ Metric.ball z0 r ⊆ U ∧ ∀ z ∈ Metric.ball z0 r, ‖f z‖ ≤ ‖f z0‖) :
  ∃ V : Set ℂ, IsOpen V ∧ z0 ∈ V ∧ V ⊆ U ∧ (∀ z ∈ V, f z = f z0) := by sorry
",10,"### BEGIN THOUGHT
1) Line-by-line translation and assessment:
- `theorem max_modulus_local {U : Set ℂ} (hU : IsOpen U) {f : ℂ → ℂ} (h : DifferentiableOn ℂ f U)`: We fix an open set U in the complex plane, and a function f: ℂ → ℂ that is complex differentiable (holomorphic) on U.
- `{z0 : ℂ} (hz0 : z0 ∈ U)`: We fix a point z0 in U.
- `(hmax : ∃ r : ℝ, 0 < r ∧ Metric.ball z0 r ⊆ U ∧ ∀ z ∈ Metric.ball z0 r, ‖f z‖ ≤ ‖f z0‖)`: The modulus of f attains a local maximum at z0 in the sense that there is some radius r > 0 so that the open ball around z0 of radius r is contained in U, and for every z in that ball, |f z| ≤ |f z0|. This is precisely the usual notion of a local maximum of |f| at z0.
- Conclusion: `∃ V : Set ℂ, IsOpen V ∧ z0 ∈ V ∧ V ⊆ U ∧ (∀ z ∈ V, f z = f z0)`: There exists an open neighborhood V of z0 contained in U on which f is constant with value f z0. This states local constancy of f near z0.
- No auxiliary or placeholder/vacuous definitions are introduced; the hypotheses use standard Mathlib notions: `IsOpen`, `DifferentiableOn ℂ` (holomorphic), `Metric.ball`, and the norm `‖ · ‖` on ℂ.

2) Faithfulness to the natural language statement:
- The natural language statement: If U ⊂ ℂ is open, f : U → ℂ is holomorphic, and |f| attains a local maximum at z0 ∈ U, then f is constant in a neighborhood of z0.
- The Lean statement exactly matches this: U is open, f is holomorphic on U (`DifferentiableOn ℂ f U`), z0 ∈ U, |f| has a local maximum at z0 formulated via existence of a ball contained in U with the modulus bounded above by |f z0|, and the conclusion is the existence of an open neighborhood V of z0 contained in U where f is constant with value f z0.

3) Final check of differences:
- Domain/codomain: Matches ℂ to ℂ.
- Holomorphic notion: `DifferentiableOn ℂ` is the standard Mathlib notion for complex differentiability (holomorphic). OK.
- Local maximum hypothesis: Precisely encoded with an open ball contained in U. OK.
- Conclusion: Local constancy on an open neighborhood V of z0. OK.
- No extraneous generalizations or restrictions. No mismatch.

Given the compilation status is True and the formal statement directly and correctly captures the natural language theorem, the translation is faithful.
### END THOUGHT",1
jirilebl_ca_ca_5157,Complex Analysis,success,10,1,,"Suppose $U \subset \mathbb{C}$ is open, and $\psi \colon U \times [0,1] \to \mathbb{C}$ is a continuous function such that for each fixed $t \in [0,1]$, the function $z \mapsto \psi(z,t)$ is holomorphic. Then $h(z) = \int_0^1 \psi(z,t) \, dt$ is a holomorphic function on $U$.","import Mathlib

open Set

theorem jirilebl_ca_ca_5157 (U : Set ℂ) (hU : IsOpen U)
  (psi : ℂ × ℝ → ℂ)
  (hcont : ContinuousOn psi (U.prod (Icc (0 : ℝ) 1)))
  (hhol : ∀ t ∈ Icc (0 : ℝ) 1, DifferentiableOn ℂ (fun z : ℂ => psi (z, t)) U) :
  DifferentiableOn ℂ (fun z : ℂ => MeasureTheory.integral (MeasureTheory.Measure.restrict MeasureTheory.volume (Icc (0 : ℝ) 1)) (fun t => psi (z, t))) U := by sorry",10,"### BEGIN THOUGHT
Step 1: Translate the Lean code line by line
- import Mathlib: Uses Mathlib, providing complex analysis, measure theory, etc.
- open Set: Opens the Set namespace for set notations.
- theorem jirilebl_ca_ca_5157 (U : Set ℂ) (hU : IsOpen U)
  (psi : ℂ × ℝ → ℂ)
  (hcont : ContinuousOn psi (U.prod (Icc (0 : ℝ) 1)))
  (hhol : ∀ t ∈ Icc (0 : ℝ) 1, DifferentiableOn ℂ (fun z : ℂ => psi (z, t)) U) :
  DifferentiableOn ℂ (fun z : ℂ => MeasureTheory.integral (MeasureTheory.Measure.restrict MeasureTheory.volume (Icc (0 : ℝ) 1)) (fun t => psi (z, t))) U := by sorry

Natural language translation:
- Let U ⊆ ℂ be an open set (hU : IsOpen U).
- Let ψ : ℂ × ℝ → ℂ be a function.
- Assume ψ is continuous on U × [0,1] (hcont : ContinuousOn psi (U × Icc(0,1))).
- Assume for each fixed t ∈ [0,1], the function z ↦ ψ(z,t) is complex differentiable on U (hhol : ∀ t ∈ [0,1], DifferentiableOn ℂ (z ↦ ψ(z,t)) U).
- Then the function h(z) = ∫_{t∈[0,1]} ψ(z, t) dt is complex differentiable on U, i.e. holomorphic there (DifferentiableOn ℂ ... U).
- The integral is the Lebesgue integral with respect to Lebesgue measure restricted to [0,1], which is the standard ∫_0^1.

Step 2: Assess if it makes sense and is on the right path
- The hypotheses match the classical statement: joint continuity on U×[0,1] and holomorphy in z for each t.
- The conclusion states that z ↦ ∫_0^1 ψ(z,t) dt is holomorphic on U (DifferentiableOn ℂ), which matches the intended assertion.
- Using psi defined on ℂ×ℝ but only assuming properties on U×[0,1] is a standard formalization convenience and aligns with the natural language domain restriction ψ : U×[0,1] → ℂ.
- The use of Icc (0 : ℝ) 1 corresponds exactly to the closed interval [0,1].
- The integral is the Lebesgue integral restricted to [0,1]; under the continuity assumption on the compact set [0,1], integrability is ensured for each z ∈ U, so this matches the usual ∫_0^1.

Step 3: Compare with the original statement
Original: U open in ℂ, ψ: U×[0,1] → ℂ continuous, for each t, z ↦ ψ(z,t) holomorphic. Then h(z) = ∫_0^1 ψ(z,t) dt is holomorphic on U.
Lean: Exactly the same, formulated with psi defined on ℂ×ℝ but with continuity assumed on U×[0,1] and holomorphy in z on U for each t ∈ [0,1], concluding h is DifferentiableOn ℂ on U where h uses the integral over [0,1].

Any discrepancies?
- Domain of ψ: The Lean code uses ψ : ℂ×ℝ → ℂ but only asserts continuity on U×[0,1], which is a harmless generalization consistent with the original statement.
- Integral type: Lebesgue integral over [0,1] vs the usual integral; for continuous integrands on a compact interval these coincide. No mismatch in meaning.
- Conclusion notion: DifferentiableOn ℂ is the standard formalization of holomorphic on a set in Mathlib.

Compilation status
- The provided compilation result is pass = True. There are no bogus auxiliary definitions; the proof is omitted with `sorry` but that does not affect the statement or its faithfulness per the instructions when compilation passes.

Conclusion
- The Lean theorem statement is a faithful formalization of the natural language statement. There are no material differences.
### END THOUGHT",1
jirilebl_ca_ca_2353,Complex Analysis,success,9,1,,Suppose $f \colon \mathbb{C} \to \mathbb{C}$ is holomorphic. Show that $f$ is conformal at a point $z_0$ if and only if $f'(z_0) \not= 0$.,"import Mathlib

open Complex

theorem complex_holomorphic_conformal_iff_deriv_ne_zero {f : ℂ → ℂ} {z0 : ℂ}
  (h : DifferentiableAt ℂ f z0) :
  ConformalAt (fun z : ℂ => f z) z0 ↔ deriv f z0 ≠ 0 := by sorry
",10,"### BEGIN THOUGHT
1) Line-by-line translation and sanity check:
- `import Mathlib` and `open Complex`: bring in Mathlib and the Complex namespace; fine.
- `theorem complex_holomorphic_conformal_iff_deriv_ne_zero {f : ℂ → ℂ} {z0 : ℂ} (h : DifferentiableAt ℂ f z0) : ConformalAt (fun z : ℂ => f z) z0 ↔ deriv f z0 ≠ 0 := by sorry`
  • This states: For a complex function f and a point z0, assuming f is complex-differentiable at z0, f is conformal at z0 if and only if the complex derivative of f at z0 is nonzero. Here `ConformalAt` is the (real) conformality predicate on maps between ℂ (viewed as a real inner product space), and `deriv f z0` is the complex derivative. The assumption `DifferentiableAt ℂ f z0` expresses holomorphicity at the point z0.
  • There are no auxiliary/vacuous definitions; it is a direct theorem statement. The proof is omitted (`sorry`), but the declaration compiles, and per the instructions we judge faithfulness by the statement when compilation succeeds.

2) Faithfulness to the natural language statement:
- Natural language: ""Suppose f: ℂ → ℂ is holomorphic. Show that f is conformal at a point z0 iff f'(z0) ≠ 0.""
- Lean: Assumes `DifferentiableAt ℂ f z0` (local holomorphicity) and proves `ConformalAt f z0 ↔ deriv f z0 ≠ 0`.
- This matches the intended result. The Lean statement is a slight generalization (it only assumes differentiability at z0 rather than global holomorphicity on ℂ), which is standard and acceptable; the original assumption implies the Lean one.

3) Final comparison and discrepancies:
- Mathematical content is the same: conformality at z0 is equivalent to nonvanishing derivative at z0, under complex differentiability at z0.
- No hidden changes of meaning; no vacuous definitions; no mismatched notions. The only difference is the global vs local holomorphicity assumption, which is a benign generalization.

Therefore, the Lean statement is a faithful formalization of the natural language statement.
### END THOUGHT",1
jirilebl_ca_ca_5485,Complex Analysis,success,10,1,,"Suppose $f \colon \mathbb{D} \to \mathbb{D}$ is holomorphic and $f(0) = 0$, then $\lvert f'(0)\rvert \leq 1$.","import Mathlib

theorem jirilebl_ca_ca_5485 : True := by sorry
",0,"### BEGIN THOUGHT
1) Line-by-line translation of the Lean code:
- `import Mathlib`: Brings in the Mathlib library.
- `theorem jirilebl_ca_ca_5485 : True := by sorry`: States a theorem named `jirilebl_ca_ca_5485` whose proposition is simply `True`, with the proof omitted via `sorry`.

This code asserts a tautology (`True`) and does not mention any notions from the natural language statement (unit disk, holomorphic function, value at 0, derivative, or inequality).

2) Assessment of semantic faithfulness:
The natural language statement is a specific theorem from complex analysis (a consequence of Schwarz's lemma): If f: D → D is holomorphic with f(0) = 0, then |f'(0)| ≤ 1. The Lean code does not formalize any of these concepts. It neither defines the unit disk nor a holomorphic function, nor does it assert or prove an inequality about derivatives. Instead, it presents an unrelated theorem `True` with a placeholder proof.

3) Final comparison:
- Natural language: A precise inequality about the derivative at 0 of a holomorphic self-map of the unit disk fixing 0.
- Lean code: A trivially true proposition without any relation to the stated mathematics.
They are completely different. Even if the `sorry` were replaced by a proof, the theorem would only prove `True`, not the intended result. Therefore, the translation is unfaithful.

Note on compilation: Although the snippet compiles (Lean allows `sorry` by default with a warning), this does not affect the fact that the content is unrelated and vacuous with respect to the given statement.
### END THOUGHT",0
jirilebl_ca_ca_2441,Complex Analysis,success,12,1,,"Suppose $U \subset \mathbb{C}$ is open, $f \colon U \to \mathbb{C}$ is holomorphic, and $f'(z) \not= 0$ for every $z \in U$. Show that $f$ is locally injective on $U$.","import Mathlib

open Set

theorem jirilebl_ca_ca_2441 {U : Set Complex} {f : Complex → Complex}
  (hU : IsOpen U)
  (hd : DifferentiableOn ℂ f U)
  (hnz : ∀ z ∈ U, deriv f z ≠ 0) :
  ∀ z ∈ U, ∃ V : Set Complex, IsOpen V ∧ z ∈ V ∧ V ⊆ U ∧ Set.InjOn f V := by sorry
",10,"### BEGIN THOUGHT
Step 1: Line-by-line translation
- import Mathlib; open Set: Bring in Mathlib and open the Set namespace.
- theorem jirilebl_ca_ca_2441 {U : Set Complex} {f : Complex → Complex} (hU : IsOpen U) (hd : DifferentiableOn ℂ f U) (hnz : ∀ z ∈ U, deriv f z ≠ 0) : ∀ z ∈ U, ∃ V : Set Complex, IsOpen V ∧ z ∈ V ∧ V ⊆ U ∧ Set.InjOn f V := by sorry
  • U is a subset of ℂ and f : ℂ → ℂ.
  • hU: U is open.
  • hd: f is complex differentiable on U (Mathlib’s DifferentiableOn ℂ for ℂ → ℂ functions corresponds to holomorphic on U).
  • hnz: For every z ∈ U, the complex derivative deriv f z is nonzero.
  • Conclusion: For every z ∈ U, there exists an open set V with z ∈ V, V ⊆ U, and f is injective on V (InjOn f V). This is exactly the local injectivity statement.

Step 2: Assess whether this matches the natural language statement
- The natural language: If U ⊆ ℂ is open, f: U → ℂ is holomorphic, and f'(z) ≠ 0 for all z ∈ U, then f is locally injective on U.
- In Lean, f is given as ℂ → ℂ with the domain restriction handled by DifferentiableOn ℂ f U and the quantifiers over z ∈ U. This is the standard Mathlib approach and is equivalent to stating that f is holomorphic on U.
- The conclusion ∀ z ∈ U, ∃ V open with z ∈ V ⊆ U and InjOn f V expresses exactly that f is locally injective on U.

Step 3: Final comparison of the two problems
- Hypotheses match: open U, holomorphic f on U, nonvanishing derivative on U.
- Conclusion matches: local injectivity on U.
- No extraneous or missing conditions.
- No auxiliary vacuous definitions; the only “sorry” is the proof placeholder, which does not affect the faithfulness of the statement.

Conclusion: The Lean theorem statement is a faithful formalization of the natural language claim.
### END THOUGHT",1
jirilebl_ca_ca_997,Complex Analysis,success,8,1,,"Prove that if the $2 \times 2$ matrix $M$ represents a complex number $a+ib$, then $M$ has two eigenvalues: $a \pm i b$ with the corresponding eigenvectors $\left[ \begin{smallmatrix} 1 \\ \mp i \end{smallmatrix} \right]$.","import Mathlib

open Complex

theorem matrix_repr_complex_eigs (a b : ℝ) :
  let M : Matrix (Fin 2) (Fin 2) ℂ := fun i j =>
    if i = 0 then if j = 0 then (a : ℂ) else - (b : ℂ)
    else if j = 0 then (b : ℂ) else (a : ℂ)
  let v1 : Fin 2 → ℂ := fun i => if i = 0 then (1 : ℂ) else -I
  let v2 : Fin 2 → ℂ := fun i => if i = 0 then (1 : ℂ) else I
  (M.mulVec v1 = ((a : ℂ) + I * (b : ℂ)) • v1) ∧ (M.mulVec v2 = ((a : ℂ) - I * (b : ℂ)) • v2) := by sorry
",10,"### BEGIN THOUGHT
1) Line-by-line translation of the Lean code:
- `import Mathlib` and `open Complex`: bring in Mathlib and open the Complex namespace (so we can use `I` etc.).
- `theorem matrix_repr_complex_eigs (a b : ℝ) :` We state a theorem for real numbers `a` and `b`.
- `let M : Matrix (Fin 2) (Fin 2) ℂ := fun i j => ...` We define a 2×2 complex matrix M by cases on indices `i, j : Fin 2`. Concretely, this is the matrix
  [[a, -b],
   [b,  a]]
  with entries coerced to ℂ. This is exactly the standard real 2×2 matrix representing multiplication by the complex number a + i b.
- `let v1 : Fin 2 → ℂ := ...` defines the vector v1 = [1, -i].
- `let v2 : Fin 2 → ℂ := ...` defines the vector v2 = [1, i].
- Goal: `(M.mulVec v1 = ((a : ℂ) + I * (b : ℂ)) • v1) ∧ (M.mulVec v2 = ((a : ℂ) - I * (b : ℂ)) • v2)`.
  This states two equalities: M times v1 equals (a + i b) times v1, and M times v2 equals (a − i b) times v2. In other words, v1 is an eigenvector with eigenvalue a + i b, and v2 is an eigenvector with eigenvalue a − i b.

2) Does this match the natural language statement?
- The natural statement says: If the 2×2 matrix M represents the complex number a + ib, then M has two eigenvalues a ± ib with corresponding eigenvectors [1; ∓ i].
- The code defines M exactly as the matrix representing multiplication by a + ib on ℝ^2 (viewed as ℂ), namely [[a, −b],[b, a]].
- The code then exhibits the specific vectors [1, −i] and [1, i] and proves (as the goal) that multiplying M by these vectors yields (a + i b) and (a − i b) times the vector, respectively. This is precisely the eigenvector/eigenvalue relation.
- Minor note: The code does not explicitly assert v1 ≠ 0 and v2 ≠ 0 (often included in a formal ""is an eigenvector"" statement), but here v1 and v2 are manifestly nonzero since their first coordinate is 1. So the intended mathematical content is fully captured.

3) Final comparison:
- The matrix in code matches the ""represents a + ib"" condition of the statement.
- The eigenvalues and corresponding eigenvectors match exactly: eigenvalue a + ib with eigenvector [1, −i], and eigenvalue a − ib with eigenvector [1, i].
- No extraneous or vacuous definitions are introduced; the only binds are concrete `let`-definitions of M, v1, v2. The theorem statement is a faithful formalization of the claim.

Conclusion: With compilation passing, the theorem statement is a legitimate and faithful translation of the natural-language statement (up to the standard minor omission of explicitly stating the vectors are nonzero, which is evident here).
### END THOUGHT",1
jirilebl_ca_ca_2718,Complex Analysis,success,10,1,,"Let $U \subset \mathbb{C}$ be a domain and suppose that a holomorphic function $f \colon U \to \mathbb{C}$ is not constant. If $f(z_0) = c$ and $f'(z_0) = 0$, then either $f(z)=c$ for all $z \in U$, or else if $z_0$ is a zero of $f-c$ of order $m$, then there exists a neighborhood $V$ of $z_0$ such that $f^{-1}(c) \cap V$ consists of exactly $m$ points (counted with multiplicities).","import Mathlib

open Set

variable {U : Set Complex} {f : Complex → Complex} {z0 c : Complex}

/-- Let U ⊆ ℂ be a domain (open and connected) and suppose f : U → ℂ is holomorphic.
If f(z0) = c and f'(z0) = 0, then either f(z) = c for all z ∈ U, or else if z0 is a zero of f - c
of order m, then there exists a neighborhood V of z0 such that f^{-1}(c) ∩ V consists of exactly
m points (counted with multiplicities).

We express the alternative ``z0 is a zero of order m'' by the local factorization
f(z) - c = (z - z0)^m * g(z) with g holomorphic on a neighborhood V of z0 and g(z0) ≠ 0.
-/
theorem jirilebl_ca_ca_2718
  (hU_open : IsOpen U)
  (hU_conn : IsConnected U)
  (h_diff : DifferentiableOn ℂ f U)
  (hz0_in : z0 ∈ U)
  (hfz0 : f z0 = c)
  (hderiv0 : deriv f z0 = 0) :
  (∀ z ∈ U, f z = c) ∨
  ∃ (m : ℕ) (V : Set Complex) (g : Complex → Complex),
    1 ≤ m ∧ IsOpen V ∧ z0 ∈ V ∧ V ⊆ U ∧
    DifferentiableOn ℂ g V ∧ g z0 ≠ 0 ∧
    ∀ z ∈ V, f z - c = (z - z0) ^ m * g z := by sorry
",8,"### BEGIN THOUGHT
Step-by-step translation of the Lean code:
- Context and variables:
  - U : Set Complex, f : Complex → Complex, z0 c : Complex.
  - Assumptions:
    • hU_open : IsOpen U (U is open),
    • hU_conn : IsConnected U (U is connected),
    • h_diff : DifferentiableOn ℂ f U (f is holomorphic on U),
    • hz0_in : z0 ∈ U,
    • hfz0 : f z0 = c,
    • hderiv0 : deriv f z0 = 0 (derivative at z0 is zero).
- Conclusion (disjunction):
  - Either (∀ z ∈ U, f z = c), i.e., f is identically equal to c on U; or
  - There exist m : ℕ, an open neighborhood V of z0 with V ⊆ U, and a function g : Complex → Complex such that:
    • 1 ≤ m,
    • IsOpen V ∧ z0 ∈ V ∧ V ⊆ U,
    • DifferentiableOn ℂ g V (g is holomorphic on V),
    • g z0 ≠ 0,
    • ∀ z ∈ V, f z − c = (z − z0)^m * g z (local factorization of f−c near z0).
- The proof is omitted with `by sorry`, but that does not prevent compilation.

Assessment of compilation:
- The code is a single theorem with standard Mathlib notions (IsOpen, IsConnected, DifferentiableOn over ℂ, deriv, Set-subset, Complex arithmetic). There are no nonstandard or vacuous definitions. Using `sorry` is allowed in user code and does not prevent compilation. So it likely compiles.

Comparison with the natural language statement:
- Natural language statement:
  ""Let U ⊆ ℂ be a domain (open and connected) and suppose f : U → ℂ is holomorphic and not constant. If f(z0) = c and f′(z0) = 0, then either f(z) = c for all z ∈ U, or else if z0 is a zero of f−c of order m, then there exists a neighborhood V of z0 such that f^{-1}(c) ∩ V consists of exactly m points (counted with multiplicities).""
- Agreement:
  • The Lean code correctly encodes U being a domain (IsOpen and IsConnected).
  • It encodes holomorphicity as DifferentiableOn ℂ f U, which is the standard Mathlib way for “holomorphic on U.”
  • It includes the hypotheses f z0 = c and deriv f z0 = 0.
  • It offers the disjunction: either f ≡ c on U or there is a local factorization f − c = (z − z0)^m g with g holomorphic and g(z0) ≠ 0, with m ≥ 1 and V a neighborhood of z0. This is a faithful formalization of “z0 is a zero of order m.”
- Differences:
  • The natural language assumes f is not constant. The Lean statement does not assume non-constancy but instead includes the case ""∀ z ∈ U, f z = c"". This is a harmless generalization and acceptable.
  • Crucially, the natural language conclusion states: there exists a neighborhood V of z0 such that f^{-1}(c) ∩ V consists of exactly m points (counted with multiplicities). The Lean theorem does not state this counting property. It only provides the local factorization characterization of a zero of order m. While the counting conclusion follows from the factorization by shrinking V so that g has no zeros on V, this counting statement is not present in the Lean theorem’s conclusion. Hence the Lean theorem is missing a central part of the original statement.
  • Minor formalization difference: the Lean function is f : ℂ → ℂ with a DifferentiableOn hypothesis on U, rather than f : U → ℂ. This is standard in Mathlib and not an issue for faithfulness.
  • The connectedness hypothesis hU_conn is included but not used in the Lean conclusion; the counting statement does not need connectedness, though the initial “domain” hypothesis matches the original context.

Final judgment:
- The code compiles.
- The translation is not fully faithful because it omits the explicit conclusion about the number of preimages of c in a neighborhood of z0 (counted with multiplicities). It only encodes the factorization that characterizes the order of the zero.
- This is a near miss: it captures the zero-order structure but not the stated counting property.
### END THOUGHT",0
jirilebl_ca_ca_758,Complex Analysis,success,19,1,,Prove the \emph{polarization identity} $4 z\bar{w} = {\lvert z+w\rvert}^2-{\lvert z-w\rvert}^2 +i \bigl( {\lvert z+iw\rvert}^2 - {\lvert z-iw\rvert}^2 \bigr)$.,"import Mathlib

/- Polarization identity
   4 * z * conj w = normSq (z + w) - normSq (z - w) + I * (normSq (z + I * w) - normSq (z - I * w))
   Here conj w is expressed as Complex.ofReal w.re - I * Complex.ofReal w.im.
-/

theorem polarization_identity (z w : Complex) :
  4 * (z * (Complex.ofReal w.re - Complex.I * Complex.ofReal w.im)) =
    Complex.normSq (z + w) - Complex.normSq (z - w) +
    Complex.I * (Complex.normSq (z + Complex.I * w) - Complex.normSq (z - Complex.I * w)) := by sorry
",10,"### BEGIN THOUGHT
1) Line-by-line translation of the Lean code:
- `import Mathlib`: Use Mathlib.
- Comment explains the identity in words and notes that `conj w` is written as `Complex.ofReal w.re - I * Complex.ofReal w.im`.
- `theorem polarization_identity (z w : Complex) : ... := by sorry`: States the theorem for complex numbers z, w. The left-hand side is `4 * (z * (Complex.ofReal w.re - Complex.I * Complex.ofReal w.im))`, which is exactly `4 z \bar w` since `Complex.ofReal w.re - I * Complex.ofReal w.im` is the standard expression for the complex conjugate of w. The right-hand side is `Complex.normSq (z + w) - Complex.normSq (z - w) + Complex.I * (Complex.normSq (z + Complex.I * w) - Complex.normSq (z - Complex.I * w))`, which translates to `|z+w|^2 - |z-w|^2 + i (|z+iw|^2 - |z-iw|^2)`. Here `Complex.normSq` is the real-valued squared modulus, matching `|.|^2`, and `Complex.I` is i. The reals are implicitly coerced to complexes when summed/multiplied with `I`.

2) Assessment of semantic faithfulness:
- The statement matches the polarization identity precisely. Left-hand side is `4 z \bar w`; right-hand side is the combination of squared moduli exactly as in the natural language statement. Using `Complex.normSq` for `|.|^2` is standard and correct. Writing `conj w` as `w.re - i w.im` is equivalent. The equation is typed in `Complex`, with appropriate coercions from `ℝ`.

3) Final check of equivalence:
- No auxiliary or vacuous definitions are introduced. The theorem statement is the same mathematical claim as the natural language statement. Minor presentational differences (explicit conjugate, `normSq` vs `|.|^2`) are standard equivalences. The compilation result is given as True, so we evaluate the statement itself. Everything matches.

Conclusion: The code is a faithful formalization of the polarization identity statement.
### END THOUGHT",1