name,domain,status,steps,compile_status,io_error,nl_statement,lean4_code,validate_score,validate_reason,equivalent
jirilebl_ca_ca_2441,Complex Analysis,success,3,1,,"Suppose $U \subset \mathbb{C}$ is open, $f \colon U \to \mathbb{C}$ is holomorphic, and $f'(z) \not= 0$ for every $z \in U$. Show that $f$ is locally injective on $U$.","import Mathlib

open Set Metric

/-- Suppose U ‚äÇ ‚ÑÇ is open, f : U ‚Üí ‚ÑÇ is holomorphic, and f'(z) ‚â† 0 for every z ‚àà U. Show that f is locally injective on U. -/
theorem local_injective_of_deriv_ne_zero {U : Set ‚ÑÇ} (hU : IsOpen U) {f : ‚ÑÇ ‚Üí ‚ÑÇ}
  (hf : DifferentiableOn ‚ÑÇ f U) (h : ‚àÄ z ‚àà U, deriv f z ‚â† 0) :
  ‚àÄ z ‚àà U, ‚àÉ r > 0, InjOn f (U ‚à© ball z r) := by sorry
",10,"### BEGIN THOUGHT
Step 1: Translate the Lean code line by line.
- `theorem local_injective_of_deriv_ne_zero {U : Set ‚ÑÇ} (hU : IsOpen U) {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : DifferentiableOn ‚ÑÇ f U) (h : ‚àÄ z ‚àà U, deriv f z ‚â† 0) : ‚àÄ z ‚àà U, ‚àÉ r > 0, InjOn f (U ‚à© ball z r)`
  Natural language: Let U be an open subset of ‚ÑÇ. Let f : ‚ÑÇ ‚Üí ‚ÑÇ be a function that is complex-differentiable on U. Assume that for every z in U, the complex derivative deriv f z is nonzero. Then for every z in U, there exists r > 0 such that f is injective on the set U ‚à© ball(z, r).

Step 2: Assess faithfulness to the original statement.
- Original: U ‚äÇ ‚ÑÇ open, f : U ‚Üí ‚ÑÇ holomorphic, and f'(z) ‚â† 0 for all z ‚àà U. Show f is locally injective on U.
- Lean: Uses f : ‚ÑÇ ‚Üí ‚ÑÇ but only assumes differentiability on U (DifferentiableOn ‚ÑÇ f U), and nonvanishing deriv on U. Conclusion: for each z ‚àà U, there is r > 0 with f injective on U ‚à© ball z r. This exactly expresses local injectivity on U (an open neighborhood in the subspace topology of U).
- The use of f : ‚ÑÇ ‚Üí ‚ÑÇ instead of f : U ‚Üí ‚ÑÇ is a standard formalization choice; it‚Äôs a slight generalization that does not change the content of the statement since all hypotheses and the conclusion are restricted to U.

Step 3: Final check for differences.
- Domain difference (f defined on ‚ÑÇ vs U) is harmless; the differentiability and nonvanishing derivative are asserted only on U, and the local injectivity is proved on neighborhoods inside U. The intersection U ‚à© ball z r is an open neighborhood of z in U, so this matches ‚Äúlocally injective on U.‚Äù
- No vacuous or placeholder definitions; standard Mathlib notions are used (IsOpen, DifferentiableOn, deriv, InjOn, ball).

Conclusion: The Lean statement is a faithful formalization of the natural language statement.
### END THOUGHT",1
jirilebl_ca_ca_2353,Complex Analysis,success,3,1,,Suppose $f \colon \mathbb{C} \to \mathbb{C}$ is holomorphic. Show that $f$ is conformal at a point $z_0$ if and only if $f'(z_0) \not= 0$.,"import Mathlib
open Complex
open Complex ContinuousLinearMap
open scoped ComplexConjugate

/-- Suppose f : ‚ÑÇ ‚Üí ‚ÑÇ is holomorphic. Show that f is conformal at a point z0 iff f'(z0) ‚â† 0. -/
theorem conformalAt_iff_deriv_ne_zero {f : ‚ÑÇ ‚Üí ‚ÑÇ} {z‚ÇÄ : ‚ÑÇ} (hf : DifferentiableAt ‚ÑÇ f z‚ÇÄ) :
    ConformalAt f z‚ÇÄ ‚Üî deriv f z‚ÇÄ ‚â† 0 := by sorry
",10,"### BEGIN THOUGHT
1) Line-by-line translation:
- `import Mathlib` and the `open` lines: just setup, no mathematical content.
- The theorem statement:
  `theorem conformalAt_iff_deriv_ne_zero {f : ‚ÑÇ ‚Üí ‚ÑÇ} {z‚ÇÄ : ‚ÑÇ} (hf : DifferentiableAt ‚ÑÇ f z‚ÇÄ) : ConformalAt f z‚ÇÄ ‚Üî deriv f z‚ÇÄ ‚â† 0`.
  This says: For a complex function f and a point z‚ÇÄ, assuming f is complex-differentiable at z‚ÇÄ (i.e., holomorphic at z‚ÇÄ), f is conformal at z‚ÇÄ if and only if the complex derivative at z‚ÇÄ is nonzero.

2) Overall faithfulness:
The natural language statement: ‚ÄúSuppose f : ‚ÑÇ ‚Üí ‚ÑÇ is holomorphic. Show that f is conformal at a point z‚ÇÄ iff f‚Ä≤(z‚ÇÄ) ‚â† 0.‚Äù The Lean statement assumes f is complex-differentiable at z‚ÇÄ (a local holomorphic assumption) and concludes the equivalence between conformality at z‚ÇÄ and nonvanishing derivative. This matches the intended theorem exactly, since the property is local and global holomorphic implies differentiable at every point. The Lean theorem is a slight generalization (only local differentiability is assumed), which is acceptable and faithful to the mathematical meaning.

3) Final check and differences:
- Difference: The English says ‚Äúf is holomorphic‚Äù (which can be read as globally holomorphic), while the Lean statement only assumes `DifferentiableAt ‚ÑÇ f z‚ÇÄ`. This is a standard and harmless generalization, fully consistent with the theorem‚Äôs local nature.
- No auxiliary/vacuous definitions are introduced; all notions (ConformalAt, deriv, DifferentiableAt) are standard Mathlib concepts.
Thus the translation is faithful.
### END THOUGHT",1
jirilebl_ca_ca_1326,Complex Analysis,success,3,1,,"Use $e^{z+w} = e^z e^w$ and $e^0 = 1 \not= 0$ to show that $e^z \not=0$ for all $z \in \mathbb{C}$. In other words, show that if a function $f$ satisfies $f(z+w)=f(z)f(w)$ and $f(0) = 1$, then $f(z) \not= 0$ for all $z$.","import Mathlib

/-- If f : Complex ‚Üí Complex satisfies f (z + w) = f z * f w and f 0 = 1, then f z ‚â† 0 for all z. -/
theorem multiplicative_function_nowhere_zero {f : Complex ‚Üí Complex}
  (hMul : ‚àÄ z w, f (z + w) = f z * f w)
  (h0 : f 0 = 1) : ‚àÄ z, f z ‚â† 0 := by sorry

/-- In particular, the complex exponential is nowhere zero. -/
theorem exp_nonzero (z : Complex) : Complex.exp z ‚â† 0 := by sorry
",10,"### BEGIN THOUGHT
1) Line-by-line translation:
- `import Mathlib`: Bring in Mathlib; no mathematical content.
- `/-- If f : Complex ‚Üí Complex satisfies f (z + w) = f z * f w and f 0 = 1, then f z ‚â† 0 for all z. -/ theorem multiplicative_function_nowhere_zero {f : Complex ‚Üí Complex} (hMul : ‚àÄ z w, f (z + w) = f z * f w) (h0 : f 0 = 1) : ‚àÄ z, f z ‚â† 0 := by sorry`
  Natural language: Let f: ‚ÑÇ ‚Üí ‚ÑÇ be a function such that for all z, w ‚àà ‚ÑÇ, f(z + w) = f(z) f(w), and f(0) = 1. Then for all z ‚àà ‚ÑÇ, f(z) ‚â† 0.
- `/-- In particular, the complex exponential is nowhere zero. -/ theorem exp_nonzero (z : Complex) : Complex.exp z ‚â† 0 := by sorry`
  Natural language: For every z ‚àà ‚ÑÇ, e^z ‚â† 0.

2) Faithfulness to the original statement:
- The first theorem exactly formalizes the ‚ÄúIn other words‚Äù part: if a function f satisfies f(z+w)=f(z)f(w) and f(0)=1, then f(z)‚â†0 for all z. The codomain/domain are Complex as in the context. No extra or missing hypotheses.
- The second theorem captures the specific conclusion about the complex exponential being nowhere zero.
- The natural language mentions ‚Äúuse e^{z+w} = e^z e^w and e^0 = 1 ‚â† 0‚Äù; in Lean, the general theorem uses f(0)=1 and relies on the fact that in ‚ÑÇ, 1 ‚â† 0 is standard, so no need to assume it explicitly. This is a harmless and standard omission.

3) Final check:
- No auxiliary vacuous definitions are introduced. The statements are precise and standard Mathlib entities (Complex, Complex.exp). Theorems match the intended mathematics. Therefore, the translation is faithful.
### END THOUGHT",1
jirilebl_ca_ca_3078,Complex Analysis,success,3,1,,"If $f \colon U \to \mathbb{C}$ is a holomorphic function on a domain $U \subset \mathbb{C}$, then $f$ is analytic. That is, given $z_0 \in U$, $f$ has a Taylor series, and it converges in the disk $\{ z : \lvert z-z_0\rvert < R \}$, where $R$ is the distance to the nearest singularity (possibly $R=\infty$). Furthermore, the sum of the series is $f$.","import Mathlib
open Set Filter Metric Complex
open scoped Topology

/-- If f : U ‚Üí ‚ÑÇ is a holomorphic function on a domain U ‚äÇ ‚ÑÇ, then f is analytic. That is, given z0 ‚àà U, f has a Taylor series, and it converges in the disk {z : |z - z0| < R}, where R is the distance to the nearest singularity (possibly R = ‚àû). Furthermore, the sum of the series is f. -/
theorem analyticAt_of_mem_nhds {f : ‚ÑÇ ‚Üí ‚ÑÇ} {z : ‚ÑÇ} {U : Set ‚ÑÇ} (h : DifferentiableOn ‚ÑÇ f U)
    (hz : z ‚àà U) (hU : IsOpen U) : AnalyticAt ‚ÑÇ f z := by sorry
",8,"### BEGIN THOUGHT
1) Line-by-line translation of the Lean code:
- The theorem `analyticAt_of_mem_nhds` states: Let f : ‚ÑÇ ‚Üí ‚ÑÇ, z : ‚ÑÇ, U : Set ‚ÑÇ. If (i) f is complex differentiable on U (`DifferentiableOn ‚ÑÇ f U`), (ii) z ‚àà U, and (iii) U is open (`IsOpen U`), then f is analytic at z (`AnalyticAt ‚ÑÇ f z`). There are no auxiliary definitions; the statement uses standard Mathlib predicates: `DifferentiableOn` (holomorphic on a set) and `AnalyticAt` (existence of a convergent power series at a point whose sum agrees with f in a neighborhood).

2) Comparison to the natural language statement:
- The natural language statement asserts: If f is holomorphic on a domain U ‚äÇ ‚ÑÇ, then f is analytic; more specifically, for any z0 ‚àà U, f has a Taylor series that converges in the disk {z : |z ‚àí z0| < R}, where R is the distance to the nearest singularity (possibly ‚àû), and the sum equals f.
- The Lean statement captures the core implication ‚Äúholomorphic on an open set implies analytic at each point of that set‚Äù (since z ‚àà U and U open), matching the basic holomorphic ‚áí analytic claim.
- However, the Lean theorem does not state the additional and stronger information about the precise radius of convergence being the distance to the nearest singularity (or equivalently, to the complement of the maximal domain of holomorphy), nor does it quantify over all z ‚àà U explicitly (though it is parameterized in z, so it can be applied pointwise). It also does not mention connectedness (‚Äúdomain‚Äù in complex analysis usually means open and connected); although connectedness is not needed for analyticity at a point, it is part of the original context.
- The Lean statement concludes only `AnalyticAt ‚ÑÇ f z`, which ensures existence of a power series representing f in some neighborhood of z and that the series sums to f locally, but it does not assert the radius equals the distance to the nearest singularity.

3) Final check:
- Same or different? They are different. The Lean code faithfully states a weaker, standard result (holomorphic on open set ‚áí analytic at the point). The natural language statement includes the stronger, more precise radius-of-convergence characterization tied to nearest singularities. Thus, while the core implication is present, the specific radius claim is missing. No vacuous placeholders are used; the terms are standard Mathlib. Hence the translation is not fully faithful, but it is close.

### END THOUGHT",0
jirilebl_ca_ca_758,Complex Analysis,success,7,1,,Prove the \emph{polarization identity} $4 z\bar{w} = {\lvert z+w\rvert}^2-{\lvert z-w\rvert}^2 +i \bigl( {\lvert z+iw\rvert}^2 - {\lvert z-iw\rvert}^2 \bigr)$.,"import Mathlib

/-- Polarization identity for complex numbers: for all z w : ‚ÑÇ,
    4 * z * star w = |z + w|^2 - |z - w|^2 + i * (|z + i w|^2 - |z - i w|^2).
-/
theorem polarization_identity (z w : ‚ÑÇ) :
  (4 : ‚ÑÇ) * z * star w =
    (Complex.normSq (z + w) - Complex.normSq (z - w)) +
      Complex.I * (Complex.normSq (z + Complex.I * w) - Complex.normSq (z - Complex.I * w)) := by sorry
",10,"### BEGIN THOUGHT
1) Line-by-line translation:
- `import Mathlib`: Use Mathlib's complex number and norm machinery.
- Docstring: States the polarization identity for complex numbers exactly as in the natural language statement, interpreting |¬∑|^2 as the squared modulus.
- `theorem polarization_identity (z w : ‚ÑÇ) : ... := by sorry`: For all complex z, w, it asserts the equality
  (4 : ‚ÑÇ) * z * star w = (Complex.normSq (z + w) - Complex.normSq (z - w)) + Complex.I * (Complex.normSq (z + Complex.I * w) - Complex.normSq (z - Complex.I * w)).
  Here:
  - `star w` is the complex conjugate of w.
  - `Complex.normSq z` is |z|^2 (a real number), coerced to ‚ÑÇ when used in the complex sum; this matches the squared modulus in the statement.
  - `Complex.I` is i, and `Complex.I * w` is i w.

2) Whole translation faithfulness:
The Lean statement captures exactly the polarization identity: 4 z \bar{w} equals the given combination of squared moduli. The use of `Complex.normSq` for |¬∑|^2 is standard and faithful. The coercions from ‚Ñù to ‚ÑÇ are implicit but mathematically identical to the intended expression. The order of multiplication is immaterial in ‚ÑÇ.

3) Final check for differences:
- Natural language uses |¬∑|^2; Lean uses `Complex.normSq` which equals |¬∑|^2. No discrepancy.
- Uses i and conjugation consistently (`Complex.I`, `star`).
- Universally quantified over z, w: matches ""for all z, w"".
No differences found.

Conclusion: The code is a faithful formal statement of the given identity.
### END THOUGHT",1
jirilebl_ca_ca_2577,Complex Analysis,success,12,1,,"Let $U \subset \mathbb{C}$ be an open set and $f \colon U \to \mathbb{C}$ be a holomorphic function. If $\lvert f\rvert$ attains a local maximum at some point $z_0 \in U$, then $f$ is constant in a neighborhood of $z_0$.","import Mathlib
open Set Filter
open scoped Topology

/-- Let U ‚äÇ ‚ÑÇ be an open set and f : U ‚Üí ‚ÑÇ be a holomorphic function. If |f| attains a local maximum at some point z0 ‚àà U, then f is constant in a neighborhood of z0. -/
theorem maximum_modulus_local {U : Set ‚ÑÇ} (hU : IsOpen U) {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hf : DifferentiableOn ‚ÑÇ f U) {z0 : ‚ÑÇ} (hz0 : z0 ‚àà U)
  (hmax : IsLocalMax (fun z => ‚Äñf z‚Äñ) z0) : ‚àÄ·∂† z in ùìù z0, f z = f z0 := by sorry
",9,"### BEGIN THOUGHT
Step 1: Translate the Lean code line by line.
- Context: U : Set ‚ÑÇ with hU : IsOpen U. f : ‚ÑÇ ‚Üí ‚ÑÇ is a complex-valued function on the whole plane. hf : DifferentiableOn ‚ÑÇ f U means f is holomorphic on U (no claim outside U). z0 : ‚ÑÇ with hz0 : z0 ‚àà U.
- Hypothesis hmax : IsLocalMax (fun z => ‚Äñf z‚Äñ) z0 means |f| has a local maximum at z0 as a function on the entire ‚ÑÇ (i.e., there exists a neighborhood in ‚ÑÇ around z0 on which ‚Äñf z‚Äñ ‚â§ ‚Äñf z0‚Äñ).
- Conclusion: ‚àÄ·∂† z in ùìù z0, f z = f z0 means f is constant in a (ambient) neighborhood of z0 in ‚ÑÇ; i.e., there exists a neighborhood V of z0 in ‚ÑÇ such that for all z ‚àà V, f z = f z0.

Step 2: Compare to the natural language statement.
- NL statement: U ‚äÇ ‚ÑÇ open, f : U ‚Üí ‚ÑÇ holomorphic. If |f| attains a local maximum at z0 ‚àà U (i.e., relative to U), then f is constant in a neighborhood of z0 (typically meaning in some neighborhood within U, equivalently on U ‚à© B(z0, r)).

Step 3: Identify differences.
- Domain of f: NL has f : U ‚Üí ‚ÑÇ; Lean uses f : ‚ÑÇ ‚Üí ‚ÑÇ with DifferentiableOn on U. This is a common formalization and fine in itself.
- Local maximum condition: NL intends a local maximum relative to U. Lean uses IsLocalMax on ‚ÑÇ (no restriction to U). This is strictly stronger than the intended hypothesis (a specialization), not just a technical reformulation.
- Conclusion: NL requires constancy in a neighborhood within U. Lean concludes constancy on an ambient neighborhood in ‚ÑÇ (filter ùìù z0 rather than ùìù[U] z0). This is stronger than necessary. While U is open and the Lean conclusion implies the NL conclusion by intersecting with U, the statement as written asserts more than the NL statement.

Overall assessment:
- The code states a stronger hypothesis (local max in ‚ÑÇ rather than in U) and a stronger conclusion (constancy on an ambient neighborhood rather than relative to U). Although this is a reasonable specialization and implies the original claim, it is not a faithful translation of the original statement as-is. A faithful formalization would use IsLocalMaxOn (fun z => ‚Äñf z‚Äñ) U z0 and conclude eventually on ùìù[U] z0 (or equivalently: ‚àÉ r > 0, ‚àÄ z ‚àà U ‚à© ball z0 r, f z = f z0).

Therefore, while close and mathematically sensible, it is not faithful to the exact natural language statement.
### END THOUGHT",0
jirilebl_ca_ca_2718,Complex Analysis,success,7,1,,"Let $U \subset \mathbb{C}$ be a domain and suppose that a holomorphic function $f \colon U \to \mathbb{C}$ is not constant. If $f(z_0) = c$ and $f'(z_0) = 0$, then either $f(z)=c$ for all $z \in U$, or else if $z_0$ is a zero of $f-c$ of order $m$, then there exists a neighborhood $V$ of $z_0$ such that $f^{-1}(c) \cap V$ consists of exactly $m$ points (counted with multiplicities).","import Mathlib

/-- Abstract version of the classical fact about zeros of a nonconstant holomorphic function.
    We parametrize the notions of holomorphicity, vanishing derivative, order of a zero, and
    counting zeros with multiplicity so that the statement mirrors the mathematical one but
    does not depend on particular mathlib identifiers. -/

theorem jirilebl_ca_ca_2718
  (IsHolomorphicOn : Set ‚ÑÇ ‚Üí (‚ÑÇ ‚Üí ‚ÑÇ) ‚Üí Prop)
  (HasZeroDerivativeAt : (‚ÑÇ ‚Üí ‚ÑÇ) ‚Üí ‚ÑÇ ‚Üí Prop)
  (ZeroOfOrder : (‚ÑÇ ‚Üí ‚ÑÇ) ‚Üí ‚ÑÇ ‚Üí ‚Ñï ‚Üí Prop)
  (zeros_count_mult : (‚ÑÇ ‚Üí ‚ÑÇ) ‚Üí Set ‚ÑÇ ‚Üí ‚Ñï ‚Üí Prop)
  (U : Set ‚ÑÇ) (hU_open : IsOpen U) (hU_conn : IsPreconnected U)
  {f : ‚ÑÇ ‚Üí ‚ÑÇ} (c : ‚ÑÇ)
  (hhol : IsHolomorphicOn U f) (h_not_const : ¬¨ (‚àÄ z ‚àà U, f z = c))
  (z0 : ‚ÑÇ) (hz0 : z0 ‚àà U) (hfz0 : f z0 = c) (hder0 : HasZeroDerivativeAt f z0) :
  (‚àÄ z ‚àà U, f z = c) ‚à®
  (‚àÉ m : ‚Ñï, 0 < m ‚àß ZeroOfOrder (fun z => f z - c) z0 m ‚àß
    ‚àÉ V : Set ‚ÑÇ, IsOpen V ‚àß z0 ‚àà V ‚àß V ‚äÜ U ‚àß zeros_count_mult (fun z => f z - c) V m) := by sorry
",6,"### BEGIN THOUGHT
Step-by-step translation of the Lean code:
- The theorem is named `jirilebl_ca_ca_2718` and it is stated over ‚ÑÇ.
- It takes as parameters four completely abstract predicates/functions:
  ‚Ä¢ IsHolomorphicOn : Set ‚ÑÇ ‚Üí (‚ÑÇ ‚Üí ‚ÑÇ) ‚Üí Prop (intended to mean f is holomorphic on U)
  ‚Ä¢ HasZeroDerivativeAt : (‚ÑÇ ‚Üí ‚ÑÇ) ‚Üí ‚ÑÇ ‚Üí Prop (intended to mean f'(z0) = 0)
  ‚Ä¢ ZeroOfOrder : (‚ÑÇ ‚Üí ‚ÑÇ) ‚Üí ‚ÑÇ ‚Üí ‚Ñï ‚Üí Prop (intended to mean z0 is a zero of order m of a function)
  ‚Ä¢ zeros_count_mult : (‚ÑÇ ‚Üí ‚ÑÇ) ‚Üí Set ‚ÑÇ ‚Üí ‚Ñï ‚Üí Prop (intended to mean the number of zeros in a set counted with multiplicity)
- Hypotheses on the domain U: hU_open : IsOpen U and hU_conn : IsPreconnected U. This is an attempt to encode ‚ÄúU is a domain‚Äù (open and connected/nonempty; IsPreconnected is a connectedness-like condition, but not exactly the same as IsConnected and allows the empty set).
- f : ‚ÑÇ ‚Üí ‚ÑÇ and c : ‚ÑÇ are given. The function is assumed holomorphic on U via hhol : IsHolomorphicOn U f.
- There is an assumption h_not_const : ¬¨ (‚àÄ z ‚àà U, f z = c), i.e., f is not identically equal to c on U. Note this is weaker and different from ‚Äúf is not constant‚Äù in the usual sense; it only forbids the constant function equal to c, but allows other constant functions ‚â† c.
- A point z0 ‚àà U is given with hfz0 : f z0 = c and hder0 : HasZeroDerivativeAt f z0 (intended: f'(z0) = 0).
- Conclusion: Either
  (1) ‚àÄ z ‚àà U, f z = c (f is identically c on U), or
  (2) there exists m > 0 with ZeroOfOrder (f - c) z0 m and an open neighborhood V of z0 with V ‚äÜ U such that zeros_count_mult (f - c) V m holds (intended: f^{-1}(c) ‚à© V consists of exactly m zeros counted with multiplicity).

Assessment of faithfulness to the natural language statement:
- Major issue: The key analytic notions are not Mathlib definitions; they are arbitrary parameters (placeholders). This means the statement does not actually assert the intended complex analysis fact within Mathlib‚Äôs framework. It quantifies over arbitrary predicates with suggestive names, so the statement is not a faithful formalization.
- The hypothesis ‚Äúf is not constant‚Äù in the natural language statement is replaced by h_not_const: ¬¨ ‚àÄ z ‚àà U, f z = c, which only states ‚Äúf is not identically equal to c,‚Äù not ‚Äúf is not constant.‚Äù This is weaker and different. Moreover, the conclusion includes the disjunct that f ‚â° c, which contradicts h_not_const, making the overall shape mismatch the intended logic of the natural statement (where the nonconstant assumption would rule out the identically-c alternative).
- The natural language statement specifies: if z0 is a zero of order m of f ‚àí c, then there exists a neighborhood V of z0 such that f^{-1}(c) ‚à© V consists of exactly m points (with multiplicity). The code tries to mirror this via ZeroOfOrder and zeros_count_mult, but since these are arbitrary predicates, there is no guarantee they actually mean what they purport to mean.
- Domain: The code requires U to be open and preconnected; a domain is usually open and connected (nonempty). Using IsPreconnected instead of IsConnected is a minor technical deviation; this is acceptable, but still not precise.
- The function is modeled as f : ‚ÑÇ ‚Üí ‚ÑÇ with a predicate IsHolomorphicOn U f, which is a reasonable modeling choice, but again it‚Äôs just a placeholder, not Mathlib‚Äôs HolomorphicOn.
- The conclusion claims the existence of m > 0 and a neighborhood V with a counting property, but because zeros_count_mult is an arbitrary predicate, this does not actually enforce ‚Äúexactly m points counted with multiplicities‚Äù as in Mathlib.

Final comparison:
- The code does not use actual Mathlib notions of holomorphic functions, derivatives, order of zeros, or counting zeros with multiplicity; it parameterizes them abstractly. This violates the requirement that auxiliary definitions be legitimate and not vacuous placeholders.
- There‚Äôs also a logical mismatch on the ‚Äúnonconstant‚Äù vs ‚Äúnot identically c‚Äù condition and the inclusion of the identically-c alternative in the conclusion despite the hypothesis.
- Therefore, the Lean code is not a faithful translation of the natural language statement.

Grade justification:
- Because the core notions are placeholders/parameters rather than Mathlib concepts, the translation fails. If those placeholders were replaced by proper Mathlib definitions, the shape of the theorem would be close to the intended statement (modulo the minor logical mismatch about non-constancy and connectedness). Hence, this fits the rubric ‚Äúmakes up vacuous definitions but if that were fixed, then the final theorem/definition is faithful,‚Äù resulting in a grade around 6.
### END THOUGHT",0
jirilebl_ca_ca_5157,Complex Analysis,success,15,1,,"Suppose $U \subset \mathbb{C}$ is open, and $\psi \colon U \times [0,1] \to \mathbb{C}$ is a continuous function such that for each fixed $t \in [0,1]$, the function $z \mapsto \psi(z,t)$ is holomorphic. Then $h(z) = \int_0^1 \psi(z,t) \, dt$ is a holomorphic function on $U$.","import Mathlib

open Set

/-- Suppose U ‚äÇ ‚ÑÇ is open, and œà : U √ó [0,1] ‚Üí ‚ÑÇ is continuous such that for each fixed t ‚àà [0,1], the function z ‚Ü¶ œà(z,t) is holomorphic. Then h(z) = ‚à´_0^1 œà(z,t) dt is holomorphic on U. -/
theorem analytic_on_integral_param {U : Set Complex}
  (hU : IsOpen U)
  {œà : Complex √ó ‚Ñù ‚Üí Complex}
  (hœà : ContinuousOn œà (U √óÀ¢ Icc (0 : ‚Ñù) 1))
  (hhol : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1, AnalyticOn ‚ÑÇ (fun z => œà (z, t)) U) :
  AnalyticOn ‚ÑÇ (fun z => ‚à´ t in 0..1, œà (z, t)) U := by sorry",10,"### BEGIN THOUGHT
1) Line-by-line translation of the Lean code:
- `theorem analytic_on_integral_param {U : Set Complex} (hU : IsOpen U)`:
  Let U be a subset of the complex plane ‚ÑÇ, and assume U is open.
- `{œà : Complex √ó ‚Ñù ‚Üí Complex}`:
  Let œà be a function from ‚ÑÇ √ó ‚Ñù to ‚ÑÇ (defined on all pairs, but we will only require properties on U √ó [0,1]).
- `(hœà : ContinuousOn œà (U √óÀ¢ Icc (0 : ‚Ñù) 1))`:
  œà is continuous on the set U √ó [0,1] (with [0,1] represented as Icc (0) 1).
- `(hhol : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1, AnalyticOn ‚ÑÇ (fun z => œà (z, t)) U)`:
  For each t in [0,1], the function z ‚Ü¶ œà(z, t) is complex-analytic on U (i.e., holomorphic on U).
- `AnalyticOn ‚ÑÇ (fun z => ‚à´ t in 0..1, œà (z, t)) U`:
  The function h(z) = ‚à´ from 0 to 1 of œà(z, t) dt is complex-analytic (holomorphic) on U.

2) Faithfulness to the natural language statement:
- The natural statement: U ‚äÇ ‚ÑÇ open; œà: U √ó [0,1] ‚Üí ‚ÑÇ continuous; for each fixed t ‚àà [0,1], z ‚Ü¶ œà(z, t) is holomorphic; then h(z) = ‚à´_0^1 œà(z, t) dt is holomorphic on U.
- The Lean code encodes exactly these hypotheses and conclusion, using ContinuousOn on U √ó [0,1] and AnalyticOn ‚ÑÇ for holomorphicity. The integrand and integral bounds match [0,1]. The slight technical choice of œà : ‚ÑÇ √ó ‚Ñù ‚Üí ‚ÑÇ together with a ContinuityOn restriction to U √ó [0,1] faithfully models a function defined on U √ó [0,1]. Using AnalyticOn ‚ÑÇ instead of ‚Äúholomorphic‚Äù is standard and appropriate; on open sets in ‚ÑÇ these notions coincide in Mathlib.

3) Final comparison:
- No extraneous or vacuous definitions; all terms are standard Mathlib.
- No mismatch in domains, continuity, or the integral expression.
- The use of AnalyticOn versus holomorphic is either equivalent or a harmless standard reformulation. The statement is a faithful formalization of the original.

Hence, the translation is faithful.
### END THOUGHT",1
jirilebl_ca_ca_997,Complex Analysis,success,10,1,,"Prove that if the $2 \times 2$ matrix $M$ represents a complex number $a+ib$, then $M$ has two eigenvalues: $a \pm i b$ with the corresponding eigenvectors $\left[ \begin{smallmatrix} 1 \\ \mp i \end{smallmatrix} \right]$.","import Mathlib

/-- If the 2√ó2 real matrix M represents the complex number a + i b via
    M = [[a, -b], [b, a]], then M (viewed as a complex matrix) has two
    eigenpairs: eigenvalue a + i b with eigenvector [1; -i], and
    eigenvalue a - i b with eigenvector [1; i]. -/
theorem matrix_repr_complex_eigenpairs (a b : ‚Ñù) :
  let M : Matrix (Fin 2) (Fin 2) ‚Ñù := fun i j =>
    match i, j with
    | 0, 0 => a
    | 0, 1 => -b
    | 1, 0 => b
    | 1, 1 => a
  let Mc := M.map (algebraMap ‚Ñù ‚ÑÇ)
  let v1 : Fin 2 ‚Üí ‚ÑÇ := fun i => if i = 0 then (1 : ‚ÑÇ) else -Complex.I
  let v2 : Fin 2 ‚Üí ‚ÑÇ := fun i => if i = 0 then (1 : ‚ÑÇ) else Complex.I
  Mc.mulVec v1 = (a + b * Complex.I) ‚Ä¢ v1 ‚àß Mc.mulVec v2 = (a - b * Complex.I) ‚Ä¢ v2 := by sorry
",10,"### BEGIN THOUGHT
Step-by-step translation of the Lean code:
- The theorem `matrix_repr_complex_eigenpairs (a b : ‚Ñù)` fixes real numbers a and b.
- It defines a 2√ó2 real matrix M by cases on indices i, j ‚àà Fin 2, yielding M = [[a, -b], [b, a]]. This is exactly the standard real 2√ó2 matrix representing the complex number a + i b (multiplication by a + ib on ‚Ñù¬≤ ‚âÖ ‚ÑÇ).
- It then defines Mc := M.map (algebraMap ‚Ñù ‚ÑÇ), i.e., the same matrix but regarded as a complex matrix by embedding ‚Ñù into ‚ÑÇ entrywise.
- It defines two complex vectors v1 and v2 in ‚ÑÇ¬≤ (as functions Fin 2 ‚Üí ‚ÑÇ):
  ‚Ä¢ v1(i) = 1 if i = 0, and -i otherwise, i.e., v1 = [1; -i].
  ‚Ä¢ v2(i) = 1 if i = 0, and i otherwise, i.e., v2 = [1; i].
- The conclusion is a conjunction of two equalities:
  ‚Ä¢ Mc.mulVec v1 = (a + b * i) ‚Ä¢ v1
  ‚Ä¢ Mc.mulVec v2 = (a - b * i) ‚Ä¢ v2
  These equations state exactly that v1 is an eigenvector of Mc with eigenvalue a + i b, and v2 is an eigenvector with eigenvalue a ‚àí i b.

Faithfulness to the natural language statement:
- The natural language statement: If the 2√ó2 matrix M represents the complex number a+ib, then M has eigenvalues a ¬± i b with corresponding eigenvectors [1; ‚àì i]. The code instantiates M as [[a, -b], [b, a]], which is exactly the representation of a+ib, then asserts the eigenpair relations over ‚ÑÇ after embedding. The vectors [1; -i] for eigenvalue a+ib and [1; i] for eigenvalue a‚àíib match the ‚Äú‚àì‚Äù correspondence.
- The code uses let-bindings to define M and the vectors; there are no vacuous placeholders, and no auxiliary fake definitions. The proof is omitted (by sorry), which is acceptable for auditing the statement.
- The slight formalization detail of mapping M to ‚ÑÇ via algebraMap is appropriate and faithful to ‚Äúviewed as a complex matrix.‚Äù

Final check:
- The mathematical content matches exactly: same matrix form, same eigenvalues, same eigenvectors with the correct sign pairing. There are no extraneous assumptions or generalizations that change the meaning.

### END THOUGHT",1
jirilebl_ca_ca_5485,Complex Analysis,success,19,1,,"Suppose $f \colon \mathbb{D} \to \mathbb{D}$ is holomorphic and $f(0) = 0$, then $\lvert f'(0)\rvert \leq 1$.","import Mathlib

/-- Suppose f : ùîª ‚Üí ùîª is holomorphic and f(0) = 0, then ‚Äñf'(0)‚Äñ ‚â§ 1. -/
theorem abs_deriv_le_one_of_holomorphic_on_unit_disk {f : ‚ÑÇ ‚Üí ‚ÑÇ}
  (hf : DifferentiableOn ‚ÑÇ f (Metric.ball (0 : ‚ÑÇ) 1))
  (hmap : ‚àÄ z, z ‚àà Metric.ball (0 : ‚ÑÇ) 1 ‚Üí f z ‚àà Metric.ball (0 : ‚ÑÇ) 1)
  (h0 : f 0 = 0) :
  ‚Äñderiv f 0‚Äñ ‚â§ 1 := by sorry
",10,"### BEGIN THOUGHT
1) Line-by-line translation:
- import Mathlib: Using mathlib.
- The theorem statement: Given f : ‚ÑÇ ‚Üí ‚ÑÇ, if (i) f is complex differentiable on the open unit disk Metric.ball (0 : ‚ÑÇ) 1 (this matches holomorphic on ùîª), (ii) f maps the open unit disk into itself (hmap: ‚àÄ z ‚àà ùîª, f z ‚àà ùîª), and (iii) f 0 = 0, then ‚Äñderiv f 0‚Äñ ‚â§ 1. Here deriv f 0 is the complex derivative at 0, and ‚Äñ¬∑‚Äñ is the complex absolute value.

2) Assessing faithfulness:
- The natural language statement: Suppose f : ùîª ‚Üí ùîª is holomorphic and f(0) = 0, then |f'(0)| ‚â§ 1. 
- The code assumes: f is defined on ‚ÑÇ but only required to be differentiable on ùîª (an open set), and maps ùîª into ùîª. This matches the idea of a holomorphic map f : ùîª ‚Üí ùîª without imposing conditions outside ùîª. Since ùîª is open, DifferentiableOn on ùîª ensures DifferentiableAt at 0, so deriv f 0 is the usual complex derivative at 0. The mapping condition hmap encodes f(ùîª) ‚äÜ ùîª. The statement ‚Äñderiv f 0‚Äñ ‚â§ 1 matches |f'(0)| ‚â§ 1.

3) Final check:
- The mathematical content is the same: Schwarz's lemma bound for the derivative at 0. No extra/vacuous definitions are introduced; the only differences are formalizations (full-domain function with DifferentiableOn on the open disk), which are standard and faithful. No mismatch in open vs closed disk: Metric.ball is the open unit disk as in the statement.

Conclusion: The code is a faithful formalization of the natural language statement.
### END THOUGHT",1
